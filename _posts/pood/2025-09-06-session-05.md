---
title: "POOD Session 5: Decipher Caching and Immutability"
date: 2025-09-06
categories: [pood]
description: 'Fifth session, lesson Decipher Caching and Immutability'
layout: post
---

# Session 5: Decipher Caching and Immutability, Cache BottleNumbers & Recognize Data Clumps

Date: September 06, 2025

This blog post consists in three parts:

- [My notes on Decipher Caching and Immutability](#caching-immutability)
- [My notes on Cache BottleNumbers](#cache-bottlenumber)
- [My notes on Recognize Data Clumps](#data-clumps)


### Key Concepts

- 

### Decipher Caching and Immutability {#caching-immutability}

Watch 1: Appreciating Immutability

To mutate is to change.

State is the particular conditional of something at certain point in time. and a variable is a thing that varies.

In the real world, things change state, or they vary, over time.

<b>And it makes perfect sense that in computer programming we would choose the term variable for that thing that holds state, that changes over time. This choice reflects our expectation, that all things vary. </b>

It's common in OO to change the state of objects; we send a message and pass a bit of data, and then you hold on to that new bit of data.

But it's possible, as the functional folks will gladly tell you, to write code where most objects would never have to change state. Instead of mutating an object, <b>if it needed to vary state, you could just create a new object on that new piece of state.</b>

What this means is if you had a coffee cup and you drank all the coffee, instead of refilling the cup, you would just get a new cup with more coffee in it.

Instead of noting that the continents had moved because of plate tectonics, you would get entirely new continents, even if they'd only moved a matter of millimeters.

What might the benefits of immutable objects be? Well, they're easy to understand. You're never in a situation where someone else is holding a pointer to an object that you're also holding onto, and that object somehow changes state underneath you.

What you see is always what you get. Immutable objects are easy to reason about.

If you have mutable objects, where state is changing, often you need collaborators in the tests that you're creating. So you have to spin up these other objects in order to get state to change in the object that's under test.

But for immutable objects, you would just create a new object on a different piece of state.

So there are many good reasons to love immutable objects. <b>And the question is why don't we use them more?</b>

- The first is just habit, when you learned OO, or any example that you look at using OO, very often mutates objects.

- The second reason I think is an unquestioned assumption that many people make that object creation will be expensive and that it's better to mutate an existing object rather than create a new one.

Watch 2: Assuming Fast Enough

In the previous section made the case for immutability. And it's a good thing. We often don't do it though, and it's mostly for two reasons. One: habit, <b>we're not in the habit of thinking about creating immutable objects.</b> But two, a bigger issue, is even if we want to create immutable objects, very often, <b>we imagine that it will be too expensive to create new objects.</b>

A person named Phil Karlton famously said:

> There are only two hard problems in Computer Science: 
> - naming and 
> - cache invalidation.

Cache is local copy of something. A temporary variable, when you declare a variable and say equal some operation, you've created a cache. Also, known as memoization.

Why would you cache? Sometimes we cache to give a name to the result of an intermediate operation, to add clarity to the code.

The other reason we may cache is to preserve the result of a costly long running operation. And so now we have a problem. If you save the result of a long running operation, how will you know when your cache gets dirty? (different result and you're holding on to a previous cache copy)

The code to figure out that your <i>cache is dirty</i> is cache invalidation.

There's a thing called the 80/20 rule, which says that 80%, or 90% or 95%, of an application's work occurs in 20% of its code. (Most of the code don't run pretty much)

Don't add complexity based on guesses. 

Write the simplest possible code, and then, and only then, if you find that parts of your app are too slow, (if someone complains) then profile your code to identify the slow parts and then work on them to make them faster.

A profiler is a tool that watches your code as it runs and measures how much time you spend in certain operations.

Your initial solution should avoid mutation. 

You should treat object creation as free and you should also avoid caching, just rerun operations and use the results. 

If you find that parts of your app are too slow and you profile it, you might find that <b>you'd be better off to break some of your objects into smaller parts.</b>

If you have parts that you need to mutate, or if you have parts that you need cache and invalidate, it's nice to minimize the size of those parts.

If you can create objects for the ideas of your business and have those objects hold on to the bags of state, you end up in a situation where it's easy to test your business logic and you're decoupled from the database.

Example of objects as buisness ideas:

```ruby
# DON'T: Business logic coupled to database/state
class Order
  def initialize(id)
    @id = id
  end

  def apply_discount
    record = Database.find(@id)
    if record.total > 100
      record.discount = record.total * 0.10
      record.save
    end
  end
end

# DO: Extract business logic into separate objects
class DiscountCalculator
  def initialize(total)
    @total = total
  end

  def calculate
    @total > 100 ? @total * 0.10 : 0
  end
end

class Order
  def apply_discount
    record = Database.find(@id)
    discount = DiscountCalculator.new(record.total).calculate
    record.discount = discount
    record.save
  end
end

# Now DiscountCalculator is easy to test without database:
# DiscountCalculator.new(150).calculate => 15.0
```

### Cache BottleNumbers {#caching-bottlenumber}

Here we applied the lessons from prior block to reduce the number of new `BottleNumbers` and simplify the code.

Watch 1: Creating BottleNumbers

With current code, how many instances of `BottleNumber` get created over the course of the song? It happens every time `verse` calls one of these methods, and that happens nine times in `verse`, that means we're creating 900 `BottleNumbers`.

Too many? As we said before, only if this code is too slow. Caching these values is very complicated.

The next trial will reduce the number of `BottleNumber`

```ruby
class Bottles
  def song
    verses(99, 0)
  end

  def verses(upper, lower)
    upper.downto(lower).map { |i| verse(i) }.join("\n")
  end

  def verse(number)
    bottle_number = BottleNumber.new(number)

    "#{bottle_number.quantity.capitalize} #{bottle_number.container} of beer on the wall, " +
    "#{bottle_number.quantity} #{bottle_number.container} of beer.\n" +
    "#{bottle_number.action}, " +
    "#{quantity(successor(number))} #{container(successor(number))} of beer on the wall.\n"
  end

  def quantity(number)
    BottleNumber.new(number).quantity
  end

  def container(number)
    BottleNumber.new(number).container
  end

  def action(number)
    BottleNumber.new(number).action
  end

  def successor(number)
    BottleNumber.new(number).successor
  end
end
```

Watch 2: Recognizing Liskov Violations


### Recognize Data Clumps {#data-clumps}


