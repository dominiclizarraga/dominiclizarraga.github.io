---
title: "POOD Session 9: Honor Demeter, Isolate Object Construction & Loosen Coupling"
date: 2025-09-27
categories: [pood]
description: '9th session, Honor Demeter, Isolate Object Construction & Loosen Coupling"
layout: post
---

# Session 8: Vary Verse

Date: October 04, 2025

This blog post consists in two parts:

- [My notes on Honor Demeter, Isolate Object Construction](#demeter)
- [My notes on Loosen Coupling](#coupling)

### Key Concepts

- 

### Honor Demeter, Isolate Object Construction{#demeter}

Watch 1: Obeying the Law of Demeter

Law of Demeter has something to do with lines of code that have more than one dot.

The next piece of code seems inocent but has multiple dependencies

- Whatever `verse_template` holds, will respond to `new`
- `new` accepts an argument
- and the thing returned by `new` responds to `lirycs`

```ruby
def verse(number)
  verse_template.new(number).lyrics
end
```

Every one of these things is a dependency, and a dependency is just something that you know about, that someone else is in charge of, so that if they changed it, you might have to change in turn.

Dependencies are unavoidable, objects have to know about one another in order to get anything done but we'd like to have loose coupling between objects. 

We'd like to have every object have the fewest number of absolutely necessary dependencies so that we don't end up having lots of distant and unrelated changes break our current code.

The Law of Demeter says: "You should not talk to your friends friends."

Theline of code above contains a message chain where each message along the chain returns a "different kind of object". Each of the returned objects conforms to a different API. That's an important component of the Law of Demeter. 

If this message chain had returned a series of objects, all of which conform to the same API, this wouldn't be a violation. If it was a bunch of `Strings`, or a bunch of `Arrays`, we don't really care. What we're concerned about is where, along the chain, every message that you send returns an object that's different than the other ones.

Here, is an example that violates Law of Demeter:

```ruby
class Foo
  def durability_of_preferred_toy_of_best_friends_pet
    best_friend.pet.preferred_toy.durability
  end
end
```

Above code `Foo` has to know that it has a `best_friend`, it has to know that `best_friend` has a `pet`, has to know that `pet` has a `toys`, and `toy` has `durability`.

It might not seem so terrible when you look at the line of code, but think about the problem with testing this.

Real objects have slow running operations, then your tests are going to be slow, unless you break in and stub them or stub in stubs or stub in stubbed stubs.

When you see that you have to stub in stubs in order to test an object, it's because you have violated the Law of Demeter.

<b>How can you fix this? Well, the time honored method for curing demeter violations is through message forwarding. And all that means is you go into each intermediate object and write a little helper method to basically remove that hop.</b>

```ruby
class Toy
  def durability
    1.hour
  end
end

class Pet
  def durability_of_preferred_toy
    preferred_toy.durability
  end
end

class Friend
  def durability_of_preferred_toy_of_pet
    pet.durability_of_preferred_toy
  end
end

class Foo
  def durability_of_preferred_toy_of_best_friends_pet
    best_friend.durability_of_preferred_toy_of_pet
  end
end
```

With these changes `Foo` talk directly to its collaborators. And what that means is, if you want to stub out the behavior of `Friend`, you can do it by creating one `stub`. You don't have to stub in stub in stub in stubs in your tests.

So it no longer is related to that network of objects, it just have one dependency on one direct collaborator.

There's one more improvement we can implement, the method `.durability_of_preferred_toy_of_pet` and so we haven't really freed ourselves from the structure of the object graph, the object dependency graph.

We need to ask "What does `Foo` really want?"

Messaging forwarding helped with testing but it doesn't help with identifying concepts in your domain.

<b>Why does Foo want to know durability of a toy of its best friend pet?</b>

Imagine it's because `Foo` is trying to arrange a play date, and it wants to know how long the pets can play before they tear up all their toys.

```ruby
class FriendWithPet
  def playdate_time_limit
    pet.durability_of_preferred_toy
  end
end

class FriendWithChild
  def playdate_time_limit
    child.tolerance_of_social_contact
  end
end

class Foo
  def playdate_time_limit
    best_friend.playdate_time_limit
  end
end
```

Since we're injecting some kind of a `Friend` object into `Foo`, they both work. They're interchangeable from `Foo`'s point of view. Because we're using dependency injection, and because we have identified what `Foo` wants, now we can collaborate with a whole universe of friends that have different constraints on `playdate_time_limit`. 

And that's the value of fixing demeter violations. They force you to step back from the current structure of your code and to create messages that embody what the sending object wants.

Watch 2: Identifying What the Verse Method Wants



### Loosen Coupling{#coupling}


