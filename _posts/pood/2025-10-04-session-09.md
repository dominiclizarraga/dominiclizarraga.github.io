---
title: "POOD Session 9: Loosen Coupling, Find Shameless Green & Vary the Bits"
date: 2025-10-04
categories: [pood]
description: '9th session, Loosen Coupling, Find Shameless Green & Vary the Bits'
layout: post
---

# Session 9: Vary Verse

Date: October 04, 2025

This blog post consists in two parts:

- [My notes on Loosen Coupling](#coupling)
- [My notes on Find Shameless Green](#shameless-green)
- [My notes on New requirement: Vary the Bits](#vary-the-bits)


### Key Concepts

- 

### Loosen Coupling {#coupling}

Watch 1: Choosing Which Units to Test

Unit tests are tests of just a single class (`Bottles`, `BottleNumber`) and an integration test is a test that checks the collaboration of more than one single class (`APIs`, `db interaction`).

The initial tests that we wrote back in Chapter 2 were unit tests to begin with because we just had that single `Bottles` class, and now they are badly out of date and they've long since been turned into integration tests.

The rule is every class should have a unit test.

All of these classes are being covered by the original tests that were unit tests but are now integration tests, and some of these new objects need their own unit tests now.

We think of tests as something that prevents regressions, as a way to prove that our code works correctly and to keep us from accidentally breaking things.

- Also, tests tell the story of the code.
- Tests help to expose the design of the code that you have, if the code is poorly designed it will be difficult to test.

You can write incorrect, misleading tests around well-designed code. However, the converse isn't really true. It's really hard to write nice, neat, intention revealing tests around code that is poorly designed.

<b>You can think of tests as the first reuse of your code.</b>

When you write tests last, it's very common to find that is really difficult to test your code, and the reason is, it's very easy when you're just writing code to get a bunch of tight coupling, to have a bunch of objects that know way too much about each other such that they can only be used in combination with each other.

If you're a test last kind of person, you just go beat on your tests until you make them work, no matter how painful it is, and you leave that entangled mess as a consequence for other people downstream.

<b>I promise you, that if you wrote tests first, you would not do this. It's too much trouble.</b>

This is an argument for writing tests first. If you write them first, you will refuse to put up with tightly-coupled code; you'll design your code so that testing is easy.

If you write the code first and put the tests last, no matter how difficult it is to get the tests running, you'll probably keep the code and just write those tests. 

Wirting tests for `BottleNumber0`, `BottleNumber1`, `BottleNumber6` is not worth the time, it wont save money and Sandi suggested to test the whole `BottleVerse` class instead.

Watch 2: Reorganizing Tests

We should strive to write the fastest tests possible, the fewest of them, with the most intention revealing expectations, and the least amount of code.

The fact that `BottleVerse` and `BottleNumber` are hidden is also a factor that don't require testing. On the other hand we have `Bottle` that gets injects `BottleVerse` which means it's a public relationship, it deserves testing.

```ruby
# public relationship and loose coupling between Bottle and BottleVerse
# it makes BottleVerse independent of context and suggest it should have unit test
class Bottles
  attr_reader :verse_template

  def initialize(verse_template: BottleVerse) ðŸ‘ˆ
    @verse_template = verse_template
  end
...
# not public relationship and tight coupling between BottleVerse and BottleNumber
class BottleVerse
  def self.lyrics(number)
    new(BottleNumber.for(number)).lyrics
  end
...
```

We started by creating a `BottleVerseTest` and move one by one of `BottlesTest`, we re-run test to see if something fails and changed the class initialized, instead of `BottlesTest` we created `BottleVerseTest`.

Another change was the verbose test name, here we want to be very explicit and reduce the uncertainty that a vague name could cause for future readers

```ruby
class BottleVerseTest < Minitest::Test
  def test_verse_general_rule_upper_bound
    expected = "99 bottles of beer on the wall, " +
      "99 bottles of beer.\n" +
      "Take one down and pass it around, " +
      "98 bottles of beer on the wall.\n"
    assert_equal expected, BottleVerse.lyrics(99)
  end

  def test_verse_general_rule_lower_bound
    expected = "3 bottles of beer on the wall, " +
      "3 bottles of beer.\n" +
      "Take one down and pass it around, " +
      "2 bottles of beer on the wall.\n"
    assert_equal expected, BottleVerse.lyrics(3)
  end

  def test_special_verse_2
    expected = "2 bottles of beer on the wall, " +
      "2 bottles of beer.\n" +
      "Take one down and pass it around, " +
      "1 bottle of beer on the wall.\n"
    assert_equal expected, BottleVerse.lyrics(2)
  end

  def test_special_verse_1
    expected = "1 bottle of beer on the wall, " +
      "1 bottle of beer.\n" +
      "Take it down and pass it around, " +
      "no more bottles of beer on the wall.\n"
    assert_equal expected, BottleVerse.lyrics(1)
  end

  def test_special_verse_0
    expected = "No more bottles of beer on the wall, " +
      "no more bottles of beer.\n" +
      "Go to the store and buy some more, " +
      "99 bottles of beer on the wall.\n"
    assert_equal expected, BottleVerse.lyrics(0)
  end
end
```

Watch 3: Seeking Context Independence

Context of an object is, its surroundings. It's the stuff that's around it, the things that it needs in order to be able to do its own job. Objects that require lots of context, large numbers of other things, are difficult to reuse in new contexts.

Objects that have less context, that require fewer things from their surroundings, are more reusable in other situations.

If we look at the `Bottle` class and because we went over several refactoring where we extracted and isolate some bit of code we do know why it's called `Bottle` but someone new might not know why therefore here is a new proposal to rename it. And given the fact that the song always goes downwards, like 15, 14, 13, 12, 11 and so on.

The first step is to copy/paste the `Bottle` class and rename the duplicate with `CountdownSong` and pass that new name to tests, re-run test and see that nothing breaks

```ruby
class CountdownSong
  attr_reader :verse_template

  def initialize(verse_template: BottleVerse)
    @verse_template = verse_template
  end
...
```

With this change the tests now seem awkward, like off of what the new name reflects, and that made the more context independent. We need to do something with the tests to tell a better story about what `CountdownSong` actually does.

Think of it from a reader point of view, where it's easy to read, where it really shows `CountdownSong` behavior. The next test is a story we would like to have, it doesn't work yet.

```ruby
# bottles_test.rb
class CountdownSongTest < MiniTest:Test
  def test_a_couple_of_tests
    expected = 
      "This is verse 99.\n" +
      "\n" +
      "This is verse 99.\n" +
      "\n" +
      "This is verse 97.\n"
    assert_equal(
      expected, CountdownSong.new.verses(99, 87))
...
```

If we write the code first, then we can start working on making it work with our code. What we need is another `verse_template` that would play as a `test_double` in RSpec.

New version more intention revealing for `test_a_couple_of_tests`

```ruby
class VerseFake
  def self.lyrics(number)
    "This is verse #{number}.\n"
  end
end

class CountdownSongTest < MiniTest:Test
  def test_a_couple_of_tests
    expected = 
      "This is verse 99.\n" +
      "\n" +
      "This is verse 99.\n" +
      "\n" +
      "This is verse 97.\n"
    assert_equal(
      expected, CountdownSong.new(verse_template: VerseFake).verses(99, 87))
...
```

Side node: we should not use pattern names in class names, for instance, inestead of `NumberDecorator` we used `BottleNumber` which is more revealing of the purpose. It's a failure of naming. We should be careful with `decorator`, `fake`, `wrapper`, `adapter` and `facade`.

The current public API of `CountdownSong` has `song`, `verses()` and `verse` and we still need to test the `veres` mehtod:

```ruby
class CountdownSongTest < MiniTest:Test
  def test_verse
    expected = "This is verse 500.\n"
    assert_equal(
      expected, CountdownSong.new(verse_template: VerseFake).verses(500))
  end

  def test_verses
    expected = 
      "This is verse 99.\n" +
      "\n" +
      "This is verse 99.\n" +
      "\n" +
      "This is verse 97.\n"
    assert_equal(
      expected, CountdownSong.new(verse_template: VerseFake).verses(99, 87))
...
```

Lastly, the method `song` in chapter 2 we had to write down all 100 cases for the song due to the code design, remember it's hardcoded `song(99, 0)` so it's time to extract and add them as argument in the `CountdownSong`

```ruby
class CountdownSong
  attr_reader :verse_template, :max, :min

  def initialize(verse_template:, max: 99999, min: 0)
    @verse_template = verse_template
    @max = max
    @min = min
  end

  def song
    verses(max, min)
  end

  def verses(upper, lower)
    upper.downto(lower).map { |i| verse(i) }.join("\n")
  end

  def verse(number)
    verse_template.lyrics(number)
  end
end
```

Here is the text for the `song` method, it has random numbers and now we can remove the big test.

```ruby
def test_song
  expected =
    "This is verse 23.\n" +
    "\n" +
    "This is verse 22.\n" +
    "\n" +
    "This is verse 21.\n" +
    "\n" +
    "This is verse 20.\n" +
    "\n" +
    "This is verse 19.\n"
  assert_equal expected, CountdownSong.new(verse_template: VerseFake, max: 23, min: 19).song
end
```

Watch 4: Communicating With the Future

### Find Shameless Green {#shameless-green}

### New requirement: Vary the Bits {#vary-the-bits}
