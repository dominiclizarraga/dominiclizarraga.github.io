---
title: "POOD Session 9: Loosen Coupling, Find Shameless Green & Vary the Bits"
date: 2025-10-04
categories: [pood]
description: '9th session, Loosen Coupling, Find Shameless Green & Vary the Bits'
layout: post
---

# Session 9: Vary Verse

Date: October 04, 2025

This blog post consists in two parts:

- [My notes on Loosen Coupling](#coupling)
- [My notes on Find Shameless Green](#shameless-green)
- [My notes on New requirement: Vary the Bits](#vary-the-bits)


### Key Concepts

- 

### Loosen Coupling {#coupling}

Watch 1: Choosing Which Units to Test

Unit tests are tests of just a single class (`Bottles`, `BottleNumber`) and an integration test is a test that checks the collaboration of more than one single class (`APIs`, `db interaction`).

The initial tests that we wrote back in Chapter 2 were unit tests to begin with because we just had that single `Bottles` class, and now they are badly out of date and they've long since been turned into integration tests.

The rule is every class should have a unit test.

All of these classes are being covered by the original tests that were unit tests but are now integration tests, and some of these new objects need their own unit tests now.

We think of tests as something that prevents regressions, as a way to prove that our code works correctly and to keep us from accidentally breaking things.

- Also, tests tell the story of the code.
- Tests help to expose the design of the code that you have, if the code is poorly designed it will be difficult to test.

You can write incorrect, misleading tests around well-designed code. However, the converse isn't really true. It's really hard to write nice, neat, intention revealing tests around code that is poorly designed.

<b>You can think of tests as the first reuse of your code.</b>

When you write tests last, it's very common to find that is really difficult to test your code, and the reason is, it's very easy when you're just writing code to get a bunch of tight coupling, to have a bunch of objects that know way too much about each other such that they can only be used in combination with each other.

If you're a test last kind of person, you just go beat on your tests until you make them work, no matter how painful it is, and you leave that entangled mess as a consequence for other people downstream.

<b>I promise you, that if you wrote tests first, you would not do this. It's too much trouble.</b>

This is an argument for writing tests first. If you write them first, you will refuse to put up with tightly-coupled code; you'll design your code so that testing is easy.

If you write the code first and put the tests last, no matter how difficult it is to get the tests running, you'll probably keep the code and just write those tests. 

Wirting tests for `BottleNumber0`, `BottleNumber1`, `BottleNumber6` is not worth the time, it wont save money and Sandi suggested to test the whole `BottleVerse` class instead.

Watch 2: Reorganizing Tests

We should strive to write the fastest tests possible, the fewest of them, with the most intention revealing expectations, and the least amount of code.

The fact that `BottleVerse` and `BottleNumber` are hidden is also a factor that don't require testing. On the other hand we have `Bottle` that gets injects `BottleVerse` which means it's a public relationship, it deserves testing.

```ruby
# public relationship and loose coupling between Bottle and BottleVerse
# it makes BottleVerse independent of context and suggest it should have unit test
class Bottles
  attr_reader :verse_template

  def initialize(verse_template: BottleVerse) ðŸ‘ˆ
    @verse_template = verse_template
  end
...
# not public relationship and tight coupling between BottleVerse and BottleNumber
class BottleVerse
  def self.lyrics(number)
    new(BottleNumber.for(number)).lyrics
  end
...
```

We started by creating a `BottleVerseTest` and move one by one of `BottlesTest`, we re-run test to see if something fails and changed the class initialized, instead of `BottlesTest` we created `BottleVerseTest`.

Another change was the verbose test name, here we want to be very explicit and reduce the uncertainty that a vague name could cause for future readers

```ruby
class BottleVerseTest < Minitest::Test
  def test_verse_general_rule_upper_bound
    expected = "99 bottles of beer on the wall, " +
      "99 bottles of beer.\n" +
      "Take one down and pass it around, " +
      "98 bottles of beer on the wall.\n"
    assert_equal expected, BottleVerse.lyrics(99)
  end

  def test_verse_general_rule_lower_bound
    expected = "3 bottles of beer on the wall, " +
      "3 bottles of beer.\n" +
      "Take one down and pass it around, " +
      "2 bottles of beer on the wall.\n"
    assert_equal expected, BottleVerse.lyrics(3)
  end

  def test_special_verse_2
    expected = "2 bottles of beer on the wall, " +
      "2 bottles of beer.\n" +
      "Take one down and pass it around, " +
      "1 bottle of beer on the wall.\n"
    assert_equal expected, BottleVerse.lyrics(2)
  end

  def test_special_verse_1
    expected = "1 bottle of beer on the wall, " +
      "1 bottle of beer.\n" +
      "Take it down and pass it around, " +
      "no more bottles of beer on the wall.\n"
    assert_equal expected, BottleVerse.lyrics(1)
  end

  def test_special_verse_0
    expected = "No more bottles of beer on the wall, " +
      "no more bottles of beer.\n" +
      "Go to the store and buy some more, " +
      "99 bottles of beer on the wall.\n"
    assert_equal expected, BottleVerse.lyrics(0)
  end
end
```

Watch 3: Seeking Context Independence

### Find Shameless Green {#shameless-green}

### New requirement: Vary the Bits {#vary-the-bits}
