---
title: "POOD Session 6: Polymorphism, Remedy Liskov & Make the Easy Change"
date: 2025-09-13
categories: [pood]
description: 'Sixth session, lesson Polymorphism, Remedy Liskov Violations & Make the Easy Change'
layout: post
---

# Session 6: Get to Know Polymorphism, Remedy Liskov Violations & Make the Easy Change

Date: September 13, 2025

This blog post consists in three parts:

- [My notes on Polymorphism](#poly)
- [My notes on Remedy Liskov Violations](#liskov)
- [My notes on Make the Easy Change](#make-easy-change)


### Key Concepts

- 

### Get to know Polymorphism {#poly}

Watch 1: Making Sense of Conditionals

This block contains two videos. One delves into conditionals and the other explores object-oriented polymorphism.

We still have not the code to be Open. Here, we are going to pick another code smell.

The most repeated pattern are the conditional, with 2 branches and all checking `number == 1` or `number == 0`.

The problem with repeating conditionals is evident. How many methods would you have to change to fulfill the six-pack requirement? You have to touch a bunch of places in here because the `six-pack-ness` is spread out over a number of these conditionals.

These conditionals provide us with generalizations in the `false` branches and specializations in the `true` branches.

If we had mixed up our styles of code, it would have been much more difficult to tell here what we needed to do next. Consistency of style enables future refactorings and enhances understanding.

Examples of bad usage of inheritance:

```ruby
# BAD: Deep/Wide Inheritance Hierarchy
class Employee; end
class FullTimeEmployee < Employee; end
class PartTimeEmployee < Employee; end
class ContractEmployee < Employee; end
class SeniorFullTimeEmployee < FullTimeEmployee; end
class JuniorFullTimeEmployee < FullTimeEmployee; end
# ... gets messy and hard to understand

# BAD: Tiny Specializations Leading to Cross-Cutting Problems
class Employee
  def swag_amount
    100
  end
  
  def tax_rate
    0.20
  end
end

class LongTermEmployee < Employee
  def swag_amount
    super * 2  # specializes only swag
  end
end

class OutOfStateEmployee < Employee
  def tax_rate
    0.15  # specializes only taxes
  end
end

# Problem: Need LongTermOutOfStateEmployee? Can't inherit from both!

# GOOD: Use Composition for Cross-Cutting Concerns
class Employee
  def initialize(swag_policy:, tax_policy:)
    @swag_policy = swag_policy
    @tax_policy = tax_policy
  end
  
  def swag_amount
    @swag_policy.calculate
  end
  
  def tax_rate
    @tax_policy.rate
  end
end

class StandardSwagPolicy
  def calculate
    100
  end
end

class LongTermSwagPolicy
  def calculate
    200
  end
end

class InStateTaxPolicy
  def rate
    0.20
  end
end

class OutOfStateTaxPolicy
  def rate
    0.15
  end
end

# Now you can mix and match any combination:
Employee.new(
  swag_policy: LongTermSwagPolicy.new,
  tax_policy: OutOfStateTaxPolicy.new
)

# ACCEPTABLE: Inheritance for Leaf Nodes (Small, Focused Classes)
class BottleNumber
  def container
    "bottles"
  end
end

class BottleNumber1 < BottleNumber
  def container
    "bottle"  # specializes most of the small class
  end
end

class BottleNumber0 < BottleNumber
  def quantity
    "no more"  # specializes most of the small class
  end
end
```

Watch 2: Replacing Conditionals with Polymorphism

"Poly" means many, "morph" in this case means form. Many forms.

We use `polymorphism` to describe a situation in which many different `objects` can respond to the same `message`.

This means that the message sender doesn't know or care the type of the object that it gets passed, and it means that later you can create new objects that `polymorphously` play some existing role and get that behavior into your app without having to change anything about those objects that are sending the messages.

Let's implement a Factory object model that evaluates and creates depending on the request, different new objects, these new objects will inherit from a general `BottleNumber` and will contain specializations. This will reduce the conditionals we have into several new small classes.

This change is like primitive obsession but instead of obsessing upon the entire class, we actually obsess on instances of the class (0 and 1).

```ruby
class Bottles
  def song
    verses(99, 0)
  end

  def verses(upper, lower)
    upper.downto(lower).map { |i| verse(i) }.join("\n")
  end

  def verse(number)
    bottle_number = bottle_number_for(number)
    next_bottle_number = bottle_number_for(bottle_number.successor)

    "#{bottle_number} of beer on the wall, ".capitalize +
    "#{bottle_number} of beer.\n" +
    "#{bottle_number.action}, " +
    "#{next_bottle_number} of beer on the wall.\n"
  end

  # Factory
  def bottle_number_for(number)
    case number
    when 0
      BottleNumber0
    when 1
      BottleNumber1
    else
      BottleNumber
    end.new(number)
  end
end

class BottleNumber
  attr_reader :number
  def initialize(number)
    @number = number
  end

  def to_s
    "#{quantity} #{container}"
  end

  def quantity
    number.to_s
  end

  def container
     "bottles"
  end

  def action
    "Take #{pronoun} down and pass it around"
  end

  def pronoun
    "one"
  end

  def successor
    number - 1
  end
end

class BottleNumber0 < BottleNumber
  def quantity
    "no more"
  end

  def action
    "Go to the store and buy some more"
  end

  def successor
    99
  end
end

class BottleNumber1 < BottleNumber
  def container
    "bottle"
  end

  def pronoun
    "it"
  end
end
```

### Remedy Liskov Violations {#liskov}

### Make the Easy Change {#make-easy-change}

