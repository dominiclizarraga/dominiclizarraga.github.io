---
title: "POOD Session 6: Get to Know Polymorphism, Remedy Liskov Violations & Make the Easy Change"
date: 2025-09-13
categories: [pood]
description: 'Sixth session, lesson Get to Know Polymorphism, Remedy Liskov Violations & Make the Easy Change'
layout: post
---

# Session 6: Get to Know Polymorphism, Remedy Liskov Violations & Make the Easy Change

Date: September 13, 2025

This blog post consists in three parts:

- [My notes on Polymorphism](#poly)
- [My notes on Remedy Liskov Violations](#liskov)
- [My notes on Make the Easy Change](#make-easy-change)


### Key Concepts

- 

### Get to know Polymorphism {#poly}

Watch 1: Making Sense of Conditionals

This block contains two videos. One delves into conditionals and the other explores object-oriented polymorphism.

We still have not the code to be Open. Here, we are going to pick another code smell.

The most repeated pattern are the conditional, with 2 branches and all checking `number == 1` or `number == 0`.

The problem with repeating conditionals is evident. How many methods would you have to change to fulfill the six-pack requirement? You have to touch a bunch of places in here because the `six-pack-ness` is spread out over a number of these conditionals.

These conditionals provide us with generalizations in the `false` branches and specializations in the `true` branches.

If we had mixed up our styles of code, it would have been much more difficult to tell here what we needed to do next. Consistency of style enables future refactorings and enhances understanding.

Examples of bad usage of inheritance:

```ruby
# BAD: Deep/Wide Inheritance Hierarchy
class Employee; end
class FullTimeEmployee < Employee; end
class PartTimeEmployee < Employee; end
class ContractEmployee < Employee; end
class SeniorFullTimeEmployee < FullTimeEmployee; end
class JuniorFullTimeEmployee < FullTimeEmployee; end
# ... gets messy and hard to understand

# BAD: Tiny Specializations Leading to Cross-Cutting Problems
class Employee
  def swag_amount
    100
  end
  
  def tax_rate
    0.20
  end
end

class LongTermEmployee < Employee
  def swag_amount
    super * 2  # specializes only swag
  end
end

class OutOfStateEmployee < Employee
  def tax_rate
    0.15  # specializes only taxes
  end
end

# Problem: Need LongTermOutOfStateEmployee? Can't inherit from both!

# GOOD: Use Composition for Cross-Cutting Concerns
class Employee
  def initialize(swag_policy:, tax_policy:)
    @swag_policy = swag_policy
    @tax_policy = tax_policy
  end
  
  def swag_amount
    @swag_policy.calculate
  end
  
  def tax_rate
    @tax_policy.rate
  end
end

class StandardSwagPolicy
  def calculate
    100
  end
end

class LongTermSwagPolicy
  def calculate
    200
  end
end

class InStateTaxPolicy
  def rate
    0.20
  end
end

class OutOfStateTaxPolicy
  def rate
    0.15
  end
end

# Now you can mix and match any combination:
Employee.new(
  swag_policy: LongTermSwagPolicy.new,
  tax_policy: OutOfStateTaxPolicy.new
)

# ACCEPTABLE: Inheritance for Leaf Nodes (Small, Focused Classes)
class BottleNumber
  def container
    "bottles"
  end
end

class BottleNumber1 < BottleNumber
  def container
    "bottle"  # specializes most of the small class
  end
end

class BottleNumber0 < BottleNumber
  def quantity
    "no more"  # specializes most of the small class
  end
end
```


Watch 2: Replacing Conditionals with Polymorphism


### Remedy Liskov Violations {#liskov}

### Make the Easy Change {#make-easy-change}

