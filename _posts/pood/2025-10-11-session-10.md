---
title: "POOD Session 10: Beware Inheritance & Lean Towards Composition"
date: 2025-10-11
categories: [pood]
description: '10th session, Beware Inheritance & Lean Towards Composition'
layout: post
---

# Session 10: Beware Inheritance & Lean Towards Composition

Date: October 11, 2025

This blog post consists in three parts:

- [My notes on Beware Inheritance](#inheritance)
- [My notes on Lean Towards Composition](#composition)


### Key Concepts

- 

### Beware Inheritance {#inheritance}

This block contains an example that illustrates how convenient inheritance can be, and how it can go very badly wrong.

In this section we're going to create a beautiful, simple, little inheritance hierarchy to show how useful inheritance can be to quickly getting things done, and then we're going to introduce a change in requirements that makes everything go horribly wrong to show when you should switch from inheritance to composition.

The new requirement is a variant of `House` that mixes up the bits, randomly. We need the original requirement to still work, `House` should still work just like it does, but they also want another variant where the `lines` come out mixed up, randomly, every time.

Let's do that with `inheritance`.

First proposal:

```ruby
# original code
class House
  DATA =
    [ "the horse and the hound and the horn that belonged to",
      "the farmer sowing his corn that kept",
      "the rooster that crowed in the morn that woke",
      "the priest all shaven and shorn that married",
      "the man all tattered and torn that kissed",
      "the maiden all forlorn that milked",
      "the cow with the crumpled horn that tossed",
      "the dog that worried",
      "the cat that killed",
      "the rat that ate",
      "the malt that lay in",
      "the house that Jack built"]

  def recite
    1.upto(12).collect {|i| line(i)}.join("\n")
  end

  def phrase(num)
    data.last(num).join(" ")
  end

  def line(num)
    "This is #{phrase(num)}.\n"
  end

  def data
    DATA
  end
end

# RandomHouse code
class RandomHouse < House
  def data
    @data ||= super.shuffle
  end
end

# PirateHouse code
class PirateHouse < House
  def prefix
    "Thar be"
  end
end

puts 
puts RandomHouse.new.line(12)

puts
puts PirateHouse.new.line(12)
```

New requirement is going to make everything break badly with this `inheritance` approach. Implement `RandomPirateHouse` without duplicating code. `Module` is not feasable, `composition` is the right solution.

You want your inheritance hierarchies to be shallow, not very deep, and narrow, not very wide. You want the subclasses to really be a kind of thing of the superclasses.

<b>Use of inheritance only on your object dependency graph leaf nodes. t the core of your app are key objects that depend on others, forming a chain outward. At the edges are leaf objects like `BottleNumber#` that are depended on but depend on nothing else.</b>

When you create subclasses that are that far out away from the center of your domain they're probably not all that important, and they're probably not going to change that much, and it might not go badly wrong to use inheritance out there.

### Lean Towards Composition {#composition}


