---
title: "POOD Session 7: Manufacture Role Players & Alter Base Classes (Monkeypatching)"
date: 2025-09-20
categories: [pood]
description: '7th session, Manufacture Role Players & Alter Base Classes (Monkeypatching)'
layout: post
---

# Session 7: Manufacture Role Players 

Date: September 20, 2025

This blog post consists in three parts:

- [My notes on Manufacture Role Players](#role-playes)
- [My notes on Alter Base Classes (Monkeypatching)](#monkeypatching)
- [Notes on Sandi's talk Managing Dependencies (Go Ahead, Make a Mess)](#dependencies)


### Key Concepts

- 

### Manufacture Role Players {#role-playes}

Watch 1: Contrasting the Concrete Factory with Shameless Green

In this lesson, we covered how the new `Factory` differs from the old conditional structure we had. Sandi encouraged us to think about why the first conditional had `0`, `1`, `2`, and `"else"` branches, while in the new `Factory` model, we only have `0`, `1`, and `"else"` branches.

We don’t have a `"2"` branch because in the `Shameless Green exercise`, becuase some words needed to be transformed from plural to singular. Now, with the new `Factory` model, it takes care of this as a `BottleNumber` class.

The key point of factories is selecting the required path and creating the corresponding instance, no behavior is involved. This contrasts with the first version, where after choosing the path, and behavior was supplied. This is something that factories should avoid doing.

Watch 2: Fathoming Factories

Polymorphism is the word we use to refer to that quality where many different objects can respond to the same message.

Message senders don't need to know the name of the class. They just need to know the name of the message, and so, the class effectively disappears.

So Shock should be ignorant of the names of all these classes. It shouldn't know the implementation details inside these classes. And it shouldn't know how to pick which class is the right one for any certain circumstance.

It's the responsibility of a factory to manufacture the correct instance of a role playing object. The factory knows all those things that the Shock class doesn't know. The factory knows all the names of the types, and it knows how to pick the right type for any specific circumstance.

You can think of factories as the place in your application where conditionals go to die.

Isolating conditionals in factories loosens the coupling between the objects in your application, and it lowers the cost of change.

If you isolate the conditional in the `factory` and the names of the types in the factory, it means that it doesn't matter to the `Shock` class, to the object wants to interact with a player of the cost role, that class doesn't care if you add or remove new `Shock` types. 

The changes that need to be made to add or remove an object all happen in the `factory`, and the `factory` contains a very simple bit of code.

Here is a visual example of how we passed from a convoluted `Bycicle/Shock` objects to a `factory` and `roles`.

Working on a `bicycle` simulation. Each `bicycle` could have optional `shocks`, and those `shocks` involved a complex `“cost”` calculation. As more `shock` types were added, the best approach was to extract them into their own `classes`. Each `shock` class implemented its own `cost` method, allowing all `shocks` to respond consistently to the same message.

This design made it easy to add new `shock` types without breaking existing code. However, Sandi explained that an even better approach would be to introduce a `factory`, which is responsible only for knowing which `shock` to instantiate. The `factory` doesn’t need to know about the internal implementation of each shock, it just returns the correct one when requested.

<div style="text-align: center;">
  <video 
    src="/videos/factories_in_code_polymorphism_many_objects_respons_to_same_msg.mp4" 
    controls 
    style="border-radius: 0.375rem; height: 350px; width: 500px;"
  >
    Your browser does not support the video tag.
  </video>
</div>

Sandi mentioned 3 types of factories:

<table border="1">
  <tr>
    <th>Dimension</th>
    <th>Options</th>
  </tr>
  <tr>
    <td><strong>Structure</strong></td>
    <td>Open or Closed</td>
  </tr>
  <tr>
    <td><strong>Choosing Logic Location</strong></td>
    <td>Factory owns the logic or Logic is dispersed in the objects being chosen</td>
  </tr>
  <tr>
    <td><strong>Type Knowledge</strong></td>
    <td>Factory knows all type names or Objects register themselves with the factory</td>
  </tr>
</table>

Watch 3: Opening the Factory

In this lesson, we looked at how our current `factory` isn’t really open. The fact that we had to manually add `BottleNumber6` shows that every time we need a new type, we’d have to edit the `factory` again. That’s fine if nothing ever changes, but it’s not very flexible. So the goal here is to make it open, to let new `BottleNumber` classes get created automatically just by following a naming convention.

To do that, we use a bit of Ruby metaprogramming. The trick is `const_get`, a method that takes a string like `"BottleNumber6"` and turns it into the actual `class`. If the `class` exists, great — we get it back. If it doesn’t, Ruby throws a `NameError`, which we can rescue and fall back to a default `BottleNumber` class. This makes the factory much more dynamic, since it no longer needs a big case statement to decide what to build.

There was also a quick side trip into how garbage collection works in Ruby, which was actually super helpful. Basically, objects get cleaned up when nothing references them anymore, but class definitions don’t, they stick around forever because Ruby keeps them in a sort of “big hash in the sky.” That’s why you need to be careful with class variables: anything stored there will live for the entire life of the program. So yeah, a bit of metaprogramming magic, a bit of memory awareness, and now our factory is officially open for business.

```ruby
class BottleNumber
  def self.for(number)
    begin
      const_get("BottleNumber#{number}")
    rescue NameError
      BottleNumber
    end.new(number)

    # case number
    # when 0
    #   BottleNumber0
    # when 1
    #   BottleNumber1
    # else
    #   BottleNumber
    # end.new(number)
  end
end
```

It's not obvious what this code does, and that might be an issue for people. It's a very valid.

These metaprogramed classes, a big downside is you can't find them anymore and someone can wipe them out since are not referenced anymore.

You know, for every question in `OO`, the answer is always, `"It depends"`, and here it depends. We're just trying to save money. We wanna write the most cost effective code. Sometimes adding a little complexity will reduce overall cost. 

You have to be careful because we wanna be overly complex a lot of times, but if complexity will save you money, then it's cheaper and you should do it.

Watch 4: Supporting Arbitrary Class Names

In this lesson, we explored the third way to make the factory open. This time, Sandi proposed using a `Hash` to support arbitrary class names, meaning the factory isn’t limited to `BottleNumber` anymore. The implementation is pretty straightforward, but even with this `hash` approach, it still feels a lot like the first version with the case statement. If you want to add a new class, you still have to edit the hash and add a new key-value pair. So technically, it’s not fully open yet, but it does separate data from logic in a cleaner way.

The case statement version is definitely easier to read since it’s just a simple list of conditions. But the advantage of the hash approach is that the data driving the program now lives separately, and that opens the door to storing it somewhere else, like in a `YAML` file or a database. 

One cool side note from this section was how Sandi pointed out that your syntax highlighter can give you hints about your code’s design. Fewer color changes usually mean simpler, more object-oriented code — bigger chunks of the same abstraction. In contrast, when you see lots of color changes, that’s often procedural code with many shifting ideas packed together.

```ruby
class BottleNumber
  def self.for(number)
    Hash.new(BottleNumber).merge(
      0 => BottleNumber0,
      1 => BottleNumber1,
      6 => BottleNumber6)[BottleNumber].new(BottleNumber)
  end
end
```
Watch 5: Dispersing the Choosing Logic

After the three types of factories we saw `case statements`, `metaprogramming`, `hash` all of them knew everything about the `BottleNumber` which is the value of the number, the class names that might be chosen, and how to map which class was needed.

Having the `factory` know all these things makes sense, especially if the choosing logic is really simple like we have here, where we're just testing for simple equality. 

If the logic necessary to choose changes in lockstep with the code in the class being chosen, you want to co-locate those things, you would like the choosing logic to be somehow over in that class.

You could take the choosing logic and disperse it into each class that might be chosen, and have the `factory` iterate over those classes and ask each of them if they're the one.

```ruby
class BottleNumber
  def self.for(number)
    [BottleNumber6, BottleNumber1, BottleNumber0, BottleNumber].
      find { |candidate| candidate.handles?(number) }.new(number)
  end
...

class BottleNumber0 < BottleNumber
  def self.handles?(number)
    number == 0
  end
...

class BottleNumber1 < BottleNumber
  def self.handles?(number)
    number == 1
  end
...

class BottleNumber6 < BottleNumber
  def self.handles?(number)
    number == 6
  end
...
```
The biggest thing we did, is we took the logic the choosing logic (qithin `factory`) that was more closely related to the objects being chosen than to the factory and we dispersed that out into each of the objects, had the `factory` iterate over that list of objects and ask each one if they were the one.

Watch 6: Self-registering Candidates



### Alter Base Classes (Monkeypatching) {#monkeypatching}

### Managing Dependencies {#dependencies}