---
title: "POOD Session 7: Manufacture Role Players & Alter Base Classes (Monkeypatching)"
date: 2025-09-20
categories: [pood]
description: '7th session, Manufacture Role Players & Alter Base Classes (Monkeypatching)'
layout: post
---

# Session 7: Manufacture Role Players 

Date: September 20, 2025

This blog post consists in three parts:

- [My notes on Manufacture Role Players](#role-playes)
- [My notes on Alter Base Classes (Monkeypatching)](#monkeypatching)
- [Notes on Sandi's talk Managing Dependencies (Go Ahead, Make a Mess)](#dependencies)


### Key Concepts

- 

### Manufacture Role Players {#role-playes}

Watch 1: Contrasting the Concrete Factory with Shameless Green

In this lesson, we covered how the new `Factory` differs from the old conditional structure we had. Sandi encouraged us to think about why the first conditional had `0`, `1`, `2`, and `"else"` branches, while in the new `Factory` model, we only have `0`, `1`, and `"else"` branches.

We don’t have a `"2"` branch because in the `Shameless Green exercise`, becuase some words needed to be transformed from plural to singular. Now, with the new `Factory` model, it takes care of this as a `BottleNumber` class.

The key point of factories is selecting the required path and creating the corresponding instance, no behavior is involved. This contrasts with the first version, where after choosing the path, and behavior was supplied. This is something that factories should avoid doing.

Watch 2: Fathoming Factories

Polymorphism is the word we use to refer to that quality where many different objects can respond to the same message.

Message senders don't need to know the name of the class. They just need to know the name of the message, and so, the class effectively disappears.

So Shock should be ignorant of the names of all these classes. It shouldn't know the implementation details inside these classes. And it shouldn't know how to pick which class is the right one for any certain circumstance.

It's the responsibility of a factory to manufacture the correct instance of a role playing object. The factory knows all those things that the Shock class doesn't know. The factory knows all the names of the types, and it knows how to pick the right type for any specific circumstance.

You can think of factories as the place in your application where conditionals go to die.

Isolating conditionals in factories loosens the coupling between the objects in your application, and it lowers the cost of change.

If you isolate the conditional in the `factory` and the names of the types in the factory, it means that it doesn't matter to the `Shock` class, to the object wants to interact with a player of the cost role, that class doesn't care if you add or remove new `Shock` types. 

The changes that need to be made to add or remove an object all happen in the `factory`, and the `factory` contains a very simple bit of code.

Here is a visual example of how we passed from a convoluted `Bycicle/Shock` objects to a `factory` and `roles`.

Working on a `bicycle` simulation. Each `bicycle` could have optional `shocks`, and those `shocks` involved a complex `“cost”` calculation. As more `shock` types were added, the best approach was to extract them into their own `classes`. Each `shock` class implemented its own `cost` method, allowing all `shocks` to respond consistently to the same message.

This design made it easy to add new `shock` types without breaking existing code. However, Sandi explained that an even better approach would be to introduce a `factory`, which is responsible only for knowing which `shock` to instantiate. The `factory` doesn’t need to know about the internal implementation of each shock, it just returns the correct one when requested.

<div style="text-align: center;">
  <video 
    src="/videos/factories_in_code_polymorphism_many_objects_respons_to_same_msg.mp4" 
    controls 
    style="border-radius: 0.375rem; height: 350px; width: 500px;"
  >
    Your browser does not support the video tag.
  </video>
</div>

Sandi mentioned 3 types of factories:

<table border="1">
  <tr>
    <th>Dimension</th>
    <th>Options</th>
  </tr>
  <tr>
    <td><strong>Structure</strong></td>
    <td>Open or Closed</td>
  </tr>
  <tr>
    <td><strong>Choosing Logic Location</strong></td>
    <td>Factory owns the logic or Logic is dispersed in the objects being chosen</td>
  </tr>
  <tr>
    <td><strong>Type Knowledge</strong></td>
    <td>Factory knows all type names or Objects register themselves with the factory</td>
  </tr>
</table>

### Alter Base Classes (Monkeypatching) {#monkeypatching}

### Managing Dependencies {#dependencies}