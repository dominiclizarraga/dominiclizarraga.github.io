---
title: "POOD Session 7: Manufacture Role Players & Alter Base Classes (Monkeypatching)"
date: 2025-09-20
categories: [pood]
description: '7th session, Manufacture Role Players & Alter Base Classes (Monkeypatching)'
layout: post
---

# Session 7: Manufacture Role Players 

Date: September 20, 2025

This blog post consists in three parts:

- [My notes on Manufacture Role Players](#role-playes)
- [My notes on Alter Base Classes (Monkeypatching)](#monkeypatching)
- [Notes on Sandi's talk Managing Dependencies (Go Ahead, Make a Mess)](#dependencies)


### Key Concepts

- 

### Manufacture Role Players {#role-playes}

Watch 1: Contrasting the Concrete Factory with Shameless Green

In this lesson, we covered how the new `Factory` differs from the old conditional structure we had. Sandi encouraged us to think about why the first conditional had `0`, `1`, `2`, and `"else"` branches, while in the new `Factory` model, we only have `0`, `1`, and `"else"` branches.

We don’t have a `"2"` branch because in the `Shameless Green exercise`, becuase some words needed to be transformed from plural to singular. Now, with the new `Factory` model, it takes care of this as a `BottleNumber` class.

The key point of factories is selecting the required path and creating the corresponding instance, no behavior is involved. This contrasts with the first version, where after choosing the path, and behavior was supplied. This is something that factories should avoid doing.

Watch 2: Fathoming Factories

Polymorphism is the word we use to refer to that quality where many different objects can respond to the same message.

Message senders don't need to know the name of the class. They just need to know the name of the message, and so, the class effectively disappears.

So Shock should be ignorant of the names of all these classes. It shouldn't know the implementation details inside these classes. And it shouldn't know how to pick which class is the right one for any certain circumstance.

It's the responsibility of a factory to manufacture the correct instance of a role playing object. The factory knows all those things that the Shock class doesn't know. The factory knows all the names of the types, and it knows how to pick the right type for any specific circumstance.

You can think of factories as the place in your application where conditionals go to die.

Isolating conditionals in factories loosens the coupling between the objects in your application, and it lowers the cost of change.

If you isolate the conditional in the `factory` and the names of the types in the factory, it means that it doesn't matter to the `Shock` class, to the object wants to interact with a player of the cost role, that class doesn't care if you add or remove new `Shock` types. 

The changes that need to be made to add or remove an object all happen in the `factory`, and the `factory` contains a very simple bit of code.

Here is a visual example of how we passed from a convoluted `Bycicle/Shock` objects to a `factory` and `roles`.

Working on a `bicycle` simulation. Each `bicycle` could have optional `shocks`, and those `shocks` involved a complex `“cost”` calculation. As more `shock` types were added, the best approach was to extract them into their own `classes`. Each `shock` class implemented its own `cost` method, allowing all `shocks` to respond consistently to the same message.

This design made it easy to add new `shock` types without breaking existing code. However, Sandi explained that an even better approach would be to introduce a `factory`, which is responsible only for knowing which `shock` to instantiate. The `factory` doesn’t need to know about the internal implementation of each shock, it just returns the correct one when requested.

<div style="text-align: center;">
  <video 
    src="/videos/factories_in_code_polymorphism_many_objects_respons_to_same_msg.mp4" 
    controls 
    style="border-radius: 0.375rem; height: 350px; width: 500px;"
  >
    Your browser does not support the video tag.
  </video>
</div>

Sandi mentioned 3 types of factories:

<table border="1">
  <tr>
    <th>Dimension</th>
    <th>Options</th>
  </tr>
  <tr>
    <td><strong>Structure</strong></td>
    <td>Open or Closed</td>
  </tr>
  <tr>
    <td><strong>Choosing Logic Location</strong></td>
    <td>Factory owns the logic or Logic is dispersed in the objects being chosen</td>
  </tr>
  <tr>
    <td><strong>Type Knowledge</strong></td>
    <td>Factory knows all type names or Objects register themselves with the factory</td>
  </tr>
</table>

Watch 3: Opening the Factory

In this lesson, we looked at how our current `factory` isn’t really open. The fact that we had to manually add `BottleNumber6` shows that every time we need a new type, we’d have to edit the `factory` again. That’s fine if nothing ever changes, but it’s not very flexible. So the goal here is to make it open, to let new `BottleNumber` classes get created automatically just by following a naming convention.

To do that, we use a bit of Ruby metaprogramming. The trick is `const_get`, a method that takes a string like `"BottleNumber6"` and turns it into the actual `class`. If the `class` exists, great — we get it back. If it doesn’t, Ruby throws a `NameError`, which we can rescue and fall back to a default `BottleNumber` class. This makes the factory much more dynamic, since it no longer needs a big case statement to decide what to build.

There was also a quick side trip into how garbage collection works in Ruby, which was actually super helpful. Basically, objects get cleaned up when nothing references them anymore, but class definitions don’t, they stick around forever because Ruby keeps them in a sort of “big hash in the sky.” That’s why you need to be careful with class variables: anything stored there will live for the entire life of the program. So yeah, a bit of metaprogramming magic, a bit of memory awareness, and now our factory is officially open for business.

```ruby
class BottleNumber
  def self.for(number)
    begin
      const_get("BottleNumber#{number}")
    rescue NameError
      BottleNumber
    end.new(number)

    # case number
    # when 0
    #   BottleNumber0
    # when 1
    #   BottleNumber1
    # else
    #   BottleNumber
    # end.new(number)
  end
end
```

It's not obvious what this code does, and that might be an issue for people. It's a very valid.

These metaprogramed classes, a big downside is you can't find them anymore and someone can wipe them out since are not referenced anymore.

You know, for every question in `OO`, the answer is always, `"It depends"`, and here it depends. We're just trying to save money. We wanna write the most cost effective code. Sometimes adding a little complexity will reduce overall cost. 

You have to be careful because we wanna be overly complex a lot of times, but if complexity will save you money, then it's cheaper and you should do it.

Watch 4: Supporting Arbitrary Class Names



### Alter Base Classes (Monkeypatching) {#monkeypatching}

### Managing Dependencies {#dependencies}