---
title: "POOD Session 8: Vary Verse"
date: 2025-09-27
categories: [pood]
description: '8th session, Vary Verse'
layout: post
---

# Session 8: Vary Verse

Date: September 27, 2025

This blog post consists in one part:

- [My notes on Vary Verse](#vary-verse)

### Key Concepts

- Law of demeter
- Composition 

### Vary Verse{#vary-verse}

Watch 1: Appreciating the Mechanical Process

This block introduces a new requirement <i>to vary the lyrics of the verse</i> which allows us to begin considering whether and when you might voluntarily make changes to improve code.

In this block introduce the ideas of 'pseudocode' and 'coding by wishful thinking.'  This block culminates with the Dependency Inversion Principle (DIP), one of the most broadly useful concepts in object-oriented programming.

The current code is simple because we started out with no abstractions. No incorrect abstractions or make abstractions from things we didn't really understand.

<b>Then we used repeatable programming techniques to follow code smells, then extract differences and isolate variance</b>

The story this code tells is that there's a more abstract kind of verse, that allthe 99 bottles verses have in common, a single abstraction.

```ruby
def verse(number)
  # here the number (Integer) gets transformed into a BottleNumber instance
  # then goes into the Factory
  bottle_number = BottleNumber.for(number)
  # here is the template
  "#{bottle_number} of beer on the wall, ".capitalize +
  "#{bottle_number} of beer.\n" +
  "#{bottle_number.action}, " +
  "#{bottle_number.successor} of beer on the wall.\n"
end
```

If you were to describe the responsibility of `verse` method, you would say it converts a `number` into a `BottleNumber`, and then it uses that `BottleNumber` to create a `verse`.

The use of the word "and" in that sentence, converts a number into a `BottleNumber` AND uses that `BottleNumber` to make a `verse` that word "and" should give you pause.

Given "and" shows that `verse` method have more than one responsibility.

These 6 lines of code, represent not much hurt, it can be considered as a code smell but since we have not gotten any other requirement we can leave it as it's.

However, if you voluntarily want to refactor this code into something more SOLID, consider the outlook that you're the steward of someone else money and if this change in the present will save money in the future or maybe you're better off and wait the next requirement.

What you want is to have a set of internal rules that allow you to make bets on whether or not changes are going to turn out, and you want those bets to pay off more often than not.

Code smell here is "Speculative generality" making improvements to code based on your ideas that will pay off later.

Really good progammers, write really changeable code.

We'll see the heuristics, the set of rules can make you more confident, not that every one of these changes is going to save you money later, but they probably won't cost you money, and enough of them will actually save you money so that it's worth doing it all the time.

Experienced programmers are like little artificial intelligence machines that have been trained on many, many, many examples of code. Their experience of making judgments, and looking at how those judgments turned out over years, and years, and years, build up into a kind of intuition. And you can think of that programming intuition really as just a form of pattern matching.

They can look at a set of code and recognize shapes that are going to cause trouble later, and they know how to transform those shapes that are going to be a problem into shapes that are going to be easy to change later.

Watch 2: Clarifying Responsibilities with Pseudocode

New requirement is to make code produce different song verses.

As we use the `.downto()` method we must ask if the new verse will count downwards too so that we can know we need to change code or not.

If we need to know if code is Open or Closed to change we can refer to diagram:

<div>
  <img 
    src="/graphics/projects/openness_diagram_sandi_metz_2.png" 
    alt="code_is_open_diagram" 
    style="border-radius: 0.375rem; height: 350px; width: 500px; display: block; margin: auto;"
  />
</div>

If code is not open and we don't know how to male it open, we look for code smells.

The benefits of writing bad code is that we introduce code smells that will give us a glimpse of the future that we can preemptively decide what code smells we are going to have and use refactoring to remove them.

Here, is a first sketch with pseudo code:

```ruby
  def verse(number)
    # if 99_bottle_song
    bottle_number = BottleNumber.for(number)

    "#{bottle_number} of beer on the wall, ".capitalize +
    "#{bottle_number} of beer.\n" +
    "#{bottle_number.action}, " +
    "#{bottle_number.successor} of beer on the wall.\n"
    #
    # elsif unknown_song_2_verse
    # ...
    #   assemble verse for unknown song 2
    # ...
    # elsif unknown_song_3
    # ...
    #   assemble verse for unknown song 3
    # ...
    # end
  end
```

Above `if statement` is just going to grow, and grow, and grow, and grow, and grow, until your life is a disaster so pseudo code help us see if we are heading a dead end road and identify it quickly.

<b>Solution: the problem is we have this conditional with a number of branches, and each of those branches should represent an `object`, a different kind of verse `variant`. And that means we should apply the `Extract Class` refactoring to pull those different `verse_templates` out into some other class. </b>

Watch 3: Extracting the Verse

As we did back in chapter 5, when we had the code smell of "primitive obsession" on `number` argument, and we created `BottleNumber` we need to follow the next steps:

1. Choose a name for the new class
2. Add `attr_reader` and `initializer`
3. Copy methods from old to new (not cut!)
4. Wire new class into old (NewClass.new)
5. Clean up extra args

<b>Classes should be name after what they are ! </b>

In this case `BottleVerse`

```ruby
class Bottles
  def verse(number)
    BottleVerse.new(number).verse(number)
    # bottle_number = BottleNumber.for(number)

    # "#{bottle_number} of beer on the wall, ".capitalize +
    # "#{bottle_number} of beer.\n" +
    # "#{bottle_number.action}, " +
    # "#{bottle_number.successor} of beer on the wall.\n"
  end
end

class BottleVerse
  attr_reader :number

  def initialize(number)
    @number = number
  end

  def verse(number)
    bottle_number = BottleNumber.for(number)

    "#{bottle_number} of beer on the wall, ".capitalize +
    "#{bottle_number} of beer.\n" +
    "#{bottle_number.action}, " +
    "#{bottle_number.successor} of beer on the wall.\n"
  end
end
```

Up to this point and running after each change tests, we were able to create a new class, make it syntatically correct, invoke it from the old class and now we still need to remove old-extra-arguments.

Watch 4: Coding by Wishful Thinking

In object-oriented programming, we think of design as happening from the message sender's point of view.

AI example code of above phrase:

```ruby
# Design from the message sender's point of view
#
# Don't ask: "What CAN this object do?" (receiver perspective)
# Ask instead: "What do I NEED this object to do?" (sender perspective)
#
# The sender (trip) only cares about getting a description, it doesn't 
# care whether the vehicle is a Car, Bike, or Plane. We design the 
# interface based on what the sender needs to send, not what the 
# receiver happens to have.

class Trip
  def initialize(vehicle)
    @vehicle = vehicle
  end

  def plan
    puts "Planning trip using: #{@vehicle.describe}"
  end
end

# All vehicles respond to the message the sender needs
class Car
  def describe
    "a comfortable car"
  end
end

class Bike
  def describe
    "an eco-friendly bike"
  end
end

# Usage - Trip sends 'describe', vehicles respond
trip1 = Trip.new(Car.new)
trip1.plan  # => Planning trip using: a comfortable car

trip2 = Trip.new(Bike.new)
trip2.plan  # => Planning trip using: an eco-friendly bike
```

The key: Trip (the sender) defines what message it needs (`describe`), and all receivers must respond to that interface.

Here is the result of wishful thinking:

```ruby
class Bottles
  def verse(number)
    BottleVerse.new(number).lyrics
  end
end

class BottleVerse
  attr_reader :number

  def initialize(number)
    @number = number
  end

  def lyrics
    bottle_number = BottleNumber.for(number)

    "#{bottle_number} of beer on the wall, ".capitalize +
    "#{bottle_number} of beer.\n" +
    "#{bottle_number.action}, " +
    "#{bottle_number.successor} of beer on the wall.\n"
  end
end
```

Watch 5: Inverting Dependencies

We just created a `BottleVerse` class because we're trying to fulfill a new requirement to produce new songs that are like `99 Bottles`, but have different lyrics.

In the prior section, we extracted the thing we wanted to vary, the `verse` method, those `lyrics` out into a new `BottleVerse` class and yet we still can't actually fulfill the requirement.

Dependency Inversion, says that you should depend on abstractions, not concretions. And right now, here in this code, the name of the `BottleVerse` class is a concretion. (This create a tight coupling between these two classes)

```ruby
class Bottles
  def verse(number)
    BottleVerse.new(number).lyrics # This makes both classes to be tight together
  end
end
```

Depending on the class name `BottleVerse` is bad but not as bad as having `Bottle` unable to interact with other classes to produce `.lyrics`.

<b>What we want to do here is change this code such that the `Bottles` class can interact with any other object that can supply lyrics. (we need to loosen the coupling between `Bottles` and `BottleVerse`)</b>

At this point `Bottles` know two things:
- `BottleVerse` which is the concretion
- The abstraction that is `.lyrics`

Knowing about `.lyrics` is ok, `Bottles` somehow gotta know what message send, but the object receiver is the one that needs fixing.

If an object can play a common role, that role should have a name, we can call it `verse_template` this will replace the concrete dependency `BottleVerse`

Here, we have extracted `BottleVerse` class and injected of a constant 
```ruby
class Bottles
  attr_reader :verse_template

  def initialize(verse_template: BottleVerse)
    @verse_template = verse_template
  end

  def verse(number)
      verse_template.new(number).lyrics
  end
end
```

Now we have the option of creating other players of this role and producing varying songs. 

<b>This idea of extracting variance into individual classes of their own, and then choosing the right variant and injecting it back into the class at runtime, is known as composition.</b>

Here is a Sandi drawing to illustrate this change:

`Bottles` used to have a `verse` method:

<div>
  <img 
    src="/graphics/projects/composition_drawing_sandi_metz_1.png" 
    alt="code_is_open_diagram" 
    style="border-radius: 0.375rem; height: 230px; width: 230px; display: block; margin: auto;"
  />
</div>

We extracted that method `verse` out into a separate class called `BottleVerse`

<div>
  <img 
    src="/graphics/projects/composition_drawing_sandi_metz_2.png" 
    alt="code_is_open_diagram" 
    style="border-radius: 0.375rem; height: 230px; width: 230px; display: block; margin: auto;"
  />
</div>

Then we injected that back in.

<div>
  <img 
    src="/graphics/projects/composition_drawing_sandi_metz_3.png" 
    alt="code_is_open_diagram" 
    style="border-radius: 0.375rem; height: 230px; width: 230px; display: block; margin: auto;"
  />
</div>

We opened the door to have many different classes that play the `verse_template` role, as long as they conform the lyrics API

<div>
  <img 
    src="/graphics/projects/composition_drawing_sandi_metz_4.png" 
    alt="code_is_open_diagram" 
    style="border-radius: 0.375rem; height: 230px; width: 250px; display: block; margin: auto;"
  />
</div>

<b>A much shorter way to say this is that we just isolated the code we wanted to vary.</b>

<b>It's one of the core concepts of how to write good OO that you take things that you want to vary, and instead of wrapping them in conditionals to provide variation, you take what would, be branches of a conditional and pull them out into classes of their own, and then someone, somewhere will pick the right object and inject it into the class that needs a variant. The principle is named Dependency Inversion.</b>

Here's the simplest explanation I can give: Depend on abstractions, not concretions.

Before the name of the `BottleVerse` class was a concretion. We didn't want to depend on that, instead, we wanted to `invert that dependency` so that we were depending on the abstraction, which is the idea that we wanted a `verse_template` rather than the concretion, the actual class name.

When we depend on abstractions, it means that we can get other players of that abstract role and use them instead of the concretion.

```ruby
class Bottles
  attr_reader :verse_template

  def initialize(verse_template: BottleVerse)
    @verse_template = verse_template
  end

  def verse(number)
      verse_template.new(number).lyrics
  end
end

class BottleVerse
  attr_reader :number

  def initialize(number)
    @number = number
  end

    def lyrics
    bottle_number = BottleNumber.for(number)

    "#{bottle_number} of beer on the wall, ".capitalize +
    "#{bottle_number} of beer.\n" +
    "#{bottle_number.action}, " +
    "#{bottle_number.successor} of beer on the wall.\n"
  end
end

class RandomVerse
  def initialize(number)
    @number = number
  end

  def lyrics
    "#{@number} random things on the shelf..."
  end
end

class SodaVerse
  def initialize(number)
    @number = number
  end

  def lyrics
    "#{@number} bottles of soda pop..."
  end
end
```
