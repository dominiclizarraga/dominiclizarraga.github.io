---
title: "POOD Session 8: Vary Verse"
date: 2025-09-27
categories: [pood]
description: '8th session, Vary Verse'
layout: post
---

# Session 8: Vary Verse

Date: September 27, 2025

This blog post consists in three parts:

- [My notes on Vary Verse](#vary-verse)
- 

### Key Concepts

- 

### Vary Verse{#vary-verse}

Watch 1: Appreciating the Mechanical Process

This block introduces a new requirement <i>to vary the lyrics of the verse</i> which allows us to begin considering whether and when you might voluntarily make changes to improve code.

In this block introduce the ideas of 'pseudocode' and 'coding by wishful thinking.'  This block culminates with the Dependency Inversion Principle (DIP), one of the most broadly useful concepts in object-oriented programming.

The current code is simple because we started out with no abstractions. No incorrect abstractions or make abstractions from things we didn't really understand.

<b>then we used repeatable programming techniques to follow code smells, then extract differences and isolate variance</b>

The story this code tells is that there's a more abstract kind of verse, that allthe 99 bottles verses have in common, a single abstraction.

```ruby
def verse(number)
  # here the number (Integer) gets transformed into a BottleNumber instance
  # then goes into the Factory
  bottle_number = BottleNumber.for(number)
  # here is the template
  "#{bottle_number} of beer on the wall, ".capitalize +
  "#{bottle_number} of beer.\n" +
  "#{bottle_number.action}, " +
  "#{bottle_number.successor} of beer on the wall.\n"
end
```

If you were to describe the responsibility of `verse` method, you would say it converts a `number` into a `BottleNumber`, and then it uses that `BottleNumber` to create a `verse`.

The use of the word "and" in that sentence, converts a number into a `BottleNumber` AND uses that `BottleNumber` to make a `verse` that word "and" should give you pause.

Given "and" shows that `verse` method have more than one responsibility.

These 6 lines of code, represent not much hurt, it can be considered as a code smell but since we have not gotten any other requirement we can leave it as it's.

However if you voluntarily want to refactor this code into something more SOLID, consider the outlook that you're the stewward of someone else money and if this change in the present will save money in the future or maybe you're better off or wair the next requirement.

What you want is to have a set of internal rules that allow you to make bets on whether or not changes are going to turn out, and you want those bets to pay off more often than not in the situation here.

Code smell here is "Speculative generality" making improvements to code based on your ideas that will pay off later.

Really good progammers, write really changeable code.

We'll see the heuristics, the set of rules can make you more confident, not that every one of these changes is going to save you money later, but they probably won't cost you money, and enough of them will actually save you money so that it's worth doing it all the time.

Experienced programmers are like little artificial intelligence machines that have been trained on many, many, many examples of code. Their experience of making judgments, and looking at how those judgments turned out over years, and years, and years, build up into a kind of intuition. And you can think of that programming intuition really as just a form of pattern matching.

They can look at a set of code and recognize shapes that are going to cause trouble later, and they know how to transform those shapes that are going to be a problem into shapes that are going to be easy to change later.

 Watch 2: Clarifying Responsibilities with Pseudocode

New requirement is to make code produce different song verses.

As we use the `.downto()` method we must ask if the new verse will count downwards too so that we can know we need to change code or not.

If we need to know if code is Open or Closed to change we can refer to diagram:

<div>
  <img 
    src="/graphics/projects/openness_diagram_sandi_metz_2.png" 
    alt="code_is_open_diagram" 
    style="border-radius: 0.375rem; height: 350px; width: 500px; display: block; margin: auto;"
  />
</div>

If code is not open and we don't know how to male it open, we look for code smells.

The benefits of writing bad code is that we introduce code smells that will give us a glimpse of the future that we can preemptively decide what code smells we are going to have and use refactoring to remove them.

Here, is a first sketch with pseudo code:

```ruby
  def verse(number)
    # if 99_bottle_song
    bottle_number = BottleNumber.for(number)

    "#{bottle_number} of beer on the wall, ".capitalize +
    "#{bottle_number} of beer.\n" +
    "#{bottle_number.action}, " +
    "#{bottle_number.successor} of beer on the wall.\n"
    #
    # elsif unknown_song_2_verse
    # ...
    #   assemble verse for unknown song 2
    # ...
    # elsif unknown_song_3
    # ...
    #   assemble verse for unknown song 3
    # ...
    # end
  end
```

Above `if statement` is just going to grow, and grow, and grow, and grow, and grow, until your life is a disaster so pseudo code help us see if we are heading a dead end road and identify it quickly.

<b>Solution: the problem is we have this conditional with a number of branches, and each of those branches should represent an `object`, a different kind of verse `variant`. And that means we should apply the `Extract Class` refactoring to pull those different `verse_templates` out into some other class. </b>

Watch 3: Extracting the Verse

As we did back in chapter 5, when we had the code smell of "primitive obsession" on `number` argument, and we created `BottleNumber` we need to follow the next steps:

1. Choose a name for the new class
2. Add `attr_reader` and `initializer`
3. Copy methods from old to new (not cut!)
4. Wire new class into old (NewClass.new)
5. Clean up extra args

<b>Classes should be name after what they are ! </b>

In this case `BottleVerse`

```ruby
class Bottles
  def verse(number)
    BottleVerse.new(number).verse(number)
    # bottle_number = BottleNumber.for(number)

    # "#{bottle_number} of beer on the wall, ".capitalize +
    # "#{bottle_number} of beer.\n" +
    # "#{bottle_number.action}, " +
    # "#{bottle_number.successor} of beer on the wall.\n"
  end
end

class BottleVerse
  attr_reader :number

  def initialize(number)
    @number = number
  end

  def verse(number)
    bottle_number = BottleNumber.for(number)

    "#{bottle_number} of beer on the wall, ".capitalize +
    "#{bottle_number} of beer.\n" +
    "#{bottle_number.action}, " +
    "#{bottle_number.successor} of beer on the wall.\n"
  end
end
```

Up to this point and running after each change tests, we were able to create a new class, make it syntatically correct, invoke it from the old class and now we still need to remove old-extra-arguments.

Watch 4: Coding by Wishful Thinking

In object-oriented programming, we think of design as happening from the message sender's point of view.

AI example code of above phrase:

```ruby
# Design from the message sender's point of view
#
# Don't ask: "What CAN this object do?" (receiver perspective)
# Ask instead: "What do I NEED this object to do?" (sender perspective)
#
# The sender (trip) only cares about getting a descriptionâ€”it doesn't 
# care whether the vehicle is a Car, Bike, or Plane. We design the 
# interface based on what the sender needs to send, not what the 
# receiver happens to have.

class Trip
  def initialize(vehicle)
    @vehicle = vehicle
  end

  def plan
    puts "Planning trip using: #{@vehicle.describe}"
  end
end

# All vehicles respond to the message the sender needs
class Car
  def describe
    "a comfortable car"
  end
end

class Bike
  def describe
    "an eco-friendly bike"
  end
end

# Usage - Trip sends 'describe', vehicles respond
trip1 = Trip.new(Car.new)
trip1.plan  # => Planning trip using: a comfortable car

trip2 = Trip.new(Bike.new)
trip2.plan  # => Planning trip using: an eco-friendly bike
```
The key: Trip (the sender) defines what message it needs (`describe`), and all receivers must respond to that interface.

Here is the result of wisful thinking:

```ruby
class Bottles
  def verse(number)
    BottleVerse.new(number).lyrics
  end
end

class BottleVerse
  attr_reader :number

  def initialize(number)
    @number = number
  end

  def lyrics
    bottle_number = BottleNumber.for(number)

    "#{bottle_number} of beer on the wall, ".capitalize +
    "#{bottle_number} of beer.\n" +
    "#{bottle_number.action}, " +
    "#{bottle_number.successor} of beer on the wall.\n"
  end
end
```

Watch 5: Inverting Dependencies

