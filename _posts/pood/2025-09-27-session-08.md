---
title: "POOD Session 8: Vary Verse"
date: 2025-09-27
categories: [pood]
description: '8th session, Vary Verse'
layout: post
---

# Session 8: Vary Verse

Date: September 27, 2025

This blog post consists in three parts:

- [My notes on Vary Verse](#vary-verse)
- 

### Key Concepts

- 

### Vary Verse{#vary-verse}

Watch 1: Appreciating the Mechanical Process

This block introduces a new requirement <i>to vary the lyrics of the verse</i> which allows us to begin considering whether and when you might voluntarily make changes to improve code.

In this block introduce the ideas of 'pseudocode' and 'coding by wishful thinking.'  This block culminates with the Dependency Inversion Principle (DIP), one of the most broadly useful concepts in object-oriented programming.

The current code is simple because we started out with no abstractions. No incorrect abstractions or make abstractions from things we didn't really understand.

<b>then we used repeatable programming techniques to follow code smells, then extract differences and isolate variance</b>

The story this code tells is that there's a more abstract kind of verse, that allthe 99 bottles verses have in common, a single abstraction.

```ruby
def verse(number)
  # here the number (Integer) gets transformed into a BottleNumber instance
  # then goes into the Factory
  bottle_number = BottleNumber.for(number)
  # here is the template
  "#{bottle_number} of beer on the wall, ".capitalize +
  "#{bottle_number} of beer.\n" +
  "#{bottle_number.action}, " +
  "#{bottle_number.successor} of beer on the wall.\n"
end
```

If you were to describe the responsibility of `verse` method, you would say it converts a `number` into a `BottleNumber`, and then it uses that `BottleNumber` to create a `verse`.

The use of the word "and" in that sentence, converts a number into a `BottleNumber` AND uses that `BottleNumber` to make a `verse` that word "and" should give you pause.

Given "and" shows that `verse` method have more than one responsibility.

These 6 lines of code, represent not much hurt, it can be considered as a code smell but since we have not gotten any other requirement we can leave it as it's.

However if you voluntarily want to refactor this code into something more SOLID, consider the outlook that you're the stewward of someone else money and if this change in the present will save money in the future or maybe you're better off or wair the next requirement.

What you want is to have a set of internal rules that allow you to make bets on whether or not changes are going to turn out, and you want those bets to pay off more often than not in the situation here.

Code smell here is "Speculative generality" making improvements to code based on your ideas that will pay off later.

Really good progammers, write really changeable code.

We'll see the heuristics, the set of rules can make you more confident, not that every one of these changes is going to save you money later, but they probably won't cost you money, and enough of them will actually save you money so that it's worth doing it all the time.

Experienced programmers are like little artificial intelligence machines that have been trained on many, many, many examples of code. Their experience of making judgments, and looking at how those judgments turned out over years, and years, and years, build up into a kind of intuition. And you can think of that programming intuition really as just a form of pattern matching.

They can look at a set of code and recognize shapes that are going to cause trouble later, and they know how to transform those shapes that are going to be a problem into shapes that are going to be easy to change later.

 Watch 2: Clarifying Responsibilities with Pseudocode

