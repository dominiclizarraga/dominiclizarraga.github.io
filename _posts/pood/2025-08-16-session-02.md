---
title: "POOD Session 2: Test Driving Shameless Green"
date: 2025-08-16
categories: [pood]
description: 'Second session, lessong considering existing tests and open/closed principle'
layout: post
---

# Session 2: Considering Existing Tests and Meet the Open/Closed Principle

Date: August 16, 2025  

### Key Concepts

pending

### Test Driving Shameless Green

In this lesson, our main task was to watch Sandi Metz’s talk, study her code, and then answer six questions about it. Afterward, we turned to the book 99 Bottles to compare our answers with Sandi’s own.

The real challenge, however, wasn’t just about finding the “right” answer, <b>it was about learning how to justify our decisions.</b> Could we explain our reasoning clearly enough to convince other programmers that our solution (or Sandi’s) was the better one? Working in a team of three, we debated each approach and practiced the art of defending design choices.

1. What decisions must be made before you can write this first test?

I think what behavior should we test. Is it a number that adds another number? Is it a boolean? In this case is a concatenated string.

Also, what methods should be publicly available? What is the API look like? (Bearing in mind that we should name methods <b>after the concept they represent rather than how they currently behave</b>.)

What parameters are we going to allow? And what method for?

Maybe, which test to write first: entire song, multiple verses, or single verse? (Think in simplicity)

Arrange, Act, Assert

We shouldn't overthink these decisions initially

2. Is it better to interpolate 'number' or to add a conditional?

I think we should aim for understability first, therefore the conditional may be a good start.

Once we deepen our domain understanding we can provide more flexibility with the interpolation.

Sandi's suggestion was to interpolate over conditional. As the test gets more specific the code will become more general.

3. Why not just interpolate a conditional?

The code we are writing is the following:

```ruby
class Bottles
  def verse(number)
    "#{number} bottles of beer on the wall, " +
    "#{number} bottles of beer. \n" +
    "Take one down and pass it around, " +
    "#{number - 1} botle#{"s" if number - != 1} of beer on the wall.\n"
  end
end
```

I think this version is hard to understand at a glance, you gotta read it more than once and remembering that the code you write is many times read than written, I point to understability first.

Sandi proposed a `case statement` where the verses are almost identical but vary by the "number" variable. Again, it’s much simpler and easier to follow.

4. Why is duplication in #verse acceptable, but not in #verses?

I think because of the Single Responsibility principle, if we add duplication in #verses we are mixing tasks between those methods. One if for returning one verse at once and the other is for passing the "number" variable as iteration.

5. What should the expectation in the song test be?

The `song` method is the main subject of this exercise, and i think of it as the final result of the code so even when it seems tedious, writing down all the 99 verses is the way to test that code is working properly.

```ruby
class Bottles
  def song
    verses(99, 0)
  end

  def verses(upper, lower)
    upper.downto(lower).map { |i| verse(i) }.join("\n")
  end

  def verse(number)
    case number
    when 0
      "No more bottles of beer on the wall, no more bottles of beer.\nGo to the store and buy some more, 99 bottles of beer on the wall.\n"
    when 1
      "1 bottle of beer on the wall, 1 bottle of beer.\nTake it down and pass it around, no more bottles of beer on the wall.\n"
    when 2
      "2 bottles of beer on the wall, 2 bottles of beer.\nTake one down and pass it around, 1 bottle of beer on the wall.\n"
    else
      "#{number} bottles of beer on the wall, #{number} bottles of beer.\nTake one down and pass it around, #{number-1} bottles of beer on the wall.\n"
    end
  end
end
```
6. What design flaw forces you to write this last annoying test?

The flaw is that `song` does not accept any arguments, it always produces the full song from 99 to 0. The `song` method <b>is closed to extension.</b>

--- Quiz answers ---


### Meet the Open/Closed Principle
