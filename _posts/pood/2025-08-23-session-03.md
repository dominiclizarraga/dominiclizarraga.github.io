---
title: "POOD Session 3: Identify Abstractions"
date: 2025-08-23
categories: [pood]
description: 'Third session, lesson Identify Abstractions & Dry Out Shameless Green'
layout: post
---

# Session 3: Identify Abstractions & Dry Out Shameless Green

Date: August 23, 2025

This blog post consists in two parts:

- [My notes on Identify Abstractions](#identify-abstractions)
- [My notes on code Dry Out Shameless Green"](#dry-out-shame-less)

### Key Concepts

- Flocking rules for identifying code that may be a good candidate for becoming an abstraction
- 

### Identify Abstractions {#identify-abstractions}

Watch 1: Following the Flocking Rules

âœ¨ <i>Quick reminder: We need to change the code to display "six-pack" instead of "6 bottles" which means make the code open to extension, closed to modification</i>

Here are the steps to find abstractions in code, these are mini-decisions, we still don't know the outcome:

1. Select the things that are most alike
2. Find the smallest difference between them
3. Make the simplest change to remove the difference

a) parse the new code
b) parse and execute it
c) parse, execute and use its results
d) deleted unused code

Remember to 

- change one line at the time.
- run tests after each change
- if the test fail, undo and make a better change

Set of rules of flocking birds

- alignment: tells them to steer on the average heading of their near neighbors
- cohesion, says steer towards the average position of their neighbors, which is sort of a long range attraction rule
- separation, don't hit each other

This will turn difference into sameness and will reveal Concealed Concepts.

Watch 2: Converging on Abstractions

Increase isolation of the thing we want to vary. With the hope that eventually the code will open for the change we want to make.

Discover hidden abstractions instead of look at the problem and make them up.

We went from this code:

```ruby

  def verse(number)
    case number
    when 0
      "No more bottles of beer on the wall, " +
      "no more bottles of beer.\n" +
      "Go to the store and buy some more, " +
      "99 bottles of beer on the wall.\n"
    when 1
      "1 bottle of beer on the wall, " +
      "1 bottle of beer.\n" +
      "Take it down and pass it around, " +
      "no more bottles of beer on the wall.\n"
    when 2
      "2 bottles of beer on the wall, "
      "2 bottles of beer.\n " +
      "Take one down and pass it around," +
      "1 bottle of beer on the wall.\n"
    else
      "#{number} bottles of beer on the wall, " +
      "#{number} bottles of beer.\n " +
      "Take one down and pass it around, " +
      "#{number - 1} bottles of beer on the wall.\n"
    end
  end
```

To this one, always following flocking rules for finding hidden abstracions, select the things that are most alike, find the smallest difference between them and make the simplest change to remove the difference:

```ruby

  def verse(number)
    case number
    when 0
      "No more bottles of beer on the wall, " +
      "no more bottles of beer.\n" +
      "Go to the store and buy some more, " +
      "99 bottles of beer on the wall.\n"
    when 1
      "1 bottle of beer on the wall, " +
      "1 bottle of beer.\n" +
      "Take it down and pass it around," +
      "no more bottles of beer on the wall.\n"
    else
      "#{number} #{container(number)} of beer on the wall, " +
      "#{number} bottles of beer.\n" +
      "Take one down and pass it around, " +
      "#{number - 1} bottles of beer on the wall.\n"
    end
  end

  def container(number)
    if number == 1
      "bottle"
    else
      "bottles"
    end
  end
```

### Dry Out Shameless Green {#dry-out-shame-less}

In this block we finished DRYing out bottles Shameless Green via the Flocking Rules. We coded for 30 minutes with the aim to DRYing out the `#verse`.

After that time we watched the solution videos, replicate the code and discussed it with the group.

This is the code we started with, after chopping off the `case statement for number 2` all tests run on green:

```ruby
def song
    verses(99, 0)
  end

  def verses(upper, lower)
    upper.downto(lower).map { |i| verse(i) }.join("\n")
  end

  def verse(number)
    case number
    when 0
      "No more bottles of beer on the wall, " +
      "no more bottles of beer.\n" +
      "Go to the store and buy some more, " +
      "99 bottles of beer on the wall.\n"
    when 1
      "1 bottle of beer on the wall, " +
      "1 bottle of beer.\n" +
      "Take it down and pass it around, " +
      "no more bottles of beer on the wall.\n"
    else
      "#{number} bottles of beer on the wall, " +
      "#{number} bottles of beer.\n" +
      "Take one down and pass it around, " +
      "#{number-1} #{container(number-1)} of beer on the wall.\n"
    end
  end

  def container(number)
    if number == 1
      "bottle"
    else
      "bottles"
    end
  end
end
```

Watch 1: Replacing Difference With Sameness

It's time to pick a pair to work on, keeping in mind go for the code that is pretty similar to each other, in other words, less differences and work towards reducing the differences.

In this case is the branch 1 and the else branch.

Their difference rely on `"1 bottle"` vs `"#{number}"`, `"it"` vs `"one"` and  `"no more"` vs `"#{number-1}"`

This change will make our code slower and more abstract, but he have to do this in order to make our code look the same. 

The cost of this change is execution time, but keeping both cases will cost more due to maintenance (2 very similar branches).

```ruby
def verse(number)
  case number
  when 0
    "No more bottles of beer on the wall, " +
    "no more bottles of beer.\n" +
    "Go to the store and buy some more, " +
    "99 bottles of beer on the wall.\n"
  when 1
    "#{number} #{container(number)} of beer on the wall, " +
    "#{number} #{container(number)} of beer.\n" +
    "Take it down and pass it around, " +
    "no more bottles of beer on the wall.\n"
  else
    "#{number} #{container(number)} of beer on the wall, " +
    "#{number} #{container(number)} of beer.\n" +
    "Take one down and pass it around, " +
    "#{number-1} #{container(number-1)} of beer on the wall.\n"
  end
end
```

When following the flocking rules trying to turn difference into sameness, <b>resist</b> the urge to volunteer changes. Limit your changes to only what the recipe calls for and see what happens

Watch 2: Equivocating About Names

The official definition of equivocate is to use ambiguous language so as to conceal the truth or avoid committing oneself.

Sometimes we just don't know and we have to do the best we can with the information we have at the time.

We are now tackling the `"it"` vs `"one"` case, therefore we need to name the concept, create a method or function to be responsible for it, and then use it, send the message in the place of this difference.

We are looking for that `method name` where `def thing` is many layers of abstraciton away.

When naming, we have 3 rules:

<table border="1">
  <tr>
    <th>Naming Rule</th>
    <th>Pros</th>
    <th>Cons</th>
  </tr>
  <tr>
    <td><strong>Time-boxed naming</strong> - Set a time limit and use a thesaurus to find the best name within that time</td>
    <td>Time limited approach prevents overthinking</td>
    <td>You'll never know less than you know right now, so a better name may emerge later; good enough names may not motivate future improvements</td>
  </tr>
  <tr>
    <td><strong>Intentionally bad placeholder</strong> - Pick the worst possible name (like "foo") knowing you'll rename it later</td>
    <td>Very fast; saves time and money</td>
    <td>The name is terrible</td>
  </tr>
  <tr>
    <td><strong>Ask someone good at naming</strong> - Find a person skilled at naming and describe your problem to them</td>
    <td>Access to expertise; the act of describing the problem may help you discover a good name yourself</td>
    <td>Self explanatory</td>
  </tr>
</table>

In this case `"it"` and `"one"` are pronouns. It feels too far from the domain of the 99 Bottles song, but it also feels more correct than anything else I can think of.

Let's use `pronoun` by first defining the method, then making it return the `else branch`. After that add the `pronoun` method in the actual code, run tests, then add a default argument, then we add another branch to cover the `1 branch`

Now that `else branch` and `1 branch` are identical and as we are getting used to this recipe the coding part becomes easier, however the naming part is the challenging.

```ruby
  def verse(number)
    case number
    when 0
      "No more bottles of beer on the wall, " +
      "no more bottles of beer.\n" +
      "Go to the store and buy some more, " +
      "99 bottles of beer on the wall.\n"
    when 1
      "#{number} #{container(number)} of beer on the wall, " +
      "#{number} #{container(number)} of beer.\n" +
      "Take #{pronoun(number)} down and pass it around, " +
      "no more bottles of beer on the wall.\n"
    else
      "#{number} #{container(number)} of beer on the wall, " +
      "#{number} #{container(number)} of beer.\n" +
      "Take #{pronoun(number)} down and pass it around, " +
      "#{number-1} #{container(number-1)} of beer on the wall.\n"
    end
  end

  def container(number)
  ...
  end

  def pronoun(number)
    if number == 1
      "it"
    else
      "one"
    end
  end
```

Watch 3: Deriving Names From Responsibilities