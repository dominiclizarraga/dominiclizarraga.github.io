<!doctype html>
<html lang=en>
<head>
  <meta charset=utf-8>
  <meta name=author content='dom lizarraga' />
  <meta name='theme-color' content='#fff' />
  <meta name='twitter:title' content="How I learned rpsec" />
  <meta name=description content="" />
  <meta name=viewport content='width=device-width,minimum-scale=1'>
  <meta property='og:site_name' content="dominiclizarraga.github.io"/>
  <meta property='og:email' content="dominiclizarraga@hotmail.com"/>
  <meta property='og:type' content=blog content="domlizarrraga" />
  <meta property='twitter:account_id' content=domlizarraga_ />
  
  
  <script type='application/ld+json'>{"@context": "http://schema.org","@type": "CreativeWork","author": "dom lizarraga"}</script>
  
    <link rel=alternate type='application/rss+xml' title="dominiclizarraga.github.io" href="http://localhost:4000/rss.xml" />
    <link rel=alternate type='application/atom+xml' title="dominiclizarraga.github.io" href="http://localhost:4000/atom.xml" />
  
  <link rel=icon type=image/x-icon href=/css/favicon.png />
  <style>:root {
  --mono-font: San Francisco Mono, Monaco, "Consolas", "Lucida Console",
    "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace;
  --sans-font: -apple-system, BlinkMacSystemFont, "avenir next", avenir,
    helvetica, "helvetica neue", ubuntu, roboto, noto, "segoe ui", arial,
    sans-serif;
}

.star {
  width: 13px;
  height: 12px;
  display: inline-block;
  background: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTMiIGhlaWdodD0iMTIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTYuMzA5IDkuMjJMMi40MDkgMTJsMS40NC00LjU2N0wwIDQuNTgzbDQuNzg4LS4wNDJMNi4zMDggMCA3LjgzIDQuNTRsNC43ODkuMDQ0LTMuODUgMi44NDlMMTAuMjA5IDEyeiIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9zdmc+");
}

body {
  color: #111;
  margin: 0px auto;
  -webkit-font-smoothing: antialiased;
  text-rendering: optimizeLegibility;
  line-height: 1.6;
  font-size: 1rem;
  font-family: var(--sans-font);
  background-color: #f8f5d5;
}

/* Print tweaks ------------------------------------------------------------- */
.only-print {
  display: none;
}

.notitle .body p:first-child {
  margin-top: 0.25rem;
}

.body img {
  width: 100%;
  max-width: 640px;
}

/* Element styles ----------------------------------------------------------- */
sup,
sub {
  vertical-align: baseline;
  position: relative;
  top: -0.4em;
}

sub {
  top: 0.4em;
}

a {
  color: #000;
  text-decoration-skip-ink: auto;
  text-decoration: underline;
}

a:visited {
  color: #333;
}

ol,
ul {
  margin: 1rem 0;
}

ul ul {
  margin: 0;
}

ol li ul {
  margin: 5px 10px;
}

iframe {
  border: 0;
}

small,
.small {
  font-size: 14px;
}

br {
  line-height: 1em;
}

h1 a {
  color: #111;
}

em {
  font-style: italic;
}

h1 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 32px;
  letter-spacing: 0.004em;
}

h2 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 1.5rem;
  letter-spacing: 0.009em;
}

h3 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 1.25rem;
  letter-spacing: 0.009em;
}

h4 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 1rem;
}

h5 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 0.875rem;
}

p {
  margin: 1rem 0;
}

blockquote {
  font-size: 16px;
  line-height: 25px;
}

td {
  vertical-align: top;
}

hr {
  background: #000;
  height: 1px;
  border: 0;
}

summary {
  cursor: pointer;
}

.body table {
  border-collapse: collapse;
  border-spacing: 0;
  width: 100%;
}

.body th {
  text-align: left;
}

.body td,
.body th {
  padding: 0.5rem;
}

.body td {
  border: 1px solid #cfcfcf;
}

.limiter {
  max-width: 640px;
  padding-left: 20px;
  padding-right: 20px;
  margin-left: auto;
  margin-right: auto;
}

/* Padding --------------------------------------- */
.pad2y {
  padding-top: 20px;
  padding-bottom: 20px;
}

span.image-credit {
  float: right;
  margin: 0 0 10px 10px;
  font-size: 12px;
}

span.image-credit:before {
  content: "‚Üë";
  margin-right: 5px;
}

figcaption {
  font-size: 11px;
  text-align: center;
  font-size: 0.8rem;
  margin-top: -1.2rem;
}

div.post blockquote p {
  margin: 0;
}

/** Writing ----------------------------------------------------------------- */
.writing,
.books {
  display: grid;
  grid-column-gap: 5px;
  grid-row-gap: 5px;
}

.writing {
  grid-template-columns: 1fr min-content;
}

.books {
  grid-template-columns: 1fr 0.75fr min-content 70px;
}

.writing a,
.books a {
  font-weight: 500;
  letter-spacing: -0.015em;
}

.writing > div,
.books > div {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.writing time,
.books time {
  padding-right: 0.25em;
  color: #333;
  font-variant-numeric: tabular-nums;
  letter-spacing: -0.012em;
  white-space: pre;
}

.project-box {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-gap: 30px;
}

.project-box a.project {
  text-decoration: none;
  color: #666;
}
.project-box a.project:hover {
  color: #000;
}
.project-box a.project img {
  display: block;
  margin-bottom: 10px;
  border-radius: 0.375rem;
  height: 160px;
  object-fit: cover;
}

/** Responsive -------------------------------------------------------------- */

/* Screen width:  0px -------- 480px -------- 640px -------- 1024px -------- ‚àû */
/* max-width: 480px:  |‚Üê‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï| */
/* max-width: 640px:  |‚Üê‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï| */
/* min-width: 640px:                    |‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Üí| */
/* max-width: 1024px: |‚Üê‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï| */

@media screen and (max-width: 480px) {
  .project-box {
    grid-template-columns: repeat(1, 1fr);
  }
}

@media screen and (max-width: 640px) {
  .limiter {
    width: auto;
  }
  .project-box {
    grid-template-columns: repeat(2, 1fr);
  }
  .writing,
  .books {
    grid-template-columns: 1fr;
    grid-row-gap: 0px;
  }

  .writing div,
  .books div {
    white-space: normal;
  }

  .writing time,
  .books div:nth-child(4n) {
    padding-bottom: 20px;
  }
}

@media screen and (min-width: 640px) {
  .nu a {
    text-decoration: none;
  }

  .nu a:hover {
    text-decoration: underline;
  }
}

@media screen and (max-width: 1024px) {
  .header-wrap {
    border-bottom: 1px solid #000;
    padding-bottom: 10px;
  }

  .sigil {
    display: none;
  }
  /* this css if for containing search result in mobile */
  #lunrsearchresults {
    width: 350px !important;
    overflow-x: hidden;
  }

  .about-image{
    margin-top: 5px;
  }

  .project-box {
    margin-top: 5px;
    margin-bottom: 20px;
  }
}

@media screen and (min-width: 1025px) {
  .header {
    position: absolute;
    /* top: 40px; */
    right: 50%;
    margin-right: 340px !important;
    letter-spacing: -0.009em;
  }
  .content h1:first-child {
    margin-top: 0;
  }
}

@media print {
  .no-print {
    display: none;
  }
  .only-print {
    display: block;
  }
  body {
    margin: 0;
  }
  .limiter {
    max-width: 100% !important;
    margin: 0 !important;
    padding: 0 !important;
  }
}

/** Code highlighting ------------------------------------------------------- */
p code,
pre code,
li code,
g.highlight,
.code {
  font-family: var(--mono-font);
}

p code {
  font-size: 90%;
}

pre code {
  font-size: 0.8rem;
  line-height: 1.5;
}

.highlight,
blockquote {
  overflow-x: auto;
  padding: 10px 20px;
  margin: 0;
  background: #fff;
  border-radius: 10px;
}

blockquote {
  font-style: italic;
}

blockquote p:first-child {
  margin-top: 0;
}

blockquote p:last-child {
  margin-bottom: 0;
}

/* pygments theme. does not support generics. .highlight class omitted */
.highlight {
  margin: 10px 0;
}

.highlight .hll {
  background-color: #ffffcc;
}

.c, /* Comment */
.cm, /* Comment.Multiline */
.cp, /* Comment.Preproc */
.cs, /* Comment.Special */
.c1 {
  color: #999988;
} /* Comment.Single */

.o, /* Operator */
.ow, /* Operator.Word */
.ge {
  color: #000000;
} /* Generic.Emph */

.kc, /* Keyword.Constant */
.kd, /* Keyword.Declaration */
.kn, /* Keyword.Namespace */
.kp, /* Keyword.Pseudo */
.kr, /* Keyword.Reserved */
.kt {
  color: #445588;
} /* Keyword.Type */

.err {
  color: #a61717;
} /* Error */

.m {
  color: #007f7f;
} /* Literal.Number */
.s {
  color: #d01040;
} /* Literal.String */

.na, /* Name.Attribute */
.nb, /* Name.Builtin */
.nc, /* Name.Class */
.no, /* Name.Constant */
.nd, /* Name.Decorator */
.ni, /* Name.Entity */
.ne, /* Name.Exception */
.nf, /* Name.Function */
.nn, /* Name.Namespace */
.nt, /* Name.Tag */
.nl {
  color: #990000;
} /* Name.Label */

.k, /* Keyword */
.nv {
  color: #008080;
} /* Name.Variable */

.mf, /* Literal.Number.Float */
.mh, /* Literal.Number.Hex */
.mi, /* Literal.Number.Integer */
.mo {
  color: #009999;
} /* Literal.Number.Oct */

.sb, /* Literal.String.Backtick */
.sc, /* Literal.String.Char */
.sd, /* Literal.String.Doc */
.s2, /* Literal.String.Double */
.se, /* Literal.String.Escape */
.sh, /* Literal.String.Heredoc */
.s1, /* Literal.String.Single */
.si, /* Literal.String.Interpol */
.ss, /* Literal.String.Symbol */
.bp, /* Name.Builtin.Pseudo */
.sx {
  color: #d01040;
} /* Literal.String.Other */

.sr, /* Literal.String.Regex */
.vc, /* Name.Variable.Class */
.vg, /* Name.Variable.Global */
.vi, /* Name.Variable.Instance */
.il {
  color: #009999;
} /* Literal.Number.Integer.Long */

/** Code for buy me a coffe mobile version ------------------------------------------------------- */

.mobile-only-button {
  margin-top: 30px;
  display: none;
}

@media screen and (max-width: 480px) {
  .mobile-only-button {
    display: flex;
    justify-content: center;
    align-items: center;
    margin-bottom: 50px;
  }
  
  /* Style for the generated iframe */
  .mobile-only-button iframe {
    margin: 0 auto;
  }
}

/** Code for styling reading time ------------------------------------------------------- */

.reading-time {
  color: #475569;
  text-align: right;
  font-style: italic;
}

/** Code for footer + RSS svg ------------------------------------------------------- */

.personal-elements-container, a[rel="nofollow"], .rss-text {
  color:rgb(71, 95, 105);
  font-style: italic;
  display: flex;
  /* align-items: center; */
  flex-direction: column;
  gap: 10px;
}

.rss-link {
  display: flex;
  align-items: flex-end;
}

/** Code for search bar ------------------------------------------------------- */

.search-bar-desktop {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
}

.search-input-container {
  max-width: 600px;
  margin-top: 10px;
  margin-right: 40px;
}

.search-input {
  border: 1px solid rgb(133, 134, 133);
  padding: 0.75rem;
  background-color: #ffffff;
  width: 100%;
  border-radius: 0.375rem;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
  transition: border-color 0.2s, box-shadow 0.2s;
  height: 10px;
  margin-left: 10px;
  font-size: 0.875rem;
}

.search-input:focus {
  border-color: #3b82f6;
  outline: none;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
}

/** Code for search bar RESULTS ------------------------------------------------------- */

#lunrsearchresults {
  padding-top: 0.2rem;
  width: 100%;
}

.limiter > #lunrsearchresults {
  margin-top: 1rem;
  margin-left: -20px !important;
}

.limiter #lunrsearchresults ul {
  padding-left: 0;
  list-style: none;
}

.lunrsearchresult {
  /* padding-bottom: 1rem; */
  margin-bottom: 1rem;
}

.lunrsearchresult a:hover .title {
  text-underline-offset: 3px;
}

strong {
  margin-bottom:1rem;
  display:block;
}

/** CSS style for authors quotes in 99 bottles book notes ------------------------------------------------------- */

.quote-box {
  margin: 20px auto;
  padding: 8px 10px;
  max-width: 600px;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  background-color: #f9f9f9;
  text-align: center;
  font-size: 14px;
}</style>
  <title>How I learned rpsec - dominiclizarraga.github.io</title>
  
  <link rel="canonical" href="http://localhost:4000/2023/06/14/how_i_learned_rspec.html">
  <!-- <script data-name="BMC-Widget" data-cfasync="false" src="https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js" data-id="domlizarrraga" data-description="Support me on Buy me a coffee!" data-message="" data-color="#5F7FFF" data-position="Right" data-x_margin="18" data-y_margin="18"></script> -->
</head>
<body>
  <div class="limiter search-bar-desktop">
    <script src="/js/lunr.js"></script>

<script>

var documents = [{
    "id": 0,
    "url": "http://localhost:4000/404",
    "title": "",
    "body": "404!"
    }, {
    "id": 1,
    "url": "http://localhost:4000/about/index.html",
    "title": "About",
    "body": "üëã Hey there! I‚Äôm Dominic a software developer proficient in Ruby on Rails, Hotwire (including Turbo + Stimulus), JS, APIs, Minitest, Capybara, Postgres, HTML, CSS(bootstrap) &amp; Tailwind. üöÄ I‚Äôm currently looking for my next adventure, my last job was with Oblsk where we worked on some amazing projects like PLT4M where I solved user stories from developing new features, creating models, involving ORM queries Sequel, testing with Mini &amp; Capy &amp; CSS responsiveness. üèÉ Then we moved to work on H4H a non-profit org that needed a solution for its marketing team so they can create content easily, here we implemented Strapi API as a headless CMS and Tailwind design (fully-responsive). ü•ä I‚Äôm currently working on a Ruby for good project called CASA where I help them to solve stakeholders tickets, I‚Äôve been doing this as a way of giving back to the community and keep learning since this project uses Rspec, bootstrap, JavaScript and bits of jQuery ‚ú®. I consider myself as very resilient and resourceful also I have learnt how to manage my emotional state and communicate efficiently and on time. üîë Here you may find my resume, LinkedIn, GitHub or if you want to drop me a line :) Tech stack  Ruby on Rails - Hotwire (Turbo &amp; Stimulus) Tailwind / Bootstrap Minitest &amp; Rspec - Capybara API‚Äôs - Agile methodologies SQL &amp; PostgreSQL AWS S3 - JavaScript HTML, CSS - GitHub - HerokuLanguages üá∫üá∏ English - Professional üá≤üáΩ Spanish - Native üá©üá™ German - Basic "
    }, {
    "id": 2,
    "url": "http://localhost:4000/confs/index.html",
    "title": "Conferences",
    "body": " Here you‚Äôll find the confs that I have attended or will be attending in the future. {% for conf in page. confs %} {{conf. name}} {{conf. description}}{% endfor %}"
    }, {
    "id": 3,
    "url": "http://localhost:4000/",
    "title": "",
    "body": "{% for post in site. categories. blog %} {{ post. title }} {{ post. date | date:  %Y-%m-%d  }}{% endfor %}"
    }, {
    "id": 4,
    "url": "http://localhost:4000/computer-science/computer-networks/",
    "title": "Networking Notes",
    "body": " Notes on Computer Networks  {% for post in site. categories. computer-networks %}  {{ post. title }}  {{ post. date | date:  %Y-%m-%d  }} {% endfor %}"
    }, {
    "id": 5,
    "url": "http://localhost:4000/computer-science/operating-systems/",
    "title": "Operating Systems Notes",
    "body": " Notes on Operating Systems  {% for post in site. categories. operating-systems %}  {{ post. title }}  {{ post. date | date:  %Y-%m-%d  }} {% endfor %}"
    }, {
    "id": 6,
    "url": "http://localhost:4000/computer-science/",
    "title": "Computer Science Notes",
    "body": " I‚Äôve committed to gaining depth in computer science, and here are the notes I‚Äôm taking along with the lessons on csprimer. com. Courses:  Programming: Beyond the basics Computer Systems Algorithms and Data Structures Computer Networks Operating Systems Relational Databases Distributed Systems {% for post in site. categories. computer-science %}  {{ post. title }}  {{ post. date | date:  %Y-%m-%d  }} {% endfor %}"
    }, {
    "id": 7,
    "url": "http://localhost:4000/pood/",
    "title": "Practical Object-Oriented Design",
    "body": " Documenting my journey through Practical Object-Oriented Design course. Here are the notes from the 12-week walkthrough of Practical Object-Oriented Design Course by Sandi Metz. I‚Äôm also reading the book 99 Botles (which I think is the same content, but written. ) Good Object-Oriented Programming requires an understanding of three things:    First, testing. You have to know how to write good tests.     Second, refactoring. You need the skills to rearrange the internals of existing code without breaking/changing the output.     Finally, OOP. You have to understand the concepts underlying object-oriented programming and design.   {% for post in site. categories. pood %}  {{ post. title }}  {{ post. date | date:  %Y-%m-%d  }} {% endfor %}"
    }, {
    "id": 8,
    "url": "http://localhost:4000/computer-science/distributed-systems/",
    "title": "Distributed Systems Notes",
    "body": " Notes on Distributed Systems  {% for post in site. categories. distributed-systems %}  {{ post. title }}  {{ post. date | date:  %Y-%m-%d  }} {% endfor %}"
    }, {
    "id": 9,
    "url": "http://localhost:4000/computer-science/algorithms-and-data-structures/",
    "title": "Algorithms and Data Structures Notes",
    "body": " Notes on Programming: Algorithms and Data Structures  {% for post in site. categories. algorithms-and-data-structures %}  {{ post. title }}  {{ post. date | date:  %Y-%m-%d  }} {% endfor %}"
    }, {
    "id": 10,
    "url": "http://localhost:4000/computer-science/beyond-the-basics/",
    "title": "Computer Systems Notes",
    "body": " Notes on Programming: Beyond the Basics  {% for post in site. categories. beyond-the-basics %}  {{ post. title }}  {{ post. date | date:  %Y-%m-%d  }} {% endfor %}"
    }, {
    "id": 11,
    "url": "http://localhost:4000/computer-science/relational-databases/",
    "title": "Computer Systems Notes",
    "body": " Notes on Relational Databases  {% for post in site. categories. relational-databases %}  {{ post. title }}  {{ post. date | date:  %Y-%m-%d  }} {% endfor %}"
    }, {
    "id": 12,
    "url": "http://localhost:4000/computer-science/systems/",
    "title": "Computer Systems Notes",
    "body": " Notes on Computer Systems  {% for post in site. categories. computer-systems %}  {{ post. title }}  {{ post. date | date:  %Y-%m-%d  }} {% endfor %}"
    }, {
    "id": 13,
    "url": "http://localhost:4000/projects/index.html",
    "title": "Projects",
    "body": " {% for project in page. projects %}        {{ project. name }}   {{ project. description }}   {% endfor %} "
    }, {
    "id": 14,
    "url": "http://localhost:4000/reading/index.html",
    "title": "Reading",
    "body": "{% for book in site. categories. book %}   {{ book. title }}  {{ book. author }} {{ book. date | date:  %Y-%m-%d  }}    {% endfor %}"
    }, {
    "id": 15,
    "url": "http://localhost:4000/2025/12/18/ruby-refactoring.html",
    "title": "Refactoring Ruby",
    "body": "2025/12/18 -  Refactoring Example The Refactoring Cycle Refactoring Step by Step The Refactoring Practice Measurable SmellsPreface. : What Is This Book About? Refactoring is the art of improving the design of existing code and was introduced to the world by Martin Fowler in Refactoring. Fowler‚Äôs book provides dozens of detailed mechanical recipes, each of which describes the steps needed to change one (usually small) aspect of a program‚Äôs design without breaking anything or changing any behavior. But to be skilled in refactoring is to be skilled not only in safely and gradually changing code‚Äôs design, but also in first recognizing where code needs improvement. The agile community has adopted the term code smell to describe the anti-patterns in software design, the places where refactoring is needed. The aim of this book, then, is to help you practice recognizing the smells in existing Ruby code and apply the most important refactoring techniques to eliminate those smells. For each smell we describe‚Ä¢ What to Look For: cues that help you spot it‚Ä¢ Why This Is a Problem: the undesirable consequences of having code with thissmell‚Ä¢ When to Leave It: the trade-offs that may reduce the priority of fi xing it‚Ä¢ How It Got This Way: notes on how it happened‚Ä¢ What to Do: refactorings to remove the smell‚Ä¢ What to Look for Next: what you may see when the smell has been removed PART I The Art of Refactoring Refactoring Example. : We‚Äôll begin with a quick example of refactoring to show how you can identify problems in code and systematically clean them up. In later chapters, we‚Äôll touch on theory, provide deeper dives into problems and how you fi x them. Sparkline Script The script generates a sparkline (a small graph used to display trends, without detail) and does it by generating an SVG document to describe the graphic. The original script was written quickly to display a single sparkline to demonstrate the trends that occur when tossing a coin. GitHub repo NUMBER_OF_TOSSES = 1000BORDER_WIDTH = 50def toss 2 * (rand(2)*2 - 1)enddef values(n) a = [0] n. times { a &lt;&lt; (toss + a[-1]) } aenddef spark(centre_x, centre_y, value)  &lt;rect x=\ #{centre_x-2}\  y=\ #{centre_y-2}\   width=\ 4\  height=\ 4\   fill=\ red\  stroke=\ none\  stroke-width=\ 0\  /&gt; &lt;text x=\ #{centre_x+6}\  y=\ #{centre_y+4}\   font-family=\ Verdana\  font-size=\ 9\   fill=\ red\  &gt;#{value}&lt;/text&gt; end$tosses = values(NUMBER_OF_TOSSES)points = []$tosses. each_index { |i| points &lt;&lt;  #{i},#{200-$tosses[i]}  }data =  &lt;svg xmlns=\ http://www. w3. org/2000/svg\    xmlns:xlink=\ http://www. w3. org/1999/xlink\  &gt; &lt;!-- x-axis --&gt; &lt;line x1=\ 0\  y1=\ 200\  x2=\ #{NUMBER_OF_TOSSES}\  y2=\ 200\       stroke=\ #999\  stroke-width=\ 1\  /&gt; &lt;polyline fill=\ none\  stroke=\ #333\  stroke-width=\ 1\   points = \ #{points. join(' ')}\  /&gt; #{spark(NUMBER_OF_TOSSES-1, 200-$tosses[-1], $tosses[-1])}&lt;/svg&gt; puts  Content-Type: image/svg+xmlContent-Length: #{data. length}#{data} Before we dive in and change things, take a moment to review the script. Which aspects of it strike you as convoluted, or unreadable, or even unmaintainable? (Part II, ‚ÄúCode Smells,‚Äù of this book lists over forty common code problems) Here are the more obvious problems we noticed in the code: ‚Ä¢ Comments: the SVG output that‚Äôs not a bad thing, because the SVG is quite opaque. But it also serves to comment the Ruby script, which suggests that the string is too complex. ‚Ä¢ Part of the SVG document is broken out into a separate method Inconsistent Style: (line 34), whereas most is built inline in the data string. ‚Ä¢ Strictly speaking, the list of properties of the XML elements Long Parameter List: aren‚Äôt Ruby parameters. But they are long lists, and we feel sure they will cause problems later. ‚Ä¢ The code uses Uncommunicative Name: data as the name of the SVG document, i as an iterator index (line 25), a as the name of an array (line 9), and n as the number of array elements (line 8). ‚Ä¢ Dead Code: The constant BORDER_WIDTH (line 2) is unused. ‚Ä¢ Greedy Method: toss tosses a coin and also scales it to be ‚Äì2 or +2. ‚Ä¢ Most of the numbers representing SVG coordinates and shape sizes Derived Value: could probably be derived from the number of tosses and the sparkline‚Äôs max and min values. ‚Ä¢ The text markers for the start and end tags of XML elements Duplicated Code: are repeated throughout the code; the calculation 200-tosses[x] is repeated (lines 25, 34). ‚Ä¢ Data Clump: The SVG components‚Äô parameters include several x-y pairs that represent points on the display canvas (lines 15, 18, 30). Some have further parameters that go to make up a rectangle (lines 16, 30). Strictly, these are parameters to SVG elements, and this is therefore a problem in the defi nition of SVG. ‚Ä¢ Global Variable: Why is tosses a global variable at all? ‚Ä¢ One might argue that all of the methods here (lines 4, 8, 14) are Utility Function: Utility Functions. ‚Ä¢ Greedy Module: The script isn‚Äôt a class, as such, but it does have multiple responsibilities: Some of the script deals with tossing coins, some deals with drawing pictures, and some wraps the SVG document in an HTTP message. ‚Ä¢ Divergent Change: The data string (lines 27‚Äì35) is probably going to need to bedifferent for almost every imaginable variation on this script. ‚Ä¢ There are already Ruby libraries for manipulating XML ele- Reinvented Wheel: ments, and even for creating SVG documents. Which should we address first? When faced with a long to-do list of code smells it‚Äôs easy to feel a little intimidated. It‚Äôs important to remember at this stage that we can‚Äôt fix everything in one sitting; we‚Äôll have to proceed in small, safe steps. It is entirely likely that you would address the smells in a different order, and that‚Äôs just fine. Consistency We can easily remove the Dead Code and change the Global Variable; Refactoring Practice. {#chapter-4}: Consider acquiring the Refactoring, Ruby edition since the exercises in this book touch on perhaps half of the refactorings cataloged in the Fields book. Practice Refactoring:  Build refactoring into your routine.  Build testing into your routine. Refactoring has two mechanisms: refactorings that are systematic and safe, and a supply of tests to verify that the transformations have been done correctly.  Take small steps. Often, noticing a smell is relatively easy, compared with working out how to get ‚Äúthere‚Äù from ‚Äúhere. ‚Äù Practice breaking up the larger refactorings (such as Tease Apart Inheritance) into small, safe steps.  Get help from others.  Add to the refactoring catalog. Exercises to try:  Scavenger Hunt/Smell of the Week.  Re-Refactor: Pick a good-sized piece of code (either your own, or one of the larger examples in the back of this book would work). Each day, start from the initial version, and refactor as far as you can in ten minutes.  Just Refactor: Pick or develop a project.  Inhale/Exhale: Find code demonstrating some smell. Apply a refactoring that addresses it.  Defactoring/Malfactoring: ‚ÄúDefactoring‚Äù and ‚Äúmalfactoring‚Äù are names we use for malicious refactoring: worsening the design of existing code.  Follow Your Nose: Pick a code smell in a good-sized project.  Harmonizing: Many of the code smells described in this book are fundamentally about some kind of duplication: identical code, similar code, code with similar structure, code with similar effects. Duplication isn‚Äôt always obvious, and sometimes the code needs to be changed to reveal it.  Refactoring Kata: A kata is a martial arts exercise that you repeat every day, for practice and to help get into the rhythm of the art. For this chapter the closing questions are the following: A. For the Extract Method, list each smell it can help to fix. (Hint: Use the What to Do sections for eachsmell catalogued in Part II,‚ÄúCode Smells,‚Äù later in this book. ) B. Which refactorings fix the most smells? C. Which refactorings aren‚Äôt mentioned by any of the smells? Why not? D. Does this list suggest any other smells we haven‚Äôt covered? That concludes our brief overview of the art of refactoring. It‚Äôs now time to address the specifics. As we mentioned in Chapter 2, ‚ÄúThe Refactoring Cycle,‚Äù perhaps the most difficult part of the refactoring cycle is in recognizing code that needs to be refactored. Part II, ‚ÄúCode Smells,‚Äù looks in detail at all of the common and some of the not so common code smells; by doing the exercises you‚Äôll learn how to recognize and eliminate them. PART II Code Smells Measurable Smells. : Most metrics seem to correlate with length, so we tend to worry about size first (usually noticeable as a Large Module or Long Method). Metrics are indicators, not absolutes. It‚Äôs very easy to get into the trap of making numbers without addressing the total complexity. So don‚Äôt refactor just for a better number; make sure it really improves your code. The smells in this chapter are the easiest to identify. They‚Äôre not necessarily the easiest to fix. Pay attention when things feel like they‚Äôre getting too big. In this chapter we‚Äôll cover the following smells:  Comments, in which the code includes text to explain what‚Äôs happening Long Method, in which a method is too long to be manageable Large Module, in which a class or module is too large to represent a meaningful abstraction Long Parameter List, in which a method needs too much information in order to get its job doneComments: What to Look For  The code contains a comment. (Some IDEs make these more obvious by colorcoding comments. )Why This Is a Problem  Flexibility: Any comment that explains the code must be kept in step if the code is changed.  Duplication: Most comments can be reflected just as well in the code itself. For example, the goal of a method can often be communicated as well through its name as it can through a comment.  Communication: Comments that say something slightly different than the code create cognitive drag or even mistrust and slow the reader down. When to Leave ItDon‚Äôt delete comments that are pulling their own weight such as rdocAPI documentation. Some comments can be particularly helpful, those that tell why something is done a particular way (or why it wasn‚Äôt), or those that cite algorithms that are not obvious (where a simpler algorithm won‚Äôt do). How It Got This WayComments may be present for the best of reasons: The author realizes that something isn‚Äôt as clear as it could be and adds a comment. What to Do    When a comment explains a code fragment, you can often use Extract Method to pull the fragment out into a separate method. The comment will often suggest a name for the new method.     When a comment explains what a method does (better than the method‚Äôs name!), use Rename Method using the comment as the basis of the new name.     When a comment explains preconditions, consider using Introduce Assertion to replace the comment with code.  What to Look for Next    Duplication: Often the code fragments broken out of along method will do similar things in similar ways; it may be possible to identify some duplication among them.     Abstraction: Creating names for code blocks helps to relate the design to the application‚Äôs domain. Review the names in the area you changed for consistency  Long Method: What to Look For  A method has a large number of lines. (We‚Äôre immediately suspicious of any method with more than five lines. )Why This Is a Problem    Flexibility: A Long Method is guaranteed to be a Greedy Method at least tworesponsibilities are coupled together in one place, which in turn leads to Divergent Change.     Testability: It can be difficult to isolate individual behaviors of a Long Method for testing; and if a method does too much it may also be difficult to create fixtures that contain enough context for the method to work properly.  When to Leave It It may be that a somewhat longer method is just the best way to express something. (Like almost all smells, the length is a warning sign, not a guarantee of a problem. ) How It Got This Way You can think of it as the Columbo syndrome. Columbo was the TV detective who always had ‚Äújust one more thing. ‚Äù A method starts down a path and, rather than break the flow or identify the helper classes, the author adds one more thing. Code is often easier to write than it is to read, so there‚Äôs a temptation to write fragments that are too big. What to Do    Use Extract Method to break up the method into smaller pieces. Look for comments or white space delineating interesting fragments. You want to extract methods that are semantically meaningful, not just introduce a function call every seven lines.     You may find other refactorings (those that clean up straight-line code, conditionals, and variable usage) helpful before you even begin splitting up the method.     If the method doesn‚Äôt separate easily into pieces, consider Replace Method with Method Object to turn the method into a separate object.  It‚Äôs natural to worry about the performance hit from increasing the number of method calls, but most of the time this is a non-issue. By getting the code as clean as possible before worrying about performance, you have the opportunity to gain big insights that can estructure systems and algorithms in a way that dramatically increases performance. What to Look for Next    Duplication: Often the code fragments broken out of a Long Method do similar things in similar ways; it may be possible to identify some duplication among them.     Communication: Creating names for code fragments helps to relate the design to the application‚Äôs domain. Review the names in the area you changed for consistency.     Abstraction: The signatures of the new methods may suggest a missing class, or new structure may be revealed in the original method.     Flexibility: Review the new methods for Feature Envy; with more small pieces you now have the opportunity to move code to more ‚Äúnatural‚Äù homes.  Large Module: What to Look For  A class or module has a large number of instance variables, methods, or just lines of code. Why This Is a Problem    Testability: A Large Module is usually difficult to test, either because it depends on many other modules or because it is difficult or time-consuming to create instances in isolation.     Flexibility: The module represents too many responsibilities folded together that is, every Large Module is also a Greedy Module.  How It Got This WayLarge modules get big a little bit at a time. The developer keeps adding just one more capability to a module until eventually it grows too big. Sometimes the problem is a lack of insight into the parts that make up the whole module. What to DoIn general, you‚Äôre trying to break up the module. This usually proceeds piecemeal: ‚Ä¢ Very often a review of the module reveals a composite of other smells, such as Long Methods, Data Clumps, and Temporary Fields; fix these smells first. ‚Ä¢ To break up the module further, use Extract Class or Extract Module if you can identify a new piece that has part of this module‚Äôs responsibilities. ‚Ä¢ If you have a large class, you might try Extract Subclass if you can divide responsibilities between the class and a new subclass. ‚Ä¢ Sometimes a class is big because it‚Äôs a GUI class, and it represents both a display component and a model. In this case, you can use Duplicate Observed Data to help extract a domain class. What to Look for Next    Duplication: As you peel off each piece of the Large Module you may discover it has similar responsibilities or interface to an existing module.     Communication: Dividing up confused responsibilities, and giving names to them, helps the reader relate the code to the real domain. Review the names (see Chapter 6) used in the slimmer module and everything you extracted.  Long Parameter List: What to Look For‚Ä¢ A method has more than one or two parameters. ‚Ä¢ A method yields more than one or two objects to an associated block. Why This Is a Problem    Simplicity: A Long Parameter List often indicates that a method has more than one responsibility. Sometimes the parameters have no meaningful grouping they don‚Äôt go together. In such cases it may be that the method, or the objects it uses, doesn‚Äôt represent a meaningful and cohesive abstraction in the problem domain.     Flexibility: A Long Parameter List represents a large number of pieces of shared information between the caller and called code. If either changes, the parameter list is likely to need changing too.     Communication: A lot of parameters represent a lot to remember the programmer has to remember not only what objects to pass, but in which order. More succinct APIs are easier and quicker to use.  When to Leave ItThis is one of those places where a smell doesn‚Äôt always equate to a problem. You might smell a Long Parameter List but decide it‚Äôs right for the situation at hand for example, to avoid the called method picking up a dependency that you don‚Äôt want it to have. Ensure that your changes don‚Äôt upset this balance. How It Got This WayYou might be trying to minimize coupling between objects. Instead of the called object being aware of relationships between classes, you let the caller locate everything; then the method concentrates on what it is being asked to do with the pieces. The method may have acquired many parameters because the programmer generalized it to deal with multiple variations by creating a general algorithm with a lot of control parameters. What to Do‚Ä¢ If a parameter‚Äôs value can be obtained from another object this one already knows, use Replace Parameter with Method ‚Ä¢ If the parameters come from a single object, try Preserve Whole Object. ‚Ä¢ If the data is not from one logical object, you still might group them via Introduce Parameter Object. What to Look for Next    Duplication: Sometimes a method‚Äôs clients all have to jump through the same hoops in order to call it. Check for Duplicated Code among the callers.     Communication: Parameters add to the cognitive load required to understand a class‚Äôs interface; all of the above refactorings help to hide detail. Review all of this class‚Äôs method signatures looking for Data Clumps and naming patterns.     Size: The amount of code required to call a method can be large when the method requires a lot of unrelated parameters. Look for signs of Feature Envy and Open Secret around the objects you are now passing as parameters to the method.  Exercises:: Exercises 5. 1: Comments Exercises 5. 2: Long Method Exercises 5. 3: Large Class Exercises 5. 4: Smells and Refactorings Exercises 5. 5: Triggers "
    }, {
    "id": 16,
    "url": "http://localhost:4000/2025/10/25/session-12.html",
    "title": "POOD Session 12: Conclusion",
    "body": "2025/10/25 - Session 12: Conlusion of POOD Go to you app and seek for Liskov violationreduce what you get back when you send a message, implement a common interface, write test, then you can make a new class  Polymorphism, objects that play roles, we have confidence that objects do what i send them. Find the conditional, same shape, same tests, that would be candidate to create small classes.    you need practice it     search one of those tools that looks over time in your repo how much has a big class changed, that needs refactoring.     it‚Äôs cheaper to create objects, otherwhise you get mutating objects which is bad. Not mutating objects will make things simpler  "
    }, {
    "id": 17,
    "url": "http://localhost:4000/2025/10/11/session-11.html",
    "title": "POOD Session 11: Escalation, Loosen Coupling in Tests & Nothing is Something",
    "body": "2025/10/11 - Session 11: Escalation, Loosen Coupling in Tests &amp; Nothing is SomethingDate: October 18, 2025 This blog post consists in four parts:  My notes on Escalation My notes on Loosen Coupling in Tests My notes on Glory in One Final Easy Change My notes on Nothing is SomethingKey Concepts:  Escalation: This block introduces a new requirement: Escalation #2-Mix up Actors and Actions.  This triggers a whole bunch of refactorings and writing of new tests, after which the code ends up both simpler and more abstract. Watch 1: Seeking Abstractions New requirement is split the data into two arrays, one named ‚Äòactor‚Äô and the other ‚Äòaction‚Äô. Example: # The trailing 'that' in each line below separates two things: 'actor' and 'action'# actors:# 'the horse and the hound and the horn' or 'the rooster that crowed in the morn'## actions# 'that belong to' or'that woke'## Create another variant that randomly mixes actors and actions. # ------------actor-----------------------action---------# Thus, 'the priest all shaven and shorn', 'that killed', etc. As you work, consider these questions:    Should you split the DATA into two arrays, one named ‚Äòactor‚Äô and the other ‚Äòaction‚Äô? Or is there a more general way to satisfy the actor/action requirement?     This is the first requirement that involves that DATA array.  Is it time to isolate the DATA in a separate class?     If the DATA moves to a separate class which is then injected back into House, should the injected data come in the correct order, or should House still be responsible for ordering it?  As we look here at the current House class, if you were to ask yourself, ‚ÄúDoes it have more than one responsibility?‚Äù or perhaps ‚ÄúIf it did two things, what would those two things be?‚Äù the answer is, probably, the DATA feels like one kind of thing, and the code, the algorithm, feels like another. Let‚Äôs start by writing some tests for the new classes before we extract DATA from House: class OriginalOrdererTest &lt; Minitest::Test def test_order  input = %w(a b c d e)  expected = input  assert_equal expected, OriginalOrderer. new. order(input) endendclass RandomOrdererTest &lt; Minitest::Test def test_order  Random. srand(1)  input = %w(a b c d e)  puts input  expected = %w(c b e a d)  assert_equal expected, RandomOrderer. new. order(input)  Random. srand endendclass RandomLastOrdererTest &lt; Minitest::Test def test_order  Random. srand(1)  input = %w(a b c d e always_last_item)  expected = %w(c b e a d always_last_item)  assert_equal expected, RandomLastOrderer. new. order(input)  Random. srand endendThis is the code so far once we have extracted the DATA into its own class, making sure it provides the right order since it‚Äôs not a House responsability: class Phrases  DATA =  [ [ the horse and the hound and the horn ,  that belonged to ],   [ the farmer sowing his corn ,  that kept ],   [ the rooster that crowed in the morn ,  that woke ],   [ the priest all shaven and shorn ,  that married ],   [ the man all tattered and torn ,  that kissed ],   [ the maiden all forlorn ,  that milked ],   [ the cow with the crumpled horn ,  that tossed ],   [ the dog ,  that worried ],   [ the cat ,  that killed ],   [ the rat ,  that ate ],   [ the malt ,  that lay in ],   [ the house ,  that Jack built ]  ] attr_reader :data def initialize(orderer: OriginalOrderer. new)  @data = orderer. order(DATA) end def phrase(num)  data. last(num). join(   ) end def size  data. size endendclass House attr_reader :phrases, :prefix def initialize(phrases: Phrases. new, prefixer: MundanePrefixer. new)  @phrases = phrases  @prefix = prefixer. prefix end def recite  1. upto(phrases. size). collect {|i| line(i)}. join( \n ) end def phrase(num)  phrases. phrase(num) end def line(num)   #{prefix} #{phrase(num)}. \n  endendclass RandomOrderer def order(data)  data. shuffle endendclass OriginalOrderer def order(data)  data endendclass RandomLastOrderer def order(data)  data[0. . -2]. shuffle &lt;&lt; data. last endendclass PiratePrefixer def prefix   Thar be  endendclass MundanePrefixer def prefix   This is  endendputsphrases = Phrases. new(orderer: OriginalOrderer. new)puts House. new(phrases: phrases). line(12)Now that we have separated these bits of code, we can play with actors and actions: # test for the new methodclass MixedColumnOrdererTest &lt; Minitest::Test def test_order  Random. srand(1)  input = [[ a1 ,  a2 ], [ b1 ,  b2 ], [ c1 ,  c2 ], [ d1 ,  d2 ], [ e1 ,  e2 ]]  expected = [[ c1 ,  a2 ], [ b1 ,  c2 ], [ e1 ,  e2 ], [ a1 ,  d2 ], [ d1 ,  b2 ]]  assert_equal expected, MixedColumnOrderer. new. order(input)  Random. srand endend# codeclass Phrases  DATA =  [ [ the horse and the hound and the horn ,  that belonged to ],   [ the farmer sowing his corn ,  that kept ],   [ the rooster that crowed in the morn ,  that woke ],   [ the priest all shaven and shorn ,  that married ],   [ the man all tattered and torn ,  that kissed ],   [ the maiden all forlorn ,  that milked ],   [ the cow with the crumpled horn ,  that tossed ],   [ the dog ,  that worried ],   [ the cat ,  that killed ],   [ the rat ,  that ate ],   [ the malt ,  that lay in ],   [ the house ,  that Jack built ]  ] attr_reader :data def initialize(orderer: OriginalOrderer. new)  @data = orderer. order(DATA) end def phrase(num)  data. last(num). join(   ) end def size  data. size endendclass House attr_reader :phrases, :prefix def initialize(phrases: Phrases. new, prefixer: MundanePrefixer. new)  @phrases = phrases  @prefix = prefixer. prefix end def recite  1. upto(phrases. size). collect {|i| line(i)}. join( \n ) end def phrase(num)  phrases. phrase(num) end def line(num)   #{prefix} #{phrase(num)}. \n  endendclass MixedColumnOrderer def order(data)  data. transpose. map { |column| column. shuffle }. transpose endendclass RandomOrderer def order(data)  data. shuffle endendclass OriginalOrderer def order(data)  data endendclass RandomLastOrderer def order(data)  data[0. . -2]. shuffle &lt;&lt; data. last endendclass PiratePrefixer def prefix   Thar be  endendclass MundanePrefixer def prefix   This is  endendputsphrases = Phrases. new(orderer: MixedColumnOrderer. new)puts House. new(phrases: phrases). line(12)This requirement, that we mix up actors and actions, gave us the impetus to extract a Phrases class, and that class is now responsible not only for the data but for putting the data in order. House gets injected with an instance of Phrases, and that Phrases object is responsible for returning each phrase to the House class. All of this code is super simple, and part of that simplicity comes from the fact that we‚Äôve insisted on finding straightforward abstractions. Also, we‚Äôre using composition, and we were able to conceive of writing a new orderer to do this, and we were able to think about extracting the data off into some other place where the array of data could have some different kind of shape. Loosen Coupling in Tests: This block we loose coupling between objects, we started by writing thest first. A few comments on how we extracted DATA from House and created Phrases class, however we don‚Äôt have test in place, and if we look carefully the arrays with the phrases kind of belong to House and also the logix which is independent of what data we might have. Phrases isn‚Äôt about House at all, it‚Äôs about assembling a bunch of little bits into a longer phrase. This is because how the code is designed. Test that was intention revealing that will force us to loose coupling between House and Phrases: class PhrasesTest &lt; Minitest::Test def test_phrase  expected  =  ?  # The House data makes a confusing test due to bad code design  assert_equal expected, Phrases. new. phrase(3) endendThe first thing we‚Äôre going to do is go over to the code and do a tiny refactoring where we extract and then inject the data in order to create a seam where we could inject something else.  HOUSE_DATA = [ [ the horse and the hound and the horn ,  that belonged to ],  [ the farmer sowing his corn ,  that kept ],  [ the rooster that crowed in the morn ,  that woke ],  [ the priest all shaven and shorn ,  that married ],  [ the man all tattered and torn ,  that kissed ],  [ the maiden all forlorn ,  that milked ],  [ the cow with the crumpled horn ,  that tossed ],  [ the dog ,  that worried ],  [ the cat ,  that killed ],  [ the rat ,  that ate ],  [ the malt ,  that lay in ],  [ the house ,  that Jack built ] ]class Phrases attr_reader :data def initialize(orderer: OriginalOrderer. new, input_data: HOUSE_DATA)  @data = orderer. order(input_data) end def phrase(num)  data. last(num). join(   ) end def size  data. size endendWith these changes we can now make more test more useful class PhrasesTest &lt; Minitest::Test def test_phrase  input_data  = [[ a1 ,  a2 ], [ b1 ,  b2 ], [ c1 ,  c2 ], [ d1 ,  d2 ], [ e1 ,  e2 ]]  expected =  phrase 2 phrase 3 phrase 4   assert_equal expected, Phrases. new(input_data: input_data). phrase(3) endendThis will release Phrases to be used in different contexts, not just House We solved this tight coupling as we always do it, by extracting some behavior and then injecting it, to create a seam that we can use to inject something else. Another improvement is: show the readers of this new test that Phrase can handle both a one dimensional and a two-dimensional array. Let‚Äôs rename it, copy it, and create an almost identical one, but that uses a two-dimensional array as an input. Here is the renaming result and also the Phrases#size tests: class PhrasesTest &lt; Minitest::Test def test_1d_phrase  input_data  = [ phrase 1 ,  phrase 2 ,  phrase 3 ,  phrase 4 ]  expected =  phrase 2 phrase 3 phrase 4   assert_equal expected, Phrases. new(input_data: input_data). phrase(3) end def test_2d_phrase  input_data  = [[ phrase 1a ,  1b ], [ phrase 2a ,  2b ], [ phrase 3a ,  3b ], [ phrase 4a ,  4b ]]  expected =  phrase 2a 2b phrase 3a 3b phrase 4a 4b   assert_equal expected, Phrases. new(input_data: input_data). phrase(3) end def test_size  assert_equal 10, Phrases. new(input_data: [ a ] * 10). size endendNow, let‚Äôs turno to House class, if you look at it attentively you‚Äôll see that it has nothing to do with House anymore, it takes in some bits and assembles them. Same procedure: Copy/Paste class =&gt; replace old_name with new_name =&gt; run tests class CumulativeTale attr_reader :phrases, :prefix def initialize(phrases: Phrases. new, prefixer: MundanePrefixer. new)  @phrases = phrases  @prefix = prefixer. prefix end def recite  1. upto(phrases. size). collect {|i| line(i)}. join( \n ) end def phrase(num)  phrases. phrase(num) end def line(num)   #{prefix} #{phrase(num)}. \n  endendWith these new changes we can adjust the old tests that test every individual line so that they get assembled correctly in all those lines. Now, it‚Äôs not necessary to write all these tests of individual variants. If one works, they‚Äôll all work. class CumulativeTaleTest &lt; Minitest::Test def setup  @data = [[ phrase 1a ,  1b ], [ phrase 2a ,  2b ], [ phrase 3a ,  3b ], [ phrase 4a ,  4b ]]  @phrases = Phrases. new(input_data: @data) end def test_line  expected =  This is phrase 2a 2b phrase 3a 3b phrase 4a 4b. \n   assert_equal expected, CumulativeTale. new(phrases: @phrases). line(3) end def test_recite  expected =    This is phrase 4a 4b. \n  +    \n  +    This is phrase 3a 3b phrase 4a 4b. \n  +    \n  +    This is phrase 2a 2b phrase 3a 3b phrase 4a 4b. \n  +    \n  +    This is phrase 1a 1b phrase 2a 2b phrase 3a 3b phrase 4a 4b. \n   assert_equal expected, CumulativeTale. new(phrases: @phrases). recite endendWe‚Äôve created tests for the Phrases class, and we‚Äôve renamed the House class to CumulativeTale, and dramatically simplified its tests. Glory in One Final Easy Change: In this block we‚Äôre asked to fulfill one final requirement, add another separator to the DATA. It should be actors, actions and modifier and mix all of those. Example: [‚Äúthe rooster that crowed in the morn‚Äù, ‚Äúthat woke‚Äù] ‚Äúthe rooster‚Äù = actor‚Äúthat crowed in the morn‚Äù = modifier‚Äúthat woke‚Äù = action This change will be super easy, there won‚Äôt need much code and that‚Äôs because of how the code is currently arranged. Because we relied on abstractions rather than concretions, and made a MixedColumnOrderer instead of creating actor and action variables in the original House class. See the . flatten. compact we had to add in order to deal with nil elements HOUSE_DATA =[ [ the horse and the hound and the horn , nil,  that belonged to ], [ the farmer ,  sowing his corn ,  that kept ], [ the rooster ,  that crowed in the morn ,  that woke ], [ the priest ,  all shaven and shorn ,  that married ], [ the man ,  all tattered and torn ,  that kissed ], [ the maiden ,  all forlorn ,  that milked ], [ the cow ,  with the crumpled horn ,  that tossed ], [ the dog , nil,  that worried ], [ the cat , nil,  that killed ], [ the rat , nil,  that ate ], [ the malt , nil,  that lay in ], [ the house , nil,  that Jack built ]]class Phrases  attr_reader :data  def initialize(orderer: OriginalOrderer. new, input_data: HOUSE_DATA)   @data = orderer. order(input_data)  end  def phrase(num)   data. last(num). flatten. compact. join(   )  end  def size   data. size  endendWe just enhanced the behavior of CumulativeTale so that it can deal with arrays that have bits of three parts, even if some of those parts include nil. Nothing is Something: These are the notes I took on Sandi‚Äôs talk ‚ÄòNothing is Something‚Äô    Talk is comprised of four parts.     Sandi comes from SmallTalk land where you have 6 keywords no confitional if therefore you are force to always think and take advatange of Objects.     nil is something. when you send a message to a nil it will complain with undefined method for nill  # example of falling into sending messages to nilids = [ pig ,   ,  sheep ]animals = ids. map { |id| Animal. find(id) }animals. each { |animal| puts animal. name }=&gt; pig=&gt; NoMethodError undefined method '+' for nilCan be midly fixed with conditionals however we are not using OOP: # example using if conditionalsids = [ pig ,   ,  sheep ]animals = ids. map { |id| Animal. find(id) }animals. each { |animal| puts animal. nil?  no animal  : animal. name }=&gt;  pig =&gt;  no animal =&gt;  sheep The solution fully leveraging OOP - Null object pattern # example using OOPclass GuaranteedAnimal def self. find(id)  Animal. find(id) || MissingAnimal. new endendclass Animal def name  . . .  endendclass MissingAnimal def name   no animal  endendids = [ pig ,   ,  sheep ]animals = ids. map { |id| GuaranteedAnimal. find(id) }animals. each { |animal| puts animal. name }=&gt;  pig =&gt;  no animal =&gt;  sheep ‚òùÔ∏è Make objects that stand in for those nils    Inheritance is for specialization, it‚Äôs not for sharing code.     Composition, inject an object to play a the role of the things that varies  1) isolate the thing that varies 2) name the concept 3) define a role 4) inject the player  composition + dependency injection = Object Oriented Design"
    }, {
    "id": 18,
    "url": "http://localhost:4000/2025/10/11/session-10.html",
    "title": "POOD Session 10: Beware Inheritance & Lean Towards Composition",
    "body": "2025/10/11 - Session 10: Beware Inheritance &amp; Lean Towards CompositionDate: October 11, 2025 This blog post consists in two parts:  My notes on Beware Inheritance My notes on Lean Towards CompositionKey Concepts:  Beware Inheritance: This block contains an example that illustrates how convenient inheritance can be, and how it can go very badly wrong. In this section we‚Äôre going to create a beautiful, simple, little inheritance hierarchy to show how useful inheritance can be to quickly getting things done, and then we‚Äôre going to introduce a change in requirements that makes everything go horribly wrong to show when you should switch from inheritance to composition. The new requirement is a variant of House that mixes up the bits, randomly. We need the original requirement to still work, House should still work just like it does, but they also want another variant where the lines come out mixed up, randomly, every time. Let‚Äôs do that with inheritance. First proposal: # original codeclass House DATA =  [  the horse and the hound and the horn that belonged to ,    the farmer sowing his corn that kept ,    the rooster that crowed in the morn that woke ,    the priest all shaven and shorn that married ,    the man all tattered and torn that kissed ,    the maiden all forlorn that milked ,    the cow with the crumpled horn that tossed ,    the dog that worried ,    the cat that killed ,    the rat that ate ,    the malt that lay in ,    the house that Jack built ] def recite  1. upto(12). collect {|i| line(i)}. join( \n ) end def phrase(num)  data. last(num). join(   ) end def line(num)   This is #{phrase(num)}. \n  end def data  DATA endend# RandomHouse codeclass RandomHouse &lt; House def data  @data ||= super. shuffle endend# PirateHouse codeclass PirateHouse &lt; House def prefix   Thar be  endendputs puts RandomHouse. new. line(12)putsputs PirateHouse. new. line(12)New requirement is going to make everything break badly with this inheritance approach. Implement RandomPirateHouse without duplicating code. Module is not feasable, composition is the right solution. You want your inheritance hierarchies to be shallow, not very deep, and narrow, not very wide. You want the subclasses to really be a kind of thing of the superclasses. Use of inheritance only on your object dependency graph leaf nodes. t the core of your app are key objects that depend on others, forming a chain outward. At the edges are leaf objects like BottleNumber# that are depended on but depend on nothing else. When you create subclasses that are that far out away from the center of your domain they‚Äôre probably not all that important, and they‚Äôre probably not going to change that much, and it might not go badly wrong to use inheritance out there. Lean Towards Composition: In the last section we implemented a little inheritance hierarchy that worked however once we wanted to introduce a new change it flopped. First proposal: class House DATA =  [  the horse and the hound and the horn that belonged to ,    the farmer sowing his corn that kept ,    the rooster that crowed in the morn that woke ,    the priest all shaven and shorn that married ,    the man all tattered and torn that kissed ,    the maiden all forlorn that milked ,    the cow with the crumpled horn that tossed ,    the dog that worried ,    the cat that killed ,    the rat that ate ,    the malt that lay in ,    the house that Jack built ] attr_reader :data def initialize(random=false)  @data =    if random == true    DATA. shuffle   else    DATA   end end def recite  1. upto(12). collect {|i| line(i)}. join( \n ) end def phrase(num)  data. last(num). join(   ) end def line(num)   #{prefix} #{phrase(num)}. \n  end def prefix   This is  endendputs# this code looks weirdputs House. new(true). line(12)In object-oriented programming, we can expect that if an object knows enough to pass you a true or a false, or a truck or a carrot, they know enough to pass you a smarter thing. You shouldn‚Äôt have to look at the type and supply behavior for different kinds of things. You should just have a thing that came in that you can send a message to, and get the thing back that you want. We don‚Äôt like this code at all, but the good thing about writing this conditional is, it tells us exactly what we wish we had. We need an object to stand in for true that behaves like what‚Äôs in the true branch, and we need another object to stand in for false that returns what‚Äôs in the false branch. Those two objects play a common role. They have to conform to the same API, and in the methods that conform to that API they have different behavior so that they can be treated interchangeably, but they do different things. We know we need two classes, and we know they have to conform to the same API, but we don‚Äôt want to have to name them right now. Second proposal: class House DATA =  [  the horse and the hound and the horn that belonged to ,    the farmer sowing his corn that kept ,    the rooster that crowed in the morn that woke ,    the priest all shaven and shorn that married ,    the man all tattered and torn that kissed ,    the maiden all forlorn that milked ,    the cow with the crumpled horn that tossed ,    the dog that worried ,    the cat that killed ,    the rat that ate ,    the malt that lay in ,    the house that Jack built ] attr_reader :data def initialize(orderer: OriginalOrderer. new)  @data = orderer. order(DATA) end def recite  1. upto(12). collect {|i| line(i)}. join( \n ) end def phrase(num)  data. last(num). join(   ) end def line(num)   #{prefix} #{phrase(num)}. \n  end def prefix   This is  endendclass RandomOrderer def order(data)  data. shuffle endendclass OriginalOrderer def order(data)  data. shuffle endend# we can now invoke RandomOrderer and PiratePrefixer since we rely on compositionputs House. new(orderer: RandomOrderer. new). line(12)putsputs House. new(prefixer: PiratePrefixer. new). line(12)We should name objects after we have written down the code, remember Objects are, not doers. And for the new requirement that entailed RandomPirateHouse we can do the follwing: class House DATA =  [  the horse and the hound and the horn that belonged to ,    the farmer sowing his corn that kept ,    the rooster that crowed in the morn that woke ,    the priest all shaven and shorn that married ,    the man all tattered and torn that kissed ,    the maiden all forlorn that milked ,    the cow with the crumpled horn that tossed ,    the dog that worried ,    the cat that killed ,    the rat that ate ,    the malt that lay in ,    the house that Jack built ] attr_reader :data, :prefix def initialize(orderer: OriginalOrderer. new, prefixer: MundanePrefixer. new)  @data = orderer. order(DATA)  @prefix = prefixer. prefix end. . . class PiratePrefixer def prefix   Thar be  endendclass MundanePrefixer def prefix   This is  endendputsputs House. new(orderer: RandomOrderer. new, prefixer: PiratePrefixer. new). line(12)Here is another variant we want to tackle and is regarding the ending of the sentences. class RandomButLastOrderer def order(data)  data[0. . -2]. shuffle &lt;&lt; data. last endendConclusion: Sandi does use inheritance a lot. It can be super easy, and handy, but as soon as it starts going wrong, as soon as you start creating deep or wide hierarchies, or subclasses that duplicate behavior across the hierarchy, you have to switch to composition. Composition is a little bit harder for humans to think about, but once you get it, once you get the knack in your head, it‚Äôs easy to use, and it‚Äôs very flexible and changeable. The key to composition is being able to imagine objects that apparently do nothing. "
    }, {
    "id": 19,
    "url": "http://localhost:4000/2025/10/04/session-09.html",
    "title": "POOD Session 9: Loosen Coupling, Find Shameless Green & Vary the Bits",
    "body": "2025/10/04 - Session 9: Vary VerseDate: October 04, 2025 This blog post consists in three parts:  My notes on Loosen Coupling My notes on Find Shameless Green My notes on New requirement: Vary the BitsKey Concepts:  Loosen Coupling: Watch 1: Choosing Which Units to Test Unit tests are tests of just a single class (Bottles, BottleNumber) and an integration test is a test that checks the collaboration of more than one single class (APIs, db interaction). The initial tests that we wrote back in Chapter 2 were unit tests to begin with because we just had that single Bottles class, and now they are badly out of date and they‚Äôve long since been turned into integration tests. The rule is every class should have a unit test. All of these classes are being covered by the original tests that were unit tests but are now integration tests, and some of these new objects need their own unit tests now. We think of tests as something that prevents regressions, as a way to prove that our code works correctly and to keep us from accidentally breaking things.  Also, tests tell the story of the code.  Tests help to expose the design of the code that you have, if the code is poorly designed it will be difficult to test. You can write incorrect, misleading tests around well-designed code. However, the converse isn‚Äôt really true. It‚Äôs really hard to write nice, neat, intention revealing tests around code that is poorly designed. You can think of tests as the first reuse of your code. When you write tests last, it‚Äôs very common to find that is really difficult to test your code, and the reason is, it‚Äôs very easy when you‚Äôre just writing code to get a bunch of tight coupling, to have a bunch of objects that know way too much about each other such that they can only be used in combination with each other. If you‚Äôre a test last kind of person, you just go beat on your tests until you make them work, no matter how painful it is, and you leave that entangled mess as a consequence for other people downstream. I promise you, that if you wrote tests first, you would not do this. It‚Äôs too much trouble. This is an argument for writing tests first. If you write them first, you will refuse to put up with tightly-coupled code; you‚Äôll design your code so that testing is easy. If you write the code first and put the tests last, no matter how difficult it is to get the tests running, you‚Äôll probably keep the code and just write those tests. Wirting tests for BottleNumber0, BottleNumber1, BottleNumber6 is not worth the time, it wont save money and Sandi suggested to test the whole BottleVerse class instead. Watch 2: Reorganizing Tests We should strive to write the fastest tests possible, the fewest of them, with the most intention revealing expectations, and the least amount of code. The fact that BottleVerse and BottleNumber are hidden is also a factor that don‚Äôt require testing. On the other hand we have Bottle that gets injects BottleVerse which means it‚Äôs a public relationship, it deserves testing. # public relationship and loose coupling between Bottle and BottleVerse# it makes BottleVerse independent of context and suggest it should have unit testclass Bottles attr_reader :verse_template def initialize(verse_template: BottleVerse) üëà  @verse_template = verse_template end. . . # not public relationship and tight coupling between BottleVerse and BottleNumberclass BottleVerse def self. lyrics(number)  new(BottleNumber. for(number)). lyrics end. . . We started by creating a BottleVerseTest and move one by one of BottlesTest, we re-run test to see if something fails and changed the class initialized, instead of BottlesTest we created BottleVerseTest. Another change was the verbose test name, here we want to be very explicit and reduce the uncertainty that a vague name could cause for future readers class BottleVerseTest &lt; Minitest::Test def test_verse_general_rule_upper_bound  expected =  99 bottles of beer on the wall,   +    99 bottles of beer. \n  +    Take one down and pass it around,   +    98 bottles of beer on the wall. \n   assert_equal expected, BottleVerse. lyrics(99) end def test_verse_general_rule_lower_bound  expected =  3 bottles of beer on the wall,   +    3 bottles of beer. \n  +    Take one down and pass it around,   +    2 bottles of beer on the wall. \n   assert_equal expected, BottleVerse. lyrics(3) end def test_special_verse_2  expected =  2 bottles of beer on the wall,   +    2 bottles of beer. \n  +    Take one down and pass it around,   +    1 bottle of beer on the wall. \n   assert_equal expected, BottleVerse. lyrics(2) end def test_special_verse_1  expected =  1 bottle of beer on the wall,   +    1 bottle of beer. \n  +    Take it down and pass it around,   +    no more bottles of beer on the wall. \n   assert_equal expected, BottleVerse. lyrics(1) end def test_special_verse_0  expected =  No more bottles of beer on the wall,   +    no more bottles of beer. \n  +    Go to the store and buy some more,   +    99 bottles of beer on the wall. \n   assert_equal expected, BottleVerse. lyrics(0) endendWatch 3: Seeking Context Independence Context of an object is, its surroundings. It‚Äôs the stuff that‚Äôs around it, the things that it needs in order to be able to do its own job. Objects that require lots of context, large numbers of other things, are difficult to reuse in new contexts. Objects that have less context, that require fewer things from their surroundings, are more reusable in other situations. If we look at the Bottle class and because we went over several refactoring where we extracted and isolate some bit of code we do know why it‚Äôs called Bottle but someone new might not know why therefore here is a new proposal to rename it. And given the fact that the song always goes downwards, like 15, 14, 13, 12, 11 and so on. The first step is to copy/paste the Bottle class and rename the duplicate with CountdownSong and pass that new name to tests, re-run test and see that nothing breaks class CountdownSong attr_reader :verse_template def initialize(verse_template: BottleVerse)  @verse_template = verse_template end. . . With this change the tests now seem awkward, like off of what the new name reflects, and that made the more context independent. We need to do something with the tests to tell a better story about what CountdownSong actually does. Think of it from a reader point of view, where it‚Äôs easy to read, where it really shows CountdownSong behavior. The next test is a story we would like to have, it doesn‚Äôt work yet. # bottles_test. rbclass CountdownSongTest &lt; Minitest:Test def test_a_couple_of_tests  expected =     This is verse 99. \n  +    \n  +    This is verse 99. \n  +    \n  +    This is verse 97. \n   assert_equal(   expected, CountdownSong. new. verses(99, 87)). . . If we write the code first, then we can start working on making it work with our code. What we need is another verse_template that would play as a test_double in RSpec. New version more intention revealing for test_a_couple_of_tests class VerseFake def self. lyrics(number)   This is verse #{number}. \n  endendclass CountdownSongTest &lt; Minitest:Test def test_a_couple_of_tests  expected =     This is verse 99. \n  +    \n  +    This is verse 99. \n  +    \n  +    This is verse 97. \n   assert_equal(   expected, CountdownSong. new(verse_template: VerseFake). verses(99, 87)). . . Side node: we should not use pattern names in class names, for instance, inestead of NumberDecorator we used BottleNumber which is more revealing of the purpose. It‚Äôs a failure of naming. We should be careful with decorator, fake, wrapper, adapter and facade. The current public API of CountdownSong has song, verses() and verse and we still need to test the verse mehtod: class CountdownSongTest &lt; Minitest:Test def test_verse  expected =  This is verse 500. \n   assert_equal(   expected, CountdownSong. new(verse_template: VerseFake). verses(500)) end def test_verses  expected =    This is verse 47. \n  +    \n  +    This is verse 46. \n  +    \n  +    This is verse 45. \n  +    \n  +    This is verse 44. \n  +    \n  +    This is verse 43. \n   assert_equal expected, CountdownSong. new(verse_template: VerseFake). verses(47,43) end def test_verses  expected =     This is verse 99. \n  +    \n  +    This is verse 99. \n  +    \n  +    This is verse 97. \n   assert_equal(   expected, CountdownSong. new(verse_template: VerseFake). verses(99, 87)). . . Lastly, the method song in chapter 2 we had to write down all 100 cases for the song due to the code design, remember it‚Äôs hardcoded song(99, 0) so it‚Äôs time to extract and add them as argument in the CountdownSong class CountdownSong attr_reader :verse_template, :max, :min def initialize(verse_template:, max: 99999, min: 0)  @verse_template = verse_template  @max = max  @min = min end def song  verses(max, min) end def verses(upper, lower)  upper. downto(lower). map { |i| verse(i) }. join( \n ) end def verse(number)  verse_template. lyrics(number) endendHere is the text for the song method, it has prime numbers (which means they‚Äôre meaningless, by convention) and now we can remove the big test. def test_song expected =   This is verse 23. \n  +   \n  +   This is verse 22. \n  +   \n  +   This is verse 21. \n  +   \n  +   This is verse 20. \n  +   \n  +   This is verse 19. \n  assert_equal expected, CountdownSong. new(verse_template: VerseFake, max: 23, min: 19). songendWatch 4: Communicating With the Future We‚Äôre almost done and the code looks good. We still need to send signals for future readers. One of those signal systems is shape. The shape arrage -&gt; act -&gt; assert pattern. That pattern means you set up an expectation, and then you do something, and the you check if the result of that thing you did met that expectation. If all of the tests you have written have a specific shape, and the one doesn‚Äôt it will cause a mental jolt on the reader and they‚Äôll wonder what‚Äôs the difference? The objective is to have all the tests with same shape so that nothing is indicating to the readers by the shape. Another topic is dynamic typing, Ruby is awesome and not being statis typed gives you freedom, however the price you pay for the freedom is that it‚Äôs on your head to make sure that when you inject an object into a class, where you have a number of choices of actual classes that you can inject, you pick some role player and inject it, ‚Äúthe receiver‚Äù has to be able to trust that that object plays the role it‚Äôs supposed to play. The compiler would prevent it. Above idea provokes a Liskov violation, where you implement an if conditional in order to check the type and know what message should be sent or what API use. Therefore, you need to make sure that all the objects that appear to play a role really do so, such that some other object that‚Äôs interacting with one of those role playing objects can treat them all as if they‚Äôre interchangeable so that you do not have to say ‚ÄúWhat kind of thing are you?‚Äù in order to know how to talk to them, you have to get this right yourself. There‚Äôs a couple of different ways to make this happen.  You can just tell everybody ‚ÄúEverything that says it‚Äôs a verse_template has to play the role of verse_template. ‚Äù, which means it needs to respond to lyrics. That means, in the case of our code, that BottleVerse and VerseFake have to both respond to lyrics and everybody, if they make a new one, or if they use them, or if they change them, they need to honor that contract.    Use a library that help you with types like Sobet. This will help define a common interface and then make all the objects conform to the interface     Write tests to prove that objects that play a common role conform to their API, and that‚Äôs what we‚Äôre about to do here.  # bottles_test. rbmodule VerseRoleTest def test_plays_verse_role  assert_respond_to @role_player, :lyrics endendclass VerseFake def self. lyrics(number)   This is verse #{number}. \n  endendclass VerseFakeTest &lt; Minitest::Test include VerseRoleTest def setup  @role_player = VerseFake endendSandi‚Äôs summary of this block:  Tests help prevent errors in code, but to characterize them so simply is a disservice; they offer far more. Good OO is built upon small, interchangeable objects that interact via abstractions. The behavior of each individual object is often quite obvious, but the same cannot be said for the operation of the whole. Tests fill this breach.  Object-oriented applications rely on message sending. The key virtue of messages is that they add indirection. Messages allow the sender to ask for an abstraction and be confident that the receiver will use the appropriate concrete implementation to fulfill the request. Senders are responsible for knowing what they want, receivers, for knowing how to do it. Separating intention from implementation in this way allows you to introduce new variations without altering existing code; simply create a new object that responds to the original message with a different implementation.  When designed with the following features, object-oriented code can interact with new and unanticipated variants without having to change:    Variants are isolated. They‚Äôre usually isolated in some kind of object, often a new class.     Variant selection is isolated. Selection happens in factories, which may be as simple as isolated conditionals that choose a class.     Message senders and receivers are loosely coupled. This is commonly accomplished by injecting dependencies.     Variants are interchangeable. Message senders treat injected objects as equivalent players of identical roles.   Initially, this reliance on abstractions and indirection increases the complexity of code. What OO promises in return is a reduction in the future cost of change. Highly concrete, tightly coupled code will resist tomorrow‚Äôs change. Code that depends on loosely coupled abstractions will encourage it.  Because tests need to execute code, they supply early and direct information about inadequate design, and they provide impetus and inspiration for refinements. When tests are difficult to write, require lots of setup, or can‚Äôt tell a satisfying story, something is wrong. Listen. Fixing problems now is not only cheaper than fixing them later, but will improve your code, clarify your tests, and make glad your work. Find Shameless Green: Here we started a brand new problem called ‚ÄúThe House that Jack built‚Äù. This time I searched what that song was about in comparison to the first time I faced ‚Äú99 bottles‚Äù Here is a small research: Definition: A traditional English cumulative rhyme that builds layer by layer ‚Äî each verse adds a new element while repeating all the previous ones. Verse 1:This is the house that Jack built. Verse 2:This is the maltThat lay in the house that Jack built. Verse 3:This is the rat,That ate the maltThat lay in the house that Jack built. Verse 4:This is the cat,That killed the rat,That ate the maltThat lay in the house that Jack built. Watch 1: Finding Shameless Green We are tasked to write the first version of code that satisfies tests, remember reaching green as soon as possible is the goal, aiming for understability rather than changeability. My frist version of the code: class House def line(number)  case number  when 1    This is the house that Jack built. \n   when 2    This is the malt that lay in the house that Jack built. \n   when 3    This is the rat that ate the malt that lay in the house that Jack built. \n   when 4    This is the cat that killed the rat that ate the malt that lay in the house that Jack built. \n   when 5    This is the dog that worried the cat that killed the rat that ate the malt that lay in the house that Jack built. \n   when 6    This is the cow with the crumpled horn that tossed the dog that worried the cat that killed the rat that ate the malt that lay in the house that Jack built. \n   when 7    This is the maiden all forlorn that milked the cow with the crumpled horn that tossed the dog that worried the cat that killed the rat that ate the malt that lay in the house that Jack built. \n   when 8    This is the man all tattered and torn that kissed the maiden all forlorn that milked the cow with the crumpled horn that tossed the dog that worried the cat that killed the rat that ate the malt that lay in the house that Jack built. \n   when 9    This is the priest all shaven and shorn that married the man all tattered and torn that kissed the maiden all forlorn that milked the cow with the crumpled horn that tossed the dog that worried the cat that killed the rat that ate the malt that lay in the house that Jack built. \n   when 10    This is the rooster that crowed in the morn that woke the priest all shaven and shorn that married the man all tattered and torn that kissed the maiden all forlorn that milked the cow with the crumpled horn that tossed the dog that worried the cat that killed the rat that ate the malt that lay in the house that Jack built. \n   when 11    This is the farmer sowing his corn that kept the rooster that crowed in the morn that woke the priest all shaven and shorn that married the man all tattered and torn that kissed the maiden all forlorn that milked the cow with the crumpled horn that tossed the dog that worried the cat that killed the rat that ate the malt that lay in the house that Jack built. \n   else    This is the horse and the hound and the horn that belonged to the farmer sowing his corn that kept the rooster that crowed in the morn that woke the priest all shaven and shorn that married the man all tattered and torn that kissed the maiden all forlorn that milked the cow with the crumpled horn that tossed the dog that worried the cat that killed the rat that ate the malt that lay in the house that Jack built. \n   end end def recite  (1. . 12). map { |number| line(number) }. join( \n ) endendThis time, first i search more about the domain, then started coding one test at the time until it met criteria and lastly I tried different solutions for the loop from String. new with &lt;&lt; or . prepend() but this one worked. I know that it‚Äôs going to be different from Sandi‚Äôs answer but I tried to aim for understability. ‚Ä¶ WOW! it look quite the same!! I was about to start interpolating like the last time since I noticed the pattern in each sentence but I resisted to make the premature abstraction ! Writing Shameless Green in the simplest possible way is not a commitment to keeping Shameless Green, but remember that if you get to green quickly, you‚Äôll have green tests and you can write more complicated code using refactorings. New requirement: Vary the Bits: Current lesson gives you a chance to practice:  following the Open/Closed Principle choosing the most related Code Smell selecting the correct refactoring recipe writing the code. Someone tells you that have a great idea that will change the output of the current code. The first thing you‚Äôre going to do is think about that ‚Äúflowchart‚Äù, where you ask yourself, ‚ÄúIs this code ‚Äòopen‚Äô to the new requirement?‚Äù And the answer to that is ‚Äòno‚Äô, this code isn‚Äôt open to changing the little bits in all these lines.  Then, you know how to make it open? The answer is no. Mostly every time the first two answers are NO. Let‚Äôs fall back to code smells ! And this code has many of the same code smells we solve in 99 Bottles like:  magic number conditional code (checking for type value) long method code duplicationWe‚Äôll ignore conditional, and stay with magic number and code duplication. ‚ÄúWhich one of those is more closely related to the thing I‚Äôm trying to vary?‚Äù, it‚Äôs the duplication, so let‚Äôs work on that. We have a recipe that lets us remove duplication, it allows us to turn difference into sameness and that‚Äôs the Flocking Rules.  Flocking Rules ‚Äì A systematic way to discover hidden abstractions by:   Selecting the most similar pieces of code (Find the things that are least different)     Finding the smallest difference between them     Making the simplest change to remove that difference  In this case we might argue that verse 11 and 12 have the most things in common or maybe 1 and 2, so you should ask yourself ‚ÄúWhich one is simpler?‚Äù And it‚Äôs immediately obvious that the simplest pair is 1 and 2, and that means that‚Äôs what you should work on. First proposal: class House def recite  1. upto(12). collect {|i| line(i)}. join( \n ) end def phrase(num)  if num == 1       else    the malt that lay in    end end def line(num)  case num  when 1. . 2    This is #{phrase(num)}the house that Jack built. \n   when 3    This is the rat that ate the malt that lay in the house that Jack built. \n This one seems clever but if we add another branch for number 3 we‚Äôll end up with same conditionals like original code, remember we are looking for an algorithm that handles all different variants and doesn‚Äôt contain any duplication and that will enable to treat everything the same. Using some pattern matching skills we discovered that the slots of the phrases we are pluging in have more meaning that the string itself, they have the position in which they are going to be placed, therefore we can use to design the algorithm that handle varieties. class House def recite  1. upto(12). collect {|i| line(i)}. join( \n ) end def phrase(num)  [ the rat that ate ,  the malt that lay in  ,   ]. last(num). join(  ) end def line(num)  case num  when 1. . 3    This is #{phrase(num)}the house that Jack built. \n   when 4    This is the cat that killed the rat that ate the malt that lay in the house that Jack built. \n   when 5    This is the dog that worried the cat that killed the rat that ate the malt that lay in the house that Jack built. \n We can cotinue doing this one line at the time and running tests so we make sure we don‚Äôt break something. This is the code we finished with: class House def recite  1. upto(12). collect {|i| line(i)}. join( \n ) end def phrase(num)  [  the horse and the hound and the horn that belonged to ,    the farmer sowing his corn that kept ,    the rooster that crowed in the morn that woke ,    the priest all shaven and shorn that married ,    the man all tattered and torn that kissed ,    the maiden all forlorn that milked ,    the cow with the crumpled horn that tossed ,    the dog that worried ,    the cat that killed ,    the rat that ate ,    the malt that lay in ,     ]. last(num). join(   ) end def line(num)   This is #{phrase(num)}the house that Jack built. \n  endend"
    }, {
    "id": 20,
    "url": "http://localhost:4000/2025/09/27/session-08.html",
    "title": "POOD Session 8: Vary Verse & Honor Demeter, Isolate Object Construction",
    "body": "2025/09/27 - Session 8: Vary VerseDate: September 27, 2025 This blog post consists in two parts:  My notes on Vary Verse My notes on Honor Demeter, Isolate Object ConstructionKey Concepts:  Law of demeter CompositionVary Verse: Watch 1: Appreciating the Mechanical Process This block introduces a new requirement to vary the lyrics of the verse which allows us to begin considering whether and when you might voluntarily make changes to improve code. In this block introduce the ideas of ‚Äòpseudocode‚Äô and ‚Äòcoding by wishful thinking. ‚Äô This block culminates with the Dependency Inversion Principle (DIP), one of the most broadly useful concepts in object-oriented programming. The current code is simple because we started out with no abstractions. No incorrect abstractions or make abstractions from things we didn‚Äôt really understand. Then we used repeatable programming techniques to follow code smells, then extract differences and isolate variance The story this code tells is that there‚Äôs a more abstract kind of verse, that allthe 99 bottles verses have in common, a single abstraction. def verse(number) # here the number (Integer) gets transformed into a BottleNumber instance # then goes into the Factory bottle_number = BottleNumber. for(number) # here is the template  #{bottle_number} of beer on the wall,  . capitalize +  #{bottle_number} of beer. \n  +  #{bottle_number. action},   +  #{bottle_number. successor} of beer on the wall. \n endIf you were to describe the responsibility of verse method, you would say it converts a number into a BottleNumber, and then it uses that BottleNumber to create a verse. The use of the word ‚Äúand‚Äù in that sentence, converts a number into a BottleNumber AND uses that BottleNumber to make a verse that word ‚Äúand‚Äù should give you pause. Given ‚Äúand‚Äù shows that verse method have more than one responsibility. These 6 lines of code, represent not much hurt, it can be considered as a code smell but since we have not gotten any other requirement we can leave it as it‚Äôs. However, if you voluntarily want to refactor this code into something more SOLID, consider the outlook that you‚Äôre the steward of someone else money and if this change in the present will save money in the future or maybe you‚Äôre better off and wait the next requirement. What you want is to have a set of internal rules that allow you to make bets on whether or not changes are going to turn out, and you want those bets to pay off more often than not. Code smell here is ‚ÄúSpeculative generality‚Äù making improvements to code based on your ideas that will pay off later. Really good progammers, write really changeable code. We‚Äôll see the heuristics, the set of rules can make you more confident, not that every one of these changes is going to save you money later, but they probably won‚Äôt cost you money, and enough of them will actually save you money so that it‚Äôs worth doing it all the time. Experienced programmers are like little artificial intelligence machines that have been trained on many, many, many examples of code. Their experience of making judgments, and looking at how those judgments turned out over years, and years, and years, build up into a kind of intuition. And you can think of that programming intuition really as just a form of pattern matching. They can look at a set of code and recognize shapes that are going to cause trouble later, and they know how to transform those shapes that are going to be a problem into shapes that are going to be easy to change later. Watch 2: Clarifying Responsibilities with Pseudocode New requirement is to make code produce different song verses. As we use the . downto() method we must ask if the new verse will count downwards too, so that we can know we need to change code or not. If we need to know if code is Open or Closed to change we can refer to diagram:  If code is not open and we don‚Äôt know how to make it open, we look for code smells. The benefits of writing bad code is that we introduce code smells that will give us a glimpse of the future that we can preemptively decide what code smells we are going to have and use refactoring to remove them. Here, is a first sketch with pseudo code:  def verse(number)  # if 99_bottle_song  bottle_number = BottleNumber. for(number)   #{bottle_number} of beer on the wall,  . capitalize +   #{bottle_number} of beer. \n  +   #{bottle_number. action},   +   #{bottle_number. successor} of beer on the wall. \n   #  # elsif unknown_song_2_verse  # . . .   #  assemble verse for unknown song 2  # . . .   # elsif unknown_song_3  # . . .   #  assemble verse for unknown song 3  # . . .   # end endAbove if statement is just going to grow, and grow, and grow, and grow, and grow, until your life is a disaster so pseudo code help us see if we are heading a dead end road and identify it quickly. Solution: the problem is, we have this conditional with a number of branches, and each of those branches should represent an object, a different kind of verse variant. And that means we should apply the Extract Class refactoring to pull those different verse_templates out into some other class.  Watch 3: Extracting the Verse As we did back in chapter 5, when we had the code smell of ‚Äúprimitive obsession‚Äù on number argument, and we created BottleNumber we need to follow the next steps:  Choose a name for the new class Add attr_reader and initializer Copy methods from old to new (not cut!) Wire new class into old (NewClass. new) Clean up extra argsClasses should be name after what they are ! In this case BottleVerse: class Bottles def verse(number)  BottleVerse. new(number). verse(number)  # bottle_number = BottleNumber. for(number)  #  #{bottle_number} of beer on the wall,  . capitalize +  #  #{bottle_number} of beer. \n  +  #  #{bottle_number. action},   +  #  #{bottle_number. successor} of beer on the wall. \n  endendclass BottleVerse attr_reader :number def initialize(number)  @number = number end def verse(number)  bottle_number = BottleNumber. for(number)   #{bottle_number} of beer on the wall,  . capitalize +   #{bottle_number} of beer. \n  +   #{bottle_number. action},   +   #{bottle_number. successor} of beer on the wall. \n  endendUp to this point and running after each change tests, we were able to create a new class, make it syntatically correct, invoke it from the old class and now we still need to remove old-extra-arguments. Watch 4: Coding by Wishful Thinking In object-oriented programming, we think of design as happening from the message sender‚Äôs point of view. AI example code of above phrase: # Design from the message sender's point of view## Don't ask:  What CAN this object do?  (receiver perspective)# Ask instead:  What do I NEED this object to do?  (sender perspective)## The sender (trip) only cares about getting a description, it doesn't # care whether the vehicle is a Car, Bike, or Plane. We design the # interface based on what the sender needs to send, not what the # receiver happens to have. class Trip def initialize(vehicle)  @vehicle = vehicle end def plan  puts  Planning trip using: #{@vehicle. describe}  endend# All vehicles respond to the message the sender needsclass Car def describe   a comfortable car  endendclass Bike def describe   an eco-friendly bike  endend# Usage - Trip sends 'describe', vehicles respondtrip1 = Trip. new(Car. new)trip1. plan # =&gt; Planning trip using: a comfortable cartrip2 = Trip. new(Bike. new)trip2. plan # =&gt; Planning trip using: an eco-friendly bikeThe key: Trip (the sender) defines what message it needs (describe), and all receivers must respond to that interface. Here is the result of wishful thinking: class Bottles def verse(number)  BottleVerse. new(number). lyrics endendclass BottleVerse attr_reader :number def initialize(number)  @number = number end def lyrics  bottle_number = BottleNumber. for(number)   #{bottle_number} of beer on the wall,  . capitalize +   #{bottle_number} of beer. \n  +   #{bottle_number. action},   +   #{bottle_number. successor} of beer on the wall. \n  endendWatch 5: Inverting Dependencies We just created a BottleVerse class because we‚Äôre trying to fulfill a new requirement to produce new songs that are like 99 Bottles, but have different lyrics. In the prior section, we extracted the thing we wanted to vary, the verse method, those lyrics out into a new BottleVerse class and yet we still can‚Äôt actually fulfill the requirement. Dependency Inversion, says that you should depend on abstractions, not concretions. And right now, here in this code, the name of the BottleVerse class is a concretion. (This create a tight coupling between these two classes) class Bottles def verse(number)  BottleVerse. new(number). lyrics # This makes both classes to be tight together endendDepending on the class name BottleVerse is bad but not as bad as having Bottle unable to interact with other classes to produce . lyrics. What we want to do here is change this code such that the Bottles class can interact with any other object that can supply lyrics. (we need to loosen the coupling between Bottles and BottleVerse) At this point Bottles know two things:  BottleVerse which is the concretion The abstraction that is . lyricsKnowing about . lyrics is ok, Bottles somehow gotta know what message send, but the object receiver is the one that needs fixing. If an object can play a common role, that role should have a name, we can call it verse_template this will replace the concrete dependency BottleVerse Here, we have extracted BottleVerse class and injected of a constant class Bottles attr_reader :verse_template def initialize(verse_template: BottleVerse)  @verse_template = verse_template end def verse(number)  verse_template. new(number). lyrics endendNow we have the option of creating other players of this role and producing varying songs. This idea of extracting variance into individual classes of their own, and then choosing the right variant and injecting it back into the class at runtime, is known as composition. Here is a Sandi drawing to illustrate this change: Bottles used to have a verse method:  We extracted that method verse out into a separate class called BottleVerse  Then we injected that back in.  We opened the door to have many different classes that play the verse_template role, as long as they conform the lyrics API  A much shorter way to say this is that we just isolated the code we wanted to vary. It‚Äôs one of the core concepts of how to write good OO that you take things that you want to vary, and instead of wrapping them in conditionals to provide variation, you take what would, be branches of a conditional and pull them out into classes of their own, and then someone, somewhere will pick the right object and inject it into the class that needs a variant. The principle is named Dependency Inversion. Here‚Äôs the simplest explanation I can give: Depend on abstractions, not concretions. Before the name of the BottleVerse class was a concretion. We didn‚Äôt want to depend on that, instead, we wanted to invert that dependency so that we were depending on the abstraction, which is the idea that we wanted a verse_template rather than the concretion, the actual class name. When we depend on abstractions, it means that we can get other players of that abstract role and use them instead of the concretion. class Bottles attr_reader :verse_template def initialize(verse_template: BottleVerse)  @verse_template = verse_template end def verse(number)   verse_template. new(number). lyrics endendclass BottleVerse attr_reader :number def initialize(number)  @number = number end  def lyrics  bottle_number = BottleNumber. for(number)   #{bottle_number} of beer on the wall,  . capitalize +   #{bottle_number} of beer. \n  +   #{bottle_number. action},   +   #{bottle_number. successor} of beer on the wall. \n  endendclass RandomVerse def initialize(number)  @number = number end def lyrics   #{@number} random things on the shelf. . .   endendclass SodaVerse def initialize(number)  @number = number end def lyrics   #{@number} bottles of soda pop. . .   endendHonor Demeter, Isolate Object Construction: Watch 1: Obeying the Law of Demeter Law of Demeter has something to do with lines of code that have more than one dot. The next piece of code seems inocent but has multiple dependencies  Whatever verse_template holds, will respond to new new accepts an argument and the thing returned by new responds to lirycsdef verse(number) verse_template. new(number). lyricsendEvery one of these things is a dependency, and a dependency is just something that you know about, that someone else is in charge of, so that if they changed it, you might have to change in turn. Dependencies are unavoidable, objects have to know about one another in order to get anything done but we‚Äôd like to have loose coupling between objects. We‚Äôd like to have every object have the fewest number of absolutely necessary dependencies so that we don‚Äôt end up having lots of distant and unrelated changes break our current code. The Law of Demeter says: ‚ÄúYou should not talk to your friends friends. ‚Äù Theline of code above contains a message chain where each message along the chain returns a ‚Äúdifferent kind of object‚Äù. Each of the returned objects conforms to a different API. That‚Äôs an important component of the Law of Demeter. If this message chain had returned a series of objects, all of which conform to the same API, this wouldn‚Äôt be a violation. If it was a bunch of Strings, or a bunch of Arrays, we don‚Äôt really care. What we‚Äôre concerned about is where, along the chain, every message that you send returns an object that‚Äôs different than the other ones. Here, is an example that violates Law of Demeter: class Foo def durability_of_preferred_toy_of_best_friends_pet  best_friend. pet. preferred_toy. durability endendAbove code Foo has to know that it has a best_friend, it has to know that best_friend has a pet, has to know that pet has a toys, and toy has durability. It might not seem so terrible when you look at the line of code, but think about the problem with testing this. Real objects have slow running operations, then your tests are going to be slow, unless you break in and stub them or stub in stubs or stub in stubbed stubs. When you see that you have to stub in stubs in order to test an object, it‚Äôs because you have violated the Law of Demeter. How can you fix this? Well, the time honored method for curing demeter violations is through message forwarding. And all that means is you go into each intermediate object and write a little helper method to basically remove that hop. class Toy def durability  1. hour endendclass Pet def durability_of_preferred_toy  preferred_toy. durability endendclass Friend def durability_of_preferred_toy_of_pet  pet. durability_of_preferred_toy endendclass Foo def durability_of_preferred_toy_of_best_friends_pet  best_friend. durability_of_preferred_toy_of_pet endendWith these changes Foo talk directly to its collaborators. And what that means is, if you want to stub out the behavior of Friend, you can do it by creating one stub. You don‚Äôt have to stub in stub in stub in stubs in your tests. So it no longer is related to that network of objects, it just have one dependency on one direct collaborator. There‚Äôs one more improvement we can implement, the method . durability_of_preferred_toy_of_pet and so we haven‚Äôt really freed ourselves from the structure of the object graph, the object dependency graph. We need to ask ‚ÄúWhat does Foo really want?‚Äù Messaging forwarding helped with testing but it doesn‚Äôt help with identifying concepts in your domain. Why does Foo want to know durability of a toy of its best friend pet? Imagine it‚Äôs because Foo is trying to arrange a play date, and it wants to know how long the pets can play before they tear up all their toys. class FriendWithPet def playdate_time_limit  pet. durability_of_preferred_toy endendclass FriendWithChild def playdate_time_limit  child. tolerance_of_social_contact endendclass Foo def playdate_time_limit  best_friend. playdate_time_limit endendSince we‚Äôre injecting some kind of a Friend object into Foo, they both work. They‚Äôre interchangeable from Foo‚Äôs point of view. Because we‚Äôre using dependency injection, and because we have identified what Foo wants, now we can collaborate with a whole universe of friends that have different constraints on playdate_time_limit. And that‚Äôs the value of fixing demeter violations. They force you to step back from the current structure of your code and to create messages that embody what the sending object wants. Watch 2: Identifying What the Verse Method Wants Now that we‚Äôve been introduced to Law of Demeter, it‚Äôs time to figure out what verse method wants. The rule about injecting dependencies is that you want to inject the thing that you plan to talk directly to, which suggests that in most cases you would inject an instance of a class. If testing is hard, it suggests that parts of your application are going to be difficult to reuse in other contexts. See below a proposal for sending . lyrics to the verse_template and extracting the . new from Bottle out to BottleVerse. class Bottle def verse(number)  # verse_template. new(number). lyrics  verse_template. lyrics endendclass BottleVerse def self. lyrics(number)  new(number). lyrics end attr_reader :number def initialize(number)  @number = number end def lyrics  bottle_number = BottleNumber. for(number)   #{bottle_number} of beer on the wall,  . capitalize +   #{bottle_number} of beer. \n  +   #{bottle_number. action},   +   #{bottle_number. successor} of beer on the wall. \n  endendWatch 3: Pushing Object Creation to the Edge The last issue we have with current code is the following:  it contains hardcoded reference to BottleNumber it has a blank line in it (it likely indicates a change of topic, failure of single responsability) the only thing that does to number is turning it into something elsedef lyrics bottle_number = BottleNumber. for(number)  #{bottle_number} of beer on the wall,  . capitalize +  #{bottle_number} of beer. \n  +  #{bottle_number. action},   +  #{bottle_number. successor} of beer on the wall. \n endWell-designed object-oriented applications consist of loosely-coupled objects that use polymorphism to vary behavior. Loose coupling happens with dependency injection; we choose and inject objects to have behavior. Polymorphism means that I can have a bunch of different kinds of objects that I inject that conform to the same API but provide different implementations. Once you define an API and start creating objects that play roles and injecting those objects to get variants, the whole world opens up where you can easily create new variants without changing existing code. A couple of rules to make code in the present more flexible to unknown change in the future.  I want to resist allowing methods to know the names of concrete classes. It‚Äôs a bad idea. Your code would be more flexible and changeable in the future if you didn‚Äôt do it. Always look for an opportunity to get those concrete constant names out of my methods. And that‚Äôs just a general rule that applies in every case.  The next rule, is always look for opportunities to separate the construction of objects from the use of those objectsPush the transformation of other data into objects that we‚Äôre using away from the code in the center of the app, and try to push it back up the stack into the earliest possible place I could change it. class BottleVerse def self. lyrics(number)  new(BottleNumber. for(number)). lyrics end atrr_reader :bottle_number def initialize(bottle_number)  @bottle_number = bottle_number end def lyrics   #{bottle_number} of beer on the wall,  . capitalize +   #{bottle_number} of beer. \n  +   #{bottle_number. action},   +   #{bottle_number. successor} of beer on the wall. \n  endendSandi‚Äôs summary of this chapter:  This block pulled the lyrics of the ‚Äú99 Bottles‚Äù song out of Bottles and put them into a new BottleVerse class. It then injected an instance of BottleVerse back into Bottles. Extracting BottleVerse reduced the Bottles‚Äôs responsibilities, making it easier to understand and maintain. Injecting BottleVerse into Bottles loosened the coupling between Bottles and the outside world. Bottles now thinks of itself as being injected with players of the verse template role and will happily collaborate with any newly arriving object as long as that object responds to lyrics(number).  The impetus behind extracting BottleVerse was a new requirement to produce songs with different lyrics, that is, to vary the verse. The recent refactorings satisfied that requirement by following a fundamental strategy of object-oriented design: extracting the BottleVerse class isolated the behavior that the new requirement needed to vary.  While continuing to lean on code smells and refactoring recipes, this block introduced the idea of a programming aesthetic. A programming aesthetic is the set of internal heuristics that guide your behavior in times of uncertainty. Vague feelings about the rightness of code become part of your aesthetic once you can eloquently and convincingly use actual words to explain your concerns and proposed improvements. A good programming aesthetic focuses attention on improvements that are likely to prove worthwhile.  This block suggested five precepts that belong in everyone‚Äôs object-oriented programming aesthetic:  Put domain behavior on instances.  Be averse to allowing instance methods to know the names of constants.  Seek to depend on injected abstractions rather than hard-coded concretions.  Push object creation to the edges, expecting objects to be created in one place and used in another.  Avoid Demeter violations, using the temptation to create them as a spur to search for deeper abstractions.  The practical effect of following these precepts is to loosen the coupling between objects. The code to which you would apply them generally already works so adherence might seem optional, and is certainly not free. Complying with these precepts will frequently increase the amount of code and add levels of indirection, at least in the short term. However, these added costs are overwhelmingly offset by the eventual savings accrued as a result of decoupling.  Any application that survives will change. The only thing of which you can be more confident is that you cannot predict where this change will occur. The certainty of change coupled with the uncertainty of that change‚Äôs location means that your best programming strategy is to strive to loosen the coupling of all code everywhere from the moment of initial creation.  Therefore, these precepts don‚Äôt attempt to guess the future; rather, they leverage against it. Instead of writing code that speculatively imagines a later need for one specific feature, they tell you to loosen the coupling of all code so that you can easily adapt to whatever future arrives.  Uncertainty about the future is not a license to guess; it‚Äôs a directive to decouple. Your future will be brighter if you develop a programming aesthetic that drives you to do so. Short quiz Define the Law of Demeter.  I know this can be awkward, but try your best. :-) You can talk to your friends, but not to their friends.  More technically, you should only send messages to your direct dependencies.  You should not reach across your dependencies to talk to their dependencies. If you violate Demeter by talking to your friends‚Äô friends, you tightly couple yourself to a network of objects.  This makes your application fragile, that is, your object might break because of an unexpected change to a distant and apparently unrelated thing. You can avoid Demeter violations by designing code based on what an object ‚Äúanswer??‚Äù rather than what other objects ‚Äúanswer??‚Äù.  wants, already do"
    }, {
    "id": 21,
    "url": "http://localhost:4000/2025/09/20/session-07.html",
    "title": "POOD Session 7: Manufacture Role Players & Alter Base Classes (Monkeypatching)",
    "body": "2025/09/20 - Session 7: Manufacture Role PlayersDate: September 20, 2025 This blog post consists in three parts:  My notes on Manufacture Role Players My notes on Alter Base Classes (Monkeypatching) Notes on Sandi‚Äôs talk Managing Dependencies (Go Ahead, Make a Mess)Key Concepts:  Manufacture Role Players: Watch 1: Contrasting the Concrete Factory with Shameless Green In this lesson, we covered how the new Factory differs from the old conditional structure we had. Sandi encouraged us to think about why the first conditional had 0, 1, 2, and  else  branches, while in the new Factory model, we only have 0, 1, and  else  branches. We don‚Äôt have a  2  branch because in the Shameless Green exercise, becuase some words needed to be transformed from plural to singular. Now, with the new Factory model, it takes care of this as a BottleNumber class. The key point of factories is selecting the required path and creating the corresponding instance, no behavior is involved. This contrasts with the first version, where after choosing the path, and behavior was supplied. This is something that factories should avoid doing. Watch 2: Fathoming Factories Polymorphism is the word we use to refer to that quality where many different objects can respond to the same message. Message senders don‚Äôt need to know the name of the class. They just need to know the name of the message, and so, the class effectively disappears. So Shock should be ignorant of the names of all these classes. It shouldn‚Äôt know the implementation details inside these classes. And it shouldn‚Äôt know how to pick which class is the right one for any certain circumstance. It‚Äôs the responsibility of a factory to manufacture the correct instance of a role playing object. The factory knows all those things that the Shock class doesn‚Äôt know. The factory knows all the names of the types, and it knows how to pick the right type for any specific circumstance. You can think of factories as the place in your application where conditionals go to die. Isolating conditionals in factories loosens the coupling between the objects in your application, and it lowers the cost of change. If you isolate the conditional in the factory and the names of the types in the factory, it means that it doesn‚Äôt matter to the Shock class, to the object wants to interact with a player of the cost role, that class doesn‚Äôt care if you add or remove new Shock types. The changes that need to be made to add or remove an object all happen in the factory, and the factory contains a very simple bit of code. Here is a visual example of how we passed from a convoluted Bycicle/Shock objects to a factory and roles. Working on a bicycle simulation. Each bicycle could have optional shocks, and those shocks involved a complex ‚Äúcost‚Äù calculation. As more shock types were added, the best approach was to extract them into their own classes. Each shock class implemented its own cost method, allowing all shocks to respond consistently to the same message. This design made it easy to add new shock types without breaking existing code. However, Sandi explained that an even better approach would be to introduce a factory, which is responsible only for knowing which shock to instantiate. The factory doesn‚Äôt need to know about the internal implementation of each shock, it just returns the correct one when requested.    Your browser does not support the video tag.  Sandi mentioned 3 types of factories:    Dimension  Options    Structure  Open or Closed    Choosing Logic Location  Factory owns the logic or Logic is dispersed in the objects being chosen    Type Knowledge  Factory knows all type names or Objects register themselves with the factory Watch 3: Opening the Factory In this lesson, we looked at how our current factory isn‚Äôt really open. The fact that we had to manually add BottleNumber6 shows that every time we need a new type, we‚Äôd have to edit the factory again. That‚Äôs fine if nothing ever changes, but it‚Äôs not very flexible. So the goal here is to make it open, to let new BottleNumber classes get created automatically just by following a naming convention. To do that, we use a bit of Ruby metaprogramming. The trick is const_get, a method that takes a string like  BottleNumber6  and turns it into the actual class. If the class exists, great ‚Äî we get it back. If it doesn‚Äôt, Ruby throws a NameError, which we can rescue and fall back to a default BottleNumber class. This makes the factory much more dynamic, since it no longer needs a big case statement to decide what to build. There was also a quick side trip into how garbage collection works in Ruby, which was actually super helpful. Basically, objects get cleaned up when nothing references them anymore, but class definitions don‚Äôt, they stick around forever because Ruby keeps them in a sort of ‚Äúbig hash in the sky. ‚Äù That‚Äôs why you need to be careful with class variables: anything stored there will live for the entire life of the program. So yeah, a bit of metaprogramming magic, a bit of memory awareness, and now our factory is officially open for business. class BottleNumber def self. for(number)  begin   const_get( BottleNumber#{number} )  rescue NameError   BottleNumber  end. new(number)  # case number  # when 0  #  BottleNumber0  # when 1  #  BottleNumber1  # else  #  BottleNumber  # end. new(number) endendIt‚Äôs not obvious what this code does, and that might be an issue for people. It‚Äôs a very valid. These metaprogramed classes, a big downside is you can‚Äôt find them anymore and someone can wipe them out since are not referenced anymore. You know, for every question in OO, the answer is always,  It depends , and here it depends. We‚Äôre just trying to save money. We wanna write the most cost effective code. Sometimes adding a little complexity will reduce overall cost. You have to be careful because we wanna be overly complex a lot of times, but if complexity will save you money, then it‚Äôs cheaper and you should do it. Watch 4: Supporting Arbitrary Class Names In this lesson, we explored the third way to make the factory open. This time, Sandi proposed using a Hash to support arbitrary class names, meaning the factory isn‚Äôt limited to BottleNumber anymore. The implementation is pretty straightforward, but even with this hash approach, it still feels a lot like the first version with the case statement. If you want to add a new class, you still have to edit the hash and add a new key-value pair. So technically, it‚Äôs not fully open yet, but it does separate data from logic in a cleaner way. The case statement version is definitely easier to read since it‚Äôs just a simple list of conditions. But the advantage of the hash approach is that the data driving the program now lives separately, and that opens the door to storing it somewhere else, like in a YAML file or a database. One cool side note from this section was how Sandi pointed out that your syntax highlighter can give you hints about your code‚Äôs design. Fewer color changes usually mean simpler, more object-oriented code ‚Äî bigger chunks of the same abstraction. In contrast, when you see lots of color changes, that‚Äôs often procedural code with many shifting ideas packed together. class BottleNumber def self. for(number)  Hash. new(BottleNumber). merge(   0 =&gt; BottleNumber0,   1 =&gt; BottleNumber1,   6 =&gt; BottleNumber6)[BottleNumber]. new(BottleNumber) endendWatch 5: Dispersing the Choosing Logic After the three types of factories we saw case statements, metaprogramming, hash all of them knew everything about the BottleNumber which is the value of the number, the class names that might be chosen, and how to map which class was needed. Having the factory know all these things makes sense, especially if the choosing logic is really simple like we have here, where we‚Äôre just testing for simple equality. If the logic necessary to choose changes in lockstep with the code in the class being chosen, you want to co-locate those things, you would like the choosing logic to be somehow over in that class. You could take the choosing logic and disperse it into each class that might be chosen, and have the factory iterate over those classes and ask each of them if they‚Äôre the one. class BottleNumber def self. for(number)  [BottleNumber6, BottleNumber1, BottleNumber0, BottleNumber].    find { |candidate| candidate. handles?(number) }. new(number) end. . . class BottleNumber0 &lt; BottleNumber def self. handles?(number)  number == 0 end. . . class BottleNumber1 &lt; BottleNumber def self. handles?(number)  number == 1 end. . . class BottleNumber6 &lt; BottleNumber def self. handles?(number)  number == 6 end. . . The biggest thing we did, is we took the logic the choosing logic (qithin factory) that was more closely related to the objects being chosen than to the factory and we dispersed that out into each of the objects, had the factory iterate over that list of objects and ask each one if they were the one. Watch 6: Self-registering Candidates In the last lesson we extracted the logic from the BottleNumber#self. for to its own classes, then we iterate over each of the options and sent self. handles?(number) but the factory is still closed (hard-coded). We have two options:    You can get the factory to go, somehow, out in your application and figure out what classes are candidates,     or you can do the opposite, you can have each of the candidate classes tell the factory that they want to be on the factory‚Äôs list.  We started with option #2 since it‚Äôs possible: class BottleNumber def self. for(number)  registry. find { |candidate| candidate. handles?(number) }. new(number) end def self. registry  @registry ||= [] end def self. register(candidate)  registry. prepend(candidate) end. . .  BottleNumber. registry(self). . . class BottleNumber0 &lt; BottleNumber BottleNumber. registry(self). . . class BottleNumber1 &lt; BottleNumber BottleNumber. registry(self). . . class BottleNumber6 &lt; BottleNumber BottleNumber. registry(self). . . This factory is now open for extension, and the choosing logic has been dispersed back into the classes that got chosen. That means the factory can manufacture instances of classes whose types it doesn‚Äôt know, for reasons that it‚Äôs unaware. Here is another proposal: class BottleNumber def self. for(number)  registry. find { |candidate| candidate. handles?(number) }. new(number) end def self. registry  @@registry ||= [] end. . . class BottleNumber6 &lt; BottleNumber register(self) # BottleNumber. registry(self). . . Above, Sandi compares two nearly identical lines of code, one that calls register directly and another that explicitly references BottleNumber. register. At first glance, the version without the class name might seem cleaner or less dependent, but in reality, both have the same number of dependencies: one depends on inheritance (the implicit self), and the other depends on knowing the factory‚Äôs class name. The key idea is to choose the more stable dependency. Since inheritance structures are more likely to change over time than the name of a class, it‚Äôs usually safer to depend on the class name directly. That makes the code clearer, more flexible, and easier for future developers to understand. Code that depends on inheritance, that gives me a couple of vulnerabilities. Change is inevitable, and every design decision you make is basically a bet on the future. Some bets will save you time and money later, while others will cost you. The key is to stay aware that you‚Äôre always guessing and to pay attention to how those guesses turn out over time. That‚Äôs how you develop better instincts as a programmer. Sandi emphasizes that she avoids betting on inheritance, not because she dislikes it, but because experience has shown her it‚Äôs less stable than other dependencies. The takeaway is to be deliberate about what you depend on. Watch 7: Auto-registering Candidates This time, instead of having candidates (BottleNumber) registering themselves, we‚Äôre going to have the factory who should be candiadtes, and do the register for them. We‚Äôve already seen an example of this idea back in the first section, where we made an open factory using const_get. All of the class names followed a convention BottleNumber#. Now, we can add a method in common to all classes or have the calsses to be 24-characters-long anything that can make them unique. In this case all classes BottleNumber# inherit from BottleNumber and we are now going to leverage the ‚Äú&lt;‚Äù operator to create a subclass in Ruby (e. g. , class BottleNumber6 &lt; BottleNumber), Ruby automatically calls the inherited() method on the superclass, passing the new subclass as an argument. By overriding this hook, we can automatically register each subclass in our factory without manual registration calls. This only works if you‚Äôre committed to using inheritance. class BottleNumber def self. for(number)  registry. find { |candidate| candidate. handles?(number) }. new(number) end def self. registry  @registry ||= [BottleNumber] end def self. register(candidate)  registry. prepend(candidate) end def self. inhereted(candidate)  register(candidate) end. . .  BottleNumber. registry(self). . . class BottleNumber0 &lt; BottleNumber # BottleNumber. registry(self). . . class BottleNumber1 &lt; BottleNumber # BottleNumber. registry(self). . . class BottleNumber6 &lt; BottleNumber # BottleNumber. registry(self). . . This is one of those situations we‚Äôre placing bets on dependencies. It‚Äôs possible that some later change will come and we will wish we‚Äôd done this one way or another. Just pay attention to how it turns out. Maybe you‚Äôll learn something that‚Äôll help you make better guesses in the future. Alter Base Classes (Monkeypatching): In this lesson we examinated the pros and cons of monkeypatching This line of code has three dependencies. What are they? Well, one, you know the name of the class, the BottleNumber class. Two, you know the name of a message that you can send to that class, the for message. And three, you know the number, you know the value of a number. That‚Äôs three dependencies. Can we accomplish the task here in two dependencies instead of three? class BottleNumber0 &lt; BottleNumber def successor  BottleNumber. for(99) endendThese questions may help you decide what and how reduce dependencies.  Is the value of the number optional? Do you unconditionally need to know the value of the number?Yes, because that‚Äôs the thing that you‚Äôre turning into a BottleNumber. class Integer def to_bottle_number  BottleNumber. for(self) endendclass BottleNumber0 &lt; BottleNumber def successor  99. to_bottle_number end. . . class BottleNumber1 &lt; BottleNumber def successor  1. to_bottle_number end. . . class BottleNumber def successor  (number - 1). to_bottle_number end. . . Here is another approach to monkeypatch the Integer class with module. module ToButtleNumber refine Integer do  def to_bottle_number   BottleNumber. for(self)  end endend# add the keyword  using using ToButtleNumberclass BottleNumber0 &lt; BottleNumber def successor  99. to_bottle_number end. . . class BottleNumber1 &lt; BottleNumber def successor  1. to_bottle_number end. . . class BottleNumber def successor  (number - 1). to_bottle_number end. . . Third and last proposal for reducing the dependencies: def BottleNumber(number) return number if number. kind_of?(BottleNumber) BottleNumber. for(number)endWhat we‚Äôre really working with here is conversion functions. That‚Äôs the sweet spot for these kinds of refinements. # CamelCasedef BottleNumber(number) return number if number. kind_of?(BottleNumber) BottleNumber. for(number)endclass BottleNumber0 &lt; BottleNumber def successor  BottleNumber(99) end. . . class BottleNumber1 &lt; BottleNumber def successor  BottleNumber(1) end. . . class BottleNumber def successor  BottleNumber(number - 1) end. . . Don‚Äôt alter the behavior of the standard library, never, ever, under any circumstances whatsoever. Methods like to_bottle_number that are so unique to the problem that you‚Äôre working on that it feels really unlikely that going to get a conflict with some more general gem. Sandi‚Äôs summary:  Maintainable OO code rests on polymorphism, on constructing applications from families of small, interchangeable objects that represent variants of a role. Instead of writing classes that contain a bunch of conditionals that choose behavior, polymorphism asks you to disperse variants of behavior into classes of their own.  Placing variants into separate classes eliminates the need for conditionals inside those classes, but it does not completely eliminate the need for conditionals; it just kicks the proverbial conditional can down the road (or back in the stack). In every situation where a role-playing object is needed, some code, somewhere has to know enough to pick the right one.  Enter factories.  Factories are where conditionals go to die. They contain conditionals that select classes, and they isolate those conditionals in a single, easily-tested place. They hide the names of role-playing classes and so allow the rest of your application to depend on the API of a role rather than on the concrete names of whatever classes currently exist.  This block explored the various forms a factory might take, and considered the trade-offs involved. No factory, whether open or closed, whether it owns the choosing logic or asks candidates if they should be chosen, or whether it reaches out for registrants or accept volunteers, is perfect for every situation. All factories, however, enable polymorphism and thus improve your code. Managing Dependencies:    You made changes as requested, then you are told they meant a different thing, so you hacked it and got it back to original state, then they asked another changes, and you create/delete files and you end up hating rails, ruby!     In the beginning the app felt so great, you got so much done, you were very effective. We feel happy when we are doing our best work.     You were cost-effective, now you‚Äôre a money pit.     You gotta need to understand the mess     Things are so woven together that you cannot pull a single thread without breaking many things.     This mess is made up of knowledge. Your app is full of objects and those objects know a lot about themselves and about others.     And it‚Äôs knowledge of others that weaves objects together.     When an object knows something about the other, that is a dependency.     When something you depend on changes, you might be forced yo change in turn.     You cannot avoid dependencies. Objects collaborate, they always know things about one another.     There are many ways to arrange code to solve any problem. And easily arrange dependencies that turn things badly.     Controlling dependencies needs understanding of the stability of the various bits of knowledge of your app.     It doesn‚Äôt matter how stable it‚Äôs as long as it‚Äôs more stable than the things the object depend upon.     Write code that you future self would love     OOP helps you:   Label the knowledge Complicat the code (refactorring)   Isolate the inestability     Concrete code is easy to understand, costly to change.     Abstract code is harder to understand when you first look at it but it‚Äôs much cheaper to change.     OO principles push your code to more abstractions, it‚Äôs not that there‚Äôs not cost involved but the benefits outweigh the costs.     If messy code cost you nothing, you can walk away and leave it as it‚Äôs.     Preference, I‚Äôd rather send a message than implement behavior and know things of other object.   Instead of asking ‚ÄúWhere should i put this code?‚Äù you should ask ‚ÄúWhat message should i send?‚ÄùIn the following link you‚Äôll find 50 flashcards and a 10 questions-quiz based on Sandi‚Äôs video ‚ÄúGo ahead, make a mess (dependencies)‚Äù It‚Äôs a Google NotebookLM link to exerciseWatch: Appreciating the Mechanical Process "
    }, {
    "id": 22,
    "url": "http://localhost:4000/2025/09/13/session-06.html",
    "title": "POOD Session 6: Polymorphism, Remedy Liskov & Make the Easy Change",
    "body": "2025/09/13 - Session 6: Get to Know Polymorphism, Remedy Liskov Violations &amp; Make the Easy ChangeDate: September 13, 2025 This blog post consists in three parts:  My notes on Polymorphism My notes on Remedy Liskov Violations My notes on Make the Easy ChangeKey Concepts:  Get to know Polymorphism: Watch 1: Making Sense of Conditionals This block contains two videos. One delves into conditionals and the other explores object-oriented polymorphism. We still have not the code to be Open. Here, we are going to pick another code smell. The most repeated pattern are the conditional, with 2 branches and all checking number == 1 or number == 0. The problem with repeating conditionals is evident. How many methods would you have to change to fulfill the six-pack requirement? You have to touch a bunch of places in here because the six-pack-ness is spread out over a number of these conditionals. These conditionals provide us with generalizations in the false branches and specializations in the true branches. If we had mixed up our styles of code, it would have been much more difficult to tell here what we needed to do next. Consistency of style enables future refactorings and enhances understanding. Examples of bad usage of inheritance: # BAD: Deep/Wide Inheritance Hierarchyclass Employee; endclass FullTimeEmployee &lt; Employee; endclass PartTimeEmployee &lt; Employee; endclass ContractEmployee &lt; Employee; endclass SeniorFullTimeEmployee &lt; FullTimeEmployee; endclass JuniorFullTimeEmployee &lt; FullTimeEmployee; end# . . . gets messy and hard to understand# BAD: Tiny Specializations Leading to Cross-Cutting Problemsclass Employee def swag_amount  100 end  def tax_rate  0. 20 endendclass LongTermEmployee &lt; Employee def swag_amount  super * 2 # specializes only swag endendclass OutOfStateEmployee &lt; Employee def tax_rate  0. 15 # specializes only taxes endend# Problem: Need LongTermOutOfStateEmployee? Can't inherit from both!# GOOD: Use Composition for Cross-Cutting Concernsclass Employee def initialize(swag_policy:, tax_policy:)  @swag_policy = swag_policy  @tax_policy = tax_policy end  def swag_amount  @swag_policy. calculate end  def tax_rate  @tax_policy. rate endendclass StandardSwagPolicy def calculate  100 endendclass LongTermSwagPolicy def calculate  200 endendclass InStateTaxPolicy def rate  0. 20 endendclass OutOfStateTaxPolicy def rate  0. 15 endend# Now you can mix and match any combination:Employee. new( swag_policy: LongTermSwagPolicy. new, tax_policy: OutOfStateTaxPolicy. new)# ACCEPTABLE: Inheritance for Leaf Nodes (Small, Focused Classes)class BottleNumber def container   bottles  endendclass BottleNumber1 &lt; BottleNumber def container   bottle  # specializes most of the small class endendclass BottleNumber0 &lt; BottleNumber def quantity   no more  # specializes most of the small class endendWatch 2: Replacing Conditionals with Polymorphism ‚ÄúPoly‚Äù means many, ‚Äúmorph‚Äù in this case means form. Many forms. We use polymorphism to describe a situation in which many different objects can respond to the same message. This means that the message sender doesn‚Äôt know or care the type of the object that it gets passed, and it means that later you can create new objects that polymorphously play some existing role and get that behavior into your app without having to change anything about those objects that are sending the messages. Let‚Äôs implement a Factory object model that evaluates and creates depending on the request, different new objects, these new objects will inherit from a general BottleNumber and will contain specializations. This will reduce the conditionals we have into several new small classes. This change is like primitive obsession but instead of obsessing upon the entire class, we actually obsess on instances of the class (0 and 1). class Bottles def song  verses(99, 0) end def verses(upper, lower)  upper. downto(lower). map { |i| verse(i) }. join( \n ) end def verse(number)  bottle_number = bottle_number_for(number)  next_bottle_number = bottle_number_for(bottle_number. successor)   #{bottle_number} of beer on the wall,  . capitalize +   #{bottle_number} of beer. \n  +   #{bottle_number. action},   +   #{next_bottle_number} of beer on the wall. \n  end # Factory def bottle_number_for(number)  case number  when 0   BottleNumber0  when 1   BottleNumber1  else   BottleNumber  end. new(number) endendclass BottleNumber attr_reader :number def initialize(number)  @number = number end def to_s   #{quantity} #{container}  end def quantity  number. to_s end def container    bottles  end def action   Take #{pronoun} down and pass it around  end def pronoun   one  end def successor  number - 1 endendclass BottleNumber0 &lt; BottleNumber def quantity   no more  end def action   Go to the store and buy some more  end def successor  99 endendclass BottleNumber1 &lt; BottleNumber def container   bottle  end def pronoun   it  endendQuiz:  This refactoring is super easy, yet it greatly increases the abstraction of the code. List some qualities of the current code that make this refactoring so easy. All of the following are true:  The tests run quickly.  The code has a consistent style.  The methods have a single responsibility.  The conditionals test for equality.  Imagine the code you would have written to solve the 99 bottles problem before you knew about Shameless Green or read the 99 Bottles of OOP book. (You may actually have made a stab at solving the problem before starting the course‚Äìthat‚Äôs the code I‚Äôm asking about here. )Would it have been equally easy to refactor that code into this state? If not, what qualities of the code would have made the refactoring difficult? It‚Äôs common for that first attempt to have the following qualities:  The abstractions are incorrect or incomplete.  The code and the conditionals have an inconsistent style.  Methods have more than one responsibility. Remedy Liskov Violations: Watch 1: Transitioning Between Types Here, we are tackling the Liskov violation that . succesor represents, remember it should return BottleNumber not a number. We named the factory  self. for . The name  . for  implies that it takes an argument, but in my experience factories always do. The job of a factory is to pick an object, and it needs some thing to pick on. class Bottles def song  verses(99, 0) end def verses(upper, lower)  upper. downto(lower). map { |i| verse(i) }. join( \n ) end def verse(number)  bottle_number = BottleNumber. for(number)   #{bottle_number} of beer on the wall,  . capitalize +   #{bottle_number} of beer. \n  +   #{bottle_number. action},   +   #{bottle_number. successor} of beer on the wall. \n  endendclass BottleNumber attr_reader :number def initialize(number)  @number = number end def self. for(number)  case number  when 0   BottleNumber0  when 1   BottleNumber1  else   BottleNumber  end. new(number) end def to_s   #{quantity} #{container}  end def quantity  number. to_s end def container   bottles  end def action   Take #{pronoun} down and pass it around  end def pronoun   one  end def successor  BottleNumber. for(number - 1) endendclass BottleNumber0 &lt; BottleNumber def quantity   no more  end def action   Go to the store and buy some more  end def successor  BottleNumber. for(99) endendclass BottleNumber1 &lt; BottleNumber def container   bottle  end def pronoun   it  endendQuiz  What is the official definition of the Liskov Substitution Principle?  ‚ÄúFunctions that use pointers to base classes must be able to use objects of derived classes without knowing it. ‚ÄùOr more generally‚Ä¶  ‚ÄúObjects of a superclass shall be replaceable with objects of its subclasses without breaking the application‚Äù If ‚Äòofficial‚Äô Liskov has to do with inheritance, how can whatever‚Äôs wrong with the #successor methods be a Liskov violation? Write a new Liskov Substitution Principle definition that extends it to cover both problems.    The Liskov Substitution Principle can be expanded to include not only subtypes but also any other object that is meant to be interchangeable with current one. Liskov requires that methods return the objects that they ‚Äúpromise‚Äù to return.     In our case the very name of the #successor method implies that it returns something that acts like a BottleNumber, that is, that it returns an object that conforms to the API of the receiver. Returning a number instead of a BottleNumber forces that caller to check the returned object‚Äôs type in order to know how to talk to it.  This is a Liskov violation.  Make the Easy Change: Watch 1: Making the Easy Change In this lesson we discovered that the code is now open to the six-pack requirement. A quick recap of what we‚Äôve done so far:    We started out by writing the Shameless Green implementation of 99 Bottles.     then we got a new requirement to say 1 six-pack instead of 6 bottles.     We decided to make this code open to change (we didn‚Äôt really know how to do that)     Therefore we used that flow chart that suggested that we find code smells (they are 24).      We identifed code smells, and then we picked the code smell that we thought, if we corrected it (duplicate code).     We had to isolate the things we want to vary.     The first code smell that we worked on was all that duplication in the verse method; we decided it contained concealed concepts, and we used the flocking rules to identify those concepts, to give those concepts names.     Selecting the most similar pieces of code     Finding the smallest difference between them     Making the simplest change to remove that difference     After that, we decided that all the methods that we‚Äôd created using the flocking rules were obsessing upon a primitive.     We extracted the BottleNumber class in order to cure that obsession.     Finally, we noticed that we had repeating conditionals in that BottleNumber class, and we cured those conditionals by following the Replace Conditional with Polymorphism recipe and making a little inheritance hierarchy of different players of the BottleNumber role.  For implementing the six-pack we switched to TDD so the first thing to do is writing a failing test. We changed in bottles_test. rb the following, notice the ‚Äú1 six-pack‚Äù 7 bottles of beer on the wall, 7 bottles of beer. Take one down and pass it around, 1 six-pack of beer on the wall. 1 six-pack of beer on the wall, 1 six-pack of beer. Take one down and pass it around, 5 bottles of beer on the wall. Then ran tests and failed: 7 bottles of beer on the wall, 7 bottles of beer. -Take one down and pass it around, 1 six-pack of beer on the wall. +Take one down and pass it around, 6 bottles of beer on the wall. -1 six-pack of beer on the wall, 1 six-pack of beer. +6 bottles of beer on the wall, 6 bottles of beer. Take one down and pass it around, 5 bottles of beer on the wall. Then we added a new class of specialization BottleNumber6 with two methods #quantity and #container and don‚Äôt forget about the Factory, we gotta add one case branch. class BottleNumber attr_reader :number def initialize(number)  @number = number end def self. for(number)  case number  when 0   BottleNumber0  when 1   BottleNumber1  when 6   BottleNumber6  else   BottleNumber  end. new(number) end. . . class BottleNumber6 &lt; BottleNumber def quantity   1  end def container   six-pack  endend‚ÄúMake the change easy, (warning, this might be hard), then make the easy change. ‚Äù, and that‚Äôs exactly the experience that we had. We‚Äôve spent chapters making the code open, but once it was open, the change was easy. If you learn the code smells and you get familiar with even just the names of the refactorings, you can identify code smells and look up the refactoring recipes when you want to use them. It‚Äôll make your code better and your life easier. Watch 2: Defending the Domain It‚Äôs true that the number of bugs in code is related to the volume of code, the more code you write, the more bugs you‚Äôll have, so it‚Äôs better to minimize the amount of code you have. However, it‚Äôs not a good idea to reduce it beyond the logical point. It‚Äôs only a good idea to reduce it if it‚Äôs correct. The original class, Bottles, can know about BottleNumber. It has to know about how to get them but once we extract those BottleNumber# classes we have to turn our back on Bottles. Bottles can know about the things that it‚Äôs gonna contain, BottleNumber can‚Äôt know about the objects that will contain it. The relationship can‚Äôt be bidirectional. It‚Äôd mean you can never use them in another context The above ideas were to stand your domain on the next proposal: class BottleNumber6 &lt; BottleNumber def quantity   1  end def container   six-pack  endend# VSclass BottleNumber6 &lt; BottleNumber def to_s   #{quantity} #{container}  endendSandi‚Äôs summary  The purpose of this block was to produce a code arrangement that was open to the six-pack requirement. Not only did it succeed in fulfilling that requirement, but along the way it also resolved a number of other issues.  This block explored the Data Clump code smell. It replaced a Switch Statement with a set of polymorphic objects, which it created using a factory. It corrected the Liskov violation in successor, and used that problem as a jumping-off point for a more general lesson about how to change the return types of polymorphic methods.  The BottleNumber for factory was straightforward and most certainly did the job. While simple factories like this work great in many situations, they‚Äôre not best for every case. There‚Äôs a whole world of different styles of factories waiting to be explored. "
    }, {
    "id": 23,
    "url": "http://localhost:4000/2025/09/06/session-05.html",
    "title": "POOD Session 5: Decipher Caching and Immutability",
    "body": "2025/09/06 - Session 5: Decipher Caching and Immutability, Cache BottleNumbers &amp; Recognize Data ClumpsDate: September 06, 2025 This blog post consists in three parts:  My notes on Decipher Caching and Immutability My notes on Cache BottleNumbers My notes on Recognize Data ClumpsKey Concepts:  Immutability vs mutation in object-oriented programming Cache invalidation and the 80/20 rule Liskov Substitution Principle violations Data Clumps code smell Modeling business logic as separate objectsDecipher Caching and Immutability: Watch 1: Appreciating Immutability To mutate is to change. State is the particular conditional of something at certain point in time. and a variable is a thing that varies. In the real world, things change state, or they vary, over time. And it makes perfect sense that in computer programming we would choose the term variable for that thing that holds state, that changes over time. This choice reflects our expectation, that all things vary.  It‚Äôs common in OO to change the state of objects; we send a message and pass a bit of data, and then you hold on to that new bit of data. But it‚Äôs possible, as the functional folks will gladly tell you, to write code where most objects would never have to change state. Instead of mutating an object, if it needed to vary state, you could just create a new object on that new piece of state. What this means is if you had a coffee cup and you drank all the coffee, instead of refilling the cup, you would just get a new cup with more coffee in it. Instead of noting that the continents had moved because of plate tectonics, you would get entirely new continents, even if they‚Äôd only moved a matter of millimeters. What might the benefits of immutable objects be? Well, they‚Äôre easy to understand. You‚Äôre never in a situation where someone else is holding a pointer to an object that you‚Äôre also holding onto, and that object somehow changes state underneath you. What you see is always what you get. Immutable objects are easy to reason about. If you have mutable objects, where state is changing, often you need collaborators in the tests that you‚Äôre creating. So you have to spin up these other objects in order to get state to change in the object that‚Äôs under test. But for immutable objects, you would just create a new object on a different piece of state. So there are many good reasons to love immutable objects. And the question is why don‚Äôt we use them more?    The first is just habit, when you learned OO, or any example that you look at using OO, very often mutates objects.     The second reason I think is an unquestioned assumption that many people make that object creation will be expensive and that it‚Äôs better to mutate an existing object rather than create a new one.  Watch 2: Assuming Fast Enough In the previous section made the case for immutability. And it‚Äôs a good thing. We often don‚Äôt do it though, and it‚Äôs mostly for two reasons. One: habit, we‚Äôre not in the habit of thinking about creating immutable objects. But two, a bigger issue, is even if we want to create immutable objects, very often, we imagine that it will be too expensive to create new objects. A person named Phil Karlton famously said:  There are only two hard problems in Computer Science:    naming and  cache invalidation.  Cache is local copy of something. A temporary variable, when you declare a variable and say equal some operation, you‚Äôve created a cache. Also, known as memoization. Why would you cache? Sometimes we cache to give a name to the result of an intermediate operation, to add clarity to the code. The other reason we may cache is to preserve the result of a costly long running operation. And so now we have a problem. If you save the result of a long running operation, how will you know when your cache gets dirty? (different result and you‚Äôre holding on to a previous cache copy) The code to figure out that your cache is dirty is cache invalidation. There‚Äôs a thing called the 80/20 rule, which says that 80%, or 90% or 95%, of an application‚Äôs work occurs in 20% of its code. (Most of the code don‚Äôt run pretty much) Don‚Äôt add complexity based on guesses. Write the simplest possible code, and then, and only then, if you find that parts of your app are too slow, (if someone complains) then profile your code to identify the slow parts and then work on them to make them faster. A profiler is a tool that watches your code as it runs and measures how much time you spend in certain operations. Your initial solution should avoid mutation. You should treat object creation as free and you should also avoid caching, just rerun operations and use the results. If you find that parts of your app are too slow and you profile it, you might find that you‚Äôd be better off to break some of your objects into smaller parts. If you have parts that you need to mutate, or if you have parts that you need cache and invalidate, it‚Äôs nice to minimize the size of those parts. If you can create objects for the ideas of your business and have those objects hold on to the bags of state, you end up in a situation where it‚Äôs easy to test your business logic and you‚Äôre decoupled from the database. Example of objects as buisness ideas: # DON'T: Business logic coupled to database/stateclass Order def initialize(id)  @id = id end def apply_discount  record = Database. find(@id)  if record. total &gt; 100   record. discount = record. total * 0. 10   record. save  end endend# DO: Extract business logic into separate objectsclass DiscountCalculator def initialize(total)  @total = total end def calculate  @total &gt; 100 ? @total * 0. 10 : 0 endendclass Order def apply_discount  record = Database. find(@id)  discount = DiscountCalculator. new(record. total). calculate  record. discount = discount  record. save endend# Now DiscountCalculator is easy to test without database:# DiscountCalculator. new(150). calculate =&gt; 15. 0Cache BottleNumbers: Here we applied the lessons from prior block to reduce the number of new BottleNumbers and simplify the code. Watch 1: Creating BottleNumbers With current code, how many instances of BottleNumber get created over the course of the song? It happens every time verse calls one of these methods, and that happens nine times in verse, that means we‚Äôre creating 900 BottleNumbers. Too many? As we said before, only if this code is too slow. Caching these values is very complicated. The next trial will reduce the number of BottleNumber: class Bottles def song  verses(99, 0) end def verses(upper, lower)  upper. downto(lower). map { |i| verse(i) }. join( \n ) end def verse(number)  bottle_number = BottleNumber. new(number)   #{bottle_number. quantity. capitalize} #{bottle_number. container} of beer on the wall,   +   #{bottle_number. quantity} #{bottle_number. container} of beer. \n  +   #{bottle_number. action},   +   #{quantity(successor(number))} #{container(successor(number))} of beer on the wall. \n  end def quantity(number)  BottleNumber. new(number). quantity end def container(number)  BottleNumber. new(number). container end def action(number)  BottleNumber. new(number). action end def successor(number)  BottleNumber. new(number). successor endendWatch 2: Recognizing Liskov Violations In last session we created bottle_number within verse and that reduced the BottleNumber from 900 to 200 creation. We left the 4 phrase with no implementation of this new cache since it requires a different number. We need the succersor number. Adding next_bottle_number implies that you‚Äôre going to get another BottleNumber back, and yet here you don‚Äôt. I‚Äôm going to call this yet another violation of that generalized Liskov Substitution Principle. The method makes a promise that you are going to get back a BottleNumber but instead you get a number. Why? Because back in the shameless green lesson it was useful and seemed like a good idea. We didn‚Äôt even have BottleNumber. We should have changed successor so that it would return instances of BottleNumber rather than instances of a number. Notice that the refactoring recipes, even though they guided us all along the way, they don‚Äôt really help with this problem. You have to be able to look at the names of things and understand that you need to make an additional change in the successor method; because you‚Äôve changed type, successor needs to return the new type. class Bottles def song  verses(99, 0) end def verses(upper, lower)  upper. downto(lower). map { |i| verse(i) }. join( \n ) end def verse(number)  bottle_number = BottleNumber. new(number)  next_bottle_number = BottleNumber. new(bottle_number. successor)   #{bottle_number. quantity. capitalize} #{bottle_number. container} of beer on the wall,   +   #{bottle_number. quantity} #{bottle_number. container} of beer. \n  +   #{bottle_number. action},   +   #{next_bottle_number. quantity} #{next_bottle_number. container} of beer on the wall. \n  endendclass BottleNumber attr_reader :number def initialize(number)  @number = number end def quantity  if number == 0    no more   else   number. to_s  end end def container  if number == 1    bottle   else    bottles   end end def action  if number == 0    Go to the store and buy some more   else    Take #{pronoun} down and pass it around   end end def pronoun  if number == 1    it   else    one   end end def successor  if number == 0   99  else   number - 1  end endendSandi‚Äôs recap until this lesson:  This block continued the quest to make Bottles open to the six-pack requirement. It recognized that many methods in Bottles obsessed on number, and undertook the Extract Class refactoring to cure this obsession. The refactoring created a new class named BottleNumber.  During the course of the refactoring, conditionals were examined from an experienced OO practitioners‚Äô point of view. This block also explored the rewards of modeling abstractions, the trade-offs of caching, the advantages of immutability, and the benefits of deferring performance tuning.  Most programmers are happier with the current code than they were with Shameless Green, but this version is far from perfect. The total Flog score, for example, has gone up again. From Flog‚Äôs point of view, after turning one conditional into many back in previous lessons, you‚Äôve now compounded your sins by introducing a new class which adds no new behavior but increases the length of the code.  Also, there are no unit tests for BottleNumber. It relies entirely on Bottle ‚Äòs tests. The code still exudes many smells (duplication, conditionals, and temporary field, to name a few). And, finally, it commits a Liskov violation in the successor method.  Recent refactorings were undertaken in hopes of making the code open to the six-pack requirement, but this has not yet succeeded. You‚Äôve been acting in faith that removing code smells would eventually lead to openness. It‚Äôs possible that your faith is being tested.  Despite the imperfections listed above, there are ways in which the code is better. There are now two classes, but each has focused responsibilities. While it‚Äôs true that the whole is bigger, each part is easy to understand and reason about.  The code is consistent and regular, and embodies an extremely stable landing point that splendidly enables the next refactoring. Quiz for these Liskov, primitive obsession cure session:  Why do the current #successor methods violate the Liskov Substitution Principle?They make a promise that they do not keep. They return an unexpected type, forcing the receiver to know too many things (have too many dependencies).  How many instances of the BottleNumber class are being created before this refactoring? And how many after?900 before, 200 after.  OO works out better if you write code that can treat object creation as . . . FREE Recognize Data Clumps: Watch 1: Consolidating Data Clumps What‚Äôs a Data Clump? Martin Fowler defines it as three or four things that always seem to come together, either passed as perimeters or used as a group. Examples: Imagine you had a reporting system where many methods took a starting and an ending date. start_date and end_date are always passed together and share behaviors (validation, formatting, comparison). class DateRange attr_reader :start_date, :end_date def initialize(start_date, end_date)  @start_date, @end_date = start_date, end_date  validate end def validate  raise  Invalid range  if start_date &gt; end_date end def duration  (end_date - start_date). to_i endendInstead of passing two arguments everywhere: Report. new(start_date, end_date)you pass a single cohesive object: Report. new(DateRange. new(start_date, end_date))Sandi Metz outlines an implicit 4-step reasoning process in this section:  Identify Repeating Pairs or GroupsLook for two or more values that ‚Äúalways travel together‚Äù passed as arguments or used side by side (quantity + container, start_date + end_date, x + y).  Recognize Shared BehaviorAsk: ‚ÄúDo other parts of the app perform similar checks or operations on these values?‚Äù Example: validating a date range, computing coordinates, or pluralizing bottles.  Corral the Clump into an ObjectCreate a class that encapsulates both the data and the behavior related to it. This lets scattered logic ‚Äúcoalesce‚Äù into one place.  Simplify the Calling CodeReplace multiple arguments with a single object. This reduces duplication and increases consistency, your app now speaks in terms of meaningful concepts (DateRange, Point, BottleNumber) instead of raw primitives. This refactor simplified the verse, reduced duplication, and made the method cleaner: class Bottles def song  verses(99, 0) end def verses(upper, lower)  upper. downto(lower). map { |i| verse(i) }. join( \n ) end def verse(number)  bottle_number = BottleNumber. new(number)  next_bottle_number = BottleNumber. new(bottle_number. successor)   #{bottle_number} of beer on the wall,  . capitalize +   #{bottle_number} of beer. \n  +   #{bottle_number. action},   +   #{next_bottle_number} of beer on the wall. \n  endendclass BottleNumber attr_reader :number def initialize(number)  @number = number end def to_s   #{quantity} #{container}  end def quantity  if number == 0    no more   else   number. to_s  end end def container  if number == 1    bottle   else    bottles   end end def action  if number == 0    Go to the store and buy some more   else    Take #{pronoun} down and pass it around   end end def pronoun  if number == 1    it   else    one   end end def successor  if number == 0   99  else   number - 1  end endend"
    }, {
    "id": 24,
    "url": "http://localhost:4000/2025/08/30/session-04.html",
    "title": "POOD Session 4: Cure Primitive Obsession with Extract Class",
    "body": "2025/08/30 - Session 4: Cure Primitive Obsession with Extract ClassDate: August 30, 2025 This blog post consists in one part:  My notes on Cure Primitive ObsessionKey Concepts:  Primitive obsession Extract Class refactoring pattern Naming classes after what they are vs. what they do Modeling abstract concepts as objectsCure Primitive Obsession with Extract Class: Watch 1: Selecting the Target Code Smell In this lesson we have more code, more abstraction which means more levels of indirection. It‚Äôs not really more complex and mini-differences are hidden in these abstractions. We‚Äôre midway through refactoring. Seeing the code become more complicated is normal. We can learn more in the next talk. All the little things talk. Refactoring recipes don‚Äôt promise to make the code simpler, they promise to help you make a very planned change and if fail revert it. The code is not open yet, and we chose the code duplication as code smell to solve and we followed flocking rules for identifying abstractions. We need to make a decision if we continue with our current code and if we revert it and pick a different code smell. We‚Äôve got to ask ourselves, did the refactor we implement, isolate more the parts I want to vary? ( six-pack ) And the answer is yes, quatity(number) and container(number) If we were to vary container or quantity now, we‚Äôre dealing with a smaller amount of code. Sandi recommended to move on and pick another code smell. We had to pick the next code smell and Sandi helped us with the following questions:    Do any of the methods have the same shape?     Are there any arguments that have the same name?     If you were to put the private keyword in here, where would it go?     If this were 2 classes, were would you split it?     The method that have arguments, do they depend on the argument itself or the whole class?  Almost all questions are YES. Something that caught my attention was how the number argument started as a verse in song and verses(upper, lower) methods but in verse(number) it becomes a bottle number, which is confusing, same argument name for two different concepts. A worse problem is when we use the different names for the same concept. def container(number) if number == 1   bottle  else   bottles  endendLet‚Äôs evaluate the container(number): You passed it an argument, and that argument is so impaired that it does not come with its own behavior. You force it to know that it should test it for some values, and you force it to know what behavior to supply, based on the value that it tested for. You force it into the conditional. You forced it to know the different values that it might test in the conditional. And you forced it to know the behavior that applied to each of those. This is not OO. We should be able to call number. container at this point we cannot. The code needs a smarter number. Watch 2: Extracting Classes A number of methods take the same argument (number). Most of them have the same shape. They contain a conditional, they would be considered private, and they depend more on the argument that got passed than the class as a whole. These things suggest the Primitive Obsession code smell. The cure for Primitive Obsession is to extract a class. We‚Äôll ‚Äúwrap a coat of behavior around a primitive,‚Äù we‚Äôre taking something simple like a number or a string and giving it a bit of intelligence. Now, since we‚Äôre going to create a class, the first thing we do is name it. What is this thing? Example: it‚Äôs a bottle. It‚Äôs blue, 22 ounces, made of plastic, and holds water. But remember what we write in code isn‚Äôt the bottle itself. It‚Äôs a representation of all bottles. Think of a boolean, like true, you can‚Äôt pick one up or see it. It‚Äôs not physical; it‚Äôs an idea. In Ruby, true is just a variable that points to an instance of TrueClass. That‚Äôs the beauty of object-oriented programming: it lets you build worlds where ideas are as real as physical objects. When you start modeling concepts the same way you model things, you‚Äôve crossed an important milestone as an OO programmer. Those hidden, abstract ideas, the ones that live in the relationships between real objects, are where the most powerful abstractions are found. Another example: in an Event Management System, perhaps you have buyers and tickets and there‚Äôs a bunch of interactions between them. You have purchases and refunds and discounts and you could resell your tickets. Now, all of the logic to do those actions, those operations, could exist in either ticket or buyer, but it‚Äôs better if they get modeled as their own separate things. If you do that, and put the logic in its own object, you create objects that are easier to understand, easier to change, easier to vary, and easier to test. And since tests are just a form of reuse, a test is often the first reuse of an object. If you can test it, if it‚Äôs easy to test, it means it will be also easy to reuse. Here is another example to illustrate what primitive obsession code smell is: # BEFORE: Primitive Obsessionclass Order def initialize(country_code)  @country_code = country_code end def tax_rate  if @country_code ==  US    0. 07  elsif @country_code ==  MX    0. 16  else   0. 20  end end def currency  if @country_code ==  US     USD   elsif @country_code ==  MX     MXN   else    EUR   end endend# AFTER: Extract Class to cure Primitive Obsessionclass Order def initialize(country)  @country = country end def tax_rate  @country. tax_rate end def currency  @country. currency endendclass Country attr_reader :code def initialize(code)  @code = code end def tax_rate  case code  when  US  then 0. 07  when  MX  then 0. 16  else 0. 20  end end def currency  case code  when  US  then  USD   when  MX  then  MXN   else  EUR   end endendWhen naming instance methods, we asserted that methods ought to be named one level of abstraction higher than what they do, but the rule is different for classes. Classes ought to be named after what they are, and therefore this new class is a BottleNumber. The class Bottles is now free of conditionals and BottleNumber only deals with number nothing about the Song and this is how this the code we finished with during this session. class Bottles def song  verses(99, 0) end def verses(upper, lower)  upper. downto(lower). map { |i| verse(i) }. join( \n ) end def verse(number)   #{quantity(number). capitalize} #{container(number)} of beer on the wall,   +   #{quantity(number)} #{container(number)} of beer. \n  +   #{action(number)},   +   #{quantity(successor(number))} #{container(successor(number))} of beer on the wall. \n  end def quantity(number)  BottleNumber. new(number). quantity end def container(number)  BottleNumber. new(number). container end def action(number)  BottleNumber. new(number). action end def successor(number)  BottleNumber. new(number). successor endendclass BottleNumber attr_reader :number def initialize(number)  @number = number end def quantity  if number == 0    no more   else   number. to_s  end end def container  if number == 1    bottle   else    bottles   end end def action  if number == 0    Go to the store and buy some more   else    Take #{pronoun} down and pass it around   end end def pronoun  if number == 1    it   else    one   end end def successor  if number == 0   99  else   number - 1  end endend"
    }, {
    "id": 25,
    "url": "http://localhost:4000/2025/08/23/session-03.html",
    "title": "POOD Session 3: Identify Abstractions",
    "body": "2025/08/23 - Session 3: Identify Abstractions &amp; Dry Out Shameless GreenDate: August 23, 2025 This blog post consists in two parts:  My notes on Identify Abstractions My notes on code Dry Out Shameless Green‚ÄùKey Concepts:  Flocking Rules ‚Äì A systematic way to discover hidden abstractions by:   Selecting the most similar pieces of code     Finding the smallest difference between them     Making the simplest change to remove that difference     Abstraction Discovery ‚Äì Don‚Äôt invent abstractions upfront; uncover them by observing recurring patterns and responsibilities that emerge through refactoring.     Naming by Responsibility ‚Äì When extracting methods, name them after what they do, not how they do it. (e. g. quantity, container, pronoun, action, successor)     Liskov Substitution Principle ‚Äì Objects should behave as they claim to; avoid conditionals that depend on an object‚Äôs type.     Duck Typing ‚Äì In Ruby, objects are defined by their behavior, not their class. If two objects respond to the same messages, they share a ‚Äúrole. ‚Äùe. g. PrivateContract and CommercialContract both respond to #name, so they can be used interchangeably.     Depending on Abstractions     Emergent Design ‚Äì By consistently applying the Flocking Rules, abstractions emerge naturally; you don‚Äôt need to foresee the design from the start.  Identify Abstractions: Watch 1: Following the Flocking Rules ‚ú® Quick reminder: We need to change the code to display ‚Äúsix-pack‚Äù instead of ‚Äú6 bottles‚Äù which means make the code open to extension, closed to modification Here are the steps to find abstractions in code, these are mini-decisions, we still don‚Äôt know the outcome:  Select the things that are most alike Find the smallest difference between them Make the simplest change to remove the differencea) parse the new codeb) parse and execute itc) parse, execute and use its resultsd) deleted unused code Remember to  change one line at the time.  run tests after each change if the test fail, undo and make a better changeSet of rules of flocking birds ü¶Ö-ü¶Ö-ü¶Ö-ü¶Ö  alignment: tells them to steer on the average heading of their near neighbors cohesion, says steer towards the average position of their neighbors, which is sort of a long range attraction rule separation, don‚Äôt hit each otherThis will turn difference into sameness and will reveal Concealed Concepts. Watch 2: Converging on Abstractions Increase isolation of the thing we want to vary. With the hope that eventually the code will open for the change we want to make. Discover hidden abstractions instead of look at the problem and make them up. We went from this code:  def verse(number)  case number  when 0    No more bottles of beer on the wall,   +    no more bottles of beer. \n  +    Go to the store and buy some more,   +    99 bottles of beer on the wall. \n   when 1    1 bottle of beer on the wall,   +    1 bottle of beer. \n  +    Take it down and pass it around,   +    no more bottles of beer on the wall. \n   when 2    2 bottles of beer on the wall,      2 bottles of beer. \n   +    Take one down and pass it around,  +    1 bottle of beer on the wall. \n   else    #{number} bottles of beer on the wall,   +    #{number} bottles of beer. \n   +    Take one down and pass it around,   +    #{number - 1} bottles of beer on the wall. \n   end endTo this one, always following flocking rules for finding hidden abstracions, select the things that are most alike, find the smallest difference between them and make the simplest change to remove the difference:  def verse(number)  case number  when 0    No more bottles of beer on the wall,   +    no more bottles of beer. \n  +    Go to the store and buy some more,   +    99 bottles of beer on the wall. \n   when 1    1 bottle of beer on the wall,   +    1 bottle of beer. \n  +    Take it down and pass it around,  +    no more bottles of beer on the wall. \n   else    #{number} #{container(number)} of beer on the wall,   +    #{number} bottles of beer. \n  +    Take one down and pass it around,   +    #{number - 1} bottles of beer on the wall. \n   end end def container(number)  if number == 1    bottle   else    bottles   end endDry Out Shameless Green: In this block we finished DRYing out bottles Shameless Green via the Flocking Rules. We coded for 30 minutes with the aim to DRYing out the #verse. After that time we watched the solution videos, replicate the code and discussed it with the group. This is the code we started with, after chopping off the case statement for number 2 all tests run on green: def song  verses(99, 0) end def verses(upper, lower)  upper. downto(lower). map { |i| verse(i) }. join( \n ) end def verse(number)  case number  when 0    No more bottles of beer on the wall,   +    no more bottles of beer. \n  +    Go to the store and buy some more,   +    99 bottles of beer on the wall. \n   when 1    1 bottle of beer on the wall,   +    1 bottle of beer. \n  +    Take it down and pass it around,   +    no more bottles of beer on the wall. \n   else    #{number} bottles of beer on the wall,   +    #{number} bottles of beer. \n  +    Take one down and pass it around,   +    #{number-1} #{container(number-1)} of beer on the wall. \n   end end def container(number)  if number == 1    bottle   else    bottles   end endendWatch 1: Replacing Difference With Sameness It‚Äôs time to pick a pair to work on, keeping in mind go for the code that is pretty similar to each other, in other words, less differences and work towards reducing the differences. In this case is the branch 1 and the else branch. Their difference rely on  1 bottle  vs  #{number} ,  it  vs  one  and  no more  vs  #{number-1}  This change will make our code slower and more abstract, but he have to do this in order to make our code look the same. The cost of this change is execution time, but keeping both cases will cost more due to maintenance (2 very similar branches). def verse(number) case number when 0   No more bottles of beer on the wall,   +   no more bottles of beer. \n  +   Go to the store and buy some more,   +   99 bottles of beer on the wall. \n  when 1   #{number} #{container(number)} of beer on the wall,   +   #{number} #{container(number)} of beer. \n  +   Take it down and pass it around,   +   no more bottles of beer on the wall. \n  else   #{number} #{container(number)} of beer on the wall,   +   #{number} #{container(number)} of beer. \n  +   Take one down and pass it around,   +   #{number - 1} #{container(number - 1)} of beer on the wall. \n  endendWhen following the flocking rules trying to turn difference into sameness, resist the urge to volunteer changes. Limit your changes to only what the recipe calls for and see what happens Watch 2: Equivocating About Names The official definition of equivocate is to use ambiguous language so as to conceal the truth or avoid committing oneself. Sometimes we just don‚Äôt know and we have to do the best we can with the information we have at the time. We are now tackling the  it  vs  one  case, therefore we need to name the concept, create a method or function to be responsible for it, and then use it, send the message in the place of this difference. We are looking for that method name where def thing is many layers of abstraciton away. When naming, we have 3 rules:    Naming Rule  Pros  Cons    Time-boxed naming - Set a time limit and use a thesaurus to find the best name within that time  Time limited approach prevents overthinking  You'll never know less than you know right now, so a better name may emerge later; good enough names may not motivate future improvements    Intentionally bad placeholder - Pick the worst possible name (like  foo ) knowing you'll rename it later  Very fast; saves time and money  The name is terrible    Ask someone good at naming - Find a person skilled at naming and describe your problem to them  Access to expertise; the act of describing the problem may help you discover a good name yourself  Self explanatory In this case  it  and  one  are pronouns. It feels too far from the domain of the 99 Bottles song, but it also feels more correct than anything else I can think of. Let‚Äôs use pronoun by first defining the method, then making it return the else branch. After that add the pronoun method in the actual code, run tests, then add a default argument, then we add another branch to cover the 1 branch Now that else branch and 1 branch are identical and as we are getting used to this recipe the coding part becomes easier, however the naming part is the challenging.  def verse(number)  case number  when 0    No more bottles of beer on the wall,   +    no more bottles of beer. \n  +    Go to the store and buy some more,   +    99 bottles of beer on the wall. \n   when 1    #{number} #{container(number)} of beer on the wall,   +    #{number} #{container(number)} of beer. \n  +    Take #{pronoun(number)} down and pass it around,   +    no more bottles of beer on the wall. \n   else    #{number} #{container(number)} of beer on the wall,   +    #{number} #{container(number)} of beer. \n  +    Take #{pronoun(number)} down and pass it around,   +    #{number - 1} #{container(number - 1)} of beer on the wall. \n   end end def container(number) . . .  end def pronoun(number)  if number == 1    it   else    one   end endWatch 3: Deriving Names From Responsibilities We finished last lesson by picking def pronoun(number) for the  it  and  one  and it was difficult to come up with that name, it‚Äôs even more complex when we don‚Äôt know the domain. We‚Äôll continue with the same flocking rules as previously, pick the code that are similar, remove differences, create a new method to inject in that space and remove unused code. A good trick for naming is ‚ÄúWhat is the responsibility of the method or function that I‚Äôm trying to create to replace this difference?‚Äù At least for now, the good enough name for the change on  no more  words is going to be  quantity . Watch 4: Choosing Meaningful Defaults In this section we add the  def quantity  method and play with a default argument  def quantity(number=0)  When you can, use the else branch first. def verse(number) case number when 0   No more bottles of beer on the wall,   +   no more bottles of beer. \n  +   Go to the store and buy some more,   +   99 bottles of beer on the wall. \n  else   #{number} #{container(number)} of beer on the wall,   +   #{number} #{container(number)} of beer. \n  +   Take #{pronoun(number)} down and pass it around,   +   #{quantity(number - 1)} #{container(number - 1)} of beer on the wall. \n  endenddef quantity(number=0) if number == 0   no more  else  number endenddef container(number)def pronoun(number)Watch 5: Seeking Stable Landing Points The section emphasizes the importance of consistency in code style to reduce mental load and business costs. Sandi Metz explains that consistent, similarly structured methods make code easier to read and maintain. She advises teams to adopt and follow a style guide, even if imperfect, because any consistent style is better than none. If teams can‚Äôt agree, rotate disputed styles for a month; if seniors resist, let them keep their own area but require adherence to team style elsewhere. Over time, consistency benefits everyone by highlighting real differences in code and lowering long-term costs. Watch 6: Obeying the Liskov Substitution Principle The point of Liskov is that objects have to be what they say they are. They have to behave like you expect. They can‚Äôt do anything that forces folks that interact with them to check what kind of a thing they are in order to know how to talk to them. Please notice the consistency we have in the new methods, all of them have if statements, and receive an argument number however we are doing a kind of a duck type. ü¶Ü Example: # Define the  duck type  role: every Contract must respond to `name`class PrivateContract def initialize(person_name)  @person_name = person_name end def name  @person_name endendclass CommercialContract def initialize(business_name)  @business_name = business_name end def name  @business_name endend# Code that works with any kind of contractdef print_contract_name(contract) puts  Contract with: #{contract. name} end# Example usageprivate_contract  = PrivateContract. new( John Doe )commercial_contract = CommercialContract. new( Acme Corporation )print_contract_name(private_contract)# =&gt; Contract with: John Doeprint_contract_name(commercial_contract)# =&gt; Contract with: Acme CorporationIn the example above, we unified the API so that both private and commercial contracts respond to the same message: . name Here is the code by fixing it from the quantity method to respond to . capitalize  def verse(number)  case number  when 0    #{quantity(number). capitalize} bottles of beer on the wall,   +    no more bottles of beer. \n  +    Go to the store and buy some more,   +    99 bottles of beer on the wall. \n   else    #{quantity(number). capitalize} #{container(number)} of beer on the wall,   +    #{number} #{container(number)} of beer. \n  +    Take #{pronoun(number)} down and pass it around,   +    #{quantity(number - 1)} #{container(number - 1)} of beer on the wall. \n   end end def quantity(number=0)  if number == 0    no more   else   number. to_s  end end def container(number) def pronoun(number)Even in a dynamically-typed language like Ruby, you should never check an object‚Äôs type just to decide what message to send. Instead, define a clear role (a duck type) and make sure every object that plays that role conforms to its API. Watch 6: Taking Bigger Steps So we‚Äôve been through this pattern a couple of times where we turned small differences into methods, so we could send messages to make things the same. We grabbed that shape (verse method and 4 case statements) and moved it down into these new methods that we‚Äôre creating. def verse(number) case number when 0   #{quantity(number). capitalize} bottles of beer on the wall,   +   #{quantity(number)} #{container(number)} of beer. \n  +  action(number) +   99 bottles of beer on the wall. \n  else   #{quantity(number). capitalize} #{container(number)} of beer on the wall,   +   #{quantity(number)} #{container(number)} of beer. \n  +  action(number) +   #{quantity(number - 1)} #{container(number - 1)} of beer on the wall. \n  endenddef action(number) if number == 0   Go to the store and buy some more,   else   Take #{pronoun(number)} down and pass it around,   endenddef quantity(number)def container(number)def pronoun(number)Watchn 7: Discovering Deeper Abstractions We‚Äôve almost arrived to have same code on both branches, except the last line of verse method. In our first apporach we proposed adding a new branch to if statemnt def verse(number) case number when 0   #{quantity(number). capitalize} bottles of beer on the wall,   +   #{quantity(number)} #{container(number)} of beer. \n  +  action(number) +   #{quantity(number - 1)} bottles of beer on the wall. \n  else   #{quantity(number). capitalize} #{container(number)} of beer on the wall,   +   #{quantity(number)} #{container(number)} of beer. \n  +  action(number) +   #{quantity(number - 1)} #{container(number - 1)} of beer on the wall. \n  endenddef quantity(number) if number == -1 # üëà  99 elsif number == 0    no more  else  number. to_s endendWith this change the tests are green however  -1  isn‚Äôt a valid value in the context of the song, which has to make you wonder whether things are working by accident and not really working by design. We‚Äôd better ask ourselves, what is the responsibility of the quantity method? quantity is responsible for knowing what to sing in place of a number. If there are 50, you‚Äôre going to sing ‚Äú50‚Äù, if there‚Äôs 0, you‚Äôre going to sing ‚Äúno more‚Äù. This is the method that represents the mapping between the value of a number and the string that you sing in its place. As the song progresses, the verse number gets decremented, except when we reach 0, it wraps back around to the top and starts over again with 99. When you‚Äôre confused, very often a good strategy is: don‚Äôt try to solve the whole problem straight away. If you can nibble away at it, solving the simple parts of the problem might make the hard ones easier. And here we already have a rule for what to do when we‚Äôre confused; it‚Äôs to try to make things more alike, even if not yet identical, using code that we‚Äôve already written. You can think of this next verse as the successive verse. If I ask you for the successor of the letter B, you would tell me C, you wouldn‚Äôt tell me A. We think of A as the predecessor and B as a successor. I kind of like the word successor here, but we have to agree that successor means next and not necessarily next higher.  def verse(number)  case number  when 0    #{quantity(number). capitalize} bottles of beer on the wall,   +    #{quantity(number)} #{container(number)} of beer. \n  +   action(number) +    #{quantity(succesor(number))} #{container(number)} of beer on the wall. \n   else    #{quantity(number). capitalize} #{container(number)} of beer on the wall,   +    #{quantity(number)} #{container(number)} of beer. \n  +   action(number) +    #{quantity(number - 1)} #{container(number - 1)} of beer on the wall. \n   end end def succesor(number)  if number == 0    99   else   number - 1  end end def action(number) def quantity(number) def container(number) def pronoun(number)Watch 8: Depending on Abstractions Abstractions are beautiful things. They allow you to consolidate the implementation details for an idea in your code in a single place so that everybody can use it if they know its name. They give a name to those things so that you can have a conversation with people using this shortcut language, instead of having to describe the whole thing. class Bottles def song  verses(99, 0) end def verses(upper, lower)  upper. downto(lower). map { |i| verse(i) }. join( \n ) end def verse(number)   #{quantity(number). capitalize} #{container(number)} of beer on the wall,   +   #{quantity(number)} #{container(number)} of beer. \n  +  action(number) +   #{quantity(succesor(number))} #{container(succesor(number))} of beer on the wall. \n  end def succesor(number)  if number == 0    99   else   number - 1  end end def action(number)  if number == 0    Go to the store and buy some more,    else    Take #{pronoun(number)} down and pass it around,    end end def quantity(number=0)  if number == 0    no more   else   number. to_s  end end def container(number)  if number == 1    bottle   else    bottles   end end def pronoun(number)  if number == 1    it   else    one   end endendWe use the Flocking Rules to convert four concrete verse_templates into a single more abstract verse method. And along the way, we found a bunch of smaller, internal abstractions and we‚Äôve created methods for them and named them. It‚Äôs important to ask whether this new code actually improves upon the Shameless Green variant from which we started. Most programmers do think it‚Äôs better, but you may be sad to find out that static analysis tools will score it worse. We turned one conditional into many and add 55% more code. The counterbalance of that is that there‚Äôs a lot of value in this code. What we have now, that we didn‚Äôt use to have, is a bunch of identified, named concepts. We know that 99 bottles contains a container and a pronoun and a quantity and an action, and even a successor.  This block finished the refactoring that began in previous blocks. It iteratively followed the Flocking Rules to remove differences in the verse method, and as a result unearthed abstractions that were deeply hidden within the 99 Bottles song.  It illustrated the power of the Flocking Rules to uncover sophisticated concepts, even those which cast only dim shadows in the existing code. You don‚Äôt have to understand the entire problem in order to find and express the correct abstractions‚Äîyou merely apply these rules, repeatedly, and abstractions will naturally appear.  One final thought before moving on. Consider this question: If several different programmers started from Shameless Green and refactored the verse method according to the Flocking Rules, what would the resulting code look like? If you‚Äôve guessed that everyone‚Äôs code would be identical, excepting the names used for the concepts, you‚Äôd be right. This has enormous value.  Now we‚Äôll return to the ‚Äúsix-pack‚Äù problem. "
    }, {
    "id": 26,
    "url": "http://localhost:4000/2025/08/16/session-02.html",
    "title": "POOD Session 2: Test Driving Shameless Green",
    "body": "2025/08/16 - Session 2: Considering Existing Tests and Meet the Open/Closed PrincipleDate: August 16, 2025 This blog post consists in four parts:  My notes on Test Driving Shameless Green My notes on code Open/Closed principle‚Äù My notes on code Code smells talk‚Äù A Google NotebookLM link that contains 2 exercises based on the code smells video (quiz and flashcards). Key Concepts:  Aim for code that is easier to understand, then refactor.  Single responsabillity principle (SRP) How adding conditionals increases code paths exponentially.  Tolerate duplication as a temporary tradeoff for clarity.  Recognizing code smells The 24 code smells (and 2 more!) Open/Closed principle Refactor systematically by discarding and solving one at a time Test Driving Shameless Green: In this lesson, our main task was to watch Sandi Metz‚Äôs talk, study her code, and then answer six questions about it. Afterward, we turned to the book 99 Bottles to compare our answers with Sandi‚Äôs own. The real challenge, however, wasn‚Äôt just about finding the ‚Äúright‚Äù answer, it was about learning how to justify our decisions. Could we explain our reasoning clearly enough to convince other programmers that our solution (or Sandi‚Äôs) was the better one? Working in a team of three, we debated each approach and practiced the art of defending design choices.  What decisions must be made before you can write this first test?I think what behavior should we test. Is it a number that adds another number? Is it a boolean? In this case is a concatenated string. Also, what methods should be publicly available? What is the API look like? (Bearing in mind that we should name methods after the concept they represent rather than how they currently behave. ) What parameters are we going to allow? And what method for? Maybe, which test to write first: entire song, multiple verses, or single verse? (Think in simplicity) Arrange, Act, Assert We shouldn‚Äôt overthink these decisions initially  Is it better to interpolate ‚Äònumber‚Äô or to add a conditional?I think we should aim for understability first, therefore the conditional may be a good start. Once we deepen our domain understanding we can provide more flexibility with the interpolation. Sandi‚Äôs suggestion was to interpolate over conditional. As the test gets more specific the code will become more general.  Why not just interpolate a conditional?The code we are writing is the following: class Bottles def verse(number)   #{number} bottles of beer on the wall,   +   #{number} bottles of beer. \n  +   Take one down and pass it around,   +   #{number - 1} botle#{ s  if number - != 1} of beer on the wall. \n  endendI think this version is hard to understand at a glance, you gotta read it more than once and remembering that the code you write is many times read than written, I point to understability first. Sandi proposed a case statement where the verses are almost identical but vary by the ‚Äúnumber‚Äù variable. Again, it‚Äôs much simpler and easier to follow.  Why is duplication in #verse acceptable, but not in #verses?I think because of the Single Responsibility principle, if we add duplication in #verses we are mixing tasks between those methods. One if for returning one verse at once and the other is for passing the ‚Äúnumber‚Äù variable as iteration.  What should the expectation in the song test be?The song method is the main subject of this exercise, and i think of it as the final result of the code so even when it seems tedious, writing down all the 99 verses is the way to test that code is working properly. class Bottles def song  verses(99, 0) end def verses(upper, lower)  upper. downto(lower). map { |i| verse(i) }. join( \n ) end def verse(number)  case number  when 0    No more bottles of beer on the wall, no more bottles of beer. \nGo to the store and buy some more, 99 bottles of beer on the wall. \n   when 1    1 bottle of beer on the wall, 1 bottle of beer. \nTake it down and pass it around, no more bottles of beer on the wall. \n   when 2    2 bottles of beer on the wall, 2 bottles of beer. \nTake one down and pass it around, 1 bottle of beer on the wall. \n   else    #{number} bottles of beer on the wall, #{number} bottles of beer. \nTake one down and pass it around, #{number-1} bottles of beer on the wall. \n   end endend What design flaw forces you to write this last annoying test?The flaw is that song does not accept any arguments, it always produces the full song from 99 to 0. The song method is closed to extension. ‚Äî Quiz answers ‚Äî  &gt; What decisions must be made before you can write this first test? (Video 1:55)  &gt; You have to make lots of decisions! For example, you must design your API, decide on the classes you plan to create and the messages to which they respond, and determine the required inputs and expected outputs for each method.  &gt; (99 Bottles book section 2. 2)  &gt; Is it better to interpolate 'number' or to add a conditional? (Video 2:50)  &gt; It is better to interpolate the value of the number into the verse string rather than to add a new conditional.  &gt; (99 Bottles book section 2. 2)  &gt; We tend to discount the complexity of adding a conditional where none existed before, but beware!  &gt; A method containing a single two-branch conditional has two execution paths, that is, there are two separate paths through the code.  &gt; If you add a second two-branch conditional, you create four possible execution paths.  &gt; Adding yet another two-branch conditional (now you have three two-branch conditionals) results in eight execution paths, not six.  &gt; The number of execution paths increases exponentially, calculated as the number of branches raised to the power of the number of conditionals.  &gt; For example, 2 branches √ó 10 conditionals = 1,023 possible paths!  &gt; There's no way a method like this has a complete test suite.  &gt; Why not just interpolate a conditional?!? (Video 4:08)  &gt; Interpolating a conditional to decide whether or not to add an 's' to  bottle  adds complexity without creating a useful abstraction. It's better to duplicate for now and wait for more information from future tests.  &gt; Refactor only when you are confident about your abstractions. Until then, tolerate duplication as a temporary tradeoff for clarity.  &gt; (99 Bottles book section 2. 2)  &gt; Why is duplication in #verse acceptable, but not in #verses? (Video 6:24)  &gt; The Single Responsibility Principle says each method should do one thing well. The #verse method‚Äôs job is to produce correct lyrics. The #verses method‚Äôs job is to call #verse for each verse and join the results.  &gt; Duplication inside #verse is fine because it‚Äôs encapsulated ‚Äî it‚Äôs invisible to other parts of the app. But duplicating that logic elsewhere (like in #verses) would violate SRP.  &gt; (99 Bottles book section 2. 6)  &gt; What should the expectation in the song test be? (Video 7:44)  &gt; The whole song.  &gt; (99 Bottles book section 2. 10)  &gt; The song test is annoying! You're forced to write that long expectation because of a design flaw in the code. Speculate about what that flaw might be. (Video 9:45)  &gt; This was just to make you think! The answer will become clear as the course progresses. :-) Meet the Open/Closed Principle: Block 3 covers two new ideas: the Open/Closed Principle and Code Smells. Here, we were tasked to watch short videos (~4 mins) that showed us design principles for the next code exercise. Watch #1: Listening to Change What we do most of us do for a living is, we change code. And what that means is the cost of code is in the reading. Writing code happens only once, but reading happens over and over and over. Have you ever done that thing where you‚Äôre working on some code and you add code for a feature that‚Äôs not yet been asked for but that you guess will arrive in the future? How‚Äôd that turn out? Dead code, whether it‚Äôs obsolete or anticipatory, adds costs, if the cost of code is in the reading. That last note remineded me of this Jeremy Smith tweet  Things I‚Äôve learned the hard way about web development:    automated testing is always worth it in the long-run  limit your dependencies where possible, and keep up with dependency upgrades  don‚Äôt write code in anticipation of future needs  integrate code changes often, no long feature branches  deploy schema, data, and code changes separately whenever possible  limit your work in progress  make sure you have monitoring in place so that, when things go wrong, you know about it first  don‚Äôt save the toughest, most unclear part of a project for last  if you think you might miss a deadline, communicate that as early as possible  address common production exceptions so you don‚Äôt lose important rare ones in the noise  anticipate product usage changes and seasonality and account for it in infrastructure changes and feature releases The rule is: the sum of the costs incurred by guessing far outweighs the money you save by very occasionally being right. So what should you do? The rule is every bit of code you write should be for a feature that is currently being used. Here is the challenge: Every place, the song currently says six bottles, it should instead say 1 six-pack. We could fulfill this new requirement by adding two more branches to the existing case statement but that would lead to 4 branches and eventually to unmaintainable code. Things that change, do. And what I mean by that is that the stuff that changes, the things that change at the highest rate in your application often are concepts or ideas that are core to your domain. And so the most changeable things are the most valuable to your business.  We need to make it more amenable to change, which means we need OO. Watch #2: Starting With the Open/Closed Principle Requirement is: change the word from ‚Äúsix bottles‚Äù to ‚Äú1 six-pack‚Äù. We gotta make the code open. Open is the ‚ÄúO‚Äù in SOLID. This principle says that when you‚Äôre adding code to fulfill a new requirement, you should not simultaneously change existing code. Think of it, what it would mean for your code, if every time you went to write the code to fulfill a new requirement, the existing code was open to the new code you wanted to write. This will imply:  Tests continue to run green Almost impossible to break and existing feature You can write brand new tests Implement new feature by just adding code. Not adjusting current code. Diagram for checking if code is open:  A very strict definition of openness for this problem. The current code is open to new requirement if you can implement that requirement without changing anything in any existing class. Do you know how to make it open? if you can‚Äôt instantly describe the transformation that will bend this code into a shape that‚Äôs open to the new requirement, you don‚Äôt really know how to do it. (This is very common) We need a technique to find code smells that we‚Äôll see in the next section. Watch #3: Recognizing Code Smells Have you ever been defeated by refactoring? You try and make a change, and you dive in and change a bunch of code, and you break a bunch of tests, and you thrash around with a machete, you finally throw up your hands and do a git reset --hard? Why? Because code has a lots of different wrong parts. If you try to fix everything at once is easy to get really in over you head. It would be much easier to improve code if you could reach in and grab a single thread and tug and fix that one piece until it was correct, leaving everything else unchanged. Code smells are things that might be wrong with your code. They‚Äôre the names of code arrangements that could be a problem. They are 24, listed in the book (chapter 3), Martin Fowler‚Äôs refactoring.  Code smelss categories (5):    Bloaters - Things that increase code volume unnecessarily    Long Function  Self explanatory    Large Class  Self explanatory    Data Clumps  Two or more pieces of data that always come together should be wrapped in an object    Long Parameter List  Self explanatory    Primitive Obsession  Passing primitives (String, Integer) around with behavior instead of wrapping them in objects    Abusers - Things you could do in OO but should be careful with    Repeated Switches  Same conditional pattern appearing multiple times `case statements`; branches should be objects    Refused Bequest  Subclasses that don't implement all superclass methods and throw exceptions (related to inheritance)    Alternative Classes with Different Interfaces  Different classes doing the same thing with different method names    Temporary Field  Using temporary variables to cache results or name operations; consider using methods    Global Data  Data you don't own that others can change    Mutable Data  Prefer immutable objects when possible    Preventers - Code that prevents easy changes    Divergent Change  One object changes for different reasons; should be split into multiple objects    Shotgun Surgery  One single change requires modifications in many places; should be consolidated    Mysterious Name  Self explanatory    Dispensables - Arbitrary additions that increase length without adding value    Lazy Element (lazy class)  Object not doing enough to justify its existence    Speculative Generality  Writing code for imagined requirements; when you write code for future features    Data Class  Class with only data; behavior should be combined with data    Duplicated Code  Self explanatory    Comments  Explaining code instead of writing self-explanatory code    Loops  Use Map/Filter instead of writing loops    Couplers - Objects bound together by messages    Feature Envy  Object interacting too much with another object; may belong together    Insider Trading  Objects passing private implementation details    Message Chains  Sending messages through multiple objects in sequence (Message. where(sender:  Joe ). count( OK ))    Middle Man  Object only forwarding messages without adding value Code smells map to curative refactorings. Each of those refactorings comes with a recipe, a step-by-step guide about how to do it. you can identify code smells, then go look up the refactoring recipes that are curative for it, select one, and then follow the step-by-step directions to get rid of that smell. Refactoring is to alter the arrangement of code without changing its behavior. (refactoring should happen all under green because tests ought your back) Watch #4: Identifying the Best Point of Attack Requirement is: change the word from ‚Äúsix bottles‚Äù to ‚Äú1 six-pack‚Äù. class Bottles def song  verses(99, 0) end def verses(upper, lower)  upper. downto(lower). map { |i| verse(i) }. join( \n ) end def verse(number)  case number  when 0    No more bottles of beer on the wall, no more bottles of beer. \nGo to the store and buy some more, 99 bottles of beer on the wall. \n   when 1    1 bottle of beer on the wall, 1 bottle of beer. \nTake it down and pass it around, no more bottles of beer on the wall. \n   when 2    2 bottles of beer on the wall, 2 bottles of beer. \nTake one down and pass it around, 1 bottle of beer on the wall. \n   else    #{number} bottles of beer on the wall, #{number} bottles of beer. \nTake one down and pass it around, #{number-1} bottles of beer on the wall. \n   end endendWe have repeated switches, duplicated code, long function, maginc number (have meaning but lack fo name), and concealed concept (duplication of concepts that are represented by different implementations of code). We have at least 5 code smells and we gotta choose just one. And probably discard some of the code smells as candidates, since it‚Äôs common that some code smells create other code smells. We throw out long function and repeated switches. that leaves magic number, concealed concept and duplicated code. We‚Äôll tackle concealed concept. The core idea here is that, if we isolate the thing we want to vary, it‚Äôs then possible to make new variants without editing existing code. And that‚Äôs what it means to be open. Watch #5: Refactoring Systematically You can think of refactoring versus adding new features as two different programming modes.    In refactoring mode, you move code around, but you don‚Äôt touch a test. The test run merrily along unchanged, and you should never see red.     In adding new features mode, the first thing you do is write a failing test; you should see red right away. Then you can write the code to make that test pass.     And if the code base you‚Äôre working on is open to your new feature, then you can implement that feature without altering any existing code.  When refactoring tests break:    You‚Äôre not really refactoring. You‚Äôre not rearranging code without changing behavior. You‚Äôre actually rearranging code while changing behavior.     The tests are flawed. Tests are tightly coupled to current implementation of the code.  Notes on Sandi Metz‚Äôs talk (Get a Whiff of This (code smells talk)‚Äù)::    Kent Beck created the term ‚Äúcode smells‚Äù and with Martin Fowler, both wrote the chapter 3 of the book Refactoring.     They have been in this since 1990.     Try to mention 5 code smells? Most people can‚Äôt.     Once you give a complex idea a name, we can talk to each other in an unambiguous way without having miscommunications.     A code smells might indicate a problem, not that it is a problem.     Sandi lists the 5 categories of code smells, bloaters, abusers, code change preventers, dispensables and couplers‚Äî they can be found above in a table.     If ugly code doesn‚Äôt change then it cost no money.     In OO we have data + behaviour in objects, not only data.     Don‚Äôt write code that you think will be needed later. Don‚Äôt guess! The times you are right have to outweight the time you‚Äôre wrong.     The code is written once and read thousands therefore we cost money reading code. Make it clear     If you add the code smell speculative generality you increase levels of abstraction, which is indirection in turn difficult to understand.     Every code smell maps to its own curative refactoring recipe     The next PDF includes a cross reference of Martin Fowler refactoring to each code smell  Code smells Talk exercises Google NotebookLM: In the following link you‚Äôll find 50 flashcards and a 10 questions-quiz based on Sandi‚Äôs video ‚ÄúGet a Whiff of This (code smells)‚Äù It‚Äôs a Google NotebookLM link to exercise Hope you can learn something new ! Here is an sample how the flashcards look like and my result of the exercises: Flashcards on Get a Whiff of This by Sandi Metz (code smells) talk:   Get a Whiff of This by Sandi Metz (code smells) talk quiz result:   "
    }, {
    "id": 27,
    "url": "http://localhost:4000/2025/08/16/99-bottles-of-oop.html",
    "title": "99 bottles of OOP",
    "body": "2025/08/16 -  Rediscovering Simplicity Test Driving Shameless Green Unearthing Concepts Practicing Horizontal Refactoring Separating Responsibilities Achieving Openness Manufacturing Intelligence Developing a Programming Aesthetic Reaping the Benefits of DesignIntroduction. : Writing code is the process of working your way to the next stable end point, not the end point itself. You don‚Äôt know the answer in advance, but instead, you are seeking it. This book documents every step down every path of code, and so provides a guided-tour of the decisions made along the way. It not only shows how good code looks when it‚Äôs done, it reveals the thoughts that produced it. Rediscovering Simplicity: Experience has taught you that most code will someday change, and you‚Äôve begun to craft it in anticipation of that day. Complexity seems both natural and inevitable. Where you once optimized code for understandability, you now focus on its changeability. Your code is less concrete but more abstract -you‚Äôve made it initially harder to understand in hopes that it will ultimately be easier to maintain. OOD doesn‚Äôt claim to be free; it merely asserts that its benefits outweigh its costs. Design decisions inevitably involve trade-offs. There‚Äôs always a cost. For example, if you‚Äôve duplicated a bit of code in many places, the Don‚Äôt Repeat Yourself (DRY) principle tells you to extract the duplication into a single common method and then invoke this new method in place of the old code. DRY is a great idea, but that doesn‚Äôt mean it‚Äôs free. The price you pay for DRYing out code is that the invoker of the new method no longer knows the result, only the message it should send. If you‚Äôre willing to pay this price, that is, you are willing to be ignorant of the actual behavior, the reward you reap is that when the behavior changes, you need alter your code in only one place. Example: # before DRYclass Invoice def total_in_cents  (line_items. sum(&amp;:price) * 100). to_i end def discount_in_cents  (discount. amount * 100). to_i endend# after DRYclass Invoice def total_in_cents  convert_to_cents(line_items. sum(&amp;:price)) end def discount_in_cents  convert_to_cents(discount. amount) end private def convert_to_cents(amount)  (amount * 100). to_i endend   total_in_cents no longer shows how the conversion happens.     Whoever calls total_in_cents only knows: ‚ÄúI send a message convert_to_cents‚Äù they don‚Äôt directly know that it multiplies by 100 and converts to integer.     So if later someone asks: ‚ÄúWait, does this return a float or an integer?‚Äù ‚Äî you can‚Äôt see that directly in the total_in_cents method anymore. You must chase down into convert_to_cents to know.  Did you divide one large class into many small ones? You can now reuse the new classes independently of one another, but it‚Äôs no longer obvious how they fit together for the original case. Have you injected a dependency instead of hard-coding the class name of a collaborator? The receiver can now freely depend on new and previously unforeseen objects, but it must remain ignorant of their actual class. The examples above change code by increasing its level of abstraction. DRYing out code inserts a level of indirection between the place that uses behavior and the place that defines it. Breaking one large class into many forces the creation of something new to embody the relationship between the pieces. Injecting a dependency transforms the receiver into something that depends on an abstract role rather than a concrete class. Design is thus about picking the right abstractions. If you choose well, your code will be expressive, understandable and flexible.      Benefits   Cons       DRY (Don't Repeat Yourself)         ‚Ä¢ Eliminates code duplication    ‚Ä¢ Single source of truth for behavior    ‚Ä¢ Easier maintenance - change in one place    ‚Ä¢ Reduces bugs from inconsistent implementations         ‚Ä¢ Adds level of indirection between usage and definition    ‚Ä¢ Can make code harder to understand    ‚Ä¢ May create premature abstractions    ‚Ä¢ Debugging requires jumping between files/methods        Dependency Injection         ‚Ä¢ Enables flexible composition with unforeseen objects    ‚Ä¢ Improves testability with mock objects    ‚Ä¢ Reduces coupling between classes    ‚Ä¢ Supports polymorphism and duck typing         ‚Ä¢ Receiver must remain ignorant of actual class types    ‚Ä¢ Increases complexity of object construction    ‚Ä¢ Can make dependencies less obvious    ‚Ä¢ Requires abstract thinking about roles vs. classes        Single Responsibility Principle (Divide Large Classes)         ‚Ä¢ Classes can be reused independently    ‚Ä¢ Easier to test individual components    ‚Ä¢ More focused, cohesive responsibilities    ‚Ä¢ Simpler to understand each piece in isolation         ‚Ä¢ No longer obvious how pieces fit together    ‚Ä¢ Requires new abstractions to coordinate parts    ‚Ä¢ Can lead to over-engineering    ‚Ä¢ May scatter related logic across multiple files     However, if you get the abstractions wrong, your code will be convoluted, confusing, and costly. Unfortunately, abstractions are hard, and even with the best of intentions, it‚Äôs easy to get them wrong. Early abstractions are often not quite right, and therefore they create a catch-22. You can‚Äôt create the right abstraction until you fully understand the code, but the existence of the wrong abstraction may prevent you from ever doing so. This suggests that you should not reach for abstractions, but instead, you should resist them until they absolutely insist upon being created. This book is about finding the right abstraction. 1. 1. Simplifying Code: The code you write should meet two often-contradictory goals. It must remain concrete enough to be understood while simultaneously being abstract enough to allow for change. Code can range on a spectrum from very concrete (one long, detailed procedure) to very abstract (many tiny classes and methods). The best solutions usually aren‚Äôt at the extremes but somewhere in the middle, where the code is both understandable and easy to change. The programmer‚Äôs job is to find that balance. This section discusses four different solutions to the ‚Äú99 Bottles of Beer‚Äù problem. 1. 1. 1. Incomprehensibly Concise: class Bottles def song  verses(99, 0) end def verses(hi, lo)  hi. downto(lo). map {|n| verse(n) }. join( \n ) end def verse(n)   #{n == 0 ? 'No more' : n} bottle#{'s' if n != 1}  +    of beer on the wall,   +   #{n == 0 ? 'no more' : n} bottle#{'s' if n != 1} of beer. \n  +   #{n &gt; 0 ?  Take #{n &gt; 1 ? 'one' : 'it'} down and pass it around    :  Go to the store and buy some more },   +   #{n-1 &lt; 0 ? 99 : n-1 == 0 ? 'no more' : n-1} bottle#{'s' if n-1 != 1} +    of beer on the wall. \n  endendThis first solution embeds a great deal of logic into the verse string. The code above performs a neat trick. It manages to be concise to the point of incomprehensibility while simultaneously retaining loads of duplication. Consistency (in conditionals) The style of the conditionals is inconsistent. Most use the ternary form, other statements are made conditional by adding a trailing if. Every time the style of the conditionals changes, the reader has to press a mental reset button and start thinking anew. Duplication The code duplicates both data and logic. Having multiple copies of the strings ‚Äúof beer‚Äù and ‚Äúon the wall‚Äù isn‚Äôt great, but at least string duplication is easy to see and understand. Logic, however, is harder to comprehend than data, and duplicated logic is doubly so. Names The most obvious point to be made about the names in the verse method is that there aren‚Äôt any. The verse string contains embedded logic. Each bit of logic serves some purpose, and it is up to you to construct a mental map of what thesepurposes might be. This code would be easier to understand if it did not place that burden upon you. Creating a method requires identifying the code you‚Äôd like to extract and deciding on a method name. This, in turn, requires naming the concept, and naming things is just plain hard. In the case above, it‚Äôs especially hard. This code not only contains many hidden concepts, but those concepts are mixed together. Combining many ideas into a small section of code makes it difficult to isolate and name any single concept. When you first write a piece of code, you obviously know what it does. Therefore, during initial development, the price you pay for poor names is relatively low. However, code is read many more times than it is written, and its ultimate cost is often very high and paid by someone else. Code is also charged with doing what it‚Äôs supposed to do now as well as being easy to alter so that it can do more later.  How difficult was it to write? How hard is it to understand? How expensive will it be to change?Code is easy to understand when it clearly reflects the problem it‚Äôs solving, and thus openly exposes that problem‚Äôs domain If this solution would be openly exposed the ‚Äú99 Bottles‚Äù domain, a brief glance at the code would answer these questions:  How many verse variants are there? Which verses are most alike? In what way? Which verses are most different, and in what way? What is the rule to determine which verse comes next?These questions reflect core concepts of the problem, yet none of their answers are apparent in this solution. The number of variants, the difference between the variants, and the algorithm for looping are distressingly obscure. This code does not reflect its domain, and therefore you can infer that it was difficult to write and will be a challenge to change. 1. 1. 2. Speculatively General: This next solution errs in a different direction. It does many things well but can‚Äôt resist indulging in unnecessary complexity. class Bottles NoMore = lambda do |verse|   No more bottles of beer on the wall,   +   no more bottles of beer. \n  +   Go to the store and buy some more,   +   99 bottles of beer on the wall. \n  end LastOne = lambda do |verse|   1 bottle of beer on the wall,   +   1 bottle of beer. \n  +   Take it down and pass it around,   +   no more bottles of beer on the wall. \n  end Penultimate = lambda do |verse|   2 bottles of beer on the wall,   +   2 bottles of beer. \n  +   Take one down and pass it around,   +   1 bottle of beer on the wall. \n  end Default = lambda do |verse|   #{verse. number} bottles of beer on the wall,   +   #{verse. number} bottles of beer. \n  +   Take one down and pass it around,   +   #{verse. number - 1} bottles of beer on the wall. \n  end def song  verses(99, 0) end def verses(finish, start)  (finish). downto(start). map {|verse_number|   verse(verse_number) }. join( \n ) end def verse(number)  verse_for(number). text end def verse_for(number)  case number  when 0 then Verse. new(number, &amp;NoMore)  when 1 then Verse. new(number, &amp;LastOne)  when 2 then Verse. new(number, &amp;Penultimate)  else Verse. new(number, &amp;Default)  end endendclass Verse attr_reader :number def initialize(number, &amp;lyrics)  @number = number  @lyrics = lyrics end def text  @lyrics. call self endendTo summarize, sending verse(number) to an instance of Bottles invokes verse_for(number), which uses the value of number to select the correct lambda on which to create and return an instance of Verse. The verse method then sends text to the returned Verse, which in turn sends call to the lambda, passing self as an argument. This invokes the lambda, which may or may not actually use the argument that was passed. This example answers better the next questions in comparison to first example:    How many verse variants are there?There are four verse variants (look at the constants).     Which verses are most alike? In what way?Verses 3-99 are most alike (as evidenced by the fact that all are produced by the Default variant).     Which verses are most different? In what way?Verses 0, 1 and 2 are clearly different from 3-99, although it‚Äôs not obvious in what way.     What is the rule to determine which verse should be sung next?Buried deep within the NoMore lambda is a hard-coded ‚Äú99,‚Äù which might cause one to infer that verse 99 follows verse 0.  Now, the value/cost questions:    How difficult was it to write?There‚Äôs far more code here than is needed to pass the tests. This unnecessary code took time to write.     How hard is it to understand?The many levels of indirection are confusing. Their existence implies necessity, but you could study this code for a long time without discerning why they are needed.     How expensive will it be to change?The mere fact that indirection exists suggests that it‚Äôs important. You may feel compelled to understand its purpose before making changes.  As you can see from these answers, this solution does a good job of exposing core concepts, but does a bad job of being worth its cost. The code does two basic things. First, it defines templates for each kind of verse (lines 2-28), and second, it chooses the appropriate template for a specific verse number and renders that verse‚Äôs lyrics (lines 39-63). Notice that the verse templates contain all of the information needed to answer the domain questions. But it‚Äôs not the templates that are costly; it‚Äôs the code that chooses a template and renders the lyrics for a verse. This choosing/rendering code is overly complicated 1. 1. 3. Concretely Abstract: This solution valiantly attempts to name the concepts in the domain: class Bottles def song  verses(99, 0) end def verses(bottles_at_start, bottles_at_end)  bottles_at_start. downto(bottles_at_end). map do |bottles|   verse(bottles)  end. join( \n ) end def verse(bottles)  Round. new(bottles). to_s endendclass Round attr_reader :bottles def initialize(bottles)  @bottles = bottles end def to_s  challenge + response end def challenge  bottles_of_beer. capitalize +     + on_wall +  ,   +  bottles_of_beer +  . \n  end def response  go_to_the_store_or_take_one_down +  ,   +  bottles_of_beer +     + on_wall +  . \n  end def bottles_of_beer   #{anglicized_bottle_count} #{pluralized_bottle_form} of #{beer}  end def beer   beer  end def on_wall   on the wall  end def pluralized_bottle_form  last_beer? ?  bottle  :  bottles  end def anglicized_bottle_count  all_out? ?  no more  : bottles. to_s end def go_to_the_store_or_take_one_down  if all_out?   @bottles = 99   buy_new_beer  else   lyrics = drink_beer   @bottles -= 1   lyrics  end end def buy_new_beer   Go to the store and buy some more  end def drink_beer   Take #{it_or_one} down and pass it around  end def it_or_one  last_beer? ?  it  :  one  end def all_out?  bottles. zero? end def last_beer?  bottles == 1 endendThis solution is characterized by having many small methods. This is normally a good thing, but somehow in this case it‚Äôs gone badly wrong. Have a look at how this solution does on the domain questions:    How many verse variants are there?It‚Äôs almost impossible to tell.     Which verses are most alike? In what way?Ditto.     Which verses are most different? In what way?Ditto.     What is the rule to determine which verse should be sung next?Ditto.  Value/cost questions.    How difficult was it to write?Difficult. This clearly took a fair amount of thought and time.     How hard is it to understand?The individual methods are easy to understand, but despite this, it‚Äôs tough to get a sense of the entire song. The parts don‚Äôt seem to add up to the whole.     How expensive will it be to change?While changing the code inside any individual method is cheap, in many cases, one simple change will cascade and force many other changes.  It‚Äôs obvious that the author of this code was committed to doing the right thing, and that they carefully followed the Red, Green, Refactor style of writing code. It looks as though these strings were refactored into separate methods at the first sign of duplication. DRY reduces change costs by eliminating duplication, but increases understanding costs through indirection. Use DRY when the savings from easier maintenance outweigh the complexity of following abstract layers. The beer method centralizes the drink name in one location. To change from ‚Äúbeer‚Äù to ‚ÄúKool-Aid,‚Äù you only modify line 42, avoiding scattered string updates throughout the codebase. But then look at these other method names, and how many time they‚Äôre used: def bottles_of_beerdef buy_new_beerdef drink_beerdef last_beer?This small change in requirements forces a change in many places, which is exactly the problem DRY promises to avoid. When you name a method beer that returns ‚Äúbeer,‚Äù you tie the method name to its current implementation. This breaks when you change the implementation to return ‚ÄúKool-Aid. ‚Äù You should name methods not after what they do, but after what they mean, what they represent in the context of your domain. The method should be called beverage because that‚Äôs what it represents in the song‚Äôs context - one level of abstraction higher than the specific implementation. # fromdef beverage  beer end# to:def beverage  Kool-Aid endTherefore, one lesson to be gleaned from this solution is that you should name methods after the concept they represent rather than how they currently behave. However, notice that even if you edited the code to improve every method name, this code still isn‚Äôt quite right. Changing the name of the beer method to beverage makes it easy to replace the string ‚Äúbeer‚Äù with the string ‚ÄúKool-Aid‚Äù but does nothing to improve this code‚Äôs score on the domain questions. 1. 1. 4. Shameless Green: None of the solutions shown thus far do very well on the value/cost questions. First example (Incomprehensibly Concise), cares only for terseness (brevity). Second example (Speculatively General) tries for extensibility but achieves unwarranted complexity (too much lambdas usage). The heart of the third example (Concretely Abstract) is in the right place, but it can‚Äôt get its feet out of the mud (too many methods, difficult to follow). Speculatively General and Concretely Abstract were both written with an eye toward reducing future costs. The failure here is not bad intention‚Äîit‚Äôs insufficient patience.  This next example is patient and so provides an antidote for all that has come before. class Bottles def song  verses(99, 0) end def verses(upper, lower)  upper. downto(lower). map {|i| verse(i)}. join( \n ) end def verse(number)  case number  when 0    No more bottles of beer on the wall,   +    no more bottles of beer. \n  +    Go to the store and buy some more,   +    99 bottles of beer on the wall. \n   when 1    1 bottle of beer on the wall,   +    1 bottle of beer. \n  +    Take it down and pass it around,   +    no more bottles of beer on the wall. \n   when 2    2 bottles of beer on the wall,   +    2 bottles of beer. \n  +    Take one down and pass it around,   +    1 bottle of beer on the wall. \n   else    #{number} bottles of beer on the wall,   +    #{number} bottles of beer. \n  +    Take one down and pass it around,   +    #{number-1} bottles of beer on the wall. \n   end endendThe most immediately apparent quality of this code is how very simple it is. The code is gratifyingly easy to comprehend. Domain questions.    How many verse variants are there?Clearly, four.     Which verses are most alike? In what way?3-99, where only the verse number varies.     Which verses are most different? In what way?0, 1 and 2 are different from 3-99, though figuring out how requires parsing strings with your eyes.     What is the rule to determine which verse should be sung next?This is still not explicit. The 0 verse contains a deeply buried, hard-coded 99.  Value/cost questions:    How difficult was this to write?It was easy to write.     How hard is it to understand?It is easy to understand.     How expensive will it be to change?It will be cheap to change. Even though the verse strings are duplicated, if one verse changes it‚Äôs easy to keep the others in sync.  By the criteria that have been established, Shameless Green is clearly the best solution, yet almost no one writes it. Most programmers have a powerful urge to do more, but sometimes it‚Äôs best to stop right here. When you DRY out duplication or create a method to name a bit of code, you add levels of indirection that make it more abstract. In theory these abstractions make code easier to understand and change, but in practice they often achieve the opposite. One of the biggest challenges of design is knowing when to stop, and deciding well requires making judgments about code. 1. 2. Judging Code: You judge code constantly. Writing code requires making choices; the choices you make reflect personal, internalized criteria. 1. 2. 1. Evaluating Code Based on Opinion: Just as ‚ÄúEverybody complains about the weather but nobody does anything about it‚Äù, everyone has an opinion about what good code looks like, but those opinions usually don‚Äôt tell us what action to take to create it. Here are a few definitions of clean code.  I like my code to be elegant and efficient.  ‚Äî Bjarne Stroustrupinventor of C++  Clean code is ‚Ä¶ full of crisp abstractions ‚Ä¶  ‚Äî Grady Boochauthor of Object Oriented Analysis and Design with Applications  Clean code was written by someone who cares.  ‚Äî Michael Feathersauthor of Working Effectively with Legacy Code Your own definition probably follows along these same lines. Any pile of code can be made to work; good code not only works, but is also simple, understandable, expressive and changeable. The problem with these definitions is that although they accurately describe how good code looks once it‚Äôs written, they give no help with achieving this state, and provide little guidance for choosing between competing solutions. Since form follows function, good code can also be defined simply, and somewhat circularly, as that which provides the highest value for the lowest cost. Our sense of elegance, expressiveness and simplicity is an outgrowth of our experiences when reading and modifying code. Code that is easy to understand and a pleasure to extend naturally feels simple and elegant. 1. 2. 2. Evaluating Code Based on Facts: Measures that rise to become metrics are backed by research that has stood the test of time. They‚Äôve been scrutinized by many people over many years. You can think of metrics as crowd-sourced opinions about the quality of code. This section examines three different metrics: Source Lines of Code, Cyclomatic Complexity, and ABC Source Lines of Code This one number has been used to predict the total effort needed to develop software, to measure the productivity of those who write it, and to predict the cost of maintaining it. The metric has the advantage of being easily garnered and reproduced, but suffers from many flaws. Using SLOC to predict the development effort needed for a new project is done by counting the SLOC of existing projects for which total effort is known, deciding which of those existing projects the new project most resembles, and then running a cost estimation model to make the prediction. Measuring programmer productivity by counting lines of code assumes that all programmers write equally efficient code. While the cost of maintenance is related to the size of an application, the way in which code is organized also matters. It is cheaper to maintain a well-designed application than it is to maintain a pile of spaghetti-code. Cyclomatic Complexity In 1976, Thomas J. McCabe, Sr. published ‚ÄúA Complexity Measure‚Äù:  What is needed is a mathematical technique that will provide a quantitative basis for modularization and allow us to identify software modules that will be difficult to test or maintain. Think of this algorithm as a little machine that ponders your code and then maps out all the possible routes through every combination of every branch of every conditional. A method with many deeply nested conditionals would score very high, while a method with no conditionals at all would score 0. Cyclomatic complexity neither predicts application development time nor measures programmer productivity. Cyclomatic complexity sounds great, and it‚Äôs easy to see that it could be useful, but it views the world of code through a narrow lens. Assignments, Branches and Conditions (ABC) Metric The problem with cyclomatic complexity is that it doesn‚Äôt take everything into account. Code does more than just evaluate conditions; it also assigns values to variables and sends messages. These things add up, and as you do more and more of each, your code becomes increasingly difficult to understand. In 1997, twenty-one years after the unveiling of cyclomatic complexity, Jerry Fitzpatrick published ‚ÄúApplying the ABC Metric to C, C++, and Java‚Äù. His ABC stands for assignments, branches and conditions, where:  Assignments is a count of variable assignments.  Branches counts not branches of an if statement (as one could forgivably infer) but branches of control, meaning function calls or message sends.  Conditions counts conditional logic. ABC is a measure of complexity. Highly complex code is difficult to understand and change, therefore ABC scores are a proxy for code quality. High scores suggest that code will be hard to test and expensive to maintain. Summary     Step   Principle   Description       1   Start Shameless Green   Write the simplest code that works, even if it has duplication. Don't try to be clever or anticipate future needs.      2   Tolerate Duplication   Let duplicate code exist until you fully understand the problem domain. Duplication is often better than the wrong abstraction.      3   Resist Premature Abstraction   Don't create abstractions until they  absolutely insist upon being created.   Wait until the pattern becomes obvious and painful.      4   Name for the Domain, Not Implementation   When you do abstract, name methods/classes after what they represent in your problem space (beverage not beer), not their current behavior.      5   Optimize for Change, Not Cleverness   Make code easy to understand and modify by future you. Simple, clear code beats concise, clever code every time.      6   Ask the Domain Questions   Before changing anything, evaluate if your code clearly reveals: How many variants exist? Which parts are most alike/different? What are the core rules and patterns?      7   Ask the Value/Cost Questions   For any solution, honestly assess: How difficult was it to write? How hard is it to understand? How expensive will it be to change?      The Golden Rule: If your code doesn't clearly answer the domain questions or fails the value/cost test, step back toward simplicity. The right abstractions will emerge naturally when you understand the problem deeply enough.   Test Driving Shameless Green: The Shameless Green solution consists of intention-revealing, working software, and is the result of writing simple code to pass a series of presupplied tests. The provenance of the code that was written in Chapter 1 is obvious, but the tests appeared without explanation. It is now time to take a step back, and investigate how to create tests that lead to Shameless Green. 2. 1. Understanding Testing: The practice of writing tests before writing code became known as test-driven development(TDD). In its simplest form, TDD works like this:    Write a test. Because the code does not yet exist, this test fails. Test runners usually display failing tests in red.     Make it run. Write the code to make the test pass. Test runners commonly display passing tests in green.     Make it right. Each time you return to green, you can refactor any code into a better shape, confident that it remains correct if the tests continue to pass.  The ideas of testing, and of testing first, have won the hearts and minds of programmers. However, a commitment to writing tests doesn‚Äôt make this easy. TDD presents a never-ending challenge. You must repeatedly decide which test to write next, how to arrange code so that the test passes, and how much refactoring to do once it does. Each decision requires judgment and has consequences. If your TDD judgment is not yet fully developed, it‚Äôs reasonable to temporarily adopt that of a master. Here‚Äôs an excellent guiding principle:  Quick green excuses all sins. ‚Äî Kent Beck Green means safety. Green indicates that, at least as evidenced by the tests at hand, you understand the problem. Green is the wall at your back that lets you move forward with confidence. Getting to green quickly simplifies all that follows. Because the initial goal is more about reaching green than writing perfect code, the refactoring step sometimes removes duplication and other times retains it. The plan is to create tests that thoroughly describe the ‚Äú99 Bottles‚Äù problem, and then to solve the problem with the implementation known as Shameless Green. The Shameless Green solution strives for maximum understandability but is generally unconcerned with changeability This chapter concentrates on creating the tests and writing simple code to pass them. Future chapters refactor the resulting code to improve the design. 2. 2. Writing the First Test: The first test is often the most difficult to write. At this point, you know the least about whatever it is you intend to do. Your problem is a big, fuzzy, amorphous blob, and it‚Äôs challenging to reach in and carve off a single piece. It feels important to choose well, because where you start informs how you‚Äôll proceed, and ultimately determines where you‚Äôll end. In the beginning, you have ideas about the problem but actually know very little. Your ideas may turn out to be correct, but it‚Äôs just as possible that time will prove them wrong. You can‚Äôt figure out what‚Äôs right until you write some tests, at which time you may realize that the best course of action is to throw everything away and start over. Therefore, the purpose of some of your tests might very well be to prove that they represent bad ideas. Learning which ideas won‚Äôt work is forward progress, however disappointing it may be in the moment. So while it is important to consider the problem and to sketch out an overall plan before writing the first test, don‚Äôt overthink it. If you were to sketch out a public Application Programming Interface (API) for ‚Äú99 Bottles,‚Äù it might look like this:  verse(n) Return the lyrics for the verse number n verses(a, b) Return the lyrics for verses numbered a through b song Return the lyrics for the entire songThis API allows others to request a single verse, a range of verses, or the entire song. Now that you have a plan for the API, there are a number of possibilities for the first test. You could write a test for the entire song, for a series of contiguous verses, or for any single verse. Let‚Äôs begin by testing a single verse: class BottlesTest &lt; Minitest::Test def test_the_first_verse  expected =    99 bottles of beer on the wall,   +    99 bottles of beer. \n  +    Take one down and pass it around,   +    98 bottles of beer on the wall. \n   assert_equal expected, Bottles. new. verse(99) endendThe simple test above assumes a Bottles class with a verse(n) method that returns the 99th verse when called with 99. This test, like all tests, contains three parts:  Setup Create the specific environment required for the test. (Arrange) Do Perform the action to be tested. (Act) Verify Confirm the result is as expected. (Assert)Running that test produces this error: 1) Error: BottlesTest#test_the_first_verse: NameError: uninitialized constant BottlesTest::Bottles test/bottles_test. rb:16:in `test_the_first_verse'TDD tells you to write the simplest code that will pass this test. The above error states that the Bottles class does not yet exist. class BottleendBecause you wrote the test, you can confidently predict that running it a second time will now produce the following error: 1) Error: BottlesTest#test_the_first_verse: NoMethodError: undefined method `verse' for #&lt;Bottles:0x007fde360741f0&gt; test/bottles_test. rb:16:in `test_the_first_verse'Then, add verse method: class Bottle def verse endendRun tests again: 1) Error: BottlesTest#test_the_first_verse: ArgumentError: wrong number of arguments (1 for 0) /Users/skm/Projects/books/99bottles/lib/bottles. rb:6:in `verse' test/bottles_test. rb:16:in `test_the_first_verThen, add the argument that we missed: class Bottle def verse(_) endendRun tests again: 1) Failure: BottlesTest#test_the_first_verse [test/bottles_test. rb:16]: --- expected +++ actual @@ -1,3 +1 @@ - 99 bottles of beer on the wall, 99 bottles of beer.  -Take one down and pass it around, 98 bottles of beer on the wall.  -  +nilMinitest shows the difference between expected and actual output by prefixing the expectedwith ‚Äò-‚Äò and the actual with ‚Äò+‚Äô. Therefore, you can interpret: Minitest expected‚Ä¶  ‚Äú99 bottles of beer on the wall, 99 bottles of beer. ‚Äù followed by a newline, followed by ‚ÄúTake one down and pass it around, 98 bottles of beer on the wall. ‚Äù followed by another newline‚Äùbut instead got nil. Copy the expected output into the verse method: class Bottle def verse(_)   99 bottles of beer on the wall,   +   99 bottles of beer. \n  +   Take one down and pass it around,   +   98 bottles of beer on the wall. \n  endendThe API says that verse takes an argument, but you can make this first test pass without actually using it. Therefore, the argument continues to be named ‚Äú_‚Äù in line 2 above. Although this code passes the test, it clearly doesn‚Äôt solve the entire problem. As a matter of fact, writing a second test will break it. You as the writer of tests know that the verse method must eventually take the value of its argument into account, but you as the writer of code must act in ignorance of this fact. When doing TDD, you toggle between wearing two hats.    While in the ‚Äúwriting tests‚Äù hat, you keep your eye on the big picture and work your way forward with the overall plan in mind.     When in the ‚Äúwriting code‚Äù hat, you pretend to know nothing other than the requirements specified by the tests at hand. Thus, although each individual test is correct, until all are written, the code is incomplete.  2. 3. Removing Duplication: Now that the first test passes, you must decide what to test next. Unearthing Concepts: [Your notes for chapter 3] Practicing Horizontal Refactoring: [Your notes for chapter 4] Separating Responsibilities: [Your notes for chapter 5] Achieving Openness: [Your notes for chapter 6] Manufacturing Intelligence: [Your notes for chapter 7] Developing a Programming Aesthetic: [Your notes for chapter 8] Reaping the Benefits of Design: [Your notes for chapter 9]T "
    }, {
    "id": 28,
    "url": "http://localhost:4000/2025/08/09/session-01.html",
    "title": "POOD Session 1: Write Shameless Green",
    "body": "2025/08/09 - Session 1: Write Shameless GreenDate: August 09, 2025 This blog post consists in four parts:  My notes of the first group session My notes from the video ‚ÄúAll little things‚Äù I had ChatGPT to explain me some concepts A Google NotebookLM link that contains 2 exercises based on the video (quiz and flashcards). Key concepts:  DRY is not always good.  Duplication is far cheaper than the wrong abstraction Make smaller things and let them know about each other as little as possible.  To do good OOP, you need to refactor. To do refactoring, you must have tests.  Open/Closed. Open for extension, closed for modification.  Inheritance Middleman Factory item Small touch on Single Responsibility PrincipleNotes from 1st session: I‚Äôve started a 12-week walkthrough of Practical Object-Oriented Design Course by Sandi Metz, and we‚Äôre reading the first two chapters of 99 botles. Here are the highlights from the first session: We were tasked to watch Sandi Metz‚Äôs talk All the little things (here my notes) and then to complete as much of the coding challenge as possible and make all tests pass within 15 mins. The test was about singing the 99 bottles of beer song which is a song counting down bottles of beer.  SIDE NOTE: I asked chatGPT about this song after I solved the exercise which is wrong. My mentor has always told me to figure out as much as I can on the domain model (the rules and boundaries of the problem). And since it was the first time I knew about this song I missed very important details, for instance: knowing the highest number possible is 99 and the lowest is 0. It may have changed my approach. The tests asserted/expected a concatenated string and at a first glance I identified that numbers and a few words were changing as we were counting down. I tried to follow conventions like short classes, short methods and so on. First, I made sure I was outputting the correct string and then pinpointed the numbers that needed the counting-down, then came up with the method name bottle_count_phrase because it was meant for toggling from the words bottle, bottles and no more bottles (0, 1 or &gt; 1 (greater than 1) respectively) and the integer change by subtracting 1. I tried the first version and it worked, so I advanced to the next test, until I faced the word variation (‚Äúone‚Äù or ‚Äúit‚Äù). After identifying the possible variables, in this case only 2, I first wrote down an if statement, which later became a ternary operator. With these possible paths and having the 4 tests passing (green) this was my solution: class Bottles def verse(characters)  song(characters) end def song(number_of_bottles)   #{bottle_count_phrase(number_of_bottles)} of beer on the wall,   +   #{bottle_count_phrase(number_of_bottles)} of beer. \n  +   Take #{removal_pronoun(number_of_bottles -= 1)} down and pass it around,   +   #{bottle_count_phrase(number_of_bottles)} of beer on the wall. \n  end def bottle_count_phrase(number_of_bottles_remaining)  if number_of_bottles_remaining == 0    no more bottles   elsif number_of_bottles_remaining == 1    #{number_of_bottles_remaining} bottle   else    #{number_of_bottles_remaining} bottles   end end def removal_pronoun(number_of_bottles)  number_of_bottles &gt;= 1 ?  one  :  it  endendAfter this exercise we were encouraged to see Sandi‚Äôs solution which is the following: def song verses(99, 0)enddef verses(upper, lower) upper. downto(lower). map { |i| verse(i) }. join( \n )endcase numberwhen 0  No more bottles of beer on the wall, no more bottles of beer. \nGo to the store and buy some more, 99 bottles of beer on the wall. \n when 1  1 bottle of beer on the wall, 1 bottle of beer. \nTake it down and pass it around, no more bottles of beer on the wall. \n when 2  2 bottles of beer on the wall, 2 bottles of beer. \nTake one down and pass it around, 1 bottle of beer on the wall. \n else  #{number} bottles of beer on the wall, #{number} bottles of beer. \nTake one down and pass it around, #{number-1} bottles of beer on the wall. \n endAs soon as I saw it, felt like my mentor was talking to me again:  Make sure you understand the domain.  Stare at the input, see what changes in the output.  Devise how to achieve those modifications (do I need an array, hash or counter variable to store any type of result?).  If outcome is the expected, then improve. Where I‚Äôm getting with this is, that if I knew that we were only to receive integers as inputs and that the song based on that input, was always going to be the same except the words (‚Äòone‚Äô vs. ‚Äòit‚Äô) and numbers, I could have hardcoded the solution (not saying it‚Äôs an easy approach to come up with) but my approach was thought with more flexible design with interpolation and conditionals but definitely, I overcomplicated the solution. Something that I noticed in this course as in the Effective testing with RSpec by Myron Marston and Ian Dees is that the authors encourage to tackle test one by one even though it sounds obvious to avoid cluttering your terminal with errors, sometimes we want to see the full picture but their approach is very effective. Lesson learned, read thoroughly the problem, understand the inputs, outputs, if possible make a hand-written drawing, understand what changes, what type of data structure? and lastly if the result is the expected, refine it. It also reminds me of the PEDAC method. And we must aim as quick as possible to ‚ÄòShameless Green‚Äô which is a solution that‚Äôs optimized for readability without consideration for future change. We can think of it as the simplest version possible. At the end of this lesson we have the next question? What is the definition of Shameless Green? Possible answers: a) Even thinking about it is embarrassing. b) A solution that‚Äôs optimized for changeability without regard for understandability. c) A solution that‚Äôs optimized for understandability without regard for changeability. ‚úÖ Notes on Sandi Metz‚Äôs talk (video): ‚ÄúAll the Little Things‚Äù:    All the problems we have caused by writting ugly code has the same simple solution.     One piece of advice: make smaller things. Make more classes, more methods and let them know about each other as little as possible.     Metric Flog is a crowd source idea about the complexity of code (Assignments, Branches, Calls). The higher the worse (harder to understand and reason about).     Sandi used to think that she had to understand everything in order to help with anything.     Squint test, is identifying code that can benefit of changing.     Changes in shape (nested conditionals == harder to reason about)     Changes in color, meaning code has different levels of abstractions, therefore it‚Äôs difficult to follow.     When we write code and follow a pattern, if it‚Äôs a good pattern, code gets better. But if it‚Äôs a bad one, we exacerbate the problem. (Example: No one adds 500 lines of code to an ActiveRecord model, they just kept adding more. )     Refactoring is: change its arrangement without altering its behaviour.     To do refactoring, you must have tests.     OOP build seams between objects, they send messages each other. Messages create seams. In prodecual code, it‚Äôs just one flow.     The first refactoring is not going to be neither smart nor clever. But that‚Äôs the whole point. The point is to get to green as quickly as possible.     Write code for one test at the time.     Finish the refactoring before going off on a tangent so keep the duplication.     Duplication is far cheaper than the wrong abstraction.     If you have code that you don‚Äôt understand you have two choices: you can keep it forever or you can write test around it and refactor.     All intermediate refactoring make the code more complex. intermediate complexity leads to ultimate simplicity.     Open/Closed. Open for extension, closed for modification.     Object oriented design is a style guide for arranging code.     With Open/Closed in place we‚Äôd be able to add new behavior without editing existing code.     When you have different prefixes and common suffixes, they‚Äôre candidate to have the prefix as a Class and the suffix as a instance_method. Example:        Before (prefixes and suffixes)   After refactoring                  class GildedRose      def normal_tick       . . .       end     end                   class Normal      def initialize()       . . .       end      def tick       . . .       end     end                      class GildedRose     def brie_tick      . . .      end    end                   class Brie      def initialize()       . . .       end      def tick       . . .       end     end                      class GildedRose     def sulfuras_tick      . . .      end    end                   class Sulfuras      def initialize()       . . .       end      def tick       . . .       end     end             If a purpose of an object is just forwarding messages to someone else, you must ask if it justifies its existance (codesmell is called middleman).     Item factory, it finds the rights object and sends a message to it. (it produces the right kind of item object and then forwards messages)     Inheritance is not evil. You want subclasses to be at the leafnode (at the end) of the object graph (shallow, narrow) and subclasses use all the behaviour of the super class.     Business logic != code configuration  Notes on Middleman and ItemFacory principle with ChatGPT: Ah, I see exactly the part you‚Äôre struggling with. Let me break it down for you clearly, because Sandi Metz is talking about two related ideas here: message forwarding and the ‚Äúmiddleman‚Äù problem. 1Ô∏è‚É£ The Gilded Rose problem Originally, the GildedRose class has one big method (tick) with 43 lines of conditional logic. It checks the type of item (Normal, Brie, Backstage, Sulfuras) and applies the rules for that item. From GildedRose‚Äôs perspective:  It‚Äôs treating items as roles‚Äî‚ÄúI have something that behaves like a Normal item, or like a Brie, etc. ‚Äù But the code treats them as concrete classes‚Äîit looks inside and checks strings, runs conditionals, and manipulates quality and days_remaining directly. Sandi‚Äôs point: we should flip this around‚Äîinstead of Gilded Rose knowing how each item works, each item should know how to ‚Äútick‚Äù itself. GildedRose just asks ‚Äúitem, do your tick. ‚Äù 2Ô∏è‚É£ The ‚Äúmiddleman‚Äù concept A middleman is a class whose only purpose is to forward a message to someone else. For example: class GildedRose def tick_item(item_name)  item = get_item_class(item_name). new  item. tick endendHere:  GildedRose isn‚Äôt doing any real work itself; it just finds the right item class and tells it to do its tick.  That‚Äôs message forwarding. Sandi says: ‚ÄúWhen an object‚Äôs only purpose is to forward messages somewhere else, you have to wonder if it justifies its existence. ‚Äù  If GildedRose only forwards messages and does nothing else, maybe it‚Äôs not necessary.  But in this case, it still has one real responsibility: it figures out which item class to instantiate based on a string. That‚Äôs enough justification for its existence. So GildedRose becomes effectively an item factory: it produces the right kind of item object and then forwards messages. 3Ô∏è‚É£ Why this matters for design By doing this:  Each item class is responsible for its own behavior ‚Üí follows the Single Responsibility Principle.  GildedRose no longer has huge conditionals ‚Üí easier to maintain.  Forwarding messages creates a seam ‚Üí you can easily swap in new item types without touching GildedRose. Before: GildedRose -&gt; lots of if statements -&gt; manipulates every item type directlyAfter: GildedRose -&gt; finds item object -&gt; sends :tickitem object -&gt; handles its own rules From GildedRose‚Äôs point of view, it doesn‚Äôt care what kind of item it is, only that it responds to tick. That‚Äôs duck typing in action. 4Ô∏è‚É£ Why ‚Äúmiddleman‚Äù isn‚Äôt always bad here Yes, a middleman is sometimes unnecessary. But here, GildedRose:  Maps strings to classes (Normal, Brie, Backstage‚Ä¶) Instantiates the correct class Sends tickThat one responsibility makes it justified. Without it, you‚Äôd have to do the mapping everywhere else in your code, which would violate DRY and clarity. ‚úÖ TL;DR  Original GildedRose: knows too much about every item type ‚Üí big, messy conditionals.  Refactored: GildedRose just figures out which object to talk to ‚Üí forwards tick ‚Üí small object design.  Middleman = class that only forwards messages. Sometimes it‚Äôs unnecessary, sometimes it‚Äôs a justified abstraction (here, a factory). ‚Äî End of ChatGPT notes ‚Äî All the little things video exercises Google NotebookLM: In the following link you‚Äôll find 50 flashcards and a 10 questions-quiz based on Sandi‚Äôs video ‚ÄúAll the little things‚Äù It‚Äôs a Google NotebookLM link to exercise Hope you can learn something new ! Here is an sample how the flashcards look like and my result of the exercises: Flashcards on object oriented design talk:   Object oriented design quiz result:   "
    }, {
    "id": 29,
    "url": "http://localhost:4000/2025/08/04/double-testing-mental-model.html",
    "title": "Mental model for writing double tests",
    "body": "2025/08/04 - With my recent journey of gaining more testing experience and with chatGPT on my side, I started looking at some sort of pattern when writing the double testing exercises from the book Efective testing with RSpec by Myron Marston and Ian Dees I shared the idea with the LLM, and it helped me build the following. First thing that poped my mind was the Arrange, Act, Assert so I did used that one to guide the LLM to what type of output I wanted. LLM response: You‚Äôre thinking in exactly the right direction! What you described is essentially the AAA pattern in testing: Arrange, Act, Assert. To help you memorize and internalize it ‚Äî especially when working with test doubles and APIs ‚Äî here‚Äôs a simple mental checklist or mantra you can use, along with a mnemonic: üîÅ The 6-Step ‚ÄúDouble-Driven Test‚Äù Flowüß† Mnemonic: ‚ÄúDUPRAP‚Äù (like ‚ÄúDo a PRAP‚Äù ‚Äî rhymes with ‚Äúwrap‚Äù) Double ‚Äî Use test data ‚Äî Program the mock ‚Äî Request ‚Äî Analyze (parse) ‚Äî Prove (assert) ‚úÖ 1. DoubleSet up your test double (mock the collaborator) let(:ledger) { instance_double('ExpenseTracker::Ledger') } üí° Think: ‚ÄúWho am I faking?‚Äù ‚Äî usually the object under the API, like ledger. ‚úÖ 2. Use Test DataDefine the test data your mock should return expenses = [ { 'payee' =&gt; 'Zoo', 'amount' =&gt; 15. 25, 'date' =&gt; '2017-06-10' }, { 'payee' =&gt; 'Starbucks', 'amount' =&gt; 5. 75, 'date' =&gt; '2017-06-10' }] üí° Think: ‚ÄúWhat result do I want my mock to send back?‚Äù ‚úÖ 3. Program the MockTell your double how to behave allow(ledger). to receive(:expenses_on) . with('2017-06-10') . and_return(expenses) üí° Think: ‚ÄúWhen the test calls this method, return my test data. ‚Äù ‚úÖ 4. RequestTrigger the route via Rack/Test get '/expenses/2017-06-10' üí° Think: ‚ÄúNow I run the actual API code with the test in place. ‚Äù ‚úÖ 5. AnalyzeParse the response so you can assert on it parsed = JSON. parse(last_response. body) üí° Think: ‚ÄúWhat did the API give me back?‚Äù ‚úÖ 6. ProveAssert the expected response expect(parsed). to eq(expenses) üí° Think: ‚ÄúDoes the response match what I expected?‚Äù üß† Bonus: Visual Reminder # 1. Doublelet(:ledger) { instance_double('ExpenseTracker::Ledger') }# 2. Use Test Dataexpenses = [ { 'payee' =&gt; 'Zoo', 'amount' =&gt; 15. 25, 'date' =&gt; '2017-06-10' } ]# 3. Program the Mockallow(ledger). to receive(:expenses_on) . with('2017-06-10') . and_return(expenses)# 4. Requestget '/expenses/2017-06-10'# 5. Analyzeparsed = JSON. parse(last_response. body)# 6. Proveexpect(parsed). to eq(expenses)üìå Final Tip: Turn It into Muscle MemoryEvery time you write a controller- or API-level test, mentally repeat: ‚ÄúDouble, Data, Allow ‚Üí Request, Parse, Expect‚Äù Write 3‚Äì5 of these for different routes, and it‚Äôll stick ‚Äî just like git add, git commit, git push stuck after a week or two. Let me know if you want to turn this into a printable or flashcard! Even though tools like LLM can help us write more code (and tests!) faster than ever, understanding the basics is still on us. At the end of the day, we‚Äôre the ones responsible for making sure the code works and be maintainable. So the better we get at thinking through these steps, the more useful the LLM becomes. Don‚Äôt skip the thinking. "
    }, {
    "id": 30,
    "url": "http://localhost:4000/2025/07/08/breath-first.html",
    "title": "This is a test for Breath first algo",
    "body": "2025/07/08 - Breath first algo "
    }, {
    "id": 31,
    "url": "http://localhost:4000/2025/07/01/algorithm.html",
    "title": "This is a test for Algorithms and Data Structures",
    "body": "2025/07/01 - Algorithm "
    }, {
    "id": 32,
    "url": "http://localhost:4000/2025/06/28/good-enough-testing.html",
    "title": "Good enough testing workshop | notes",
    "body": "2025/06/28 - Recently, I attended a workshop by Lucian Ghinda called Good Enough Testing. The workshop was a great experience, and I learned a lot about testing in Ruby on Rails. Here are my notes from the workshop:  How do you know how many tests are enough? How do you know if your tests are covering enough business logic? When do you stop testing based on risk and time? What kind of bugs are you trying to catch? what does mean to test a feature?We tend to write test on habit or gut feeling. This can be systematic. Taking into consideration the context, we choose coverage criteria (what we pay attention to), and this will drive the test design and test cases we write so we can cover what‚Äôs important with minimum effort. In other words: considering the level of risk, we define test coverage that will drive the test design so that we can achieve 100% coverage with the minimum number of test cases. Objectives of workshop:  Model the universe of all possible test cases.  Define the test coverage that is the most important in the context Identify the minimum number of test cases to achieve 100% of coverage. Do this in a systematic way. 4 test design techniques. Equivalence partitioningBounday value analysisDecision tableState transition workship recording https://goodenoughtesting. com/workshops/5 "
    }, {
    "id": 33,
    "url": "http://localhost:4000/2025/06/10/beyond-recursiveness.html",
    "title": "This is a recursive post",
    "body": "2025/06/10 - Beyond the recursive üîÑ "
    }, {
    "id": 34,
    "url": "http://localhost:4000/2025/05/17/thoughtbot-ebook-testing.html",
    "title": "Testing Rails - Thoughtbot",
    "body": "2025/05/17 - In my journey to improve my testing skills I found this Thoughtbot ebook.  Introduction.  Types of tests.  Intermediate testing.  Antipatterns.  Conclusion. Introduction. : Types of tests. : Intermediate testing. : Antipatterns. : Conclusion. : https://thoughtbot. com/upcase/rails-testing-exercises https://thoughtbot. com/upcase/fundamentals-of-tdd https://thoughtbot. com/upcase/test-driven-rails "
    }, {
    "id": 35,
    "url": "http://localhost:4000/2025/05/02/beyond-programming.html",
    "title": "This is a test for beyond programming",
    "body": "2025/05/02 - Beyond the basics I "
    }, {
    "id": 36,
    "url": "http://localhost:4000/2025/04/16/websockets.html",
    "title": "Websockets post",
    "body": "2025/04/16 - Websockets "
    }, {
    "id": 37,
    "url": "http://localhost:4000/2025/04/11/effective-testing-with-rspec.html",
    "title": "Effective testing with RSpec",
    "body": "2025/04/11 - Recently, I participated in a very competitive interview. When I submitted the code challenge, I felt my weakest area was the testing suite. Even though feedback was not available, being honest with myself and seeing some posts from the reviewers, I decided to dive deeper into testing. I picked up books like Professional Rails Testing by Jason Swett, Hands-On Test Driven Development by Greg Donald, Effective Testing with RSpec by Myron Marston and Ian Dees and even attended a testing workshop by Lucian Ghinda. I had practiced testing before, but I felt it was time to level up and get it closer to the same standard as the rest of my code. Here are the notes, examples, and quotes that stood out to me while reading.  Getting started with RSpec.  From writing specs to running them.  The RSpec way.  Starting On the Outside: Acceptance Specs.  Testing in isolation: Unit specs.  Getting real: Integration specs.  Structuring code examples.  Slicing and dicing specs with metadata.  Configuring RSpec.  Exploring RSpec expectations.  Matchers included in RSpec expectations.  Creating custom matchers.  Understanding test doubles. Part I ‚Äî Chapter 1. Getting Started. : Picture of the book! Where should i put this testing heuristics Given-When-Then scenarios The forward is written by Tom Stewart author of Understanding Computation And he expresses something that picked my curiosity:  After all, the big challenge of test-driven development is not knowing how to write tests, but knowing how to listen to them. For your tests to be worth the bites they are written in, they must be able to speak to you about how well the underlying program is designed and implemented and, crucially, you must be able to hear them. The words and ideas baked into RSpec are carefully chosen to heighten your sensitivity to this kind of feedback. As you play with its expressive little pieces you will develop a test for what a good test looks like, and the occasional stumble over a test that now seems harder or uglier or way more annoying than necessary will start you on a journey of discovery that leads to a better design for that part of your code base. ‚Äù In the introduction we see different quotes like our tests are broken again! Why does the suite take so long to run? What value are we getting from this test anyway?No matter whether you are new to automated tests or helping using them for years, this book will help you write more effective tests. by effective, we mean tests that give you more value than the time spent writing them. This book you will learn RSpec in three phases: Part I: Introductory exercises to get you acquainted with respectPart II: A work example spanning several chapters, so that you can see RSpecin action on a meaningful sized projectPart III-V: A series of deep dives into specific aspects of RSpec, which will have you get the most out of RSpec RSpec and behavior driven development: RSpec bills itself as a Behavior Driven Development (BDD) test framework. I would like to take a moment to talk about our use of that term, along with the related term, Test Driven Development (TDD). With TDD, you write each test case just before implementing the next bit of behavior. When you have a well written test, you wind up with more maintainable code. you can make changes with the confidence that your test suite will let you know if you have broken something. It is about the way they enable fearless improvements to your design. BDD brings the emphasis to where it is supposed to be: your code‚Äôs behavior.  RSpec is a productive Ruby test framework. we say productive because everything about it, its style, api, libraries, and settings are designed to support you as you write great software. We have a specific definition of effective here, does this test pay for the cost of writing and running it? A good test will provide at least one of these benefits:    design guidance: helping you distill all those fantastic ideas in your head into running, maintainable code     safety net: finding errors in your code before your customers do     documentation:capturing the behavior of a working system to help it‚Äôs maintainers  As you follow along through the examples in this book, you will practice several habits that will help you test effectively: When you describe precisely what you want your program to do, you avoid being too strict ( and failing when an irrelevant detail changes) or too lax (and getting false Confidence from incomplete tests). By writing your specs to report failure at the right level of detail, you give just enough information to find the cause of the problem, without drawing in excessive output. By clearly separating essential test code from noisy setup code, you communicate what‚Äôs exactly expected of the application, and you avoid repeating unnecessary detail. When you reorder, profile, and filter your specs, you unearth order dependencies, slow tests and incomplete work. Installing RSpec. It is made of three independent ruby gems: rspec-core: is the overall test harness that runs your specs. rspec-expectations: provides a readable, powerful Syntax for checking properties of your code. rspec-mocks: makes it easy to isolate the code you are testing from the rest of the system. ‚ûú rspec-book rbenv local 3. 4. 2‚ûú rspec-book rbenv rehash‚ûú rspec-book ruby -vruby 3. 4. 2 (2025-02-15 revision d2930f8e7a) +PRISM [arm64-darwin24]‚ûú rspec-book bundle initWriting new Gemfile to /Users/dominiclizarraga/code/dominiclizarraga/rspec-book/Gemfile‚ûú rspec-book bundle add rspecFetching gem metadata from https://rubygems. org/. . . Resolving dependencies. . . Fetching gem metadata from https://rubygems. org/. Fetching diff-lcs 1. 6. 2Fetching rspec-support 3. 13. 4Installing rspec-support 3. 13. 4Installing diff-lcs 1. 6. 2Fetching rspec-core 3. 13. 4Fetching rspec-expectations 3. 13. 5Fetching rspec-mocks 3. 13. 5Installing rspec-core 3. 13. 4Installing rspec-expectations 3. 13. 5Installing rspec-mocks 3. 13. 5Fetching rspec 3. 13. 1Installing rspec 3. 13. 1Note: The book suggests to use gem install rspec however I think it‚Äôs important to remember that, that command will install the library globally to that Ruby version so if you want to avoid that and narrow the impact that this installation may have, I suggest to create its own directory and use bundle init which will create a Gemfile and then you can add rspec gem to the Gemfile or use bundle add rspec. This will set this rspec version only to this project. Let‚Äôs write our first spec üòÅ The book starts with the very simple example of building a sandwich. What‚Äôs the most important property of a sandwich? the bread? the condiments? No, the most important thing about a sandwich is that it should taste good. RSpec uses the words describe a it to express concepts in a conversational format:  ‚ÄúDescribe an ideal sandwich‚Äù ‚ÄúFirst, it is delicious‚Äù01-getting-started/01/spec/sandwich_spec. rbRSpec. describe ‚ÄúAn ideal sandwich‚Äù do it ‚Äúis delicious‚Äù do  # developers work this way with RSpec all the time; they start with an outline and fill it in as they go.  endendThen let‚Äôs add the classes and methods 01-getting-started/01/spec/sandwich_spec. rbRSpec. describe ‚ÄúAn ideal sandwich‚Äù do it ‚Äúis delicious‚Äù do  sandwich = sandwich. new(‚Äúit‚Äôs delicious‚Äù, [])  taste = sandwich. taste  expect(sandwich). to eq(‚Äúit‚Äôs delicious‚Äù) endendThis file defines your test, known in RSpec as your specs, short for a specification (because they specify the desired behavior of your code). The outer describe block creates an example group ‚Äì an example group defines what you are testing, in this case, a sandwich, and keeps related specs together. The nested block, the one beginning with it, is an example of the sandwich‚Äôs use. As you write specs, you will tend to keep each example focused on one particular size of behavior you are testing.  This first paragraphs reminds me of Jason Swett‚Äôs book on how many times he stresses to the readers that tests are a specifications not validations! I was able to count at least 8 times that he mentions that for example:A specification is a statement of how some aspect of a software product should behave. Remember that testing is about a specification, not verification.  A test suite is a structured collection of behavior specifications. Differences between tests, specs and examples: ‚Ä¢ A test validates that a bit of code is working properly. ‚Ä¢ A spec describes the desired behavior of a bit of code. ‚Ä¢ An example shows how a particular API is intended to be used. In the bits of code that we wrote we can clearly see the pattern arrange/act/assert. The last line with the expect keyword is the assertion in other test frameworks. Let‚Äôs look at the RSpec methods we‚Äôve used: ‚Ä¢ RSpec. describe creates an example group (set of related tests). ‚Ä¢ it creates an example (individual test). ‚Ä¢ expect verifies an expected outcome (assertion). Up to this point this spec serves two purposes: documenting what your sandwich should do and checking that the sandwich does what it is supposed to. (Lovely, isn‚Äôt it? ü§å) Let‚Äôs run the test and see what happens. (We‚Äôll start reading common error tests) $ ‚ûú rspec-book git:(master) ‚úó bundle exec rspec 01-getting-started/01/spec/sandwich_spec. rbFFailures: 1) An ideal sandwich is delicious   Failure/Error: sandwich = Sandwich. new( delicious , [])     NameError:    uninitialized constant Sandwich   # . /01-getting-started/01/spec/sandwich_spec. rb:8:in 'block (2 levels) in &lt;top (required)&gt;'Finished in 0. 00539 seconds (files took 0. 09368 seconds to load)1 example, 1 failureFailed examples:rspec . /01-getting-started/01/spec/sandwich_spec. rb:6 # An ideal sandwich is deliciousHere we can see that RSpec gives us a detailed report showing us the line of code where the error occurred, and the description of the problem, in this case sandwich has not been initialized. With this we are following Red/Green/Refactor development practice essential to TDD and BDD. With this workflow, you‚Äôll make sure each example catches failing or missing code before you implement the behavior you‚Äôre testing. The next step after writing a failing spec is to make it pass. # add to the top of the file `Sandwich = Struct. new(:taste, :toppings)` # more about [Structs official docs](https://rubyapi. org/3. 4/o/struct) and [Stackoverflow](https://stackoverflow. com/questions/25873672/ruby-class-vs-struct)# re-run the testsYou should see now a green dot ‚Äú. ‚Äù and 0 failures ‚ûú rspec-book git:(master) ‚úó bundle exec rspec 01-getting-started/01/spec/sandwich_spec. rb. Finished in 0. 00578 seconds (files took 0. 07271 seconds to load)1 example, 0 failuresLet‚Äôs add a second spec! Sandwich = Struct. new(:taste, :toppings)RSpec. describe  An ideal sandwich  do it  is delicious  do  # Developers work this way with RSpec all the time; they start with an outline and fill it in as they go  sandwich = Sandwich. new( delicious , [])  taste = sandwich. taste  expect(taste). to eq( delicious ) end it  lets me add toppings  do  # Developers work this way with RSpec all the time; they start with an outline and fill it in as they go  sandwich = Sandwich. new( delicious , [])  sandwich. toppings &lt;&lt;  cheese   toppings = sandwich. toppings  expect(toppings). not_to be_empty endendThis example shows 2 new features, check for falsehood (using . not_to instead of . to) and check for data structure attributes But also they are repetitive, let‚Äôs introduce 3 new RSpec features: ‚Ä¢ RSpec hooks run automatically at specific times during testing. ‚Ä¢ Helper methods are regular Ruby methods; you control when these run. ‚Ä¢ RSpec‚Äôs let construct initializes data on demand. To avoid the repetitiveness that the prior code shows, let‚Äôs start using what we described previously hooks, helper methods, let. Hooks The first thing that we will try in our test Suite is a before hook, which will run automatically before each example. (it reminds me to ActiveRecord callbacks) RSpec. describe  An ideal sandwich  do before { @sandwich = Sandwich. new( delicious , []) }  it  is delicious  do  taste = @sandwich. taste  expect(taste). to eq( delicious ) end it  lets me add toppings  do  @sandwich. toppings &lt;&lt;  cheese   toppings = @sandwich. toppings  expect(toppings). not_to be_empty endendThe setup code is shared across specs, but the individual Sandwich instance is not. Every example gets its own sandwich. That means that you can add toppings as you do in the second spec, with the confidence that the changes won‚Äôt affect other examples. RSpec keeps track of all the hooks you have registered. Each time RSpec is about to start running one of your examples, it will run any `before` hooks that apply.  `hooks` are great for running, setup code that has real-world side effects. If you need to clear out a test database before each example, a hook is a great place to do so. Here are some drawbacks from `hooks`: First, If you misspelled `@sandwich`, Ruby will silently return `nil` instead of aborting with a failure right away. The result is typically a confusing error message. Second, to refactor your specs to use instance variables, you have had to go through the entire file and replace `sandwich` with `@sandwich`. Finally, when you initialize an instance variable maybe `before hook`, you pay the cost of that setup time for all the examples in the group even if some of them never use the instance variable. That is inefficient and can be quite noticeable. Let‚Äôs try a different approach. (a more traditional Ruby approach) RSpec does a lot for us; it is easy to forget that it is just playing Ruby underneath. Each example group is a ruby class, which means that we can define methods on it. RSpec. describe  An ideal sandwich  do def sandwich  @sandwich ||= Sandwich. new( delicious , []) end it  is delicious  do  taste = sandwich. taste  expect(taste). to eq( delicious ) end it  lets me add toppings  do  sandwich. toppings &lt;&lt;  cheese   toppings = sandwich. toppings  expect(toppings). not_to be_empty endendA typical Ruby implementation might look something like the one we just wrote which uses memoization. This pattern is pretty easy to find in Ruby but it is not without its pitfalls. the ||= operator works by seeing if @sandwich is falsey, that is, false or nil, before creating a new @sandwich. That means that it won‚Äôt work if we are actually trying to store something falsey. Sharing objects with let RSpec gives us an alternative construct, let. Which handles the edge case that we previously discussed with memoization. You can think of let as assigning a name ‚Äî in this case, :sandwich ‚Äî to the result of a block. This block is lazily evaluated, meaning RSpec will only run it the first time :sandwich is accessed within an example. The result is then memoized (cached) for the remainder of that example. Our recommendation is to use these code-sharing techniques where they improve maintainability, lesson noise, and increase clarity. RSpec. describe  An ideal sandwich  do let (:sandwich) { Sandwich. new( delicious , []) } # [let official docs](https://rspec. info/features/3-13/rspec-core/helper-methods/let/) it  is delicious  do  taste = sandwich. taste  expect(taste). to eq( delicious ) end it  lets me add toppings  do  sandwich. toppings &lt;&lt;  cheese   toppings = sandwich. toppings  expect(toppings). not_to be_empty endendClaude convo about let At the end of the chapter there is a ‚ÄúYour turn‚Äù section where the author encouraged you to respond a couple of questions and for the first chapter they asked the following: Which of the three ways to reduce duplication that we have shown to you do you like the best for this example? Why? Can you think of situations where the others might be a better option? As all good engineering questions it depends as we have seen the first one which was the before hook, it is very clean, it reads good however we saw that it has some drawbacks, like it would return nil if the instance variable is misspelled and all the refactor gymnastics that it implies for refactoring just one file even when the instance variable is not used in a group example. Then the helper method has the memoization problem and finally they let alternative covers those issues. Some extra coding for solidifying let knowledge: RSpec. describe  An ideal sandwich  do let(:sandwich) { Sandwich. new( delicious , []) }  it  is delicious  do  puts  Example 1 - Sandwich object_id: #{sandwich. object_id}   # Example 1 - Sandwich object_id: 1232  taste = sandwich. taste  expect(taste). to eq( delicious ) end it  lets me add toppings  do  puts  Example 2 - Sandwich object_id: #{sandwich. object_id}   # Example 2 - Sandwich object_id: 1240  sandwich. toppings &lt;&lt;  cheese   toppings = sandwich. toppings  expect(toppings). not_to be_empty endend# within same group exampleit  uses the same object within one example  do puts  First call: #{sandwich. object_id}  # First call: 1248 sandwich. toppings &lt;&lt;  cheese   puts  Second call: #{sandwich. object_id}  # Same object! # Second call: 1248 expect(sandwich. toppings). to include( cheese ) # Cheese is still thereendA recap of Chapter 1: We explored the describe block, which is called on a group of examples, and the it block, which is called an example (or a test case in some other testing frameworks). We covered the expect keyword. We also looked at the Arrange-Act-Assert pattern. We thoroughly read through test failures and what they mean. We understood that testing serves two purposes: documenting what the code should do, and checking that the code does what it‚Äôs supposed to do. We explored how to negate an expectation, and how to test collections such as arrays and hashes. Finally, we saw three different ways of reducing code in tests: hooks, Ruby helper methods, and the let construct. Part I ‚Äî Chapter 2. From writing specs to running them. : # Add the next file 01-getting-started/01/spec/coffee_spec. rbclass Coffee def ingridients  @ingridients ||= [] end def add(ingridient)  ingridients &lt;&lt; ingridient end def price  1. 00 endendRSpec. describe  A cup of coffee  do let(:coffee) { Coffee. new } it  costs $1  do  expect(coffee. price). to eq(1) end context  with milk  do  before { coffee. add :milk }  it  costs $1. 25  do   expect(coffee. price). to eq(1. 25)  end endendAnd in this chapter we explore the --format documentation ‚ûú rspec-book git:(master) bundle exec rspec 01-getting-started/01 --format documentationA cup of coffee costs $1 with milk  costs $1. 25 (FAILED - 1)An ideal sandwich is delicious lets me add toppingsFailures: 1) A cup of coffee with milk costs $1. 25   Failure/Error: expect(coffee. price). to eq(1. 25)      expected: 1. 25      got: 1. 0      (compared using ==)   # . /01-getting-started/01/spec/coffee_spec. rb:25:in 'block (3 levels) in &lt;top (required)&gt;'Finished in 0. 01762 seconds (files took 0. 08827 seconds to load)4 examples, 1 failureFailed examples:rspec . /01-getting-started/01/spec/coffee_spec. rb:24 # A cup of coffee with milk costs $1. 25Another suggestion from the book is adding the gem coderay which highlights with different colors the line that is failing. This is particularly useful when dealing with complex tests suites. bundle exec rspec 01-getting-started/01 -fd (see the expect and 1. 25) Another tool that is shown in this chapter is how to identify a slow test by adding --profile n (n is the number of offenders we‚Äôd like to see) # 01-getting-started/01/spec/slow_spec. rbRSpec. describe  The sleep() method  do it( can sleep for 0. 1 seconds ) { sleep 0. 1 } it( can sleep for 0. 2 seconds ) { sleep 0. 2 } it( can sleep for 0. 3 seconds ) { sleep 0. 3 } it( can sleep for 0. 4 seconds ) { sleep 0. 4 } it( can sleep for 0. 5 seconds ) { sleep 0. 5 }end# $ bundle exec rspec 01-getting-started/01 -fd --profile 2The sleep() method can sleep for 0. 1 seconds can sleep for 0. 2 seconds can sleep for 0. 3 seconds can sleep for 0. 4 seconds can sleep for 0. 5 secondsTop 2 slowest examples (0. 90852 seconds, 58. 8% of total time): The sleep() method can sleep for 0. 5 seconds  0. 50321 seconds . /01-getting-started/01/spec/slow_spec. rb:6 The sleep() method can sleep for 0. 4 seconds  0. 40531 seconds . /01-getting-started/01/spec/slow_spec. rb:5Finished in 1. 54 seconds (files took 0. 0894 seconds to load)5 examples, 0 failuresAlso this chapter covers how to run specific tests when you don‚Äôt need to run the whole test suite (from directories, to files to even just examples). $ rspec spec/unit/specific_spec. rb # Load just one spec file$ rspec spec/unit spec/foo_spec. rb # Or mix and match files and directoriesExample for running examples that contains word ‚Äúmilk‚Äù (searches arecase-sensitive) $ bundle exec rspec 01-getting-started/01 -e milk -fd Run options: include {full_description: /milk/}A cup of coffee with milk  costs $1. 25 (FAILED - 1)Failures: 1) A cup of coffee with milk costs $1. 25   Failure/Error: expect(coffee. price). to eq(1. 25)      expected: 1. 25      got: 1. 0      (compared using ==)   # . /01-getting-started/01/spec/coffee_spec. rb:25:in 'block (3 levels) in &lt;top (required)&gt;'Finished in 0. 0128 seconds (files took 0. 06799 seconds to load)1 example, 1 failureAnd if you need to run only one example or test case, you can pass rspec 01-getting-started/01/spec/coffee_spec. rb:25 and RSpec will run the example that starts on that line. Rerunning Everything That Failed There is one RSpec command that allows you to run just exactly the failing specs, this is pretty useful as the last command because you avoid running the whole test suite and you can fix one spec, rerun it, fix the next one and so on let‚Äôs dive in # here we can see that same error is being brought up, example: `with milk costs $1. 25`‚ûú rspec-book git:(master) ‚úó bundle exec rspec 01-getting-started/01/. F. . . . . . . Failures: 1) A cup of coffee with milk costs $1. 25   Failure/Error: expect(coffee. price). to eq(1. 25)      expected: 1. 25      got: 1. 0      (compared using ==)   # . /01-getting-started/01/spec/coffee_spec. rb:29:in 'block (3 levels) in &lt;top (required)&gt;'Finished in 1. 55 seconds (files took 0. 08332 seconds to load)9 examples, 1 failureFailed examples:rspec . /01-getting-started/01/spec/coffee_spec. rb:28 # A cup of coffee with milk costs $1. 25Then we add the command --only-failures at the end and this will ask us for a path to write the last run diagnosis, in this case we added: ‚ûú rspec-book git:(master) ‚úó bundle exec rspec 01-getting-started/01/ --only-failuresTo use `--only-failures`, you must first set `config. example_status_persistence_file_path`. # add this config lineRSpec. configure do |config| config. example_status_persistence_file_path = 'spec/examples. txt'endWhich will add a spec/examples. txt file with details as the following:       example_id   status   run_time         . /01-getting-started/01/spec/coffee_spec. rb[1:1]   passed   0. 00064 seconds       . /01-getting-started/01/spec/coffee_spec. rb[1:2:1]   failed   0. 01486 seconds       . /01-getting-started/01/spec/sandwich_spec. rb[1:1]   passed   0. 00007 seconds       . /01-getting-started/01/spec/sandwich_spec. rb[1:2]   passed   0. 00163 seconds       . /01-getting-started/01/spec/slow_spec. rb[1:1]   passed   0. 10517 seconds       . /01-getting-started/01/spec/slow_spec. rb[1:2]   passed   0. 20549 seconds       . /01-getting-started/01/spec/slow_spec. rb[1:3]   passed   0. 30431 seconds       . /01-getting-started/01/spec/slow_spec. rb[1:4]   passed   0. 40278 seconds       . /01-getting-started/01/spec/slow_spec. rb[1:5]   passed   0. 50561 seconds   Finally, when we re-run the --only-failures it will search for that ‚Äúfailed status‚Äù and run only that one! You can see it below: ‚ûú rspec-book git:(master) ‚úó bundle exec rspec 01-getting-started/01/ --only-failuresRun options: include {last_run_status:  failed } üëàFFailures: 1) A cup of coffee with milk costs $1. 25   Failure/Error: expect(coffee. price). to eq(1. 25)      expected: 1. 25      got: 1. 0      (compared using ==)   # . /01-getting-started/01/spec/coffee_spec. rb:29:in 'block (3 levels) in &lt;top (required)&gt;'Finished in 0. 01276 seconds (files took 0. 08701 seconds to load)1 example, 1 failureFailed examples:rspec . /01-getting-started/01/spec/coffee_spec. rb:28 # A cup of coffee with milk costs $1. 25The usage of command rspec ‚Äìnext-failure rspec-book git:(master) ‚úó bundle exec rspec 02-running-specs# above command created spec/tea_examples. txtexample_id             | status | run_time    |----------------------------------- | ------ | --------------- |. /02-running-specs/tea_spec. rb[1:1] | failed | 0. 0001 seconds |. /02-running-specs/tea_spec. rb[1:2] | failed | 0. 00005 seconds |02-running-specs/tea_spec. rbclass TeaendRSpec. configure do |config| config. example_status_persistence_file_path = 'spec/tea_examples. txt'endRSpec. describe  Tea  do let(:tea) { Tea. new } it  tastes like Earl Grey  do  expect(tea. flavor). to be :earl_grey end it  is hot  do  expect(tea. temperature). to be &gt; 200. 0 endend‚ûú rspec-book git:(master) ‚úó bundle exec rspec 02-running-specs      FFFailures: 1) Tea tastes like Earl Grey   Failure/Error: expect(tea. flavor). to be :earl_grey     NoMethodError:    undefined method 'flavor' for an instance of Tea   # . /02-running-specs/tea_spec. rb:11:in 'block (2 levels) in &lt;top (required)&gt;' 2) Tea is hot   Failure/Error: expect(tea. temperature). to be &gt; 200. 0     NoMethodError:    undefined method 'temperature' for an instance of Tea   # . /02-running-specs/tea_spec. rb:15:in 'block (2 levels) in &lt;top (required)&gt;'Finished in 0. 00362 seconds (files took 0. 08398 seconds to load)2 examples, 2 failuresFailed examples:rspec . /02-running-specs/tea_spec. rb:10 # Tea tastes like Earl Greyrspec . /02-running-specs/tea_spec. rb:14 # Tea is hotThen we add the option ‚Äìnext-failure and it will only run the very next failure, not the whole test suite. $ bundle exec rspec 02-running-specs --next-failureRun options: include {last_run_status:  failed }FFailures: 1) Tea tastes like Earl Grey   Failure/Error: expect(tea. flavor). to be :earl_grey     NoMethodError:    undefined method 'flavor' for an instance of Tea   # . /02-running-specs/tea_spec. rb:11:in 'block (2 levels) in &lt;top (required)&gt;'Finished in 0. 00049 seconds (files took 0. 08649 seconds to load)1 example, 1 failureFailed examples:rspec . /02-running-specs/tea_spec. rb:10 # Tea tastes like Earl GreyThis chapter focused on how specs should look and how they can be run. It began with the introduction of the context block, which is an alias for describe. However, it has a more specific and useful purpose: it‚Äôs often used for phrases that describe a particular state or condition of the object being tested. We learned about the command rspec --format documentation or --f d, which separates group examples from individual examples and adds indentation to visually show nesting‚Äîsuch as one or two levels deep. We also explored the gem called coderay, which adds color to test output, making it easier to scan for failures. Additionally, we covered the command rspec --profile 2, which helps identify the slowest-running tests. Next, we learned about the rspec --example word command, which allows us to run only the group examples or examples that match the given word. Then, we explored how to run a specific test by including the line number in the command, like so:rspec . /spec/coffee_spec. rb:25. We also discovered a very useful command: rspec --only-failures. This runs only the tests that failed in the previous run by using a file that stores the status of each example. We then looked into running tests in focused mode‚Äîallowing us to run only specific context, it, or describe blocks by tagging them. We can assign custom tags and then pass those tags when running rspec to filter the examples accordingly. Another feature we explored was how to sketch out the test suite when you have more ideas in mind than time to implement them. You can use an it block with just a description (without a body), which RSpec treats as pending. You can also mark tests as incomplete using pending, skip, or xit. Finally, we covered the --next-failure command, which runs only the next failing test from the previous run.       Command   Description         rspec ‚Äìformat documentation   Displays test output with indentation to show nesting of examples.        rspec ‚Äìprofile 2   Shows the 2 slowest-running tests to help identify performance bottlenecks.        rspec ‚Äìexample word   Runs only the examples that match the given word.        rspec . /spec/filename_spec. rb:25   Runs only the test located on line 25 of the specified file.        rspec ‚Äìonly-failures   Runs only the tests that failed in the previous run.        rspec ‚Äìnext-failure   Runs the next failing test from the last run.    Part I ‚Äî Chapter 3. The RSpec Way. : All these prior features of RSpec are designed to make certain habits easy:‚Ä¢ Writing examples that clearly spell out the expected behavior of the code‚Ä¢ Separating common setup code from the actual test logic‚Ä¢ Focusing on just what you need to do to make the next spec pass Writing specs isn‚Äôt the goal of using RSpec‚Äîit‚Äôs the benefits those specs provide. Let‚Äôs talk about those benefits now; they‚Äôre not all as obvious as ‚Äúspecs catch bugs. ‚Äù  Specs increase confidence in your project ‚Ä¢ The ‚Äúhappy path‚Äù through a particular bit of code behaves the way you want it to. ‚Ä¢ A method detects and reacts to an error condition you‚Äôre anticipating. ‚Ä¢ That last feature you added didn‚Äôt break the existing ones. ‚Ä¢ You‚Äôre making measurable progress through the project.  Eliminating fear     With broad test coverage, developers find out early if new code is breaking existing features.     Enabling refactoring Without a good set of specs, refactoring is a daunting task.  Our challenge as developers is to structure our projects so that big changes are easy and predictable. As Kent Beck says, ‚Äúfor each desired change, make the change easy (warning: this may be hard), then make the easy change. ‚Äù Guiding design If you write your specs before your implementation, you‚Äôll be your own first client.  As counterintuitive as it may sound, one of the purposes of writing specs is to cause pain‚Äîor rather, to make poorly designed code painful.  Sustainability RSpec may slow initial development but ensures faster, safer future changes‚Äîunless the project is small, static, or disposable.  Documenting behavior.  Transforming your workflow     Each run of your suite is an experiment you‚Äôve designed in order to validate (or refute) a hypothesis about how the code behaves.     You get fast, frequent feedback when something doesn‚Äôt work, and you can change course immediatelyRunning the entire suiteConsider the difference between a test suite taking 12 seconds and one taking 10 minutes. After 1,000 runs, the former has taken 3 hours and 20 minutes. The latter has cumulatively taken nearly 7 days. Deciding what not to testEvery behavior you specify in a test is another point of coupling between your tests and your project code. That means you‚Äôll have one more thing you‚Äôll have to fix if you ever need to change your implementation‚Äôs behavior. If you do need to drive a UI from automated tests, try to test in terms of your problem domain (‚Äúlog in as an administrator‚Äù) rather than implementation details (‚Äútype admin@example. com into the third text field‚Äù). Another key place to show restraint is the level of detail in your test assertions. Rather than asserting that an error message exactly matches a particular string (‚ÄúCould not find user with ID 123‚Äù), consider using substrings to match just the key parts (‚ÄúCould not find user‚Äù). Likewise, don‚Äôt specify the exact order of a collection unless the order is important. Part II ‚Äî Building an app with RSpec. : Part II ‚Äî Chapter 4. Building an App With RSpec. : In this chapter authors decide to build an expense tracker app where users can add/search expenses. It will use Sinatra as router and not rails since we don‚Äôt need background workers, mailers, views, asset pipelie and so on. We need a small JSON APIs and Sinatra will do the job. Acceptance specs =&gt; which checks the behavior of the application as a whole. By the end of the chapter, we‚Äôll have the skeleton of a live app and a spec to test it (It makes me think like a smoke check for the core flow. ) Also, we used a ‚Äúoutside-in development‚Äù which means start working at outermost layer (the HTTP request/response cycle) and work your way inward to the classes and methods that contain the logic. Create a directory and add bundler # 04-acceptance-specs/# add ENV['RACK_ENV'] = 'test' to spec_helper. rb# add bundler as package manager`bundle init`# then in the Gemfile file add the next gemsgem  rspec ,  ~&gt; 3. 13 gem  coderay  # easy-to-read, syntax-highlightedgem 'rack-test' # provide an API for testsgem 'sinatra' # implement the web application# then run `bundle install` and `bundle exec rspec --init`, which will create:`. rspec` # contains rspec command line flags`spec/spec_helper. rb` # contains configuration optionsIt‚Äôs easy to feel overwhelmed as we‚Äôre deciding what to test first. Where do we start? What‚Äôs thecore of the project? What‚Äôs the one thing we agree our API should do? It should faithfully save the expenses we record. We‚Äôre only going to use two of the most basic features of HTTP in these examples:‚Ä¢ A GET request reads data from the app. ‚Ä¢ A POST request modifies data. First testing run üèÉ require 'rack/test'require 'json'module ExpenseTracker RSpec. describe 'Expense Tracker API' do  include Rack::Test::Methods  it 'records submitted expenses' do   coffee = {   'payee' =&gt; 'Starbucks',   'amount' =&gt; 5. 75,   'date' =&gt; '2025-06-10'   }   post '/expenses', JSON. generate(coffee) # This will simulate an HTTP POST request (it's a Rack::Test helper)  end endendIn the console we run bundle exec rspec 04-acceptance-specs/01/expense_tracker/spec/expense_tracker_api_spec. rb and we get the next error: FFailures: 1) Expense Tracker API records submitted expenses   Failure/Error: post '/expenses', JSON. generate(coffee)     NameError:    undefined local variable or method 'app' for #&lt;RSpec::ExampleGroups::ExpenseTrackerAPI:0x000000011e93b538&gt;   # . /04-acceptance-specs/01/expense_tracker/spec/expense_tracker_api_spec. rb:14:in 'block (2 levels) in &lt;module:ExpenseTracker&gt;'Finished in 0. 00161 seconds (files took 0. 15436 seconds to load)1 example, 1 failureFailed examples:rspec . /04-acceptance-specs/01/expense_tracker/spec/expense_tracker_api_spec. rb:8 # Expense Tracker API records submitted expensesGiven error tells us that we cannot use app because we have not defined it yet, so let‚Äôs add it (temporaly with a ruby helper method. ) # 04-acceptance-specs/01/expense_tracker/spec/expense_tracker_api_spec. rb  def app   ExpenseTracker::API. new  end  it 'records submitted expenses' do   . . .   end# 04-acceptance-specs/01/expense_tracker/app/api. rbrequire 'sinatra/base'require 'json'module ExpenseTracker class API &lt; Sinatra::Base # This class defines the barest skeleton of a Sinatra app.  endendNow, by adding ExpenseTracker::API and the app method we‚Äôre verifying only that the POST request completes without crashing the app. Let‚Äôs check the response FFailures: 1) Expense Tracker API records submitted expenses   Failure/Error: expect(last_response. status). to eq(200)      expected: 200      got: 404      (compared using ==)   # . /04-acceptance-specs/01/expense_tracker/spec/expense_tracker_api_spec. rb:21:in 'block (2 levels) in &lt;module:ExpenseTracker&gt;'Finished in 0. 02102 seconds (files took 0. 20637 seconds to load)1 example, 1 failureWe need to add the route for this: # 04-acceptance-specs/01/expense_tracker/app/api. rb post '/expenses' do endLet‚Äôs fill the body of the response, we start from the testing, in this case parsing the response # 04-acceptance-specs/01/expense_tracker/spec/expense_tracker_api_spec. rb it 'records submitted expenses' do  coffee = {   'payee' =&gt; 'Starbucks',   'amount' =&gt; 5. 75,   'date' =&gt; '2017-06-10'  }  post '/expenses', JSON. generate(coffee)  p last_response  expect(last_response. status). to eq(200)  parsed = JSON. parse(last_response. body) üëà  expect(parsed). to include('expense_id' =&gt; a_kind_of(Integer)) üëà endThen in our API we are going to fool the response with the following:  # 04-acceptance-specs/01/expense_tracker/app/api. rb post '/expenses' do  JSON. generate('expense_id' =&gt; 42) endAnd as we‚Äôre inspecting the last_response we can see the @body contains the hash with key as expense_id and value as 42. -specs/01/expense_tracker/spec/expense_tracker_api_spec. rb#&lt;Rack::MockResponse:0x000000011db1ba48 @original_headers={ content-type  =&gt;  text/html;charset=utf-8 ,  content-length  =&gt;  17 ,  x-xss-protection  =&gt;  1; mode=block ,  x-content-type-options  =&gt;  nosniff ,  x-frame-options  =&gt;  SAMEORIGIN }, @errors=  , @status=200, @headers={ content-type  =&gt;  text/html;charset=utf-8 ,  content-length  =&gt;  17 ,  x-xss-protection  =&gt;  1; mode=block ,  x-content-type-options  =&gt;  nosniff ,  x-frame-options  =&gt;  SAMEORIGIN }, @writer=#&lt;Method: Rack::MockResponse(Rack::Response::Helpers)#append(chunk) /Users/dominiclizarraga/. rbenv/versions/3. 4. 2/lib/ruby/gems/3. 4. 0/gems/rack-3. 1. 16/lib/rack/response. rb:359&gt;, @block=nil, @body=[ {\ expense_id\ :42} ], @buffered=true, @length=17, @cookies={}&gt;Saving expenses is all fine and good, but it‚Äôd be nice to retrieve them. Let‚Äôs fetch expenses by date. Let‚Äôs start by adding more expenses: # within the example 'records submitted expenses' add these 2 hashes  it 'records submitted expenses' do   zoo = post_expense(    'payee' =&gt; 'Zoo',    'amount' =&gt; 15. 25,    'date' =&gt; '2017-06-10'   )    groceries = post_expense(    'payee' =&gt; 'Whole Foods',    'amount' =&gt; 95. 20,    'date' =&gt; '2017-06-11'   )    coffee = post_expense(    'payee' =&gt; 'Starbucks',    'amount' =&gt; 5. 75,    'date' =&gt; '2017-06-10'   )   get '/expenses/2017-06-10'   expect(last_response. status). to eq(200)   expenses = JSON. parse(last_response. body)   expect(expenses). to contain_exactly(coffee, zoo)  endAnd as you may see we added the post_expense(expense) method, so add it within describe block:  def post_expense(expense)  post '/expenses', JSON. generate(expense)  expect(last_response. status). to eq(200)  parsed = JSON. parse(last_response. body)  expect(parsed). to include('expense_id' =&gt; a_kind_of(Integer))  expense. merge('id' =&gt; parsed['expense_id']) endWhen you run the test suite bundle exec rspec 04-acceptance-specs/01/expense_tracker/spec/expense_tracker_api_spec. rb you should see an error like this: Failures: 1) Expense Tracker API records submitted expenses   Failure/Error: expect(expenses). to contain_exactly(coffee, zoo)      expected collection contained: [{ amount  =&gt; 5. 75,  date  =&gt;  2017-06-10 ,  id  =&gt; 42,  payee  =&gt;  Starbucks }, { amount  =&gt; 15. 25,  date  =&gt;  2017-06-10 ,  id  =&gt; 42,  payee  =&gt;  Zoo }]    actual collection contained:  []    the missing elements were:   [{ amount  =&gt; 5. 75,  date  =&gt;  2017-06-10 ,  id  =&gt; 42,  payee  =&gt;  Starbucks }, { amount  =&gt; 15. 25,  date  =&gt;  2017-06-10 ,  id  =&gt; 42,  payee  =&gt;  Zoo }]   # . /04-acceptance-specs/01/expense_tracker/spec/expense_tracker_api_spec. rb:47:in 'block (2 levels) in &lt;module:ExpenseTracker&gt;'Finished in 0. 0305 seconds (files took 0. 2402 seconds to load)1 example, 1 failureAnd the API endpoint we should enable is the following (GET '/expenses/:date') # 04-acceptance-specs/01/expense_tracker/app/api. rbmodule ExpenseTracker class API &lt; Sinatra::Base  post '/expenses' do   JSON. generate('expense_id' =&gt; 42)  end  get '/expenses/:date' do    JSON. generate([])  end endendNow, we can mark the test_case as pending by adding right after the it block pending 'Need to persist expenses' this will change the red color from our terminal to a more friendly yellow. And with this warning we can add a webserver gem, in this case add gem 'rackup', gem 'webrick' to Gemfile and create a file: # 04-acceptance-specs/01/expense_tracker/config. ru # new file üö® require_relative 'app/api' run ExpenseTracker::API. new# run `cd 04-acceptance-specs/01/expense_tracker` and from that directory [NOT rspec-book] run `bundle exec rackup`# this will boot up a webserver ‚ûú expense_tracker git:(master) ‚úó bundle exec rackup[2025-07-23 14:29:17] INFO WEBrick 1. 9. 1[2025-07-23 14:29:17] INFO ruby 3. 4. 2 (2025-02-15) [arm64-darwin24][2025-07-23 14:29:17] INFO WEBrick::HTTPServer#start: pid=6213 port=9292::1 - - [23/Jul/2025:14:29:59 -0400]  GET /expenses/2017-06-10 HTTP/1. 1  200 2 0. 0063In another terminal you can try out your server with the following command: ‚ûú rspec-book git:(master) ‚úó curl localhost:9292/expenses/2017-06-10 -w  \n [] # this is due to our 04-acceptance-specs/01/expense_tracker/app/api. rb GET route ‚úÖTo recap of this chapter we began a project about tracking expenses that will register and search them, with only 2 actions. We set up bundler since we need more libraries than RSpec, such as Sinatra, SQlite, Rack, WEBrick, etc. We started with an outside-in approach where we defined the outer layer of the app in this case the POST endpoint. We were encouraged to think deeply about the public API and what type of data we wanted back as a response. Then we started building the classes, and we made progress by clearing one error at a time. We used two new matchers include, a_kind_of and contain_exactly which we didn‚Äôt use but was mentioned and lastly we refactored an method for persisting a Hash of expenses and booted up the web server with bundle exec rackup. It‚Äôs important to mention that all these requests are simulated. Part II ‚Äî Chapter 5. Testing in isolation: Unit specs. : In this chapter we‚Äôre going to be picking up where we left off: the HTTP routing layer. Unit tests typically involve isolating a class or method from the rest of the code. The result is faster tests and easier-to-find errors. We‚Äôll use unit spec to refer to the fastest, most isolated set of tests for a particular project. With the unit tests in this chapter, you won‚Äôt be calling methods on the API class directly. Instead, you‚Äôll still be simulating HTTP requests through the Rack::Test interface. Xavier Shay article about how he tests rails apps Your tests for any particular layer‚Äîfrom customer-facing code down to low-level model classes‚Äîshould drive that layer‚Äôs public API. You‚Äôll find yourself making more careful decisions about what does or doesn‚Äôt go into the API. The behavior we want to see is - what happens when an API call succeeds and when it fails. Unit tests are great for test all the conditional branches and edge cases very fast on the other hand if we do it with acceptance/integration would be too inefficient. # create a file spec/unit/app/api_spec. rbrequire_relative '. . /app/api'module ExpenseTracker RSpec. describe API do  describe 'POST /expenses' do   context 'when the expense is successfully recorded' do    it 'returns the expense id'    it 'responds with a 200 (OK)'   end   context 'when the expense fails validation' do    it 'returns an error message'    it 'responds with a 422 (Unprocessable entity)'   end  end endendHit the console with bundle exec rspec 04-acceptance-specs/01/expense_tracker/app/api_spec. rb all tests should appear as ‚Äúpending‚Äù. We are still modeling the API so we want something like this: result = @ledger. record({ 'some' =&gt; 'data' })result. success? # =&gt; a Booleanresult. expense_id # =&gt; a numberresult. error_message # =&gt; a string or nilRemember, we‚Äôre testing the API class, not the behavior. This is the perfect spot for test doubles. A test double is an object that stands in for another one during a test. To create a stand-in for an instance of a particular class, you‚Äôll use RSpec‚Äôs instance_double method, and pass it the name of the class you‚Äôre imitating. Martin Fowler‚Äôs article about test double Add the follwoing code to file 04-acceptance-specs/01/expense_tracker/spec/unit/api_spec. rb require_relative '. . /app/api'require 'rack/test'module ExpenseTracker RecordResult = Struct. new(:success?, :expense_id, :error_message) RSpec. describe API do  include Rack::Test::Methods  def app   API. new(ledger: ledger)  end  let(:ledger) { instance_double('ExpenseTracker::Ledger') }  describe 'POST /expenses' do   context 'when the expense is successfully recorded' do    it 'returns the expense id'    it 'responds with a 200 (OK)'   end   context 'when the expense fails validation' do    it 'returns an error message'    it 'responds with a 422 (Unprocessable entity)'   end  end endendAs with the acceptance specs, you‚Äôll be using Rack::Test to route HTTP requests to the API class. Eventually, we‚Äôll move the RecordResult class into the codebase. The seam between layers is where integration bugs hide. Using a simple value object like a RecordResult or Struct between layers makes it easier to isolate code and trust your tests. Article related to catching bugs between layers. üî¶ If you feel a bit lost here is a summary of the 3 files we have written in chapter 5. üîé api. rb: Defines a thin HTTP API (Sinatra app). It‚Äôs the boundary/interface between the outside world and your app logic.    Parse incoming HTTP requests     Forward them to your application logic (Ledger object)     Return an HTTP response (JSON with status codes)  It‚Äôs like a router/controller in Rails. api_spec. rb: Tests the API in isolation using test doubles, to control its behavior and avoid hitting the database or real logic. This is a unit test for your API layer. You‚Äôre using an instance_double of Ledger to isolate the API layer and check:    Does the API route call ledger. record?     Does it return the expected response if ledger. record is successful?     What happens if ledger. record fails?  expense_tracker_spec. rb: Acceptance-level (end-to-end) spec. It tests the whole system, using real logic (no doubles), to ensure the full behavior works.    It sends POST requests with expense data.     It sends a GET request to retrieve expenses for a given day.     It checks whether the correct data is returned.     It tests the full stack: HTTP ‚Üí Sinatra ‚Üí Ledger ‚Üí persistence.  initialize(ledger:): Adds ‚Äúdependency injection‚Äù so the API can be wired up with either real objects (in end-to-end tests) or test doubles (in unit tests). # 04-acceptance-specs/01/expense_tracker/spec/unit/api_spec. rbrequire_relative '. . /. . /app/api'require 'rack/test'module ExpenseTracker RecordResult = Struct. new(:success?, :expense_id, :error_message) RSpec. describe API do  include Rack::Test::Methods  def app   API. new(ledger: ledger)  end  let(:ledger) { instance_double('ExpenseTracker::Ledger') }  describe 'POST /expenses' do   context 'when the expense is successfully recorded' do    it 'returns the expense id' do     expense = { 'some' =&gt; 'data' }     allow(ledger). to receive(:record)            . with(expense)            . and_return(RecordResult. new(true, 417, nil))     post '/expenses', JSON. generate(expense)     parsed = JSON. parse(last_response. body)     expect(parsed). to include('expense_id' =&gt; 417)    end    it 'responds with a 200 (OK)'   end   context 'when the expense fails validation' do    it 'returns an error message'    it 'responds with a 422 (Unprocessable entity)'   end  end endendThe allow method configures the test double‚Äôs behavior: when the call in this case the API class invokes . record the double will return a new RecordResult instance. Also, please notice that the expense hash doesn‚Äôt contain real data, this is ok since the whole point of the Ledger test double is that it will return a canned success or failure response. If we run the test at this point we get the following: Failures: 1) ExpenseTracker::API POST /expenses when the expense is successfully recorded returns the expense id   Failure/Error: expect(parsed). to include('expense_id' =&gt; 417)      expected { expense_id  =&gt; 42} to include { expense_id  =&gt; 417}    Diff:    @@ -1 +1 @@    - expense_id  =&gt; 417,    + expense_id  =&gt; 42,      # . /04-acceptance-specs/01/expense_tracker/spec/unit/api_spec. rb:27:in 'block (4 levels) in &lt;module:ExpenseTracker&gt;'Top 4 slowest examples (0. 03167 seconds, 91. 4% of total time):. . . Let‚Äôs handle success and failure of the request in the api. rb # 04-acceptance-specs/01/expense_tracker/app/api. rbrequire 'sinatra/base'require 'json'require_relative 'ledger'module ExpenseTracker class API &lt; Sinatra::Base  def initialize(ledger: Ledger. new)   @ledger = ledger   super()  end   post '/expenses' do   request. body. rewind   expense = JSON. parse(request. body. read)   result = @ledger. record(expense)   if result. success?    JSON. generate('expense_id' =&gt; result. expense_id)   else    status 422    JSON. generate('error' =&gt; result. error_message)   end  end endend# 04-acceptance-specs/01/expense_tracker/spec/unit/api_spec. rbrequire_relative '. . /. . /app/api'require 'rack/test'module ExpenseTracker RSpec. describe API do  include Rack::Test::Methods  def app   API. new(ledger: ledger)  end  let(:ledger) { instance_double('ExpenseTracker::Ledger') }  describe 'POST /expenses' do   context 'when the expense is successfully recorded' do    let(:expense) { { 'some' =&gt; 'data' } }        before do     allow(ledger). to receive(:record)            . with(expense)            . and_return(RecordResult. new(true, 417, nil))    end    it 'returns the expense id' do     post '/expenses', JSON. generate(expense)     parsed = JSON. parse(last_response. body)     expect(parsed). to include('expense_id' =&gt; 417)    end    it 'responds with a 200 (OK)' do     post '/expenses', JSON. generate(expense)     expect(last_response. status). to eq(200)    end   end   context 'when the expense fails validation' do    let(:expense) { { 'some' =&gt; 'data' } }        before do     allow(ledger). to receive(:record)            . with(expense)            . and_return(RecordResult. new(false, 417,  Expense incomplete ))    end    it 'returns an error message' do     post '/expenses', JSON. generate(expense)     parsed = JSON. parse(last_response. body)     expect(parsed). to include('error' =&gt; 'Expense incomplete')    end    it 'responds with a 422 (Unprocessable entity)' do     post '/expenses', JSON. generate(expense)     expect(last_response. status). to eq(422)    end   end  end endendThe last excersice is to add GET /expenses/:date starting from writing down tests:  Write the describe block, then the context, the it blocks.  The API::Sinatra is already working (we have not defined the storage engine yet) Add instance_double of ledger(RecordResult is no longer needed) Add the method expenses_on(date) on the Ledgerclass.  Generate a sample data of the JSON we want as return. (The hash should contain amount, date and payee) Modify the api. rb since the GET route always return empty array. It shoudl handle success and failure too. Here is the api. rb and the api_spec. rb. These refactored specs report ‚Äújust the facts‚Äù of the expected behavior. # 04-acceptance-specs/01/expense_tracker/app/api. rb get '/expenses/:date' do  date = params[:date]  unless /\A\d{4}-\d{2}-\d{2}\z/. match?(date)   status 400   return JSON. generate({ error:  Invalid date format  })  end  expenses = @ledger. expenses_on(date)  if expenses. any?   JSON. generate(expenses)  else   JSON. generate([])  end end# 04-acceptance-specs/01/expense_tracker/spec/unit/api_spec. rbmodule ExpenseTracker RSpec. describe API do  include Rack::Test::Methods  def app   API. new(ledger: ledger)  end  let(:ledger) { instance_double('ExpenseTracker::Ledger') }  describe  GET /expenses/:date  do   context  when expenses exist on given date  do    let(:expense_canned_response) { [ { amount  =&gt; 5. 50,  date  =&gt; '2017-06-10',  payee  =&gt;  Starbucks } ] }    before do     allow(ledger). to receive(:expenses_on)            . with('2017-06-10')            . and_return(expense_canned_response)    end    it  returns the expense records as JSON  do     get '/expenses/2017-06-10'     parsed = JSON. parse(last_response. body)     expect(parsed). to eq(expense_canned_response)    end    it  responds with a 200 (OK)  do     get '/expenses/2017-06-10'     expect(last_response. status). to eq(200)    end   end   context  when expenses don't exist on given date  do    let(:expense_not_found) { [] }    before do     allow(ledger). to receive(:expenses_on)             . with('2017-05-12')             . and_return(expense_not_found)    end    it  returns an empty array as JSON  do     get '/expenses/2017-05-12'     parsed = JSON. parse(last_response. body)     expect(parsed). to eq(expense_not_found)    end    it  responds with a 200 (OK)  do     get '/expenses/2017-05-12'     expect(last_response. status). to eq(200)    end   end   context  when the date format is not valid  do    it  returns a 400 Bad Request  do     get '/expenses/2012,12,12'     expect(last_response. status). to eq(400)    end    it  returns an error message  do     get '/expenses/2012,12,12'     expect(JSON. parse(last_response. body)). to eq({  error  =&gt;  Invalid date format  })    end   end  end endendI‚Äôll add more routes and test cases so that I can practice more  GET /expenses ‚Äì List all expenses (not just by date) GET /expense/:id‚Äî‚Äî‚Äî‚Äî- These should added once we setup SQlite ‚Äî‚Äî‚Äî‚Äî- DELETE /expenses/:id ‚Äì Delete a specific expense PUT /expenses/:id ‚Äì Update an existing expense GET /expenses/stats/:month ‚Äì Show monthly summary POST /budgets ‚Äì Set a budget limit for a category or month GET /categories GET /expenses?category=Food&amp;date=2025-07-10 (this one needs query params, we‚Äôre currently using route params)In this chapter, we explored how to move from acceptance tests ‚Äî which ensure that the entire application works as a whole ‚Äî to unit tests, which isolate specific parts of the code, such as routing logic. Unit tests typically run without a live server or real database, and instead focus on one class or method at a time. The benefits of this approach are faster test execution and clearer identification of where errors occur. Rather than calling methods directly on the API class, we simulated HTTP requests using the Rack::Test interface. This aligns with the common testing principle of exercising a class through its public interface, which leads to better design decisions and a more user-focused API. We also examined the Ledger class and introduced dependency injection (DI). In Ruby, this is as simple as passing an object as an argument to the constructor, like so: initialize(ledger: Ledger. new)This technique makes it easier to swap in test doubles when testing, allowing us to isolate the API class from the actual persistence layer. A test double is a generic term for objects that stand in for real ones during testing. Depending on the testing framework, they might be called mocks, stubs, fakes, or spies. In RSpec, we use the term double. Our goal was to create a fake Ledger object to test only the API logic ‚Äî without involving real data storage ‚Äî making the tests faster and more focused. instance_double(class_to_fake) We also encountered verifying doubles, a powerful RSpec feature that ensures your test doubles reflect the real object‚Äôs interface. This helps avoid fragile tests. In our case, forgetting to instantiate the Ledger correctly caused RSpec to raise an error ‚Äî a valuable signal that our double wasn‚Äôt matching the actual interface. If you ever need to inspect a full error stack trace during testing, you can run RSpec with the --backtrace or -b flag: bundle exec rspec -bPart II ‚Äî Chapter 6. Getting real. Integration specs. : Now we have a solid HTTP routing layer designed with the help of unit specs. These specs assummed that the underlying dependencies would eventually be implemented. Now, it‚Äôs time to write those dependecies for real. Add the sequel and sqlite gems: bundle add sequel sqlite3Remember we need to have 3 differents databases for testing, development and production so that we dont clobber with real data. Then add the 3 files (2 for configurations and 1 for the expenses migration) # 04-acceptance-specs/01/expense_tracker/config/sequel. rbrequire 'sequel'DB = Sequel. sqlite( . /db/#{ENV. fetch('RACK_ENV', 'development')}. db )# 04-acceptance-specs/01/expense_tracker/spec/support/db. rb# suite-level hook. # The following code will make sure the database structure is set up and empty,# ready for your specs to add data to itRSpec. configure do |c| c. before(:suite) do   Sequel. extension :migration  Sequel::Migrator. run(DB, 'db/migrations')  DB[:expenses]. truncate endend# 04-acceptance-specs/01/expense_tracker/db/migrations/0001_create_expenses. rbSequel. migration do change do  create_table :expenses do   primary_key :id   String :payee   Float :amount   Date :date  end endendRegarding the before(:suite) hook A typical hook will run before each example. This one will run just once: after all the specs have been loaded, but before the first one actually runs. That‚Äôs what before(:suite) hooks are for. Then run the migration with bundle exec sequel -m . /db/migrations sqlite://db/development. db --echo Outout you may see: 2025-08-05 13:32:31 INFO: (0. 001937s) PRAGMA foreign_keys = 12025-08-05 13:32:31 INFO: (0. 000010s) PRAGMA case_sensitive_like = 12025-08-05 13:32:31 INFO: (0. 001011s) SELECT sqlite_version()2025-08-05 13:32:31 INFO: (0. 000890s) CREATE TABLE IF NOT EXISTS `schema_info` (`version` integer DEFAULT (0) NOT NULL)2025-08-05 13:32:31 INFO: (0. 000039s) SELECT * FROM `schema_info` LIMIT 02025-08-05 13:32:31 INFO: (0. 000029s) SELECT 1 AS 'one' FROM `schema_info` LIMIT 12025-08-05 13:32:31 INFO: (0. 000415s) INSERT INTO `schema_info` (`version`) VALUES (0)2025-08-05 13:32:31 INFO: (0. 000050s) SELECT count(*) AS 'count' FROM `schema_info` LIMIT 12025-08-05 13:32:31 INFO: (0. 000028s) SELECT `version` FROM `schema_info` LIMIT 12025-08-05 13:32:31 INFO: Begin applying migration version 1, direction: up2025-08-05 13:32:31 INFO: (0. 000512s) CREATE TABLE `expenses` (`id` integer NOT NULL PRIMARY KEY AUTOINCREMENT, `payee` varchar(255), `amount` double precision, `date` date)2025-08-05 13:32:31 INFO: (0. 000423s) UPDATE `schema_info` SET `version` = 12025-08-05 13:32:31 INFO: Finished applying migration version 1, direction: up, took 0. 001072 secondsThen we had to create a spec/ledger_spec. rb which will test out the Ledger class behavior. require_relative '. . /. . /. . /app/ledger'require_relative '. . /. . /. . /config/sequel'require_relative '. . /. . /support/db'module ExpenseTracker RSpec. describe Ledger, :aggregate_failures do  let(:ledger) { Ledger. new }  let(:expense) do   {    'payee' =&gt; 'Starbucks',    'amount' =&gt; 5. 75,    'date' =&gt; '2017-06-10'   }  end  describe '#record' do   context  with a valid expense  do    it  succesfully saves the expense in the DB  do     result = ledger. record(expense)     expect(result). to be_success     expect(DB[:expenses]. all). to match [a_hash_including(      id: result. expense_id,      payee: 'Starbucks',      amount: 5. 75,      date: Date. iso8601('2017-06-10')     )]    end   end  end endendAnd don‚Äôt forget to add the logic into the Ledger class  def record(expense)  DB[:expenses]. insert(expense)  id = DB[:expenses]. max(:id)  RecordResult. new(true, id, nil) endHere we just leveraged 2 new matchers be_success and match [a_hash_including] This particular example we detoured a bit from TDD since we declared 2 expects under the same it block but we did it judiciously since every test that touches the DB is slower so if we follow rigorously one expect per test case we‚Äôre going to be repeating that setup and teardown many times. Also, we did added the metada :aggregate_failures so that RSpec doesn‚Äôt abort execution at the first error but to run all tests even with failures! With this out of the way, let‚Äôs add a test for invalid records  it  rejects the expense as invalid  do  expense. delete('payee')  result = ledger. record(expense)  expect(result). not_to be_success  expect(result. expense_id). to eq(nil)  expect(result. error_message). to include('`payee` is required')  expect(DB[:expenses]. count). to eq(0) endThis will break our test, but that‚Äôs all the purpose of the red-green-refactor cycle. Now let‚Äôs add the valdiation for Ledger class class Ledger def record(expense)  unless expense['payee']   return RecordResult. new(false, nil, '`payee` is required')  end  DB[:expenses]. insert(expense)  id = DB[:expenses]. max(:id)  RecordResult. new(true, id, nil) endendSomething important that authors mention is that everytime we run the test suite we are adding records to our db which is not good practice, therefore they suggest to add the next RSpec configuration for leeting RSpec that everytime it finds :db tag, it should perform a DB transaction which will entails seting up the DB before running the tests and wiping out after the test suite is ran. # suppor/db. rbc. around(:example, :db) do |example| DB. transaction(rollback: :always) { example. run }endHere is a detailed list of steps that this script will do:  RSpec calls our around hook, passing it the example we‚Äôre running.  Inside the hook, we tell Sequel to start a new database transaction.  Sequel calls the inner block, in which we tell RSpec to run the example.  The body of the example finishes running.  Sequel rolls back the transaction, wiping out any changes we made to the database.  The around hook finishes, and RSpec moves on to the next example. Now let‚Äôs jump to implement the GET /expenses_on(:date) endpoint. First start with the test describe  #expenses_on  do it  returns all expenses for the date provided  do  result_1 = ledger. record(expense. merge('date' =&gt; '2017-06-10'))  result_2 = ledger. record(expense. merge('date' =&gt; '2017-06-10'))  result_3 = ledger. record(expense. merge('date' =&gt; '2017-06-11'))  expect(ledger. expenses_on('2017-06-10')). to contain_exactly(   a_hash_including(id: result_1. expense_id),   a_hash_including(id: result_2. expense_id)  ) end it  returns an empty array when there are no matching expenses  do  expect(ledger. expenses_on('2017-06-10')). to eq([]) endend# then the ruby logicdef expenses_on(date) DB[:expenses]. where(date: date). allendThis should pass all good! Conclusion: while searching some other RSpec keywords i found this useful RSpec cheat sheet from Thoughtbot also we used the :aggregate_failures feature twice. This option allows the RSpec to continue running the entire test suite even when a test fails. We first applied it at the individual test case level, and then moved it up to an example group, which signaled RSpec to apply that behavior to the entire group. We also introduced two new matchers: be_success and match a_hash_including. Another key point we learned is that every spec interacting with the database will run more slowly. Because of this, we need to be judicious when applying the TDD methodology, which encourages writing one expect per test case. In some situations, we combined multiple expect statements within the same test case to speed up execution. Finally, we explored the --bisect command, which is useful for identifying order-dependent tests. An order dependency occurs when a test fails only if another specific test runs before it. The --bisect command automatically isolates the minimal set of examples that cause the failure by repeatedly running subsets of your tests. Example: # First, run with a specific seed to reproduce the failurerspec --seed 12345# If you see a failure, run:rspec --seed 12345 --bisectSample output: Bisect started using options:  --seed 12345 Reducing test suite by half. . . . . . The minimal reproduction command is:rspec . /spec/foo_spec. rb[1:3] . /spec/bar_spec. rb[1:5] --seed 12345This tells you exactly which tests together trigger the failure, so you can debug the cause. It‚Äôs essentially automated detective work for the classic ‚Äúthis test only fails when that other one runs first‚Äù problem. Part III ‚Äî RSpec Core. : Part III ‚Äî Chapter 7. Structuring code examples. : we‚Äôve gained the mental model of ‚Äúwhere things go‚Äù (either files or groups or examples or setup!) we‚Äôve have written short, clear examples that explain exactly what the expected behavior of the code islaid examples into logical groups, not oly to share setup but foor keep related specs together you‚Äôll learn how to organize specs into groups, you‚Äôll know where to put shared setup code and the trade-offs. This will make the tests easier to read and maintain. well-structures specs are about more than tidiness, sometimes you attach special behavior to certain examples or groups, like setting up a database or adding a custom error handling. the mechanism of metada (:tags) relies on good grouping. Getting the words right. Every RSpec is the example group in other testing Frameworks it is called test case class and it has multiple purposes:  gives a logical structure for understanding how individual examples relate to one another describes the context such as a particular class, method or situation of what you are testing, provides a ruby class to act as a scope for your shared logic, such as hooks let definition and helper methods, runs, set up and tear down code shared by several examples. The basic includes group examples, examples and expectations. describe creates an example group. This is the place where you put what you say you are testing, the description can be either a string a ruby class, a module or an object. when you use a class it has some advantages because it requires the class to exist and to be spelled correctly, Also you place here the tag filtering with extra information and that tag will be applied to the nested examples it creates a single example, you pass a description of the behavior you are specifying as with describe you can also pass custom metadata to make it more specific remember that for bdd the crucial part is to ‚Äúgetting the words right‚Äù. Now, so much alternatives for describe that makes more sense when the examples within that group all relate to a single class method or module that alternative is context which will make it more readable and considering that this is for the long term maintainability, and it will show the intent behind the code. another alternative is example instead of the it and it may be used when you are providing several data examples rather than several sentence about the subject or describing a behavior it will read much more clearly and lastly we have the specified instead of the it RSpec also provides the flexibility for adding the names you want in the book shows how you can combine this gem with binding. pry and how you can add an alias to the spec_helper. rb file and use that in your Cascade or example and that will add the pry: trueto metadata to its respective example group or single example and with this you can quickly toggle the pry behavior on and off just by adding or removing the name you define in the spec_helper. rb. Sharing logic. the main three organization tools are let definitions, hooks, and helper methods below is a code snippet that contains all of the three RSpec. describe 'POST a successful expense' do # let definitions let(:ledger) { instance_double('ExpenseTracker::Ledger') } let(:expense) { { 'some' =&gt; 'data' } } # hook before do  allow(ledger). to receive(:record)  . with(expense)  . and_return(RecordResult. new(true, 417, nil)) end # helper method def parsed_last_response  JSON. parse(last_response. body) endendWe have used the let definition several times in this book they are great for setting up anything that can be initialized in a line or two of code, and they give you the lazy evaluation for free which means that they are not going to be run until you actually invoke them. then we have the hooks that are for situations where they let definition block just won‚Äôt cut it. the important thing about hooks is the one and how often you want the hook to run. Hooks. ‚Äúwriting a hook involves two concepts. the type of hook controls when it runs relative to your examples. the scope controls how often your hook runs. ‚Äù For the when the hook should run we have three different types before, after, and around. as the name implies, you‚Äôre before hook will run before your examples. after hooks guarantee to run after your examples, even if the example fails or did before hook races an example. this hooks are intended to clean up after your setup logic and specs. this style of hook is easy to read, but it does split the setup and tear down logic into two halves that we have to keep track of. When your database cleanup logic doesn‚Äôt fit neatly into a transactional around HOOK, we recommend using a before hook for the following reasons: if you forget to add the before hook to a particular spec the failure will happen in that example rather than a later one. when you run a single example to diagnose a failure the records will stick around in the database so that you can investigate them. the around hook it‚Äôs a bit more complex because they sandwich your spec code inside your hook, so part of the hook runs before the example and part runs after. the behavior of these two Snippets is the same; it is just a question of which reads better for your application. RSpec. describe MyApp::Configuration do around(:example) do |ex|  original_env = ENV. to_hash  ex. run  ENV. replace(original_env) endendThen we have the config hooks and this is if you need to run your hooks for multiple groups. you can define the hooks once for your entire Suite in the configuration typically spec _ helper. rband they‚Äôll run for every example in your test suite RSpec. configure do |config| config. around(:example) do |ex|  original_env = ENV. to_hash  ex. run  ENV. replace(original_env) endendand with this they will run for every example in your test suite note the trade-off here:  Global hooks reduced duplication but can lead to surprising action at a distance effect in your aspects.  hooks inside example groups are easier to follow but it is easy to leave out an important Hook by mistake when you are creating a new spec file. we do recommend only use config hooks for things that are not essential for understanding how your specs work. the Beats of logic that isolate each example, such as a database transaction or environment sandboxing, or prime candidates. we prefer to keep things simple and run our hooks unconditionally. if, however, our config hooks are only needed by a subset of examples on particularly if they are as low, we will use metadata to make sure they run only for the subset that need them. now that we have seen when to run the hooks either before or after or around let‚Äôs see the scope. this is meant when I hook needs to do a really timing tensive operation like creating a bunch of database tables or launching a live web server running the hook once per second will be cost provided. for this cases you can run the hook just once for the entire Suite of specs or once per example group. hooks take a symbol like :suite or :context argument to modify this code. RSpec. describe 'Web interface to my thermostat' do before(:context) do  WebBrowser. launch end after(:context) do  WebBrowser. shutdown endendwe only consider using context hook scope for side effects such as launching a web browser, that‚Äôs satisfy both of the following two conditions: does not interact with things that have a per example life cycle is noticeable slow to run when you use a context hook scope your responsible for cleaning up any resulting state otherwise, it can cause other specs to pass or fail incorrectly this is particularly common problem with database code. any records created in a before context hook scope will not run in your per example database transactions. the records will stick around after the example groups If you need to run a piece of setup call just once, before the first example begins that‚Äôs what :suite There may be some old syntax that you may find in code bases which is Old newbefore(:each) became before(:example)before(:all) became before(:suite) Something important when a example group is nested the before hooks run from the outside in and the after hooks run from the inside out. when to use hooks we have seen that hooks serve two different purposes: removing duplicate it or incidental details that will distract readers from the point of your example. expressing the English descriptions of your example groups as executable code Abusing RSpec hooks will make you skip all over your spec directory to trace program flow. Helper methods. Sometimes, we can get too clever for our own good and misuse these constructs in an effort to remove every last bit of repetition from our specs. Let‚Äôs see an example RSpec. describe BerlinTransitTicket do let(:ticket) { BerlinTransitTicket. new } before do  # These values depend on `let` definitions  # defined in the nested contexts below!  #  ticket. starting_station = starting_station  ticket. ending_station = ending_station end let(:fare) { ticket. fare } context 'when starting in zone A' do  let(:starting_station) { 'Bundestag' }  context 'and ending in zone B' do  let(:ending_station) { 'Leopoldplatz' }  it 'costs ‚Ç¨2. 70' do   expect(fare). to eq 2. 7  end end context 'and ending in zone C' do  let(:ending_station) { 'Birkenwerder' }  it 'costs ‚Ç¨3. 30' do   expect(fare). to eq 3. 3  end endendWith all these jumps around we have welcomed a behavior defined by the TDD community calls this separation of cause and effect a mystery guest link, now let‚Äôs see how would be with a smart usage of helper methods RSpec. describe BerlinTransitTicket do def fare_for(starting_station, ending_station)  ticket = BerlinTransitTicket. new  ticket. starting_station = starting_station  ticket. ending_station = ending_station  ticket. fare end context 'when starting in zone A and ending in zone B' do  it 'costs ‚Ç¨2. 70' do  expect(fare_for('Bundestag', 'Leopoldplatz')). to eq 2. 7  end end context 'when starting in zone A and ending in zone C' do  it 'costs ‚Ç¨3. 30' do  expect(fare_for('Bundestag', 'Birkenwerder')). to eq 3. 3  end endendNow, it‚Äôs explicit exactly what behavior we‚Äôre testing, without our needing to repeat the details of the ticketing API. (these helper methods can be extracted into modules and be glued together by calling include into the group example) Sharing examples groups As we have seen, plain old Ruby modules work really nicely for sharing helper methods across example Scripts. but that‚Äôs all they can share. if you want to reuse an example, a let construct or a hook, you will need to reach for another two; shared example groups. RSpec provides multiple ways to create and use shared sample grips. This come in pairs, with one method for defining a share group and another for using it:  shared_context and include_context are for reusing common setup and helper logic. .  shared_example and include_exampleAre for reusing examples. . there is one more way to share behavior that is different, though. it_behaves_like creates a new, nested example to hold the shared code. the difference lies in how as isolated the shared behavior is from the rest of your examples. Sharing context Sooner or later, dough, you will find that you want to share some let declarations or hooks instead. before dobasic_authorize 'test_user', 'test_password'endThis hook cannot go into your modules. plane will be modules are not aware of our aspect constructs such as hooks. instead, you can convert your module to a shared context: RSpec. shared_context 'API helpers' doinclude Rack::Test::Methodsdef appExpenseTracker::API. newendbefore dobasic_authorize 'test_user', 'test_password'endEndHere is how we use it: RSpec. describe 'Expense Tracker API', :db doinclude_context 'API helpers'# . Remember that sharing context is for reusing common setup and helper logic. Sharing examples. One of the most powerful ideas in software is defining a single interface with multiple implementation for example your web app might need to cash data in a key Value Store there are many implementation of this idea each which its own advantages over the others let‚Äôs see one example of these RS pack Behavior ‚Äúshared_example‚Äù require 'hash_kv_store'RSpec. describe HashKVStore dolet(:kv_store) { HashKVStore. new }it 'allows you to fetch previously stored values' dokv_store. store(:language, 'Ruby')kv_store. store(:os, 'linux')expect(kv_store. fetch(:language)). to eq 'Ruby'expect(kv_store. fetch(:os)). to eq 'linux'endit 'raises a KeyError when you fetch an unknown key' doexpect { kv_store. fetch(:foo) }. to raise_error(KeyError)endendTo test a second implementation of this interface such as a disk-backed FileKVStore ‚Äì you could copy and paste the entire spec and replace all occurrences of HashKVStore store with FileKVStore. but then you will have to add any new common Behavior to both specs files. we will have to manually keep it two specs files in sync. This is exactly the kind of duplication that shared example groups can help you fix.  To make the switch, move your describe block into its own file and change it to a shared_example block taking an argument and use that argument in the let(:kv_store) declaration RSpec. shared_examples 'KV store' do |kv_store_class|‚û§ let(:kv_store) { kv_store_class. new }it 'allows you to fetch previously stored values' dokv_store. store(:language, 'Ruby')kv_store. store(:os, 'linux')expect(kv_store. fetch(:language)). to eq 'Ruby'expect(kv_store. fetch(:os)). to eq 'linux'endit 'raises a KeyError when you fetch an unknown key' doexpect { kv_store. fetch(:foo) }. to raise_error(KeyError)endEndAnd we use it with the following code snippet: require 'hash_kv_store'require 'support/kv_store_shared_examples'RSpec. describe HashKVStore doit_behaves_like 'KV store', HashKVStoreendNesting In the introduction to this section, we mentioned that you can include sharedexamples with either include_examples or it_behaves_like call. So far, we‚Äôve just usedIt_behaves_like. Calling include_examplesyou‚Äôd get two let declarations for :kv_store: one for HashKVStore and one for FileKVStore. $ rspec spec/include_examples_twice_spec. rb --format documentationKey-value storesallows you to fetch previously stored valuesraises a KeyError when you fetch an unknown keyallows you to fetch previously stored valuesraises a KeyError when you fetch an unknown keyFinished in 0. 00355 seconds (files took 0. 10257 seconds to load)4 examples, 0 failuresUsing it_behaves_like avoids this issue: RSpec. describe 'Key-value stores' doit_behaves_like 'KV store', HashKVStoreit_behaves_like 'KV store', FileKVStoreEndThis would output: $ rspec spec/it_behaves_like_twice_spec. rb --format documentationKey-value storesbehaves like KV storeallows you to fetch previously stored valuesraises a KeyError when you fetch an unknown keybehaves like KV storeallows you to fetch previously stored valuesraises a KeyError when you fetch an unknown keyFinished in 0. 00337 seconds (files took 0. 09726 seconds to load)4 examples, 0 failuresWhen in doubt, choose it behaves like it behaves like it‚Äôs almost always the one you want. it ensures that the contents of the Share Group don‚Äôt leak into the surrounding context and interact with your other examples. we recommend using include examples only when you are sure that shared example context on conflict with anything in the surrounding group. This is a table that wraps up all the key Concepts that we saw:       Concept   Usage   Gotcha         describe   Creates an example group for a class, module, object, or string; can combine with string; supports metadata.    Passing a class enforces existence and correct spelling; vague descriptions reduce clarity.        context   Alias for describe when grouping by situation or condition.    Misuse can make specs awkward (‚Äúdescribe when boiling‚Äù).        it   Defines a single example with behavior description; supports metadata.    Reads awkwardly if not describing a subject.        example   Alias for it; better for listing data cases.    None ‚Äî just improves readability.        specify   Alias for it; use when neither it nor example reads well.    None ‚Äî clarity preference only.        hooks   Shared setup/teardown logic with before, after, or around.    Overuse can cause ‚Äúmystery guest‚Äù indirection; keep near usage.        before(:example)   Runs before each example (default scope).    Forgetting in a spec causes failure there; can hide setup details.        after(:example)   Runs after each example, even on failure.    Setup/teardown split can be harder to follow; prefer before for DB cleanup.        around(:example)   Wraps code before and after an example in one block.    Only supports :example scope; can be harder to read.        config hooks   Hooks in RSpec. configure for the whole suite.    Risk of ‚Äúaction at a distance‚Äù; use for incidental details.        scopes   :example (default), :context (once/group), :suite (once/suite).    :context can leak state; :suite only in config; avoid old :each/:all.        global hooks   Config hooks affecting all examples.    Can cause unintended side effects; harder to trace.        hooks inside example groups   Hooks scoped to one group.    Easier to follow, but may be missed in new files.        before(:context)   Runs once before all examples in a group.    Avoid for DB records or per-example lifecycle items; must clean up state.        after(:example)   Runs after each example; used for cleanup, even if the example fails.    Splits setup and teardown logic across hooks, making flow harder to follow; prefer before for database cleanup.        let definition   Lazily defines a memoized helper variable.    Overuse can hide cause/effect; nested overrides may confuse.        helper method   Ruby method in example group for setup or reuse.    Avoid hiding essential details far away; inline when important.        shared_context + include_context   Share let, hooks, and helpers across groups.    Plain Ruby modules can‚Äôt hold RSpec constructs; merging may override definitions.        shared_examples + include_examples   Share examples; include_examples pastes into current group.    Multiple includes can cause collisions (e. g. , let overwrites).        it_behaves_like   Runs shared examples in a nested group, avoiding collisions.    Adds extra nesting in output; almost always preferred to include_examples.    Part III ‚Äî Chapter 8. Slicing and dicing specs with metadata. : Slicing and Dicing specs with Metadata In this chapter we are going to learn what type of information are spec stores for each example that it is run how to add more information to that previous stack coma and how to read it, how to perform expensive setup only when we need it and how to run just a subset of tests. over the course of this book, we have far away cute principle that has made our specs faster, more reliable, and easier to use: ‚Äú run just the code you need. ‚Äù when you are isolating a failure, run just the feeling example. when you are modifying a class, run just it‚Äôs unit tests. when you‚Äôve got expensive setup code, only run it for the specs where you need it. a key piece of RS pack that‚Äôs made many of these practices possible is its powerful metadata system. metadata undergirds many of our aspects features, and rs back exposes the same system for your use. Defining metadata where do I keep information about the context my specs are running in? by contact, we mean things like: example configuration open parentheses for example, Mark as escaped or pending close parentheses source code locations status of the previous run how one example runs differently than others for example needing a web browser or a DB without some way of attaching data to examples, you and the are aspect maintainers will be stock juggling Global variables and writing a bunch of bookkeeping code. . RSpec solution to this problem couldn‚Äôt beSimpler: a plain Ruby hash. every example an example group gets its own such hash, known as the metadata hash. RSpec populates this hash with any metadata you have explicitly chat the example with, plus some useful entries of its own. If you create the following file and you run the test you will see the next information on your terminal: require 'pp'RSpec. describe Hash doit 'is used by RSpec for metadata' do |example|pp example. metadataendend# this w ould be the output$ rspec spec/metadata_spec. rb{:block=&gt;#&lt;Proc:0x007fa6fc07e6a8@~/code/metadata/spec/metadata_spec. rb:4&gt;,:description_args=&gt;[ is used by RSpec for metadata ],:description=&gt; is used by RSpec for metadata ,:full_description=&gt; Hash is used by RSpec for metadata ,:described_class=&gt;Hash,:file_path=&gt; . /spec/metadata_spec. rb ,:line_number=&gt;4,:location=&gt; . /spec/metadata_spec. rb:4 ,:absolute_file_path=&gt; ~/code/metadata/spec/metadata_spec. rb ,:rerun_file_path=&gt; . /spec/metadata_spec. rb ,:scoped_id=&gt; 1:1 ,:execution_result=&gt;#&lt;RSpec::Core::Example::ExecutionResult:0x007ffda2846a78@started_at=2017-06-13 13:34:00 -0700&gt;,:example_group=&gt;{:block=&gt;#&lt;Proc:0x007fa6fb914bb0@~/code/metadata/spec/metadata_spec. rb:3&gt;,¬´ truncated ¬ª:shared_group_inclusion_backtrace=&gt;[],:last_run_status=&gt; unknown }. Finished in 0. 00279 seconds (files took 0. 09431 seconds to load)1 example, 0 failuresListen if it shows something that we haven‚Äôt talked about before: getting access to your examples properties at the wrong time. you can so by having your eight block take an argument. it will pass an object representing the currently running example. the call to example that metadata returns a hash containing all the metadata.  kiss like description just the string we passed to it, full description includes the checks passed to the describe, describe class, fire path, example groups and last round status with four different values as past, pending, failed or unknown Custom metadata if we want to add extra metadata to our examples in order to identify it better or to one our colleagues we can do it with the next procedure: require 'pp'RSpec. describe Hash do‚û§ it 'is used by RSpec for metadata', :fast do |example|pp example. metadataendend# this will save`:fast=&gt;true`, we can also add more than one, for example :fast, :focus Then we can call those example that contain the :fast meta tag with $ rspec --tag fast We can also do it for all examples by adding it to spec_helper. rb RSpec. configure do |config|config. define_derived_metadata(file_path: /spec\/unit/) do |meta|meta[:fast] = trueendendDefault metadata As we saw previously with the tag :aggreagate_failuresWhich will run all the test even when they fail, we can add these two all of the examples again adding it to the RSpec. configure RSpec. configure do |config|config. define_derived_metadata do |meta|# Sets the flag unconditionally;# doesn't allow examples to opt outmeta[:aggregate_failures] = trueendendHere is something important that if we don‚Äôt want to use that metal type the next code will be overwritten by the global setting: RSpec. describe 'Billing', aggregate_failures: false docontext 'using the fake payment service' dobefore doexpect(MyApp. config. payment_gateway). to include('sandbox')end# . . . endendTherefore we need to tweak it a little bit in order to allow the example group to follow its own rules we need to add a conditional to the spec helper RSpec. configure do |config|config. define_derived_metadata do |meta|meta[:aggregate_failures] = true unless meta. key?(:aggregate_failures)endendI say recap of this chapter we can conclude that it will be hash is created every time we run our test Suite and wouldn‚Äôt that hash we can find configurations, where the code is located, status of the example, we can even add our own tags And we can print that hash at the wrong time with . metadata Selecting which specs to run When you are running your specs, you often want to change which ones you include. in this section we are going to show you a few different situations where this kind of slicing and dicing comes in handy. most of the time when we start writing our tests, we don‚Äôt run then Tire so. we are either running unit spec for a specific class we are designing or we are kicking off some integration specs to catch regressions. one example to exclude some examples is the following tag: RSpec. configure do |config|config. filter_run_excluding :jruby_only unless RUBY_PLATFORM == 'java'endThe filter_run_excluding call indicates which examples we‚Äôre leaving out. The flip side to that method is filter_run_including, or just filter_run for short. This style of filtering is pretty brute-force. If no examples match the filter, RSpec will run nothing at all. A more generally useful approach is to use filter_run_when_matching. With this method, if nothing matches the filter, RSpec just ignores it. Remember that RSpec. configure block are permanent settings, baked into your setup code. They‚Äôll be in effect every time you run RSpec. If you want to run your specific subset of tests from command line you can do it with the following $ rspec --tag fast # this will run just the examples tagged with :fast # this will do exactly the opposite, run all except the tests tagged with :fast$ rspec --tag ~fastSharing code conditionally we discussed three ways to share code across many examples groups: top level config hooks modules containing helper methods shared context containingRSpec constructs such as Hooks and let blocks Metadata is what enables this flexibility, and you can use it with all the culture and techniques we listed earlier: Config hooks. pass a filter expression as a second argument to config. before, config. after or config. aroundTo run that hook only for example matching the filter. # spec/spec_helper. rbRSpec. configure do |config| config. before(:example, :db) do  puts  Setting up database for this example. . .   end config. after(:example, slow: true) do  puts  Cleaning up after a slow example. . .   end config. around(:example, api: true) do |example|  puts  Before API example   example. run  puts  After API example  endend# Usage in a spec:RSpec. describe  Some feature  do it  needs database setup , :db do  # . . .  end it  is a slow example , slow: true do  # . . .  end it  calls the API , api: true do  # . . .  endendmodules. at the filter expression to the end of your config that include call in order to include a module and it‚Äôs helper methods conditionally. this also works for similar config. extend and config. prepend # spec/support/api_helpers. rbmodule APIHelpers def api_call(path)  # pretend API call here endend# spec/spec_helper. rbRSpec. configure do |config| config. include APIHelpers, api: trueend# Usage:RSpec. describe  API requests , :api do it  can call the API  do  api_call( /status ) endendshared context. just ask with modules, at a filter expression when calling config. include_contest.  this will bring in your shirt let constructs among other things into just example groups you want.  # spec/support/api_context. rbRSpec. shared_context  API context  do let(:auth_token) {  secret  }end# spec/spec_helper. rbRSpec. configure do |config| config. include_context  API context , api: trueend# Usage:RSpec. describe  Authenticated API request , :api do it  uses the auth token  do  expect(auth_token). to eq  secret  endendHere are some other examples of metadata that we have seen before       Tag   Usage   Gotcha         :aggregate_failures   Allows multiple expectations in an example to run before failing, showing all failures together.    Without it, the first failing expectation stops the example; can hide which expectation failed first.        :pending   Marks an example as pending (not yet implemented or expected to fail).    If the example passes, RSpec flags it as a failure to remind you to remove :pending.        :order   Sets run order for examples (e. g. , :random, :defined).    Random order may expose order dependencies; :defined can hide them.        :skip   Skips the example or group entirely without running it.    Easy to forget skipped tests; may hide failing scenarios if left in place.    Part III ‚Äî Chapter 9. Configuring RSpec. : As you have work through there exercises in this book, you have often change RS specs Behavior to make it a better tool for your needs here are just a few of the things that you have customized: set up until you‚Äôre down a test database, but only for the examples that require one report every failing expectation in an example not just the first one run just examples that you are focusing on at the moment you can configure rspec into basic ways: on rspec. configure block: provides access to all configuration options: since the block lives in your code, you will typically use it to make permanent changes command line options: provides access to some configurations options, typically one off settings Command line configurations to see all available command line options, run rspec ‚Äìhelp and you‚Äôll see in you terminal options for:  calling, loading files or directories tweak the output (formatting, write output in a file, backtrace, color, no color) filtering/tags, (match a word, only run a specific example, all failures, next failure) Utility (Initialize your project with RSpec, run RSpec version)R s p e c already asked the two most important directories to load path your projects leave and expect folders. we have filtering options like the following we have output options like the following and if you want to save this options to customize the behavior for everyone we have three different options       File   Usage   Gotcha         ~/. rspec   Stores global personal RSpec preferences for all projects on your machine.    Affects every project; avoid settings that could break others‚Äô test runs if shared.        . /. rspec   Project-level defaults; should contain only essential settings agreed upon by the team.    Overusing for personal prefs can cause conflicts; always commit only team-approved settings.        . /. rspec-local   Per-project personal preferences; lives alongside the project‚Äôs . rspec file.    Exclude from version control; every developer may have their own version.    something to keep in mind is that the order that we have listed above is how options take precedence, local options will override more global ones. For instance, if your project has --profile 5 set in its . rspec file, you could override this setting by putting --no-profile in the project‚Äôs . rspec-local file. Using a custom formatter a question for matter is a regular Ruby class that registers itself with rspec to receive notification.  as your suite runs, rspec notifies the formatter of the events it is subscribed to, such as starting an example group, running an example, or encountering a failure. R s p e c s built in formatters display failure details, messages and back traces, at the very end of the run. however, as you suite grows and start thinking longer to complete, it can be nice to see failure details as soon as they are cure. How far matters work. a formatter goes through three main steps: register itself with rspec to receive a specific notifications initialize itself at the beginning of the rsvc Run react to events as they occur RSpec. configure We have seen how easily we can set configuration options for a particular spec run via the command line. as convenient as they are this modifications are not available for all the test suit. for the rest will need to call RS p e c. configure inside one or more Ruby files. you can have multiple configure blocks in your code base; if you do rspec will combine the options from all of them. Cuz we have seen before a hook can run for each example, once for each context, or globally for the entire suit . We also have other special purpose configuration hook that doesn‚Äôt fit the typical before, after, around pattern. and example would be RSpec. configure do |config|config. when_first_matching_example_defined(:db) dorequire 'support/db'endendThis hook uses metadata :db to perform extra configuration just for the specs that needed. while config hooks are great way to reduce duplication and keep your example focused, there are significant downsides if you overuse them: it‚Äôs low test suit due to extra logic running for every example spec star hotter to understand because their logic is hidden in hooks to avoid this pitfalls you can use a simpler, more explicit technique: using Ruby modules inside your configure blocks. Sharing code with Ruby modules # spec_configure. rbclass Performerinclude Singing # won't override Performer methodsprepend Dancing # may override Performer methodsendYou can even bring methods into an individual object: # spec_configure. rbaverage_person = AveragePerson. new average_person. extend SingingRSpec provides the same kind of interface inside RSpec. configure blocks. By calling include, prepend, or extend on the config object RSpec. configure do |config|# Brings methods into each exampleconfig. include ExtraExampleMethods# Brings methods into each example,# overriding methods with the same name# (rarely used)config. prepend ImportantExampleMethods# Brings methods into each group (alongside let/describe/etc. )# Useful for adding to RSpec's domain-specific languageconfig. extend ExtraGroupMethodsendThese three config methods are great for sharing Ruby methods across the respects. if you need to share more, though such as hooks or let definitions, you will need to define a shirt example group. # spec_configure. rbRSpec. configure do |config|config. include_context 'My Shared Group'endFiltering we have found the need to run just some of the examples in your suit therefore we have used rsps filtering to run the following subsets of specs: a single example or group by name only the specs matching a certain piece of metadata such as :fast Some of the rspec configuration system that we have used inside of our configure block are the following RSpec. configure do |config| config. filter_run_when_matching :focus # Runs only examples/groups tagged with :focus config. example_status_persistence_file_path = 'spec/examples. txt' # Stores example run status for --only-failures/--next-failure config. filter_gems_from_backtrace 'rack', 'rack-test', 'sequel', 'sinatra' # Removes listed gems from failure backtraces config. filter_run_when_matching :focus # Duplicate line; same as first setting aboveendAnd if I was reviewing the directory of the exercises from Facebook are realized that the configure block is almost everywhere either from the root directory to a specific model specs files where we need it a more granually effect on the test running As a conclusion for this chapter we have explored that we have two ways to configure the rspec testing framework one is from the command line and the other is with the configure method. command line options are easy to discover and they are one off to modify the next output the next format or to run a subset of tests on the other hand with configure method covers the whole test suit and also we can have more control as we declare those configure blocks inside of the files Part IV ‚Äî RSpec expectations. : With rspec-expectations, you can easily express expected outcomes about your code. It uses simple matcher objects that can be composed in useful, powerful ways. We‚Äôll dig into how rspec-expectations works, how to compose matchers, and why doing so is useful. Part IV ‚Äî Chapter 10. Exploring RSpec expectations. : In RSpec Core, we saw how rspec-core helps you structure your test code into example groups and examples. but having a sound structure is not enough for writing good tests. If our specs run code without looking at the output, we are not really testing anything, except the code doesn‚Äôt crash outright. That‚Äôs where RSpec-expectations comes in. it provides an API for a specifying expected outcomes. RSpec example should contain one or more expectations. This express what you expect to be true at a specific point in your code. In this chapter, we‚Äôll see how one crucial part of expectations ‚Äì the matcher can be combined in useful new ways. ratio = 22 / 7. 0expect(ratio). to be_within(0. 1). of(Math::PI)numbers = [13, 3, 99]expect(numbers). to all be_oddalphabet = ('a'. . 'z'). to_aexpect(alphabet). to start_with('a'). and end_with('z')The primary goal of rspec-expectations is clarity, both in the examples you write and in the output when something goes wrong. Parts of an expectation: expect(deck. cards. count). to eq(52), 'not playing with a full deck'While there is some variety here, the syntax consistently uses just a few example parts:  A subject - the thing you are testing, that is, an instance of a Ruby class.  A matcher - an object that specifies what you expect to be true about the subject, and provides the past or fail logic (Optionally) a custom failure message irb session irb(main):001&gt; require 'rspec/expectations'=&gt; trueirb(main):002&gt; include RSpec::Matchers=&gt; Objectirb(main):003&gt; expect(1). to eq(1)=&gt; trueirb(main):004&gt; expect(1). to eq(2)/Users/dominiclizarraga/. rbenv/versions/3. 4. 2/lib/ruby/gems/3. 4. 0/gems/rspec-support-3. 13. 4/lib/rspec/support. rb:110:in 'block in &lt;module:Support&gt;': (RSpec::Expectations::ExpectationNotMetError)expected: 2   got: 1(compared using ==)Wrapping your subject with expect Ruby begins evaluating your expectation at the expect method. Let‚Äôs go to irb session again: irb(main):005&gt; expect_one = expect(1)=&gt; #&lt;RSpec::Expectations::ValueExpectationTarget:0x000000013ad9. . . irb(main):006&gt; expect_one=&gt; #&lt;RSpec::Expectations::ValueExpectationTarget:0x000000013ad99708 @target=1&gt;Here, our subject is the number 1. We have wrapped in the expect method to give ourself a place to attach methods like to or not_to. in other words the expect methods wraps are object in a test friendly adapter. Side note: prior versions of RSpec expect method what should and should_not respectively. Using a matcher If expect wraps your object for testing, then the matcher actually performs the test. The matcher checks that the subject satisfies its criteria. matcher can compare numbers, find patterns in text, examine deeply nested data structures or perform any custom Behavior you need. The RSpec::Matchers module ships with built-in methods to create matchers: irb(main):007&gt; be_one = eq(1)=&gt; #&lt;RSpec::Matchers::BuiltIn::Eq:0x000000013abf9808. . . irb(main):008&gt; be_one=&gt; #&lt;RSpec::Matchers::BuiltIn::Eq:0x000000013abf9808 @expected=1&gt;This matcher can‚Äôt do anything on its own; we still need to combine it with the subject we saw in the previous section. Please, notice how expect(1) built an ExpectationTarget object internally returns: @target ‚Üí is the actual value you passed in (1 in our example). This object is just a holder for that value, plus some helper methods like . to and . not_to Then, with eq(1) built a matcher object (in this case RSpec::Matchers::BuiltIn::Eq). And internally @expected ‚Üí is the value you want to match against (1 here). irb(main):011&gt; expect_one. to(be_one)=&gt; trueirb(main):012&gt; expect_one. not_to(be_one)/Users/dominiclizarraga/. rbenv/versions/3. 4. 2/lib/ruby/gems/3. 4. 0/gems/rspec-support-3. 13. 4/lib/rspec/support. rb:110:in 'block in &lt;module:Support&gt;': (RSpec::Expectations::ExpectationNotMetError)expected: value != 1   got: 1(compared using ==)The to method tries to match the subject (in this case, the integer 1) against the provided matcher. If there‚Äôs a match, the method returns true; if not, it bails with a detailed failure message. The not_to method does the opposite: irb(main):017&gt; expect_one. not_to eq(be_one)=&gt; trueirb(main):014&gt; expect(1). not_to eq(2)=&gt; trueWhen you think of RSpec expectations as being just a couple of simple Ruby objects glued together, the syntax becomes clear. You‚Äôll use parentheses with the expect method call, a dot to attach the to or not_to method, and a space leading up to the matcher (maybe eq). Custom failure messages. Let‚Äôs see an example of a very brief Ruby code that will show us a technically correct error however we can make it more explicit by adding an alternate failure message along to the matcher to or not_to irb(main):018&gt; resp = Struct. new(:status, :body). new(400, 'unknown query param `sort`')=&gt; #&lt;struct status=400, body= unknown query param `sort` &gt;irb(main):019&gt; expect(resp. status). to eq(200)/Users/dominiclizarraga/. rbenv/versions/3. 4. 2/lib/ruby/gems/3. 4. 0/gems/rspec-support-3. 13. 4/lib/rspec/support. rb:110:in 'block in &lt;module:Support&gt;': (RSpec::Expectations::ExpectationNotMetError)expected: 200   got: 400(compared using ==)irb(main):020&gt; expect(resp. status). to eq(200),  Got a #{resp. status}: #{resp. body} /Users/dominiclizarraga/. rbenv/versions/3. 4. 2/lib/ruby/gems/3. 4. 0/gems/rspec-support-3. 13. 4/lib/rspec/support. rb:110:in 'block in &lt;module:Support&gt;': Got a 400: unknown query param `sort` (RSpec::Expectations::ExpectationNotMetError)When the matchers default failure message doesn‚Äôt provide enough detail, a custom message maybe just what you need. You can save time by writing your own matches instead if you find yourself using the same message repeatedly. RSpec expectations vs traditional assertsAssertions are simpler to explain than RSpec‚Äôs expectations‚Äîand simplicity is a good thing‚Äîbut that doesn‚Äôt necessarily make one better than the other.       Concept   Why   Code example         Composability   Matchers are first-class objects that can be combined and used flexibly.    expect(score). to be &gt; 5 &amp; be &lt; 10       Negation   Any matcher can be negated with not_to without writing a separate refute method.    expect(user. active?). not_to be true       Readability   Syntax reads like an English sentence describing the expected outcome.    expect(order. total). to eq 100       More useful errors   Failure messages clearly show which part failed, unlike generic assertions.    expect([13, 2, 3, 99]). to all be_odd   How matchers work Any Ruby object can be used as a matcher as long as it implements a minimal set of methods (. matches? and . failure_message), let‚Äôs build one in irb irb(main):021&gt; matcher = Object. new=&gt; #&lt;Object:0x0000000138954280&gt;irb(main):022&gt; expect(1). to matcher/Users/dominiclizarraga/. rbenv/versions/3. 4. 2/lib/ruby/gems/3. 4. 0/gems/rspec-expectations-3. 13. 5/lib/rspec/matchers. rb:968:in 'RSpec::Matchers#method_missing': undefined method 'matches?' for #&lt;Object:0x0000000138954280&gt; (NoMethodError)Did you mean? matchThis expectation has triggered a NoMethodError exception. RSpec expects every matcher to implement a matches? method, which takes an object and returns true if the object matches (and false otherwise). irb(main):027* def matcher. matches?(actual)irb(main):028*  actual == 1irb(main):029&gt; end=&gt; :matches?irb(main):030&gt; expect(1). to matcher=&gt; trueWhen the match fails, RSpec expectations calls the matcher‚Äôs failure_message method irb(main):031&gt; expect(2). to matcher/Users/dominiclizarraga/. rbenv/versions/3. 4. 2/lib/ruby/gems/3. 4. 0/gems/rspec-expectations-3. 13. 5/lib/rspec/matchers. rb:968:in 'RSpec::Matchers#method_missing': undefined method 'failure_message' for #&lt;Object:0x0000000138954280&gt; (NoMethodError)# here we implemented the . failure_messageirb(main):035* def matcher. failure_messageirb(main):036*  'expected object to equal 1'irb(main):037&gt; end=&gt; :failure_messageirb(main):038&gt; expect(2). to matcher/Users/dominiclizarraga/. rbenv/versions/3. 4. 2/lib/ruby/gems/3. 4. 0/gems/rspec-support-3. 13. 4/lib/rspec/support. rb:110:in 'block in &lt;module:Support&gt;': expected object to equal 1 (RSpec::Expectations::ExpectationNotMetError)These two methods matches? and failure_message are all you need to define a simple matcher. Composing matchersWhere the matchers really shine is when you compose them with other matchers to specify exactly what you expect and nothing more. the result is more robust tests and fewer false failures. Here are a few different ways to compose matchers:       Technique   Usage   Code example         Pass matcher into another   Use a matcher as an argument to another matcher.    expect(result). to start_with a_string_matching(/Hello/)       Embed in Array/Hash   Place matchers inside arrays or hashes to match structure and values.    expect(user). to match(name: a_string_starting_with( A ))       Logical operators   Combine matchers with &amp; (and) or | (or).    expect(score). to be &gt; 5 &amp; be &lt; 10   How matchers match objects Matchers build on top of Ruby‚Äôs standard protocols in order to provide composability: the humble === method. This method, often called ‚Äúthree equals‚Äù or ‚Äúcase equality‚Äù defines a category to which other objects may or may not be long. most of the time you wont call it directly from production code. Instead, Ruby will call it for you inside each one class of a case expression irb(main):039* def describe_value(value)irb(main):040*  case valueirb(main):041*  when be_within(0. 1). of(Math::PI) then 'Pi'irb(main):042*  when be_within(0. 1). of(2 * Math::PI) then 'Double Pi'irb(main):043*  endirb(main):044&gt; end=&gt; :describe_valueirb(main):045&gt; describe_value(3. 14159)=&gt;  Pi irb(main):046&gt; describe_value(6. 28319)=&gt;  Double Pi RSpec expectations perform the same check internally that Ruby‚Äôs case statement does: they call === on the object you pass in. that object can be anything, including another matcher. Passing one matcher into another It may not be obvious why you would need to pass a matcher to another matcher. that say you expect a particular array to start with a value that‚Äôs near pi. with rspec, you can pass the be_within(0. 1). of(Math::PI) matcher matcher into the start_with irb(main):047&gt; numbers = [3. 14159, 1. 734, 4. 273]=&gt; [3. 14159, 1. 734, 4. 273]irb(main):048&gt; expect(numbers). to start_with( be_within(0. 1). of(Math::PI) )=&gt; trueirb(main):049&gt; expect([]). to start_with( a_value_within(0. 1). of(Math::PI) )/Users/dominiclizarraga/. rbenv/versions/3. 4. 2/lib/ruby/gems/3. 4. 0/gems/rspec-support-3. 13. 4/lib/rspec/support. rb:110:in 'block in &lt;module:Support&gt;': expected [] to start with a value within 0. 1 of 3. 141592653589793Embedding matches in Array and hash data structures This ability to compose matchers‚Äîby passing them into one another, or by embedding them in data structures‚Äîlets you be as precise or as vague as you need to be. In other matchers like match_array or contain_exactly, RSpec does recursively apply matchers inside arrays and hashes, but start_with (and end_with) do not. irb(main):069* presidents = [irb(main):070* { name: 'George Washington', birth_year: 1732 },irb(main):071* { name: 'John Adams', birth_year: 1735 },irb(main):072* { name: 'Thomas Jefferson', birth_year: 1743 },irb(main):073* # . . . irb(main):074&gt; ]=&gt; [{name:  George Washington , birth_year: 1732},. . . irb(main):075* expect(presidents). to start_with(irb(main):076*  match(name: 'George Washington', birth_year: a_value_between(1730, 1740)),irb(main):077*  match(name: 'John Adams', birth_year: a_value_between(1730, 1740))irb(main):078&gt; )=&gt; trueCombining matters with logical and or operators There‚Äôs another way to combine matchers: compound matcher expressions. Every built-in matcher has two methods (and and or). irb(main):079&gt; alphabet = ('a'. . 'z'). to_airb(main):080&gt; =&gt; [ a ,. . . irb(main):081&gt; expect(alphabet). to start_with('a'). and end_with('z')irb(main):082&gt; =&gt; trueirb(main):083&gt; stoplight_color = %w[ green red yellow ]. sampleirb(main):084&gt; =&gt;  yellow irb(main):085&gt; expect(stoplight_color). to eq('green'). or eq('red'). or eq('yellow')irb(main):086&gt; =&gt; trueYou can use the words and/or, or you can use the &amp; and | operators Generated example descriptions Matchers have another useful ability over simpler assert methods: they‚Äôre selfdescribing. irb(main):087&gt; start_with(1). description=&gt;  start with 1 irb(main):088&gt; (start_with(1) &amp; end_with(9)). description=&gt;  start with 1 and end with 9 irb(main):089&gt; contain_exactly( a_string_starting_with(1) &amp; ending_with(9) ). description=&gt;  contain exactly (a string starting with 1 and ending with 9) As you can see, the descriptions of composed and compound matchers include the description of each part. Part IV ‚Äî Chapter 11. Matchers included in RSpec expectations. : In the previous chapter, we learned how to write expectations to check your codes behavior. We got to know the various parts of an expectation like a subject and the matcher. Now, it‚Äôs time to take a closer look at matchers. You have called them in your specs and combine them with other matchers.  RSpec ships with a ton of useful matchers to help you specify exactly how you want the code to behave. The matchers in RSpec expectations fall into three growth categories:  Primitive: matchers for basic data types like strings, numbers and so on High order matchers: that can take other matchers as inputs, then apply them across collections Block matchers: for checking properties of code including blocks, exceptions, and side effects. Primitive matches The word primitive in a programming language refers to a breath and butter data type that cannot be broken down into a smaller pieces. booleans, integers, and floating point numbers are all primitives. Primitive matchers are similar. They have simple, precise definitions that cannot be broken down any further. They are not meant to accept other matchers as input (but you can go the other direction, passing them into other matchers). Typically, they just pass the operation you are performing - and equality check, for example a straight through the subject of the expectation. Equality and identity Most fundamentals matchers are all concerned with variations of the question: ‚Äúare these two things the same?‚Äù, depending on the context. ‚ÄúThe same‚Äù might refer to one of the several things:    Identity: for example, two references to one object     Hash key equality: two objects of the same type and value, such as two copies of the string ‚Äúhello‚Äù.     Value equality: two objects of compatible types with the same meaning, such as the integer 42 on the floating Point number 42. 0  Value equality Most of the time, Ruby programmers are concerned with the last of these: value equality, embodied in Ruby‚Äôs === operator. This matcher is the one you want. However, sometimes you have a more specific me. expect(Math. sqrt(9)). to eq(3)# equivalent to:Math. sqrt(9) == 3Identity perms = Permutations. newfirst_try = perms. of(long_word_list)second_try = perms. of(long_word_list)expect(second_try). to eq(first_try)This test will likely give you a false assurances. If the underlying cache is misbehaving or was never implemented, the calculation will just run again and produce a new word list in the same order. Because both arrays have the same contents, your test will incorrectly pass. Instead, you would like to know whether or not first_try and second_try are actually referring to the same underlaying object, not just two copies with identical contents. For this stricter comparison, you will use equal matcher, which hands off to Ruby‚Äôs equal? method behind the scenes: expect(second_try). to equal(first_try)If you prefer you can also use be(x) as an alias for equal(x) to emphasize that this matcher is about identity rather than value equality expect(RSpec. configuration). to be(RSpec. configuration)Hash key equality Programmers rarely check hash key equality directly. As the name implies, it‚Äôs used to check that two values should be considered the same Hash key. RSpec eql matcher, based on Ruby‚Äôs built-in eql? method, checks for hash key equality. Generally, it behaves the same as the eq matcher since eql? always considers integers and floating point numbers to be different. # 3 == 3. 0:expect(3). to eq(3. 0)# . . . but 3. eql?(3. 0) is false:expect(3). not_to eql(3. 0)This behavior allows 3 and 3. 0 to be used as different keys in the same hash.  When in doubt, try `eq` first. (In most situations, value equality is the one you need. )Variations All three of these matchers have aliases that read better in composed matcher expressions:  an_object_eq_to aliases eq (identity) an_object_equal_to aliases equal (value equality) an_object_eql_to aliases eql (hash key equality)For instance, consider the following expectation that checks a list of Ruby classes: expect([String, Regexp]). to include(String)The intent was to require the actual Ruby String class to be present. Higher-order matchers like include checktheir arguments with the three-quals operator, ===. In this case, RSpec ends up checking String === ‚Äòa string‚Äô, which returns true. The fix is to pass the an_object_eq_to expect([String, Regexp]). to include(an_object_eq_to String)Truthiness While Ruby has literal true and false values, it allows any object to be used in a conditional. The rules are very simple false and nil are both treated as false, and everything else is treated as true even the numbers 0. expect(true). to be_truthyexpect(0). to be_truthyexpect(false). not_to be_truthyexpect(nil). not_to be_truthy# . . . and on the flip side:expect(false). to be_falseyexpect(nil). to be_falseyexpect(true). not_to be_falseyexpect(0). not_to be_falseyIf you want to specify that the value is precisely equal to true or false, simply use one of the equality matchers we described in the last section: expect(1. odd?). to be trueexpect(2. odd?). to eq falseAlises: ‚Ä¢ be_truthy is aliased as a_truthy_value. ‚Ä¢ be_falsey is aliased as be_falsy, a_falsey_value and a_falsy_value. Operator comparisons We have used thebe method with arguments before, as in expect(answer). to be(42). This method has another form, one without arguments. with it you can perform greater-than and less-than comparisons: expect(1). to be == 1expect(1). to be &lt; 2expect(1). to be &lt;= 2expect(2). to be &gt; 1expect(2). to be &gt;= 1expect(String). to be === 'a string'expect(/foo/). to be =~ 'food'In each case, RSpec uses your operator such as == or &lt; to compare the actual and the matcher on the first line, be == 1, is equivalent to eq(1). Delta and range comparisons Checking two floats for exact equality will frequently cause failures expect(0. 1 + 0. 2). to eq(0. 3)‚Ä¶then you get a failure:expected: 0. 3got: 0. 30000000000000004(compared using ==)Absolute difference Instead of looking for exact equality with floats, you should use be_within matcher: expect(0. 1 + 0. 2). to be_within(0. 0001). of(0. 3)Relative difference Equally useful is the percent_of method, where you give a relative difference instead: town_population = 1237expect(town_population). to be_within(25). percent_of(1000)A single be_within matcher supports both absolute and relative values, based on which method you chain off of it Ranges Sometimes, it‚Äôs a better fit to express your expected values in terms of a range, rather than a target value and delta. expect(town_population). to be_between(750, 1250)` be_within is aliased to a_value_within and be_between is aliased to a_value_between` Dynamic predicates A predicate is a method that answers a question with a Boolean answer. For example, Ruby‚Äôs Array class provides an empty? method rather than is_empty. expect([]). to be_emptyYou can alternately use a be_a_ or be_an_ prefix for predicates that are nouns. expect(user). to be_adminexpect(user). to be_an_adminhash = { name: 'Harry Potter', age: 17, house: 'Gryffindor' }expect(hash). to have_key(:age)How Dynamic Predicate Matchers Work  You write: expect(user). to be_admin RSpec sees: ‚ÄúHmm, I don‚Äôt recognize be_admin, but it follows the pattern be_*‚Äù RSpec transforms it: Strips off be_, adds ?, and calls that method on the subject RSpec actually calls: user. admin?# What you write     ‚Üí What RSpec callsexpect(user). to be_admin  ‚Üí user. admin?expect([]). to be_empty   ‚Üí []. empty?expect(str). to be_blank   ‚Üí str. blank?expect(obj). to be_valid   ‚Üí obj. valid?Trade-offs As readable and useful as Dynamic predicate math chairs can be, they do have some trade-offs. For example if you want to test for exact true or false results and another bigger problem is documentation, because Dynamic matters are generated on the fly, they have no documentation. Higher-order matchers All the matchers seen so far are primitives. Now, we are going to look at higher order matchers that is, matchers that you can pass other matchers into. With this technique, you can build up composed matchers that specify exactly the behavior you need. Collections and strings RSpec ships with six different matches for dealing with data structures:       Matcher   Usage   Example         include   Checks that certain items are present (any order).    expect([1, 2, 3]). to include(2, 3)       start_with   Checks that items appear at the beginning.    expect([1, 2, 3]). to start_with(1, 2)       end_with   Checks that items appear at the end.    expect( foobar ). to end_with( bar )       all   Checks that all elements satisfy a matcher.    expect([1, 3, 5]). to all be_odd       match   Matches a data structure exactly (order matters for arrays).    expect([1, 2]). to match([be_odd, be_even])       contain_exactly   Checks that a collection has exactly these items (order doesn't matter).    expect([1, 2, 3]). to contain_exactly(3, 2, 1)   All of these matchers also work with strings, with a few minor differences. Include The include matcher is one of the most flexible.  By using include rather than a structure matcher like eq or match, you can specify just the elements you care about. The collection can contain unrelated items, and your test will still pass. At its simplest, the include matcher works on any object with an include? method. Strings and arrays both support this method. expect('a string'). to include('str')expect([1, 2, 3]). to include(3)hash = { name: 'Harry Potter', age: 17, house: 'Gryffindor' }expect(hash). to include(:name)expect(hash). to include(age: 17)It also accepts a variable number of arguments so that you can specify multiple substrings, array items, hash keys or key-value pairs: expect('a string'). to include('str', 'ing')expect([1, 2, 3]). to include(3, 2)expect(hash). to include(:name, :age)expect(hash). to include(name: 'Harry Potter', age: 17)This works well, but there is a gotcha related to variable numbers of items. Consider this example: expecteds = [3, 2]expect([1, 2, 3]). to include(expecteds)# failure messageexpected [1, 2, 3] to include [3, 2]# possible solutions:expect([1, [3, 2]]). to include([3, 2])expect([1, 2, 3]). to include(*expecteds)start_with and end_with These two matchers are useful when you care about the content of a string or a collection at the start or end but don‚Äôt care about the rest. expect('a string'). to start_with('a str'). and end_with('ng')expect([1, 2, 3]). to start_with(1). and end_with(3)# use separately expect([1, 2, 3]). to start_with(1, 2)expect([1, 2, 3]). to end_with(2, 3)# aliases and compounding expect(['list', 'of', 'words']). to start_with( a_string_ending_with('st') ). and end_with( a_string_starting_with('wo'))all The all matcher is somewhat of an oddity: it is the only built-in matter that is not a verb, and it is the only one that always takes another matcher as an argument: numbers = [1, 2, 3]expect(numbers). to all be_evenThis expression does exactly what it says: it expects all the numbers in the array to be even. One gotcha to be aware of is that, like Enumerable#all?, this matcher passes against an empty array. This can lead to surprises. Example: def self. evens_up_to(n = 0)0. upto(n). select(&amp;:odd?)endexpect(evens_up_to). to all be_evenOur expectation didn‚Äôt fail and we forgot to pass an argument to evens_up_to RSpec::Matchers. define_negated_matcher :be_non_empty, :be_emptyexpect(evens_up_to). to be_non_empty. and all be_evenWe‚Äôre using another RSpec feature, define_negated_matcher, to create a new be_non_empty matcher that‚Äôs the opposite of be_empty. Now, the expectation correctly flags the broken method as failing: expected `[]. empty?` to return false, got trueMatch If you call JSON or XML APIs, you often end up with deeply nested arrays and hashes. As you did with eq, you provide a data structure that‚Äôs laid out like the result you‚Äôre expecting. match is more flexible children = [{ name: 'Coen', age: 6 },{ name: 'Daphne', age: 4 },{ name: 'Crosby', age: 2 }]expect(children). to match [{ name: 'Coen', age: a_value &gt; 5 },{ name: 'Daphne', age: a_value_between(3, 5) },{ name: 'Crosby', age: a_value &lt; 3 }]#it works with strings tooexpect('a string'). to match(/str/)expect('a string'). to match('str')Contain_exactly We‚Äôve seen that match checks data structures more loosely than eq; contain_exactly is even looser. The difference is that match requires a specific order, whereas contain_exactly ignores ordering. expect(children). to contain_exactly({ name: 'Daphne', age: a_value_between(3, 5) },{ name: 'Crosby', age: a_value &lt; 3 },{ name: 'Coen', age: a_value &gt; 5 })expect(children). to contain_exactly({ name: 'Crosby', age: a_value &lt; 3 },{ name: 'Coen', age: a_value &gt; 5 },{ name: 'Daphne', age: a_value_between(3, 5) })Which collection matcher should I use? With a half dozen collection matches to pick from, you may wonder which one is the best for your situation. In general, we recommend you use the loosest matter that still specifies the behavior you care about. Using a loose matcher makes your specs less brittle: it prevents incidental details from causing an unexpected failure. Quick reference for the different uses:  Block matchers With all the expectations we have seen so far, we have past regular Ruby objects into expect: expect(3). to eq(3) this is fine for checking properties of your data. but sometimes you need to check properties of a piece of code. for example, perhaps a certain piece of code is supposed to raise an exception. ```rubyexpect { raise 'boom' }. to raise_error('boom')Rsbec will run the block and watch for the specific side effects you specify: exceptions, mutating variables, I/O and so on. Raising and throwing R s p e c provides matters for both of the situations: that are properly named race error and throw SYM race error first, let‚Äôs look at race error also known as race exception. this matter is very flexible, supporting multiple forms: race error with no arguments match if any error is raised race error( some error class) matches if some error class or soup class is raised race error(‚Äòmessage error‚Äô) matches if an error is raised with a message exactly equal to a giving a string raise error(/some Rejects/) matches if an error is raised with a message matching a given pattern you can also combine these criteria if the class and the message are important raise_error(SomeErrorClass, ‚Äúsome message‚Äù)‚Ä¢ raise_error(SomeErrorClass, /some regex/)‚Ä¢ raise_error(SomeErrorClass). with_message(‚Äúsome message‚Äù)‚Ä¢ raise_error(SomeErrorClass). with_message(/some regex/) expect {'hello'. world}. to raise_error(an_object_having_attributes(name: :world))There are a couple of caches with race error that can lead can lead to false positives. furious, race error with no arguments will match any error and it cannot tell the difference between exceptions you did or did not mean to throw. for example if you rename a method but forget to update your spec on my Ruby will throw a effort ever. and over serious race Arrow will swallow this exception and respect will pass. always include some kind of detail ‚Äì either I specific custom ever class or a snippet from the message ‚Äì that is unique to the specific race statement you are testing throw symbol exceptions are designed for, well, exceptional situation such as an error in a program logic. they are not suited for everyday control flow, so just jumping out of a deeply nasty nasty look or a methyl. for situation like this, Ruby provides the Federal construct. expect { throw :found }. to throw_symbol(:found)expect { throw :found, 10 }. to throw_symbol(:found, a_value &gt; 9)Yielding blocks are one of rubies most distinctive features. they allow you to pass around little chunks of code using an easy to read syntax def self. just_yield puts  [just_yield] about to yield  yield puts  [just_yield] after yield endRSpec. describe  yield_control demo  do it  shows the flow  do  expect { |block_checker|   puts  [expect block] calling just_yield with block_checker    just_yield(&amp;block_checker)   puts  [expect block] returned from just_yield   }. to yield_control endend#output[expect block] calling just_yield with block_checker[just_yield] about to yield[just_yield] after yield[expect block] returned from just_yieldYou can also add with these Guild arguments, no arguments and successive arguments Mutation here we use the change matcher that will help you specify the sort of mutation you are expecting array = [1, 2, 3]expect { array &lt;&lt; 4 }. to change { array. size }The matcher performs the following actions in turn:  Run your change block and store the result, array. size, as the before value Run the code under test, array ¬´¬†4 Run your change block a second time and store the result, array. size, as theafter value Pass the expectation if the before and after values are differentThis expectation checks whether or not the expectation changed If you need to be more specific and highlight the amount of the change you can use: Specifically, you can use by, by_at_least, or by_at_most to specify the amount of the change: expect { array. concat([1, 2, 3]) }. to change { array. size }. by(3)expect { array. concat([1, 2, 3]) }. to change { array. size }. by_at_least(2)expect { array. concat([1, 2, 3]) }. to change { array. size }. by_at_most(4)and also we have the front and two if you want to know the exact before and after values expect { array &lt;&lt; 4 }. to change { array. size }. from(3)expect { array &lt;&lt; 5 }. to change { array. size }. to(5)expect { array &lt;&lt; 6 }. to change { array. size }. from(5). to(6)expect { array &lt;&lt; 7 }. to change { array. size }. to(7). from(6)Summary of this chapter: Primitive matchers       Concept   Usage   Example         Equality (eq)   Value equality: two objects that mean the same.    expect(42). to eq 42. 0       Identity (equal)   Object identity: same object reference.    expect(a). to equal(a)       Hash key equality (eql)   Equality as defined by Hash key rules.    expect(:a). to eql(:a)       Aliases   an_object_eq_to ‚Üí eqan_object_equal_to ‚Üí equalan_object_eql_to ‚Üí eql   expect(x). to an_object_eq_to(y)       Truthiness   Checks truthy/falsey values.    expect(true). to be_truthy       Operator comparison   Delegates to Ruby‚Äôs operators.    expect(5). to be &gt; 3       Delta &amp; Range   Approximate numeric comparisons.    expect(3. 14). to be_within(0. 01). of(3. 15)       Dynamic predicates   Calls Ruby predicate methods.    expect([]). to be_empty       Recommendation: When in doubt, use eq. Value equality is the one you need most often.    Higher order matchers       Matcher   Usage   Example         include   Requires certain items to be present (any order).    expect([1,2,3]). to include(2,3)       start_with   Checks items at the beginning.    expect([1,2,3]). to start_with(1)       end_with   Checks items at the end.    expect( hello ). to end_with( lo )       all   Applies a matcher to all elements.    expect([1,3,5]). to all be_odd       match   Matches against a pattern (array/hash/string/regex). Requires order.    expect({a:1,b:2}). to match(a: be &gt; 0, b: be &lt; 3)       contain_exactly   Checks that only the given items are present, ignoring order.    expect([1,2,3]). to contain_exactly(3,1,2)       Recommendation: Prefer the loosest matcher that still specifies the behavior you care about. For example, use contain_exactly when order doesn‚Äôt matter to avoid brittle specs. Match when order matter   Block matchers       Matcher   Usage   Example         raise_error   Asserts exceptions raised in a block.        expect { 1/0 }. to raise_error(ZeroDivisionError)    expect { foo }. to raise_error( bad )    expect { bar }. to raise_error(/pattern/)          yield_control   Checks that a block yields.    expect { |b| obj. call(&amp;b) }. to yield_control       change   Asserts that a block mutates state.        expect { arr &lt;&lt; 1 }. to change { arr. size }. by(1)    expect { arr &lt;&lt; 2 }. to change { arr. size }. from(1). to(2)          Recommendation: Use change when you care about mutations, yield when testing block semantics, and always make raise_error specific to avoid false positives.    Part IV ‚Äî Chapter 12. Creating custom matchers. : Creating custom matchers In the previous chapter, we took a tour of the matchers that ship with RSpec. We can be productive with them on simpler projects, they may be or what you need. Eventually, though, you are going to hit the limits of the built-in matchers. Because they are meant for testing general purpose Ruby code, they require you to speak in Ruby terms rather than your projects terms. For example please take a look at the next expectations: Without custom matchers: expect(art_show. tickets_sold. count). to eq(0)expect(u2_concert. tickets_sold. count). to eq(u2_concert. capacity)With custom matchers expect(art_show). to have_no_tickets_soldexpect(u2_concert). to be_sold_outWe have added to custom matchers have_no_tickets_sold and be_sold_out, so that we can describe the behavior in terms of events and tickets. These are the terms that the rest of the project team would use.  This reminds me of this Martin Fowler talk: https://www. youtube. com/watch?v=pGB5g-Do3qI  He cites an exercise by Kent Beck, where he asked team members: ‚ÄúDescribe how the system works using only four objects. ‚ÄùIf they all chose the same objects, he could deduce that the team had good coherence. Otherwise, if they picked different objects, it showed that the team lacked cohesion. When we write clear, easy to use custom matchers, you gain several benefits:  you stand a greater chance of building what your stakeholders want you reduce the cost of API changes (because you need only update your match) you can provide better failure messages when something and you improve the test output, example:Without custom matchers: expected: 0got: 2(compared using ==)expected: 10000got: 9900(compared using ==)With custom matchers expected #&lt;Event  Art Show  (capacity: 100)&gt; to have no tickets sold, but had 2expected #&lt;Event  U2 Concert  (capacity: 10000)&gt; to be sold out, but had 100 unsold ticketsNot only does this report to speak out the main language, it also provides additional details such as what specific events we are testing here. Delegating to existing matchers using helper methods. We are going to start with a technique we have already used to keep your code organized: helper methods This is a test that we used when we built the expense tracker app expect(ledger. expenses_on('2017-06-10')). to contain_exactly( a_hash_including(id: result_1. expense_id), a_hash_including(id: result_2. expense_id))This matcher got the job done. Notice, though, how it expresses the expectation in terms of Ruby objects: hashes and IDs. Let‚Äôs use the main language of the project: expect(ledger. expenses_on('2017-06-10')). to contain_exactly( an_expense_identified_by(result_1. expense_id), an_expense_identified_by(result_2. expense_id))# spec/spec_helper. rbmodule ExpenseTrackerMatchers def an_expense_identified_by(id)  a_hash_including(id: id) endendRSpec. configure do |config| config. include ExpenseTrackerMatchersWe are delegating to another matcher but there is a gotcha that may bring about a false positive so let‚Äôs make this match more robust. This data structure would make the test pass { id: 1, email: 'john. doe@example. com', role: 'admin'}# let‚Äôs add the payee, amount and date by using compounding ‚Äú. and‚Äùdef an_expense_identified_by(id) a_hash_including(id: id). and including(:payee, :amount, :date)endRSpec allows you to create aliases for different matchers, this is how you can define them: Example of RSpec built-in: # a_value_within as an alias of the be_within matcherexpect(results). to start_with a_value_within(0. 1). of(Math::PI)Inside of the file 12-creating-custom-matchers/05/custom_matchers. rb RSpec::Matchers. alias_matcher :an_admin, :be_an_admin# will produce&gt;&gt; be_an_admin. description=&gt;  be an admin &gt;&gt; an_admin. description=&gt;  an admin The alias_matcher method can also take a block: RSpec::Matchers. alias_matcher :an_admin, :be_an_admin do |old_description|old_description. sub('be an admin', 'a superuser')end# will produce&gt;&gt; an_admin. description=&gt;  a superuser Also you can create negating matchers From this: expect(correct_grammar). to_not split_infinitivesTo this expect(correct_grammar). to avoid_splitting_infinitivesRSpec::Matchers. define_negated_matcher :avoid_splitting_infinitives, :split_infinitivesAs with alias_matcher, you pass the name of the new matcher, followed by the old one. The avoid_splitting_infinitives matcher will now behave as the negation of split_infinitives. Using the matcher DSL. Let‚Äôs go back to the expense tracker app with built and let‚Äôs say that we are going to build a custom have_a_balance_of matcher that helps with expectations expect(account). to have_a_balance_of(30)There are two ways to build a matcher like the one we just show  Using a master DSL Creating a ruby class (any Ruby class can define a matcher, if it implements the matter protocol)Let‚Äôs start with the matcher DSL To define a matcher using the DSL, we call RSpec::Matchers. define, passing the matcher name and a block containing the matcher definition: RSpec::Matchers. define :have_a_balance_of do |amount| match { |account| account. current_balance == amount }endThe outer block receives any arguments passed to the matcher. When a spec calls have_a_balance_of(amount), RSpec will pass the amount into this block. The match method defines the actual match/no-match logic. The inner block receives the subject of the expectation (the account), and returns a truthy value if the account balance matches the expected amount. Here‚Äôs the output that it produces when a spec fails: 1) `have_a_balance_of(amount)` fails when the balance does not matchFailure/Error: expect(account). to have_a_balance_of(35)expected #&lt;Account name= Checking &gt; to have a balance of 35# . /spec/initial_account_spec. rb:17:in `block (2 levels) in &lt;topThe failure message tells us that the account should have had a balance of 35. But it doesn‚Äôt say what the actual balance was.  it reminds me to the phrase ‚ÄúThese two methods matches? and failure_message are all you need to define a simple matcher. ‚Äù in chapter 10. Let‚Äôs add the failure_message RSpec::Matchers. define :have_a_balance_of do |amount| match { |account| account. current_balance == amount }‚û§ failure_message { |account| super() + failure_reason(account) }‚û§ failure_message_when_negated { |account| super() + failure_reason(account) }private def failure_reason(account)   , but had a balance of #{account. current_balance}  endendNow this new matcher will work with expect(. . . ). to(. . . ) and for expect(. . . ). not_to(. . . )See the next failure message once we added these 2 new methods: 1) `have_a_balance_of(amount)` fails when the balance does not matchFailure/Error: expect(account). to have_a_balance_of(35)expected #&lt;Account name= Checking &gt; to have a balance of 35, but had a balance of 30# . /spec/initial_account_spec. rb:17:in `block (2 levels) in &lt;topIf we need to add a fluent interface like: ‚Ä¢ be_within(0. 1). of(50)‚Ä¢ change { ‚Ä¶ }. from(x). to(y)‚Ä¢ output(/warning/). to_stderr We can do it by defining again starting with the matcher: expect(account). to have_a_balance_of(10). as_of(Date. new(2017, 6, 12))And within out matcher file we add the as_of() RSpec::Matchers. define :have_a_balance_of do |amount|‚û§ chain(:as_of) { |date| @as_of_date = date } match { |account| account_balance(account) == amount } failure_message { |account| super() + failure_reason(account) } failure_message_when_negated { |account| super() + failure_reason(account) } private def failure_reason(account)   , but had a balance of #{account_balance(account)}  end def account_balance(account)  if @as_of_date   account. balance_as_of(@as_of_date)  else   account. current_balance  end endendDefining a matcher class If we need a little more control or my prefer to define the matter in the most explicit way possible we need to create a ruby class matcher. class HaveABalanceOf include RSpec::Matchers::Composable def initialize(amount)  @amount = amount end def as_of(date)  @as_of_date = date  self end def matches?(account)  @account = account  values_match?(@amount, account_balance) end def description  if @as_of_date    have a balance of #{description_of(@amount)} as of #{@as_of_date}   else    have a balance of #{description_of(@amount)}   end end def failure_message   expected #{@account. inspect} to #{description}  + failure_reason end def failure_message_when_negated   expected #{@account. inspect} not to #{description}  + failure_reason end private def failure_reason   , but had a balance of #{account_balance}  end def account_balance  if @as_of_date   @account. balance_as_of(@as_of_date)  else   @account. current_balance  end endendLet‚Äôs walk through: RSpec integration, within matcher. rb module AccountMatchers def have_a_balance_of(amount)  HaveABalanceOf. new(amount) endendRSpec. configure do |config| config. include AccountMatchersendHowever, in certain situations the custom matcher class is a better fit: ‚Ä¢ If your matcher is going to be used hundreds or thousands of times, writing your own class avoids a bit of extra overhead inherent in how the DSL is evaluated. ‚Ä¢ Some teams prefer more explicit code. ‚Ä¢ If you leave out the RSpec::Matchers::Composable mixin, your matcher won‚Äôt have any dependencies on RSpec and will work in non-RSpec contexts. Part V ‚Äî RSpec mocks. : A robust test suite will run fast, be deterministic, and cover all essential code paths. Unfortunately, dependencies often get in the way of these goals. We can‚Äôt reliably test code while it is integrated with other libraries or systems. Test doubles, including mock objects allow you to tightly control the environment in which your test run. Part V ‚Äî Chapter 13. Understanding test doubles. : In this chapter we will see:  How doubles can isolate your code from your dependencies, the difference between mocks, stubs, spies and null objects.  How to add test double behavior to an existing Ruby object.  and how to keep your doubles and your real objects in sync. In movies, a stunt double stands in for an actor, absorbing a punch or a fall when the actor cannot or should not do so. In test frameworks like RSpec, test double fulfills the same role. It stands in for another object doing testing. When we wrote the API unit specs for our expense tracker app, we treated the storage engine layer as if it were behaving exactly how we needed it, even though that the layer had not been written yet. This ability to isolate parts of your system while you are testing it is super powerful. With test doubles, we can:  Exercise hard to reach code paths, such as ever handling and reliable third-party service.  Write specs for a layer of your system before you have built it its dependencies.  Use an API while you are still designing it so that you can fix problems with the design before the implementation.  Demonstrate how a component Works relative to its neighbors. Types of test doubles: Test doubles have two characteristics one is the usage mode (what you are using it for and what you are expecting to) and the other is how the double is created, the origin. Here are the usage modes:  Stub: returns canned responses, avoiding any meaningful computation or I/O.  Mock: expects a specific messages: will raise an error if it doesn‚Äôt receive them by the end of the example.  Null Object: a benign test double that can stand in for any object: returns itself in response to any message.  Spy: records the message it receives so that you can check that later. Now here are the origins:    Pure double: a double whose behavior comes entirely from the test framework; this is what people normally think of when they talk about mock objects.     Partial double: an existing Ruby object that takes on some tests that will behavior, it‚Äôs an interface is a mixture of real and fake implementations.     Verifying double totally fake like a pure double, but constraints it‚Äôs interface based on a real object like a partial double; provides a safer test double by verifying that it matches the API.     Stubbed constant: a ruby constant such as a class or module name, which you create, remove or replace for a single test.  Any given test of what we have both on our origin and a usage mode and you can mix them for instance have a pure double acting as a stub, or a verifying double acting as a spy. Usage mode: mocks, stubs and spies. Generic test double In an irb session call mock RSpec library. RSpec‚Äôs double method creates a generic test double that you can use in any mode. irb(main):001&gt; require 'rspec/mocks/standalone'=&gt; trueirb(main):002&gt; ledger = double=&gt; #&lt;Double (anonymous)&gt;This double acts like an ordinary Ruby object. As you send messages to it (in other words, call methods on it), it will accept some messages and reject others. The difference is that a generic double gives you more debugging information than a regular Ruby object. irb(main):003&gt; ledger. record(an: :expense)/Users/dominiclizarraga/. rbenv/versions/3. 4. 2/lib/ruby/gems/3. 4. 0/gems/rspec-support-3. 13. 4/lib/rspec/support. rb:110:in 'block in &lt;module:Support&gt;': #&lt;Double (anonymous)&gt; received unexpected message :record with ({an: :expense}) (RSpec::Mocks::MockExpectationError)When we sent this message (. record), the double raised an exception. Doubles are strict by default: they will reject all messages except the ones you‚Äôve specifically allowed. RSpec shows both the message name and arguments we sent to our double; this is already more information than a typical Ruby NoMethodError. We can get a little more details in the error message by naming the role the double plays: irb(main):004&gt; ledger = double('Ledger')=&gt; #&lt;Double  Ledger &gt;irb(main):005&gt; ledger. record(an: :expense)/Users/dominiclizarraga/. rbenv/versions/3. 4. 2/lib/ruby/gems/3. 4. 0/gems/rspec-support-3. 13. 4/lib/rspec/support. rb:110:in 'block in &lt;module:Support&gt;': #&lt;Double  Ledger &gt; received unexpected message :record with ({an: :expense}) (RSpec::Mocks::MockExpectationError)This extra information comes in handy when you‚Äôre using multiple doubles in the same example. This same double method can create any of the other kinds of test doubles you‚Äôll use in your specs: stubs, mocks, spies, and null objects. Stubs Stubs are simple. They return preprogrammed, canned responses. Stubs are best for when you‚Äôre simulating query methods that is, methods that return a value but don‚Äôt perform side effects. The simplest way to define a stub is to pass a hash of method names and return values to the double method: irb(main):006&gt; http_response = double('HTTPResponse', status: 200, body: 'OK')=&gt; #&lt;Double  HTTPResponse &gt;irb(main):007&gt; http_response. status=&gt; 200irb(main):008&gt; http_response. body=&gt;  OK An alternative, you can perform these two steps for creating the stub and setting up the canned messages: irb(main):009&gt; http_response = double('HTTPResponse')=&gt; #&lt;Double  HTTPResponse &gt;irb(main):010&gt; allow(http_response). to receive_messages(status: 200, body: 'OK')=&gt; {status: 200, body:  OK }irb(main):011&gt; http_response. status=&gt; 200irb(main):012&gt; http_response. body=&gt;  OK Stubs watch for specific messages and return the same value each time they receive a given message. They don‚Äôt act differently based on their arguments. irb(main):013&gt; http_response. status(:args, :are, :ignored)=&gt; 200irb(main):014&gt; http_response. body(:blocks, :are, :also) { :ignored }=&gt;  OK Stubs help with a specific kind of behavior‚Äîthe kind that can be verified just by looking at return values.  Query data from a dependency Perform a computation on that data Return a resultYour specifications can verify the object‚Äôs behavior simply by examining the return value in step 3. The only responsibility of the stub is to provide a suitable response to the query in step 1. Mocks With these, it‚Äôs not a return value that you care about, but rather a side effect. Here‚Äôs a typical sequence:  Receive an event from the system Make a decision based on that event Perform an action that has a side effectFor instance, a chat bot‚Äôs Reply feature may receive a text message, decide how to reply, and then post a message in the chat room. To test this behavior, it‚Äôs not enough for your test double to provide a fixed return value at step 3. It needs to make sure the object triggered the side effect of posting a message correctly. To use a mock object, you‚Äôll pre-program it with a set of messages it‚Äôs supposed to receive. These are called message expectations. By combining the expect method with a matcher: irb(main):015&gt;ledger = double('Ledger')irb(main):016&gt; expect(ledger). to receive(:record)=&gt; #&lt;RSpec::Mocks::MessageExpectation #&lt;Double  Ledger &gt;. record(any arguments)&gt;Once you‚Äôve created a mock object, you‚Äôll typically pass it into the code you‚Äôre testing. At the end of each RSpec example, RSpec verifies that all mocks received their expected messages. irb(main):016&gt; RSpec::Mocks. verify(irb):15:in '&lt;main&gt;': (Double  Ledger ). record(*(any args)) (RSpec::Mocks::MockExpectationError)  expected: 1 time with any arguments  received: 0 times with any argumentsBecause the mock Ledger didn‚Äôt receive the messages it was expecting, it raises a MockExpectationError message. You can also specify the opposite behavior: irb(main):017&gt; expect(ledger). not_to receive(:reset)=&gt; #&lt;RSpec::Mocks::MessageExpectation #&lt;Double  Ledger &gt;. reset(any arguments)&gt;irb(main):018&gt; ledger. reset/Users/dominiclizarraga/. rbenv/versions/3. 4. 2/lib/ruby/gems/3. 4. 0/gems/rspec-support-3. 13. 4/lib/rspec/support. rb:110:in 'block in &lt;module:Support&gt;': (Double  Ledger ). reset(no args) (RSpec::Mocks::MockExpectationError)  expected: 0 times with any arguments  received: 1 timeWe see a failure because the mock object received a message it was specifically expecting not to receive. Null objects The test doubles you‚Äôve defined so far are strict: they require you to declare in advance what messages are allowed. But when your test double needs to receive several messages, having to spell each one out can make your tests brittle, you may want a test double that‚Äôs a little more forgiving. You can convert any test double to a null object by calling as_null_object on it: irb(main):019&gt; yoshi = double('Yoshi'). as_null_object=&gt; #&lt;Double  Yoshi &gt;irb(main):020&gt; yoshi. eat(:apple)=&gt; #&lt;Double  Yoshi &gt;This type of null object is known as a black hole; it responds to any message sent to it, and always returns itself. irb(main):021&gt; yoshi. eat(:apple). then_shoot(:shell). then_stomp=&gt; #&lt;Double  Yoshi &gt;If you have a ChatBot class that interacts with a room and a user, you may want to test these collaborations separately. While you‚Äôre focusing on the user related specs, you can use a null object for the room. Spies One downside of traditional mocks is that they disrupt the normal Arrange/Act/Assert sequence you‚Äôre used to in your tests. See the next code: irb(main):022* class Gameirb(main):023*  def self. play(character)irb(main):024*   character. jumpirb(main):025*  endirb(main):026&gt; end=&gt; :playirb(main):027&gt; mario = double('Mario')=&gt; #&lt;Double  Mario &gt;irb(main):028&gt; expect(mario). to receive(:jump)=&gt; #&lt;RSpec::Mocks::MessageExpectation #&lt;Double  Mario &gt;. jump(any arguments)&gt;irb(main):029&gt; Game. play(mario)=&gt; nilIt feels a bit backwards to have to assert before acting. Spies are one way to restore the traditional flow. All you have to do is change the receive expectation to have_received. irb(main):030&gt; mario = double('Mario'). as_null_object=&gt; #&lt;Double  Mario &gt;irb(main):031&gt; Game. play(mario)=&gt; #&lt;Double  Mario &gt;irb(main):032&gt; expect(mario). to have_received(:jump)=&gt; nilWhen you spy on objects with have_received, you‚Äôll either need to use null objects or explicitly allow the expected messages irb(main):033&gt; mario = double('Mario')=&gt; #&lt;Double  Mario &gt;irb(main):034&gt; allow(mario). to receive(:jump)=&gt; #&lt;RSpec::Mocks::MessageExpectation #&lt;Double  Mario &gt;. jump(any arguments)&gt;irb(main):035&gt; Game. play(mario)=&gt; nilirb(main):036&gt; expect(mario). to have_received(:jump)=&gt; nil# another way is using `spy` keyword which is an aliasirb(main):037&gt; mario = spy('Mario')=&gt; #&lt;Double  Mario &gt;irb(main):038&gt; Game. play(mario)=&gt; #&lt;Double  Mario &gt;irb(main):039&gt; expect(mario). to have_received(:jump)=&gt; nilHere, we used a chatGPT explanation for null obejcts and spies ü§ñ Scenario: ChatBot class ChatBot def initialize(room)  @room = room end def reply_to(message)  if message ==  hi    @room. post( hello üëã )  else   @room. post( ü§î )  end endendNull Object Suppose you only care about testing how the bot decides what to say, not whether it really posted to the room. Instead of stubbing every possible method on Room, we just use a null object: RSpec. describe ChatBot do it  returns a response without caring about the room  do  room = double( Room ). as_null_object # accepts any message  bot = ChatBot. new(room)  bot. reply_to( hi )  # no error, even though we didn‚Äôt define room. post endendas_null_object is useful when the collaborator is irrelevant to the test ‚Äî it ‚Äúswallows‚Äù all messages without complaints. Spy Now let‚Äôs say we do care that room. post got called correctly. Using a spy, we can check after the action: RSpec. describe ChatBot do it  posts a greeting when user says hi  do  room = spy( Room )  bot = ChatBot. new(room)  bot. reply_to( hi )  expect(room). to have_received(:post). with( hello üëã ) endendNotice the flow: Arrange: create spyAct: call methodAssert: verify with have_received This keeps the familiar Arrange‚ÄìAct‚ÄìAssert pattern, unlike mocks where you must set the expectation before acting. Combining as_null_object and Spies Sometimes, you want an object that:    Accepts any call (like a null object)     But you can still inspect later what happened (like a spy)  That‚Äôs exactly what spy (or double(‚Ä¶). as_null_object + have_received) gives you. room = double( Room ). as_null_objectbot = ChatBot. new(room)bot. reply_to( bye )expect(room). to have_received(:post). with( ü§î )# or equivalently:room = spy( Room )bot = ChatBot. new(room)bot. reply_to( bye )expect(room). to have_received(:post). with( ü§î )üîë Key Takeaways Null Object (as_null_object): ignores everything, returns itself ‚Üí great when collaborator doesn‚Äôt matter. Spy (spy or have_received): records what happened ‚Üí great when you want to assert after-the-fact. spy(‚ÄúName‚Äù) is basically shorthand for double(‚ÄúName‚Äù). as_null_object. chatGPT session ended. Origins: pure, partial, and verifying doubles Now that we have seen the different usage modes of the tests doubles, let‚Äôs look at where they come from. Pure doubles All of the test doubles you have written so far in this chapter are pure doubles: they are purpose-built by RSpec mocks and consist entirely of behavior you add to them. You can pass them into your project code just as if they were the real thing. Pure doubles are flexible and easy to get started with. They are best for testing code where you can pass in dependencies. Unfortunately, real world projects are not always so test-friendly, and you will need to turn to more powerful techniques. Partial doubles Sometimes, the code you are testing does not give you an easy way to inject dependencies, a hard coded class name may be looking three layers deep in the API you are calling. For instance, a lot of Ruby projects called Time. now without providing a way to override the behavior during testing. To test these kinds of codebases, you can use a partial double. This add mocking and stubbing behavior to an existing Ruby objects. That means any object in your system can be a partial double. All you have to do is expect or allow a specific message. =&gt; trueirb(main):004&gt; random = Random. new=&gt; #&lt;Random:0x0000000122814a20&gt;irb(main):005&gt; allow(random). to receive(:rand). and_return(0. 1234)=&gt; #&lt;RSpec::Mocks::MessageExpectation #&lt;Random:0x0000000122814a20&gt;. rand(any arguments)&gt;irb(main):006&gt; random. rand=&gt; 0. 1234In this snippet, you have created an instance of a Ruby random number generator, and then replace its rand method with one that returns a can value. You can also use a partial double as a spy using the expect(). to have_received form irb(main):009&gt; allow(Dir). to receive(:mktmpdir). and_yield('/path/to/tmp')=&gt; #&lt;RSpec::Mocks::MessageExpectation #&lt;Dir (class)&gt;. mktmpdir(any arguments)&gt;irb(main):010&gt; Dir. mktmpdir { |dir| puts  Dir is: #{dir}  }Dir is: /path/to/tmp=&gt; nilirb(main):011&gt; expect(Dir). to have_received(:mktmpdir)=&gt; nilYou could permit any message using a spy or as_null_object or explicitly allow just the message you want. With partial doubles, you can only do that later. RSpec will revert it all your changes at the end of each example. there will be object will go back to its original behavior. Since we are experimenting in stand-alone mode we need to call the tear down explicitly to clean up what happened. irb(main):012&gt; RSpec::Mocks. teardown=&gt; #&lt;RSpec::Mocks::RootSpace:0x0000000121f74e10&gt;irb(main):013&gt; random. rand=&gt; 0. 13639968906104905irb(main):014&gt; random. rand=&gt; 0. 30073063313880466Test doubles have short lifetimes RSpec tears down all your test doubles at the end of each example. That means they wont to play well with RSpec features that leave outside the typical per-examples, such as before(:context) hooks. You can work around some of these limitations with a method name with_temporary_scope. Partial doubles are useful but we consider them as a code smell, a superficial sign that might lead to a deeper design issue. Verifying doubles The upside of test doubles is that they can stand in for a dependency you do not want to track into your test. The downside is that the double and the dependency can drift out of sync with each other. Verifying doubles can protect you from this kind of drift. While we wrote the expense tracker app we touch briefly on verifying doubles when we marked the Ledger class because it didn‚Äôt exist yet. Here is a simplified version ledger = double('ExpenseTracker::Ledger')allow(ledger). to receive(:record)post '/expenses' doexpense = JSON. parse(request. body. read)result = @ledger. record(expense)JSON. generate('expense_id' =&gt; result. expense_id)endThe Ledger class didn‚Äôt exist yet; the test double provided enough of an implementation for your routing specs to pass. Consider what will happen if at some point you rename the Ledger#record method to Ledger#record_expense but forgot to update their routing code. Your specs would still pass, since they are still providing fake record method. But your code will fail in real world use, because it is trying to call a method that no longer exist. These kinds of false positives can kill confidence in your unit specs. You avoided this drive in your expense tracker project by using a verifying double to do so, you call instance_double in place of double, passing the name of The Ledger class. ledger = instance_double('ExpenseTracker::Ledger')allow(ledger). to receive(:record)With this double in place, RSpec checks that the real Ledger class (if it is loaded) actually response to the record message with the same signature. If you rename this method to record_expense, or add or remove arguments, your specs will correctly fail under your update your use of the method and your test double setup. Use verifying doubles to catch problems earlier Although your unit specs will have a false positive, you‚Äôre acceptance specs will still have cut this regression. That‚Äôs because they use the real versions of the objects, rather than counting on test doubles. By using verifying doubles in your unit specs you get the best of both worlds. You will catch errora earlier and at less cost, while writing specs that behave correctly when APIs change. RSpec gives you a few different ways to create verifying doubles, based on what it will use as an interface template for the double:    instance_double(‚ÄòSomeClass‚Äô):Constrains the double‚Äôs interface using the instance methods of SomeClass     class_double(‚ÄòSomeClass‚Äô):Constrains the double‚Äôs interface using the class methods of SomeClass     object_double(some_object):Constrains the double‚Äôs interface using the methods of some_object, rather than a class; handy for dynamic objects that use method_missing  Stubbed constants Test doubles are all about controlling the environment your specs running: what classes are available, how certain methods behaves, and so on. a key piece of that environment is the set of Ruby constant available to your code. For instance, password hashing algorithms are slow by design for security reasons, but you may want to pick them up during testing please see the next code snippet class PasswordHashCOST_FACTOR = 12# . . . endstub_const('PasswordHash::COST_FACTOR', 1)You can use stub_const to do a number of things: ‚Ä¢ Define a new constant‚Ä¢ Replace an existing constant‚Ä¢ Replace an entire module or class (because these are also constants)‚Ä¢ Avoid loading an expensive class, using a lightweight fake in its place Sometimes controlling your test environment means removing an existing constant instead of stopping one. For example, if you‚Äôre writing a library that works either with or without ActiveRecord, you can hide the ActiveRecord constant for a specific example: Hiding the ActiveRecord constant like this will cut off access to the entire module. Including any nested constants like ActiveRecord::Base. Your code won‚Äôt be able to accidentally use ActiveRecord. Just as with partial doubles, any constants you have changed or hidden will be restored at the end of each example. hide_const('ActiveRecord')We have discussed the differences between stubs, spies and null_objects. In particular we saw how they deal with the following situations:  Receiving expected messages Receiving unexpected messages Not receiving expected messagesWe also looked at the different ways to create test doubles. . pure doubles are entirely fake, whereas partial doubles are real Ruby objects that have fake behavior at it. Verifying doubles fall in between and have the advantages of both with a few of the downsides of either. Part V ‚Äî Chapter 14. Customizing test doubles. : In this chapter we are going to see how to return, raise, yield a value from our test double. How to supply custom behavior, how to ensure that the double test is calling the right arguments and how many times it calls it and in the right order. Configuring responses Since a test double is meant to standing for a real object, it needs to act like one. You need to be able to configure how it responds to the code calling it. When you allow or expect a message on a test double without specifying how it responds, RSpec provides a simple implementations that just returns nil. Your test doubles will often need to do something more interesting: return a given value, raise an error, yield to a block, or throw a symbol. allow(double). to receive(:a_message). and_return(a_return_value)allow(double). to receive(:a_message). and_raise(AnException)allow(double). to receive(:a_message). and_yield(a_value_to_a_block)allow(double). to receive(:a_message). and_throw(:a_symbol, optional_value)allow(double). to receive(:a_message) { |arg| do_something_with(arg) }# These last two are just for partial doubles:allow(object). to receive(:a_message). and_call_originalallow(object). to receive(:a_message). and_wrap_original { |original| }People new to rspec are often surprise at the behavior of expect on a partial double expect(some_existing_object). to receive(:a_message)Doesn‚Äôt just set up an expectation. it also changes the behavior of an existing object. Calls to some_existing_object. message will return nil and do nothing else. If you want to add a message expectation while retaining the original implementation, you will need to use and_call_original Returning multiple values We previously used and_return keyword when we set up our test double to return the same canned expense item each time it received the record message. Sometimes you need to stubbed method to do something more sophisticated that return the same value every time it is called. You might want to return one value for the first call, and a different one for the second call and so on. &gt;&gt; allow(random). to receive(:rand). and_return(0. 1, 0. 2, 0. 3)=&gt; #&lt;RSpec::Mocks::MessageExpectation #&lt;Double  Random &gt;. rand(any arguments)&gt;&gt;&gt; random. rand=&gt; 0. 1&gt;&gt; random. rand=&gt; 0. 2&gt;&gt; random. rand=&gt; 0. 3&gt;&gt; random. rand=&gt; 0. 3&gt;&gt; random. rand=&gt; 0. 3Here we give three return values, and they rand method returns each one in sequence. Yielding multiple values Blocks are ubiquitous in Ruby, and sometimes your test doubles will need to stand in for it interface that uses blocks. The aptly name and_yield method will configure your double to yield values extractor = double('TwitterURLExtractor')allow(extractor). to receive(:extract_urls_from_twitter_firehose) . and_yield('https://rspec. info/', 93284234987) . and_yield('https://github. com/', 43984523459) . and_yield('https://pragprog. com/', 33745639845)We chain together extract_urls_from_twitter_firehose three and_yield calls. When the code we are testing calls with a block, the method will yield the block three times. Each time, the block we receive a URL and a numeric to it. Raising exceptions flexibly When you‚Äôre testing exception handling code, you can raise exceptions from your test doubles using the and_raise modifier. This method has a flexible API that mirrors Ruby Ray‚Äôs method. In the examples we have shown so far, we‚Äôve been working with pure test doubles. These doubles have to be told exactly how to respond, because they don‚Äôt have an existing implementation to modify. allow(dbl). to receive(:msg). and_raise(AnExceptionClass)allow(dbl). to receive(:msg). and_raise('an error message')allow(dbl). to receive(:msg). and_raise(AnExceptionClass, 'with a message')an_exception_instance = AnExceptionClass. newallow(dbl). to receive(:msg). and_raise(an_exception_instance)Partial doubles are different. Since they begin as an real object with a real method implementation, you can base the fake version on the real one. Falling back to the original implementation When you are using a partial double to replace a method, sometimes you only want to replace it conditionally. You may want to use a fake implementation for a certain parameters values but fall back on the real method the rest of the time. In these cases, you can expect or allow twice: once like you normally would, and once we and_call_original to provide the default behavior. # fake implementation for specific arguments:allow(File). to receive(:read). with('/etc/passwd'). and_raise('HAHA NOPE')# fallback:allow(File). to receive(:read). and_call_originalHere, we‚Äôve used with(. . . ) to constrain which parameter values this stub applies to. Modifying the return value Sometimes, you want to slightly change the behavior of the method you are stubbing, rather than replacing it outright. You may, for instance, need to modify its return value. RSpec and and_wrap_original method, passing it a block containing your custom behavior. Your block will take the original implementation as an argument, which you can call at any time. This is the technique to stub out a CustomerService API to return a subset of customers: allow(CustomerService). to receive(:all). and_wrap_original do |original| all_customers = original. call all_customers. sort_by(&amp;:id). take(10)endThis technique can be handy for acceptance specs, where you want to test against a live service. If the vendor does not provide a test API that only returns a few records, you can call the real API and narrow down the records yourself. By working on just a subset of the data, your specs will remain snappy. Tweaking arguments You can also use and_wrap_original to tweak the arguments you pass into a method. Yhis technique comes in handy when the code you are testing uses a lot of hard coded values. allow(PasswordHash). to receive(:hash_password) . and_wrap_original do |original, cost_factor|  original. call(1)endSince both and_call_original and and_wrap_original need an existing implementation to call, they only make sense for partial doubles. When you need more flexibility So far, we have seen several different ways to customize how your test doubles behave. you can return or yield a specific sequence of values, race and exception, and so on. Sometimes, though, the behavior you need is a slightly outside what this techniques provide. If you are not quite sure how to configure a double to do what you need, you can supply a block containing whatever custom Behavior you need. Simply pass the block to the latest method call in the received expression. Here we are going to simulate an intermented Network failure while we are testing the request succeeds 75% of the time: counter = 0allow(weather_api). to receive(:temperature) do |zip_code| counter = (counter + 1) % 4 counter. zero? ? raise(Timeout::Error) : 35. 0endWhen your code calls the weather API, RSpec will run this block and depending on how many calls you‚Äôve made, either return a value or raise a timeout exception If your block gets any more complex than this example, you might be better off moving into its own Ruby class. Martin Fowler refers to this kind of standing as a fake. fakes particularly are useful when you need to preserve state across multiple method calls. Setting constraints Most of the test doubles you have created will accept any input. If you stub a method named jump with no other options, RSpec will use your scope whenever you‚Äôre code calls jump, jump(:with, :arguments), or jump { with_a_block }. In this section we are going to look at ways to set constraints on a test double so that RSpec only uses it if your code calls it in a certain. Constraining argument You will often want to check that your code is calling a method with the correct parameters. To constrain what arguments your mock object will accept, add a call to with to your message exception expect(movie). to receive(:record_review). with('Great movie!')expect(movie). to receive(:record_review). with(/Great/)expect(movie). to receive(:record_review). with('Great movie!', 5)If your code calls the method with arguments that don‚Äôt match that constraint then the exception remains unsatisfied. RSpec will treat it the same as any other unmet expectation. In this example, we are using expect, meaning that RSpec will report a failure: &gt;&gt; expect(movie). to receive(:record_review). with('Good')=&gt; #&lt;RSpec::Mocks::MessageExpectation #&lt;Double  Jaws &gt;. record_review( Good )&gt;&gt;&gt; movie. record_review('Bad')RSpec::Mocks::MockExpectationError: #&lt;Double  Jaws &gt; received ‚Ü© :record_review with unexpected arguments  expected: ( Good )  got: ( Bad )¬´ backtrace truncated ¬ªIf we had used allow instead, RSpec would have looked for another expectation that fit the passed-in arguments: (no failure raised!) &gt;&gt; allow(imdb). to receive(:rating_for). and_return(3) # default=&gt; #&lt;RSpec::Mocks::MessageExpectation #&lt;Double  IMDB &gt;. rating_for(any arguments)&gt;&gt;&gt; allow(imdb). to receive(:rating_for). with('Jaws'). and_return(5)=&gt; #&lt;RSpec::Mocks::MessageExpectation #&lt;Double  IMDB &gt;. rating_for( Jaws )&gt;&gt;&gt; imdb. rating_for('Weekend at Bernies')=&gt; 3&gt;&gt; imdb. rating_for('Jaws')=&gt; 5Your test doubles can require something as simple as a specific value, or as sophisticated as any custom logic you can devise. Argument placeholders When a message takes several arguments, you maker more about some than others. In the next example we are stubbing a shoppingcart add_product method that takes a name, a numeric id, and then vendor specific code. If we only care about the name, you can pass they worth anything as a placeholder for the others expect(cart). to receive(:add_product). with('Hoodie', anything, anything)You can also represent a sequence of anything placeholders with any_args expect(cart). to receive(:add_product). with('Hoodie', any_args)The counterpart to any_args is no_args: expect(database). to receive(:delete_all_the_things). with(no_args)Hashes and keyword arguments Ruby APIs, especially ones written before Ruby 2. 0 came out class BoxOffice def find_showtime(options)  # . . .  endendbox_office. find_showtime(movie: 'Jaws')box_office. find_showtime(movie: 'Jaws', zip_code: 97204)box_office. find_showtime(movie: 'Jaws', city: 'Portland', state: 'OR')When you‚Äôre testing code that calls such a method, you can use RSpec‚Äôs hash_including to specify which keys must be present. All three of these find_showtime calls would match the following constraint: expect(box_office). to receive(:find_showtime) . with(hash_including(movie: 'Jaws')) Flexible constraints like hash_including make your specs less brittle. Rather than having to give all the keys of your hash, you can give just the ones you care about. If the value of an unimportant key changes, your specs needn‚Äôt fail.  Ruby 2. 0 added keyword arguments class BoxOffice def find_showtime(movie:, zip_code: nil, city: nil, state: nil)  # . . .  endendThe good news is that the hash_including constraint works just as well with keyword arguments as it does with old-style option hashes. RSpec also provides a hash_excluding constraint to specify that a hash must not include a particular key Custom logic When you have written a bunch of constraints, you will inevitably find yourself repeating the same complex constraint in several specs. occasionally, you will need logic that‚Äôs too involve to express as a simple constraint. In both of these situations, you can supply your own custom logic For example, if you have several specs that shoudl call find_showtime with cities in Oregon, you can wrap this constraint in a custom rspec matter: RSpec::Matchers. define :a_city_in_oregon do match { |options| options[:state] == 'OR' &amp;&amp; options[:city] }end# usage of . withexpect(box_office). to receive(:find_showtime). with(a_city_in_oregon)You can constrain arguments using an ordinary Ruby value, a regular expression, one of RSpec-mocks provided constraints or any built-in or custom matcher. Behind the scenes, rspec marks Compares method arguments using the === operator. Custom argument constraints can reduce repetition and make your expectations easier to understand. Constraining how many times a method gets called In addition to constraining a method arguments, you can also specify how many times it should be called. client = instance_double('NasdaqClient')expect(client). to receive(:current_price). thrice. and_raise(Timeout::Error)stock_ticker = StockTicker. new(client)100. times { stock_ticker. price('AAPL') }Even though we‚Äôre calling stock_ticker. price many times, we expect the circuit breaker to stop hitting the network after the third simulated timeout error. As you might guess from the name thrice, RSpec also provides once and twice modifiers. Since the English language doesn‚Äôt provide any multiplicative adverbs after 3, you‚Äôll need to switch to the more verbose exactly(n). times expect(client). to receive(:current_price). exactly(4). timesOrdering Normally, RSpec doesn‚Äôt care what order you send messages to a test double: expect(greeter). to receive(:hello). orderedexpect(greeter). to receive(:goodbye). ordered# The following will fail:greeter. goodbyegreeter. helloUsing ordered is a sign that your specs may be too coupled to one particular implementation/ You can use all of the types of constraints we‚Äôve seen here‚Äîarguments, call counts, and ordering‚Äîtogether in one expectation: expect(catalog). to receive(:search).  with(/term/). at_least(:twice). orderedSummary of concepts covered in this chpater:       Concept   Usage   Example         and_return   Configure test double to return specific values       allow(double). to receive(:msg). and_return(value)    allow(double). to receive(:msg). and_return(0. 1, 0. 2, 0. 3)          and_raise   Configure test double to raise exceptions       allow(double). to receive(:msg). and_raise(AnException)    allow(double). to receive(:msg). and_raise('error message')          and_yield   Configure test double to yield values to blocks       allow(extractor). to receive(:extract_urls)    &nbsp;&nbsp;. and_yield('https://rspec. info/', 123)          and_call_original   Fall back to original implementation (partial doubles)       allow(File). to receive(:read). with('/etc/passwd'). and_raise('NOPE')    allow(File). to receive(:read). and_call_original          and_wrap_original   Modify behavior of original method       allow(CustomerService). to receive(:all). and_wrap_original do |orig|    &nbsp;&nbsp;orig. call. take(10)    end          with   Constrain arguments that mock will accept       expect(movie). to receive(:record_review). with('Great!')    expect(cart). to receive(:add_product). with('Hoodie', anything)          hash_including   Match hashes containing specific keys       expect(box_office). to receive(:find_showtime)    &nbsp;&nbsp;. with(hash_including(movie: 'Jaws'))          Call count modifiers   Specify how many times method should be called       expect(client). to receive(:current_price). thrice    expect(client). to receive(:price). exactly(4). times          ordered   Enforce specific order of method calls       expect(greeter). to receive(:hello). ordered    expect(greeter). to receive(:goodbye). ordered          Key Insight: Use expect vs allow wisely - expect changes behavior AND sets expectations, while allow only changes behavior. Custom blocks provide ultimate flexibility when built-in modifiers aren't enough.    Here are some usefull articles i found about the topics we went over, and also i had chatGPT to provide me more details https://stackoverflow. com/questions/28006913/rspec-allow-expect-vs-just-expect-and-return https://martinfowler. com/articles/mocksArentStubs. html https://chatgpt. com/share/68ad328f-1478-800a-9304-90c2de18939a https://share. google/aimode/SFNEx3Z7x6YM1nYTJ Part V ‚Äî Chapter 15. Using test doubles effectively. : In this chapter we will see:  the construction of an environment for each spec how to providde test doubles to the code we are testing what are the most common pitfalls and how to how to improve our code by applying this sign feedback from our testUsing test doubles effectively Over the previous two chapters, we have tried out mocks, stubs, spies and null objects. We have learned which situation each is best for. We have also seen how to configure their behavior, and how to check that a double is called correctly. Now, we would like to talk about the trade-offs. Although we frequently use doubles in our tests, I will be the first to acknowledge that doing so incurs some risk.  Code that passes the test but fails in production, because the test doubles don‚Äôt behave enough like a real.  Brittle tests that fail after a refactoring, even though the new coat is working correctly Do-nothing tests that only end up checking your doublesConstruction or test environment "
    }, {
    "id": 38,
    "url": "http://localhost:4000/2025/03/16/hands-on-tdd-rails.html",
    "title": "Hands-on TDD: Using Ruby, Rails, and RSpec",
    "body": "2025/03/16 - The book has a very practical approach (living up to its title ‚Äúhands-on‚Äù) where the author explains what you‚Äôre going to build, which tools and why those tools. It‚Äôs meant for beginner-intermediate developers. The content follows a linear structure which means you should read chapters from the beginning to the end, in a straightforward manner, you‚Äôll follow him along as he codes the web app as you see the red-green-refactor cycle. The outcome will be getting a better grasp of the benefits of applying Test-Driven Development (TDD), how to adopt this new mindset.  Introduction.  What is TDD?.  Getting started with Ruby.  Getting started with Ruby on Rails.  Setting up RSpec and FactoryBot. Introduction. : It was not so long ago that we did not even write tests for our software. At some point, some very smart people realize that writing tests for our software was actually a good idea. our tests will provide us with confidence that our software worked as expected and even more importantly keep us from getting phone calls in the middle of the night to fix things that would break in production. Not long after we started writing tests, some other very smart people realize that writing our test first would give us an opportunity to think about what we were going to ride before we would write it. It will give us a target to aim at, in effect. This was the birth of test driven development tdd is a style of software development where we write our test first, see that they are failing as expected, and only then do we pursue writing the code to make those tests passed. This is the central idea of my book. We will think about what we want to do, then we will capture that idea with a properly failing test. Then we will then write the code to make the test pass. After that, we will then we refactor our code to make it better, or prettier, or less repetitive. We will use test driven development style of software design and engineering, which means we will write failing test first and only then write our implementation code to get our failing test passing. We will use Rspec testing framework to write our test. Rspec describes itself as a tool for performing behavioral driven development and as in fact the best tool available for testing will be code. The main goal of this book is to provide a practical common Hands-On introduction to test driven style of software design and engineering. Many books on the topic of test driven development have been written before this one. Most other books are written in a small problem sort of writing style. They cover single topics, one of the time, barely more than a reference guy. They do not cover the entire process of building software application from start to finish, using TDD, as a result, they are, in my opinion, let‚Äôs practical and much less useful for actually learning practical TDD. The author states the following, I have never seen software written using TDD that was not better than software written without TDD. What is Test Driven Development?: Pending. Getting started with Ruby. : Pending. Getting started with Ruby on Rails. : Pending. Setting up RSpec and FactoryBot. : "
    }, {
    "id": 39,
    "url": "http://localhost:4000/2025/03/09/systems_test_post.html",
    "title": "Computer systems Test Post",
    "body": "2025/03/09 - Test for computer systems "
    }, {
    "id": 40,
    "url": "http://localhost:4000/2025/03/08/networking_test_post.html",
    "title": "Networking Test Post",
    "body": "2025/03/08 - Test for networking "
    }, {
    "id": 41,
    "url": "http://localhost:4000/2025/02/05/professional-rails-testing.html",
    "title": "Professional Rails Testing",
    "body": "2025/02/05 - This book has two parts, the first one goes over principles of testing, the second is about the tools you can use to test your code base.  Chapter 1. Introduction.  Chapter 2. Tests as specifications.  Chapter 3. Test driven development.  Chapter 4. Writing meaningful tests.  Chapter 5. Writing understandable tests.  Chapter 6. Duplication in test code.  Chapter 7. Mocks and stubs.  Chapter 8. Flaky tests.  Chapter 9. Testing sins and crimes.  Chapter 10. Ruby DSL.  Chapter 11. Factory bot.  Chapter 12. RSpec syntax.  Chapter 13. Capybara‚Äôs DSL. Chapter 1. Introduction. : The first chapter is about what you can expect from the book, why the author chose Rspec over Minitest and the ways you can reach out to Jason Swett. Chapter 2. Tests as specifications. : The 2nd chapter aims to lay out what a test is, in this case the author rejects the idea that tests are verifications, rather they are specifications and with this definition the objective of testing goes from ‚Äúmake sure the code worked‚Äù to ‚Äúenforce the code behave as specified‚Äù. He also provides an example of a manufacturing site where all of its finished products behave the same way because they meet their design specifications due to its production system therefore it produces that same throughput always. He also shares that the main challenge is to switch developer‚Äôs mindset from verification to a specification, this will entail moving from ‚Äúcapabilities‚Äù to ‚Äúscenarios‚Äù. the next examples are going to be capabilities: the user can update their email address the user can sign in the user can reset their password on the other hand we have scenarios, for instance: when the user signs in with a valid credentials, the dashboard page will show up when the user attempts to sign in with invalid credentials and error message is shown A specification is a statement of how some aspect of a software product should behave. Again departing from the scenario point of view and we can break it down to the following: Scenario: when a user enters a valid email and password combination into the email and password fields, then clicks ‚Äòsign in‚Äô Expectation: the user dashboards page is shown. This is a style that the author has conceived and he denotes that it makes sense to him but it is not a golden rule, in other words ‚Äúunder such-and-such a scenario, we expect such-and-such behavior‚Äù The author describes with an example of a parser program the same pattern of a scenario and expectation and it goes step by step from creating the file, adding some boilerplate, starting with some comments in order to remove the writer‚Äôs block and finally he quotes the ‚Äòarrange act and assert‚Äô phases. Small recap:Scenario (what to test, we can remember this with words like ‚Äúwhen‚Äù or ‚Äúgiven‚Äù)Expectation (We can remember with the keyword ‚Äúthen‚Äù)Setup, exercise and assertion ( arrange act and assert)     Source: Medium  Chapter 3. Test driven development. : Chapter 3 is about TTD (test driven development) he briefly describes what it is, pointing out why it is often called the ‚Äòred, green, refactor loop‚Äô, what do those colors mean? and finally the importance of refactoring the code you wrote. Red: Firstly we start with deciding ‚Äúwhat to do‚Äù and then ‚Äúdoing it‚Äù (this reduces cognitive load) keeping in mind that a test is an executable and ‚Äúspecification‚Äù. We first write the test so we set out the ‚Äòspecification‚Äô and then we write the code to fulfill given a specification. Something important here is to run the test so we can clear out any false positives on the code, by running it and getting the red color we make sure that it is failing. Importance of the green color and as the author quotes ‚ÄòKent Beck‚Äô you can make any ‚Äòsins code‚Äô in order to make the code pass, this means to write crappy code but make sure that you pass from red color to green color. Also the author describes that if the whole system is covered by testing, we can refactor the system code as much as we want without too much fear that refactoring will introduce regressions. It is not an absolute warranty but it provides high degree of well justified confidence. The author also said that he focuses on writing just enough code to make the current failure message go away, maybe not passing the whole test but just a small bit of it. And finally ‚Äòrefactor‚Äô this is where all the mess is cleaned up, duplication is removed maybe some optimization is added and here the author again shares one of his personal exercises that once he have passed the testing he hold off and give himself sometime to forget about the problem because it is very embedded in his brain and the refactor is not going to be very effective, instead he takes some time and then comes back and address the exact pain Here is one statement about TDD that I liked ‚Äú the main reason for practicing TDD is to go faster and be more productive in simpler terms you want to decrease the radio of effort invested to Value produced‚Äù TTD also encourages modular, loosely coupled design, less mental effort, more enjoyable workflow, fewer bugs, documentation, feedback loops (most important I personally think!) Here is the feedback loop that TDD can create: specify an objective devise a test that can be performed to see if #1 is done perform the test device in step 2 do some work toward the objective ( wright a line of code) repeat steps three and four until the test passes repeat from step one with a new objective Some notes from the author that I think are worth is when you write a line of code it is going to help us the message failure to go away so we can avoid coding speculatively and this will help us lower the mental burden in each step of this feedback loop, Lastly the author closes this chapter by comparing the ‚Äòmanual testing‚Äò versus the TDD that as much as you practice it, you‚Äôll get more fluent and it will become a great time saver Chapter 4. Writing meaningful tests. : The author states that having tests is better than not having tests but not always writing tests are equally good tests are more valuable when they are meaningful. A test is Meaningful if it tests not just means to ends but ends themselves. When we are testing something we can focus either on means or ends, for example if we test a staple by just examining if it has all the right parts and just trying to staple 3 sheets of paper.  By making sure that it has all the right parts it doesn‚Äôt mean we are testing the ends. On the contrary, if we staple 3, then 12, 20 and we can affirm that we can continually do this activity, that‚Äôs when we test the ends. When it comes to testing model associations it would be more meaningful to make assertions on the behaviors that these associations enable. Another great example is that airplanes engines can be tested even without attaching the engines to an airplane. How to decide what kind of test drive, here we only have cost and benefits, we want to achieve satisfactory test coverage while incurring the smallest cost possible. System tests are the only type of test that proves that all the parts of your system are successfully working together without system tests. We could theoretically have a web application with a fully passing suite of unit tests even if the application is unable to successfully serve a single request. Something that I have seen has always been trivial is % of test coverage and the author suggests the following:  What if we use a minimum number of system tests, perhaps one for the happy path and one or two more for the failure cases and then use fast unit tests for all the edge cases? This way we will get a reasonable level of confidence that our system works as a whole. Then we have: how to test models (POROs), requests, background jobs, mailer specs, helper specs, view specs and view components. Also we have a very important question ‚Äúwhen to write a test and went to not‚Äù, remember that testing is not about right or wrong but about cost and benefits here are five questions:  Is the behavior likely to ever break? If the behavior were to fail, would it fail silently? if the behavior were to fail, would it fail frequently? if the behavior were to fail, would the consequence be severe? Is the test easy to write?If any of the answers to these questions is a yes, I write the test. If and only if all of the answers are negative I do skip the test. The aggregate benefit of tests. It is common to want to get some sort of 80/20 benefit by only covering the most important 20% of the codebase tests.  I think this way of thinking focuses on the benefit of individual tests while missing the aggregate benefit of tests. Remember cost and benefits of testing can be refactoring with no fear, gaining speed for development without even thinking Dusty‚Äôs part of the code base is tested well enough? In a model do we need to test every method, again remember that we covered every Behavior not every method. Chapter 5. Writing understandable tests. : I think this is the longest chapter but is the one that has more meat because it touches topics as code quality in tests, in this case ‚Äúabstraction‚Äù, (we always hear about quality code of the app itself but not in tests), it revisits the what the ‚Äòwhen‚Äô, the ‚Äògiven‚Äô, ‚Äòthen‚Äô as a structure for the test. Also how to accommodate the different files you need in the rails app, when to use helper when those are helpful, what about concerns, when is a good practice to create a model without inheriting from ActiveRecord, how to preserve ‚Äòcohesion‚Äô, also Rspec feature which is ‚Äòshared examples‚Äô, what may cause obfuscation in the tests, whether you use ‚Äòsubject‚Äô or ‚Äòlet‚Äô in our specs, plus the author gives a very useful opinion about code duplication (he shares that duplication is okay when it comes to testing). Something that I truly liked is when the author brings up that a codebase is like a story book so each file has to be seen as a chapter, where you see essential points and it remains on those essentials topics and also incidental/distracting things that may go on the footnote or appendix. Tests are more than just a safety net to catch regressions. A test suite can serve as a guidebook to a system, showing what the system‚Äôs parts are, how the parts relate to each other, which ideas are more and less important, and of course, how are the parts of the system are supposed to behave A test suite is a structured collection of behavior specifications, and can also serve as the backbone for a systems design. It is common to think of a system‚Äôs code as its essence and the tests as something secondary.  I invite you to think of it the other way around. A system‚Äôs code shows what the system does, but the system‚Äôs application code does not have the last word.  Because an application tests are specifications, whatever the test specifies is, by definition, correct. So far we have mostly focused on writing new tests and writing them. but in a production application, in addition to being written and run, tests often need to be understood and modified. Abstraction is the art of hiding distracting details and emphasizing essential information. Test code is responsible for jobs that vary widely in the relevance to the high level meaning of the test. 1 test data has to be created. 2 dependencies have to be initialized. 3 code has to be finagled into the right state. 4 assertions have to be made, etc. Here is a testing code example: Before: RSpec. describe  Creating Comment , type: :feature, js: true do let(:user) { create(:user) } let(:raw_comment) { Faker::Lorem. paragraph }let(:article) do create(:article, user_id: user. id, show_comments: true)end  before { sign_in user }  it  User replies to a comment  do  create(:comment, commentable_id: article. id, user_id: user. id)    visit article. path. to_s    find( . toggle-reply-form ). click  find(   :xpath,     ‚Äú//div[@class=‚Äôactions‚Äô]/form[@class=‚Äônew_comment‚Äô]/textarea‚Äù). set(raw_comment)  find(   :xpath,     ‚Äú//div[contains(@class, ‚Äôreply-actions‚Äô)]/input[@name=‚Äôcommit‚Äô]). click  expect(page). to have_text(raw_comment) endendThe ‚Äúit‚Äù block should describe how it (the system) should behave. To me the way this test description is written is a sign that this test is not the result of a clearly thought out specification The next step is to think about the one or the given, in this case when user submits a reply to a comment or not article ( a scenario) the body of the reply shows up on the article‚Äôs page ( expectation) After (with better description): RSpec. describe ‚ÄúCreating Comment‚Äù, type: :feature, js: true do  context  user submits a reply to a comment on an article‚Äù do  it ‚Äúshows the reply on the article‚Äôs page‚Äù do  end endendIf an abstraction does not give you the slightest clue of what it is doing without looking at its content, Then it is a pretty poor abstraction. When a test is full of distracting details, simply moving the details behind methods is not necessarily an improvement; careful thought must be given to what abstractions the methods represent and why they are helpful. RSpec. describe  Creating Comment , type: :feature, js: true do before { sign_in user } it  User replies to a comment  do  create_setup_data  submit_comment  expect_correct_comment end def create_setup_data  let(:user) { create(:user) }  let(:raw_comment) { Faker::Lorem. paragraph }  let(:article) do   create(:article, user_id: user. id, show_comments: true)  end end def submit_comment  create(:comment, commentable_id: article. id, user_id: user. id)  visit article_path. to_s  find( . toggle-reply-form ). click    find(   :xpath,    //div[@class='actions']/form[@class='new_comment']/textarea   ). set(raw_comment)    find(   :xpath,    //div[contains(@class, 'reply-actions')]/input[@name='commit']   ). click end def expect_correct_comment  expect(page). to have_text(raw_comment) endendThe author also speaks about scoping (arranging app‚Äôs files) and gives a relevant example of an appointment model ls -1 spec/modelsappointment_spec. rbinvoice_spec. rbpatient_spec. rbuser_spec. rbls -1 app/modelsappointment. rbinvoice. rbpatient. rbuser. rbThe rails g scaffold appointment command gave the developers to containers to put stuff in, one called app/models/appointment. rband another called spec/models/appointment. rb. Slowly over time, each of these containers group, a few lines of code at a time, into a monster. How do we fix this? by slicing up the model code into a smaller, more cohesive pieces for instance: The recurrence logic moved into an object called RecurrenceRule which lives in app/models/recurrence_rule. rb or even better with namespace Schedule::RecurrenceRule and lives at app/models/schedule/recurrence_rule. rb Cohesion If a code base is like a story, a file in a code base is perhaps like a chapter in a book. A well-written chapter will clearly let the reader know what the most important points are and will feature those important points most prominently. A chapter is most understandable when it principally sticks to just one topic. If a detail would pose too much of a distraction or an interruption, it gets moved to a footnote or appendix or parenthetical clause. A piece of code is cohesive if a) everything in it shares one single idea and b) it doesn‚Äôt mix into incidental details with essential points. How cohesion gets lost  Fresh new projects are usually pretty easy to work with because when you don‚Äôt have very much code, it is easier to keep your code organized and when the total amount of code is small, things have to be pretty disorganized in order for it to hurt. Things get tougher as the project grows. Entropy is the tendency for all things to decline to disorder unavoidably sets in. A common manifestation of entropy is when I developer is tasked with adding a new behavior. he or she goes looking for the object that seems like the most fitting home for that new behavior. he or she adds the new behavior, which does not perfectly fit the object where it was placed, but the code only makes the object say 5% less cohesive, the result of all these changes in aggregate is a surprisingly bad mass. How cohesion can be preserved?  The first key to maintaining cohesion in any particular piece of code is to make a clear distinction between what‚Äôs essential and what‚Äôs incidental. Let‚Äôs say that I have for example a class called Appointment. The concerns of Appointment include among other things, start time, a client and some matters related to caching. I would say that the start time and client are essential concerns of an appointment and that the caching is probably incidental. Now where to put these newly sprouted files. The rationale here is that cashing logic will only ever be relevant to a scheduling whereas an appointment might be viewed in multiple contexts, for example sometimes scheduling and sometimes billing. app/models/appointment. rbapp/models/scheduling/appointment_caching. rbHere is another example of a Customer object with certain method including one called balance.  Over time the balance calculation becomes increasingly complicated to the point that it causes Customer to lose cohesion. I can just move the guts of the balance method into a new object (a PORO) called CustomerBalance and delegate all the gory details of balance calculation to that object. Now the Customer object once again focuses on the essential points and forget about the incidental details. app/models/customer. rbapp/models/billing/customer_balance. rbIn the case that we cannot extract the incidental details of an object we can use a ‚Äòmixin‚Äô instead. I view ‚Äòmixin‚Äô as a good way to hold a bit of code which has cohesion with itself but which does not quite qualify as an abstraction and so does not make sense as an object. For me, ‚Äòmixins‚Äô usually don‚Äôt have a standalone value, and they are usually only ever ‚Äúmixed in‚Äù to one object as supposed to be reusable.  I could have said ‚Äòconcern‚Äô instead of ‚Äòmixin‚Äô, but to me it is a distinction without a meaningful difference, and concerns come along with some conceptual baggage that I don‚Äôt want to bring into the picture here. Jason believes in organizing files by meaning rather than type. Shared examples from our spec is something that at first glance seems to be a good idea however it provides obfuscation because it is difficult for the programmer to know where the values and variables come from https://rspec. info/features/3-13/rspec-core/example-groups/shared-examples/ Duplication code only for testing. Duplication is mainly bad when it passes a risk of two or more pieces of behavior getting out of sync due to a mistake, leaving one copy of the behavior correct and the other one incorrect. Since tests are not behavior, they are not always susceptible to the same kinds of duplication mistakes as application code. Test helpers on DRY That DRY principle does not apply to test code in the same way that it applies to application code, since application code is behavior whereas the test code is a specification. Helpers are not tested and they do not contain specifications. They simply help with gruntwork. online test code a helper does benefit from being DRY just like application code does. Managing setup data Most tests require some setup data, the more setup data there is, the harder it is to keep the test code understandable. It‚Äôs important for tests to be deterministic, meaning that they behave the same way every time. if a test is not deterministic, it may pass sometimes and fail sometimes, giving false negatives and causing numbness to legitimate failures. A key ingredient in making a test stick is to start with the same state every time. If a test is allowed to pollute its environment by changing for example environmental variables, configuration settings or database data, then the test that runs after it will run in a fould environment instead of a clean slate. For this reason, Rails by default runs every test inside of the database transaction, before the test finishes, the transaction gets aborted so that any data created inside the test never gets committed to the database. Every piece of data that‚Äôs in the database when test starts, we will call this data ‚Äúbackground data‚Äù, has the potential to influence how the test behaves. the less background data there is, the fewer headaches it can cause. Naming. The author lays out a test that has three values: ‚Äòuser‚Äô, ‚Äòtoken‚Äô, ‚Äòmismatch_token‚Äô.  He states that the last one is pretty clear, however after reading the whole test he suggested changing from ‚Äòtoken‚Äô to ‚Äòvalid_token‚Äô in order to make it clearer. A good rule of thumb for naming is to call things what they are.  This rule may sound obvious, but how many times have you encountered a variable method, class or database table that‚Äôs named according to something other than what it actually is? Because code is read many more times than it is written, the cost of a poor name is often many times more than the cost saved by skipping the effort of giving it a clear name. One topic per test. Some testers believe that each test should have just one assertion, others believe that this rule is hogwash, and that a test should have as many assertions as it needs. The significant thing about the test is not how many assertions it contains but rather how many topics it contains. A test with just one topic ‚Äì a test that‚Äôs only about one thing‚Äì it‚Äôs going to be easier to understand than a test that conflates multiple topics. It is common for developers to stuff several assertions into one test out of a desire for performance efficiency, especially in system specs, which are expensive to run. That I think this is usually a false economy. Yes, a performance benefit is cheap but at expense of understandably but the savings in CPU time is paid for by engineer time and we of course know which of the two is more expensive. The phases of a test Every test has four phases: set up, exercise, assertions and tear down. in Rails the tear down usually happens automatically, so we only need to think about the ‚Äòsetup‚Äô, ‚Äòexercise‚Äô and ‚Äòassertion‚Äô steps done. They are also known as a range, act, assert. Organizing your test Suite. As we saw at the beginning of this chapter, a test suite, when thought of as a structure set of behavior specifications, can serve as the backbone of a systems design. The files and folders in a test suit should be laid out in an orderly and logically fashion so that when one needs to find something, it can be found easily. Instead of organizing tests by test type, which in a sense is an incidental detail, I find it more logical to organize my test by domain concept. Each folder in a test suite can be thought of as having two dimensions: to what domain concept it belongs and to what type of test it pertains. Traditional Rspec way to order files:      | billing     | schedule    | clinical    ----------|----------------|----------------|----------------models  | models/billing | models/schedule | models/clinicalrequests | requests/billing | requests/schedule | requests/clinicalsystem  | system/billing | system/schedule | system/clinicalJason suggests the following by meaning (domain-specific) and then type:      | models     | requests    | system    ----------|---------------|----------------|---------------billing  | billing/models | billing/requests | billing/systemschedule | schedule/models | schedule/requests | schedule/systemclinical | clinical/models | clinical/requests | clinical/systemLastly, something helpful that this new approach helps is to catch regressions, when tests are organized by the main concept, the search for regressions can be conducted much more logically and efficiently. Once you get for instance spec/schedule/appointments/system/cancel _appointment. rb passing, you can then locally run all the tests in that parent folder spec/schedule/appointment. Chapter 6. Duplication in test code. : It is commonly believed that duplication is code that appears in two or more places. But this is actually mistaken. Duplication is when there is a single behavior that‚Äôs specified into or more places. Just because two identical pieces of code are present does not necessarily mean duplication exists. And just because there are no two identical pieces of code present doesn‚Äôt mean here is no duplication. Two pieces of code could happen to be identical, but if they actually serve different purposes and lead separate lives, then they do not represent the same behavior, and they do not constitute duplication. The way to tell if two pieces of code are duplicative is not to see if their code matches. The question that determines application is; ‚Äúif I changed one piece of code in order to meet any requirement, would it be logically necessary to update the other piece of code the same way?‚Äù The main reason for duplication is that it leaves a problem susceptible to developing logical inconsistencies. If a behavior is expressed in two different places in a program, and one of them accidentally does not match the other, then the deviating behavior is necessarily wrong. Another reason duplication can be bad is because it can cost an extra maintenance burden. What determines how risky duplication is 1) one how easily noticeable the duplication is2) how much extra maintenance overhead the presence of the duplication incurs,3) how much traffic that area receives( how frequently that area of code needs to be changed or understood) Noticeability If someone updates one of the code of the behavior to meet any requirement they are very likely to miss updating the other one. We might call this the proximity factor. If two pieces of duplicated behavior appear in different files in different areas of the application, then a mess is much likely to occur, and therefore the application processes a larger risk. Another quality that makes the noise ability of the application issued is similarity. If two pieces of code look very similar than the duplicity is more likely to be noticed than if the two pieces of code do not look the same (similarity factor) Maintenance overhead If a piece of duplication exists as a part of the database schema, that‚Äôs a much higher maintenance cost than a small duplication in code. Instances of duplication there are large and are not represented by identical code can also be costly to maintain because, in those cases, you cannot just type the same thing twice, you have to perform a potentially expensive translation step in your head. Traffic levelThe more frequently the code is changed, the more of a toll it is going to incur, and so the bigger problem it is. Another tollway is when a piece of code needs to be understood as a priority to understanding a different piece of code. How to decide whether to DRY up a piece of code. There are two simple options, although it is not always easy. Severity. If a piece of duplication is severe for example it has low noticeability, it posses high maintenance overhead, and has a high traffic level, then those all add weight to the argument that the duplication should be cleaned up. The quality of alternatives just because a piece of duplication costs something does not automatically mean that the duplicated version costs less. It doesn‚Äôt happen very often but sometimes ad duplication unavoidably results in code that‚Äôs so generalized that it is virtually impossible to understand. Rule of three, write everything twice. When I‚Äôm deciding whether to dry up a duplication, I asked myself: how severe is this instance of duplication? Are we able to come up with a fix that‚Äôs better than the duplicated version and not worse? Example, imagine a piece of duplication in the form of three very simple and nearly identical lines, group together in a single file, the file is a unimportant one which only gets touch a couple of times a year, and no one needs to understand that piece of code as a prerequisite to understanding anything else. Now imagine another piece of duplication. The duplication appears in only two places but the places are distant from each other and therefore the application is hard to notice. The two places where the duplicated behavior appears are expressed differently enough that the code would elude detection by a quality tool or a manual human search. The behavior is vitality central and important one and the two places the behavior appears are virtually painful to keep in sync. Duplication is cheaper than the wrong abstraction The real difference between duplication and test code and application code. Duplication, again, is when a one behavior is expressed into or more places. The difference between the test code and application code is that test code does not contain behavior. all the behaviors are in the application code. the purpose of the test code is to specify the behaviors of the application code. What is the codebase that determines whether the application code is correct? the test. If a piece of behavior is duplicated in two places in the application code and one piece of behavior gets changed, it does always logically follow that the other piece of behavior needs to get updated to match. (otherwise they will not be the instance of a duplication. ) Chapter 7. Mocks and stubs. : What is a stub? In a football scrimmage, the team doesn‚Äôt play against a real opponent because:  It‚Äôs expensive (travel, logistics, etc. ).  It could have unwanted side effects (injuries, revealing strategies, etc. ).  Instead, they simulate the opponent using their own players to control the scenario. Similarly, in testing: A stub replaces an actual method with a controlled response. It prevents expensive operations like:  Database queries.  External API calls.  Complex calculations.  It ensures the test has more controllable responses. Example: class PaymentGateway def charge(amount)  # Imagine this calls an external API (expensive!)   Charged #{amount}  endendRSpec. describe PaymentGateway do it  stubs the charge method  do  gateway = PaymentGateway. new  allow(gateway). to receive(:charge). with(100). and_return( Stubbed charge )  expect(gateway. charge(100)). to eq( Stubbed charge ) # Controlled response endendWhat is a mock? Imagine Mr. Boss pretends to be a regular customer (mock objects pretend to be real objects)He orders specific items like a hamburger, fries, and a coke (sets expected method calls). Afterward, he ‚Äúinterrogates‚Äù the experience - ‚ÄúDid you receive the hamburger you ordered?‚Äù (verifies that expected interactions occurred) If any verification fails, the test fails A mock is a fake object (like the undercover boss is a fake customer)It has predetermined responses class Waiter def take_order(order)  # Imagine this method interacts with a real kitchen system   Order placed: #{order}  endendRSpec. describe Waiter do it  verifies that the order was placed  do  waiter = Waiter. new  expect(waiter). to receive(:take_order). with( hamburger )  waiter. take_order( hamburger ) # If this isn't called, the test fails endendSummary    A stub is like using a fake team in a football scrimmage‚Äîit avoids unnecessary costs.     A mock is like an undercover boss‚Äîit checks if expected interactions happen.  ‚ÄúDo I just need to fake a response?‚Äù ‚Üí Use a stub. ‚ÄúDo I need to verify that something was called?‚Äù ‚Üí Use a mock.       Feature   Stub   Mock         Purpose   Controls return values   Verifies method calls       Tracks calls?   No   Yes       Fails test if method is not called?   No   Yes   Testing third party interactions using stubs In principle we could test third party interactions by actually hitting live services. the upside to this approach is that it provides a very realistic environment, however the downsides are: Loss of determinism, this means that our tests will potentially be non-deterministic. Determinism is the property of always behaving the same way given the same starting conditions. Tests that involve third-party services may behave one way on some runs and another way on other runs even though they‚Äôre starting conditions were the same. Limited ability to control test scenarios, when writing tests that involved third-party services, it is desirable to cover certain scenarios such as when the server returns a value response, when the service return a graceful error response, or a 500 error so creating this scenario is impossible. Side effects, using live services can also cause rate limiting, causing the test to eventually flake once requests start failing due to rate limits, and also preventing real production requests. Stubbing services. Stubbing third party services avoids the problems that come with using live services. When services are stubbed our test can be deterministic, we can control our test scenarios and we don‚Äôt have to worry about introducing side effects. What exactly is stubbing? is a practice of replacing one piece of behavior with another. Coming up with good tests A common mistake is to write tests that ‚Äúmake sure the API gets called‚Äù and to ‚Äúmake sure the right results get returned‚Äù.  Remember that testing is about a specification, not verification. The test is not to ‚Äúmake sure the code worked‚Äù but rather to specify how the code should work. Remember that the behavior we are interested in is what happens after the API (stripe, paypal) response is received. Example of code before ‚Äústubbing‚Äù require  rails_helper include APIAuthenticationHelperRSpec. describe  GitHub tokens , type: :request do Describe ‚ÄúPOST /api/v1/github_tokens‚Äù do  it  returns a token  do   post(       api_v1_github_tokens_path,        headers: api_authorization_headers   )  expect(response. body). to be( ABC123 ) endendAfter stubbing: require  rails_helper include APIAuthenticationHelperRSpec. describe  POST /api/v1/github_tokens , type: :request do it  returns a token  do  allow(GitHubToken). to receive(:generate). and_return( ABC123 ) üëà  post(   api_v1_github_tokens_path,   headers: api_authorization_headers  )  expect(response. body). to eq( ABC123 ) endendThe behavior we are mainly interested in is not how the token gets generated but in how the GitHub tokens API endpoint response to a request for a token. The line ‚Äúallow(GitHubToken)‚Äù Does not actually call the method, but instead return the hard coded value ‚ÄúABC123‚Äù. Code example for mocking class TaskProcessor def self. process  puts  Processing task. . .   endendclass BackgroundJob def perform  TaskProcessor. process endenddef start_background_job(job = BackgroundJob. new) job. performendclass MockedJob def initialize  @performed = false end def perform  TaskProcessor. process  @performed = true end def performed?  @performed endendRSpec. describe  Starting the background job with RSpec mock  do it  calls . perform on the mock job  do  job = MockedJob. new üëà  expect(job). to receive(:perform) üëà  start_background_job(job) endendChapter 8. Flaky tests. : When a boat leaks, the crew has not one problem but two. One problem is the water that‚Äôs in the boat, causing it to lose buoyancy. This problem can be mitigated by bailing out water, but it won‚Äôt solve the other problem, which is that there are holes in the boat allowing more water to leak in.       Layer   Symptom   Root cause         Secondary   Water in the boat   Holes in the boat.        Primary   Holes in the boat   Poor design? Aging?   The holes in the boat are the symptom of the primary problem. The two layers of the flaky test problem       Layer   Symptom   Root cause         Secondary   Individual flaky tests   Instances of non-determinism (race conditions, environment corruption, randomness, external dependencies in tests, fragile time dependencies)       Primary   Instances of non-determinism (race conditions, environment corruption, randomness, external dependencies in tests, fragile time dependencies)   Application complexity, poor test design.    What is a flaky test? A flaky test is a test that passes sometimes and fails sometimes even when no code has changed. Flaky test cost test runs to fail illegitimately, causing annoyance, wasted time and a numbness to legitimate failures. All flaky tests are caused by some form of non-determinism. Code that‚Äôs deterministic is code that always gives the same output for a given input. Flaky tests are caused by some form of non-determinism. Race conditions Race conditions are most likely to arise when the buffer is small. Imagine, a guy arrives at the train station with only a 1-minute buffer. If a ticket machine is slow or a gate malfunctions, he misses the train. Similarly, in software, race conditions occur when timing issues cause unpredictable failures. This gets fixed by adding an expect(page). to have_content command immediately after the command that submits in this case the form. Unlike the indifferent click_on command expect_page. to have_content will wait a bit before it gives up and allows the test Runner to continue. click_on ‚Äúsubmit‚Äùexpect(page). to have_content(‚ÄúThanks‚Äù) # to prevent race conditionsclick_on ‚ÄúHome‚ÄùYou can modify the default wait time docs Capybara. default_max_wait_time = 10 And also per-test basis Capybara. using_wait_time(10) do expec(page). to have_content(‚ÄúSuccess‚Äù)endEnvironment state corruption Imagine two tests, each of which creates a user with email_address: test@example. com the first test will pass and, if there is a unique constraint on user. email, the second test will raise an error due to unique constraint validation. Sometimes the first test will fail and sometimes the second test will fail depending on the order in which order you run them. Another way to spoil the environment is to change a configuration setting. Let‚Äôs say you have a test environment with a background job configured not to run for most tests because most background jobs are irrelevant to what‚Äôs being tested and would just slow things down. But then let‚Äôs imagine that you have one test that you do want background jobs to run, and so at the beginning of the test you set background job setting from the don‚Äôt run to run. if you don‚Äôt remember to change the setting back to don‚Äôt run at the end all background jobs will run for all later tests and potentially cause problematic behavior. External dependencies in tests. The way to prevent flaky test caused by network dependencies is to stub services rather than hitting live services Randomness By definition common non-deterministic. If you have for example a test that generates a random integer between one and two and then asserts that the number is one that is going to fail about half the time period. Fragile time dependencies in test The way around this problem is to always use absolute times in tests instead of relative ones. For instance ‚Äú2025-03-10 08:00:00‚Äù Instead of ‚Äútomorrow 12:00 p. m. ‚Äù       Problem   Prerequisite         Race conditions   Concurrency       Environment state corruption   Mutable environment state       Randomness   Randomness       External dependencies   External dependencies       Fragile time dependencies   Features that involve time   To summarize all this in a few words, complicated applications tend to have more flaky tests than simple ones. How to fix flaky tests Flaky tests are hard to fix largely because they are hard to reproduce. If a flaky test cannot be consistently reproduced then it is very hard to hypothesize about the conditions to make it fail. It is also hard to hypothesize about the case of a flaky chest if we don‚Äôt have enough background knowledge to guide our hypothesis. If we are familiar with the conditions that can lead to flaky tests, then we can come up with much more intelligent guesses than if we are clueless about how flaky tests arise. The fact that flaky tests are hard to reproduce also means that our fixed attempts are hard to validate or invalidate. Adopt an effective bug fix methodology. I find it helpful to split the bug fix process into three distinct stages:  reproduction, diagnosis and fix. When fixing a bug it is very easy to let your head get filled with a jumble of thoughts and lose track of what you‚Äôre doing. Dividing the processing to steps helps us stay focused on one activity at the time. Arm yourself with background knowledge. All about diagnosis start as guesses to get more efficient in diagnosing flaky tests, commit to five causes of flaky tests to memory. Before reproducing: determine whether it is really a flaky test. Not everything that appears to be a flaky test is actually a flaky test. Sometimes a test that appears to be flaky is just a healthy test that‚Äôs legitimately failing. Reproducing a flaky test.  My go-to method for reproducing a flaky chest is simply to re-run the test suite multiple times on my CI service until I see the flaky test fail. I like to run the test so it‚Äôs a large number of times to not only reproduce the failure but also to get a feel for how frequently the flaky test fails. Diagnosing flaky tests.  Remember that if you preferably understood all the code and tests, you would also understand the cause of the flaky test that you are trying to diagnose. All that lies between you and a diagnosis is certain amount of understanding. Applying the fix for a flaky test. Sometimes the only way to see if a flaky test is fixed with our attempt is to wait. Do not delete a test without a good reason. Remember that the important thing is not the cost benefit ratio of an individual flaky test fixed, but the cost benefit ratio of all the flaky test fixes on average. This means that fixing flaky tests creates a positive feedback loop. Chapter 9. Testing sins and crimes. : Chapter 10. Ruby DSL. : Chapter 11. Factory bot. : Chapter 12. RSpec syntax. : Chapter 13. Capybara‚Äôs DSL. : "
    }, {
    "id": 42,
    "url": "http://localhost:4000/2025/01/31/rails-code-guide-through.html",
    "title": "Rails code guide through with Kasper Timm Hansen | notes",
    "body": "2025/01/31 - Next session with Kasper (luma link) Last Friday I attended a session with Kasper where he shared with us how he usually explores Rails codebase, he‚Äôs got a lot of experience doing this therefore I applied what I learned here. I‚Äôve always been curious how callbacks and model validations work in Rails, so I decided to explore this topic.  Setting up the app Possible error with bundle First exploration with ActiveRecord lib super keyword for . valid? super keyword for . save Ruby call stack Recap with flow chart Shortcut for Ruby method lookupAlways have a question in mind that you want to answer otherwise it may be pretty easy to get lost. üí° Setting up the app: # create a new rails apprails new callbacks &amp;&amp; cd callbacks# create a new modelrails g model Post titlerails db:migrate# add the following code to the modelclass Post &lt; ApplicationRecord validates :title, presence: true, allow_nil: false before_validation :titleize_title after_create :print_out_title private  def titleize_title   return unless title. present?   self. title = title. downcase. titleize   puts  before_validation- Title changed to #{title}   end  def print_out_title   puts  after_create- Title was saved as: #{title}   endendAfter setting up a very basic app with 2 callbacks, and one validation, we can see that both callbacks are running corrrectly. ‚ûú callbacks git:(main) ‚úó rcLoading development environment (Rails 8. 0. 1)callbacks(dev)&gt; p = Post. new=&gt; #&lt;Post:0x00000001205322c8 id: nil, title: nil, created_at: nil, updated_at: nil&gt;callbacks(dev)&gt; p. valid?=&gt; falsecallbacks(dev)&gt; p. errors. full_messages=&gt; [ Title can't be blank ]callbacks(dev)&gt; p. title =  HOLA =&gt;  HOLA callbacks(dev)&gt; p. savebefore_validation- Title changed to Hola üëà TRANSACTION (0. 1ms) BEGIN immediate TRANSACTION /*application='Callbacks'*/ Post Create (10. 0ms) INSERT INTO  posts  ( title ,  created_at ,  updated_at ) VALUES ('Hola', '2025-02-03 01:09:45. 881379', '2025-02-03 01:09:45. 881379') RETURNING  id  /*application='Callbacks'*/after_create- Title was saved as: Hola üëà TRANSACTION (0. 3ms) COMMIT TRANSACTION /*application='Callbacks'*/=&gt; truePretty standard, now what does trigger ‚Äòactive_record_callbacks‚Äô? Was it after calling ‚Äú. valid?‚Äù or ‚Äú. save‚Äù? Possible error with bundle: Let‚Äôs go and open active_record library with ‚Äòbundle open activerecord‚Äô, it might throw you an error, I fixed it by typing: # in your console, it will work for one sessionEDITOR=code bundle open activerecord# or permanently set it in your . zshrc fileexport BUNDLER_EDITOR=code# close the . zshrc filesource ~/. zshrcDocs for ‚Äòbundle open‚Äô and setting your editor for opening gems ü™Ñ First exploration with ActiveRecord lib: Within lib/active_record/validations. rb:69 and after reading a bit we can see the following chain of method calls: save ‚Üí perform_validations ‚Üí valid?. Let‚Äôs add a puts statement and test it out. def valid?(context = nil) puts  you are calling 'valid?' :)  # added for testing üëà context ||= default_validation_context output = super(context) # &lt;--- calls ActiveModel::Validations#valid? (parent method) errors. empty? &amp;&amp; outputendClose the editor and ‚Äòreload!‚Äô rails console ‚ûú callbacks git:(main) reload!Loading development environment (Rails 8. 0. 1)callbacks(dev)&gt; p = Post. new=&gt; #&lt;Post:0x0000000120b394c8 id: nil, title: nil, created_at: nil, updated_at: nil&gt;callbacks(dev)&gt; p. valid?you are calling 'valid?' :) üëà=&gt; falsecallbacks(dev)&gt; p. title =  HOLA! =&gt;  HOLA! callbacks(dev)&gt; p. saveyou are calling 'valid?' :) üëàbefore_validation- Title changed to Hola! TRANSACTION (0. 1ms) BEGIN immediate TRANSACTION /*application='Callbacks'*/ Post Create (3. 0ms) INSERT INTO  posts  ( title ,  created_at ,  updated_at ) VALUES ('Hola!', '2025-02-03 01:32:16. 234929', '2025-02-03 01:32:16. 234929') RETURNING  id  /*application='Callbacks'*/after_create- Title was saved as: Hola! TRANSACTION (0. 5ms) COMMIT TRANSACTION /*application='Callbacks'*/=&gt; trueWe can conclude with this inspection that each time we call ‚Äú. save‚Äù or ‚Äúsave!‚Äù we call in the end ‚Äú. valid?‚Äù. Now, let‚Äôs explore the 2 ‚Äòsuper‚Äô keywords following the chain of methods up to its ancestor. ‚Äòsuper‚Äô keyword for . valid?: Let‚Äôs open the gem with ‚Äòbundle open activemodel‚Äô. ‚Äò. valid?‚Äô will invoke ActiveModel::Validations#valid? lib/active_model/validations. rb:361 this method will call ‚Äòrun_validations!‚Äô which is defined in lib/active_model/validations. rb:459 def valid?(context = nil) current_context = validation_context context_for_validation. context = context errors. clear run_validations! # &lt;--- calls all validation callbacks (returns true if the record is valid, false otherwise)ensure context_for_validation. context = current_contextendrun_validations! ‚Üí _run_validate_callbacks The latter comes from ActiveSupport::Callbacks, it is dynamically generated via ‚Äòdefine_callbacks‚Äô, inside of this ActiveSupport module you‚Äôll find very interesting classes as Before, After, Around, CallbackSequence, CallbackChain (where the callbacks are stored in a []) ‚Äòsuper‚Äô keyword for . save: The second ‚Äòsuper‚Äô keyword is in ‚Äò. save‚Äô and goes up to ActiveRecord::Persistence module. Just for making this more practical I have added a puts statement to lib/active_record/persistence. rb:390 def save(**options, &amp;block) create_or_update(**options, &amp;block) puts  you saved it :)  # added for testing üëàrescue ActiveRecord::RecordInvalid falseendrails console üéÆ callbacks(dev)&gt; p = Post. new=&gt; #&lt;Post:0x000000011d5b92a8 id: nil, title: nil, created_at: nil, updated_at: nil&gt;callbacks(dev)&gt; p. title =  HOLA? =&gt;  HOLA? callbacks(dev)&gt; p. valid?you are calling 'valid?' :)before_validation- Title changed to Hola?=&gt; truecallbacks(dev)&gt; p. saveyou are calling 'valid?' :)before_validation- Title changed to Hola? TRANSACTION (0. 1ms) BEGIN immediate TRANSACTION /*application='Callbacks'*/ Post Create (8. 7ms) INSERT INTO  posts  ( title ,  created_at ,  updated_at ) VALUES ('Hola?', '2025-02-03 23:16:20. 758330', '2025-02-03 23:16:20. 758330') RETURNING  id  /*application='Callbacks'*/after_create- Title was saved as: Hola?you saved it :) üëà TRANSACTION (0. 0ms) ROLLBACK TRANSACTION /*application='Callbacks'*/=&gt; nil‚Äò. save‚Äô will call ‚Äòcreate_or_update‚Äô and then depending on whether the object is new or not, it can be about an ‚Äòinsert‚Äô or ‚Äòupdate‚Äô operation. How ruby call up its ancestor objects: Something that was difficult to wrap my head around was why ‚Äòvalid?‚Äô and ‚Äòsave‚Äô point to different modules and how they get overridden? After some lookups I figured that this is because in ‚Äòlib/active_record/base. rb‚Äô we have the following: Module ActiveRecord class Base  include Persistence  include Validations  include Callbacks  . . . endendSince Validations is included after Persistence, it overrides ‚Äòsave‚Äô, adding validation checks before calling ‚Äòsuper‚Äô to go back to ‚ÄòPersistence#save‚Äô. Recap with visual aid: When we call ‚Äò. save‚Äô, Ruby follows this lookup order: First, it checks the model‚Äôs own class (Post in this case). The Post model does not define ‚Äòsave‚Äô, so Ruby looks in the included modules. If not found, it looks in Callbacks, which does not define ‚Äòsave‚Äô either. Third, it checks ‚ÄòActiveRecord::Validations#save‚Äô. Since this method exists, it runs, calling ‚Äòperform_validations‚Äô. If validation passes, it calls ‚Äòsuper‚Äô, which means ‚Äúfind the next save method in the lookup chain. ‚Äù Finally, super calls ‚ÄòActiveRecord::Persistence#save‚Äô. This method handles inserting/updating the record.    Persistence   ‚Üë   Validations   ‚Üë   Callbacks   ‚Üë   Transactions   ‚Üë   First, Ruby looks in the Post class itself Here a flow chart as recap of what we explored: Shorcut - Ruby method lookup: I got some feeback from Kasper and he suggested the following commands as alternatives, they seem to be more efficient than looking up the code in the gem. The code will tell you where the method is defined, and you can keep chaining . super_method to go up the inheritance chain. ‚ûú callbacks git:(main) rcLoading development environment (Rails 8. 0. 1)callbacks(dev)&gt; Post. instance_method(:save). super_method=&gt; #&lt;UnboundMethod: ActiveRecord::Transactions#save(**) /Users/dominiclizarraga/. rbenv/versions/3. 4. 1/lib/ruby/gems/3. 4. 0/gems/activerecord-8. 0. 1/lib/active_record/transactions. rb:361&gt;# 2 times '. super_method'callbacks(dev)&gt; Post. instance_method(:save). super_method. super_method=&gt; #&lt;UnboundMethod: ActiveRecord::Validations#save(**options) /Users/dominiclizarraga/. rbenv/versions/3. 4. 1/lib/ruby/gems/3. 4. 0/gems/activerecord-8. 0. 1/lib/active_record/validations. rb:47&gt;# 3 times '. super_method'callbacks(dev)&gt; Post. instance_method(:save). super_method. super_method. super_method=&gt; #&lt;UnboundMethod: ActiveRecord::Persistence#save(**options, &amp;block) /Users/dominiclizarraga/. rbenv/versions/3. 4. 1/lib/ruby/gems/3. 4. 0/gems/activerecord-8. 0. 1/lib/active_record/persistence. rb:390&gt;And also for seeing the module hierarchy and suplerclasses you can use the following command: Post. ancestors=&gt; [Post (call 'Post. load_schema' to load schema informations), Post::GeneratedAssociationMethods, Post::GeneratedAttributeMethods, ApplicationRecord(abstract), ApplicationRecord::GeneratedAssociationMethods, ApplicationRecord::GeneratedAttributeMethods, ActionText::Encryption, ActiveRecord::Base, Turbo::Broadcastable, ü§Ø ActionText::Attribute, ActiveStorage::Reflection::ActiveRecordExtensions, ActiveStorage::Attached::Model, GlobalID::Identification, ActiveRecord::Marshalling::Methods, . . . . . . . . . ActiveRecord::ReadonlyAttributes, ActiveRecord::Persistence, üëà ActiveSupport::Callbacks, üëà ActiveModel::Validations, üëà ActiveSupport::Dependencies::RequireDependency, Object, PP::ObjectMixin, ActiveSupport::ToJsonWithActiveSupportEncoder, ActiveSupport::Tryable, JSON::Ext::Generator::GeneratorMethods::Object, Kernel, BasicObject]"
    }, {
    "id": 43,
    "url": "http://localhost:4000/2024/12/15/uml-inventor.html",
    "title": "UML inventor interview (Grady Booch) | notes",
    "body": "2024/12/15 - Full interview UML creator defines UML as reason tool, not coding! Also invented object oriented analysis and design. IBM fellow is a distinguished role where he seeks to do improvements for the next 5-10 years, as Alan Kay said: The best way to predict the future is to invent it. He was after automating discovery patterns in legacy code way before LLM‚Äôs (didn‚Äôt continue the project). The moment you write a code it becomes ‚Äúlegacy‚Äù until you throw it away, even when it‚Äôs very small, it has a cost, has to be maintainable, tech debt, etc. ~60s IRS population increased and paperwork was too much that was not able to be done by hand so a new process of automation with Fortran came (they used to close earlier in order to reconcile accounts) that code is still running, mostly business rules plus the government still issuing more rules YOY. Complex systems started with the defense department (SAGE 50s-80s) before satellites and radars, around this time NATO was created and they aimed to fix this problem. (Golden age of software) The premise back in the day was to build monolith systems that were sustainable over time with algorithmic languages (Cobol, Fortran). The transition from monoliths to distributed systems initially with DARPA was funded by the government and having an email was pretty difficult only a thousand people had. The issue started to be more noticeable when they wanted to scale the system with algorithmic decomposition, they needed software that work in a variety of computers, multi-lingual, distributed and real time. Late 70s Smalltalk arose and the government had an issue that all their systems were using different languages so they wanted to unify them to only one, which was Ada. Ada was far ahead of its time, it used the ideas of abstract data types, which was extremely new back in the day. This new Ada wave brought the Booch method (1979) this is the 2nd golden era of software where they dealt with system distributed problems not only algorithms. Grady came up with the Booch method by reading many sources but one that caught his attention was Plato and his quote ‚Äúhow one should best see the world? As processes or as atoms‚Äù the latter was more inclined to OOP (classes and objects, behavior). (among other philosophical sources) ~1950 subroutines were considered a bad practice/controversial because doing a function call added 2 or 3 more instructions, now is seen normal, this was before the Booch method and thinking in classes and objects, now we take that for granted! The goal of UML was to look at the software from multiple points of view. Before data orientation, people who write COBOL used to print every day a document called ‚Äúcommon data‚Äù as a matter of practice not due to language so that the whole team had the abstractions on a daily basis. Grady and his partners after spending some years in defense they moved to commercial space and built ROSE which helped the teams to write UML diagrams easily, only as a design tool. The market then asked ‚Äúnow we have an arpanet and these personal computers, how do we keep building software?‚Äù and that was the time that the concept of ‚Äúuse-cases‚Äù was conceived, it was very strange to look through it back in the day. UML helped people along Microsoft VScode to drive more complex software because now they have these two that most people can use and write code depicting entities relationships responsibilities and that increase the complexity on the systems (maybe LLM will enable us to develop more complex software?) After the. com hype people realized that the companies or products that were developed we‚Äôre not economically sustainable (maybe all the microapps we currently have?) Why u m l is not longer used in modern software? Grady‚Äôs outlooks  Big companies have exposed their apis therefore there is no much architectural thinking and company keeps building on top of it Startups for instance they just built with others people money and if it fails it doesn‚Äôt matter so I don‚Äôt have formality I just want to build something Another example if I build an airplane software I want more discipline and I want more ceremony so uml is going to be part of Also if I‚Äôm building a defense software and someone may die i want formality Also if I‚Äôm going to build something that people have built in the past again and again I don‚Äôt need uml for instance the users profiles or liking a post I just prompted the LLM On the other hand if I‚Äôm going to build something that I have never seen before something really complex that‚Äôs the sweet spot for UML James Webb space telescope uses UML. Economicals on software has changed, back in the day a computer was more expensive than a human so you have to spend more time thinking about the algorithm before trying it out now that has changed and you take that for granted but the competitional resources were very scarce Regarding the role of software architect: ‚ÄúAll architecture is designed but to all design is architecture‚Äù It represents significant design decisions that shape the form and shape of the system where significant is measured by cost of change. The above paragraph reminded me of: ‚ÄúSuccessful (working) but undesigned applications carry the seeds of their own destruction; they are easy to write, but gradually become impossible to change. ‚Äù‚Äï Sandi Metz The entire history of software engineering is rising levels of abstraction, and that‚Äôs what we are currently seeing at very high level of abstraction that does not require any more the system decision which back in the day was bread and butter Now the decisions that have to be made are what cloud service I use? What message system do I use or what platform? Which are economic decisions, should I use AWS for this? A very interesting comment from Grady was that if you are a startup you‚Äôre going to hire someone who has done this before because they know the caveats of these new ‚Äúarchitectural decision‚Äù in this case let‚Äôs say AWS because this guy has work on it before and he already knows it‚Äôs limitations and how far it can go, the costs and so forth therefore they can accelerate your development because they have more expertise on this and now these are ‚Äúsystemic decisions‚Äù because they have economic impact (even on the long term) Another bite from Grady Regarding why migrations are very hard to carry out is that you aim to build economically feasible software but technology is changing out of you so you that makes you think that you need to change either a new framework or where is the background jobs for the calculations being done either on the server or the mobile for instance ‚ÄúThe code is is the truth but the code is not the whole truth‚Äù this quote again is for design decisions and sits around that you cannot just focus on what‚Äôs the best approach to this problem where is the most optimized solution for this because it involves hardware and even society, even culture. A comparable change in history like that recent AI has brought can be when software went from being developed just to one monolith across different computers like a distributed systems systems, that forced us to rethink how we design systems because now you are able to have it either on your mobile or your PC (lates 70s) By this time many changes came for instance time-sharing, whirlwind computers then mini computers (digital) with help of semiconductors. The rise of distributed systems can be like new LLMS. The perfect storm for AI was having Andrew NG discovering that the matrix multiplication that the NVIDIA GPU us were doing for more realistic game development was the ones that they need for deep learning Grady‚Äôs take on LLM: based on his vast experience on AI and now that he has 6 years researching the brain and its parts, he concludes that LLMs are unreliable narrators based on their architecture, they allow us to build scale bullshit generators, like stochastic parrots. The result is coherent though. We are not going to hit AGI by scaling. For new folks joining the market: -You will always need people to make informed decisions, tools change, it‚Äôs another level of abstraction. Find a place yourself where no one else is there and make your name there. There are plenty of spaces in the computer field, lastly have fun! Books recommendations "
    }, {
    "id": 44,
    "url": "http://localhost:4000/2024/10/12/intercom-off-script.html",
    "title": "Intercom Off Script series | notes",
    "body": "2024/10/12 - Here I wrote down some notes after watcihng the Intercom Off-script series about how they are facing the AI age and how the see it Youtube playlist Video #1  technology comes and goes,you gotta fall in love with the problem think of the core problem of your business, not the tech stack or framework work is always the same, if you want to send something you used to send it on a horse, now you use ups or fedex, want to entertain people? first it was newspaper now it‚Äôs smartphones.  the quickest to adapt, not the strongest does AI would change something in my process?It will blow up the total address of all Market because it will and I will customers or users who know what they want to do however they don‚Äôt know how to do it for instance in Excel or monday. com, salesforce who are great product very robust products but not so many people know how to use them, AI will enable them to use them at its maximum We need to rebuild our products our societies around this new technology and it is day one Video #2 Being disturbing pollution change and reshape our society because before that everything was made by hand and after that breakthrough moment we were able to have houses cars clothing Also technology is like a one-way street that once you go and cross that door you never look back before for instance once we had the iPhone in our hands we did not think about the traditional phone call or mail post What matters the most is that customers and businesses get greater experiences, it boils down to it Video #3 Attention algorithm and then wrap up with a Transformer machine learning technique Then the Transformer was trained with the huge amount of data that never before And finally it seems like it is understanding and it is capable to do some summarizing words follow some instructions An example of what AI needs was when governments increase their budget in order to roll out new highways because they saw that as much highways and streets interconnected you have the more trade Commerce and tourist activity you will get in this case AI needs more compute infrastructure and so on (Things happen fast when the value is there and apparently AI is delivering some value) Apparently it is learning because it is paying attention to the important things It‚Äôs got some limitations but you can‚Äôt work around those limitations People say that it is just a talking prediction like predicting the next word on the sentence RAG Is given the llm more context in order to make it understand the current situation therefore it will provide a more accurate answer Take a small series of tasks That you can really over-delivery on, not too broad. We have used openAI models as building blocks, Maybe five or 10 different prompts Underneath the hood, Each of them doing a specific task like search for this customer in the db, then get their last order, then disambiguate this question From an engineering perspective take five things your product should do and isolate them And get AI to do that task separately Video #4 Mother sauce and software in general seems to be very complicated and clunky because they serve a broad amount of users, It‚Äôs like cities in general they are designed for a general audience not for cyclist or pet owners or car drivers Now with AI you can have UI design that is generated on the Fly based on the user request instead of having a form where users submits email phone number number order it will go and retrieve those data from the database and make up a new form just to confirm that the information is correct and it will be completely Custom Tailor to each requested and even to each user It raises the floor for the designers, the human touch becomes more valued If you wear a drummer in the 80s and you see that a rhythm controller has come out you would thought that you are cooked but it happened all the opposite more drummers came to play their songs (democratizacion of music) So you don‚Äôt need to become a master at your craft in order to make music however there still need of people who are a master at the craft even when AI provides shortcuts Embrace the squiggle (process of designing something, converge, diverge ideas, discussions, etc) Video #5 Better, faster cheaper on online business Customer service in businesses prior the war was more personal they made individual transactions, and then as the business expanded they needed to hire more customer service in order to make it more Global more professional and then after that the 01800 phone lines came up and that was the time that the call centers started then with computers and internet the email and then the CRM too, chatbots, etc, also how customers leave feedback from the service they got and that was a time where you needed a quality customer service. Easiest decision is to cut people in order to make profit‚Ä¶So in order to increase the quality of your customer service at the internet scale is very difficult Video #6 Big boys and small are no longer selling software seats to humans, but software doing the work. We don‚Äôt pay for CS, we pay what‚Äôs in the receipt, and CS is all around. Having a internet business bring the benefits of scales which is selling around the clock, around the globe Heretofore (before now, new word) Agents gen1 (conversation, text boxes) and gen 2 (more familiar, proactive and take action) Cannibalize themselves if they want to survive and Netflix did with their shipping DVD business before streaming. "
    }, {
    "id": 45,
    "url": "http://localhost:4000/2024/08/17/open-source.html",
    "title": "Operating Systems - open source",
    "body": "2024/08/17 - Test for a open source ! "
    }, {
    "id": 46,
    "url": "http://localhost:4000/2024/08/15/linux.html",
    "title": "This is a test for Operating Systems",
    "body": "2024/08/15 - Test for a Linux ! "
    }, {
    "id": 47,
    "url": "http://localhost:4000/2024/05/26/what-is-distributed-systems.html",
    "title": "This is a test for Distributed Systems",
    "body": "2024/05/26 - What is Distributed Systems "
    }, {
    "id": 48,
    "url": "http://localhost:4000/2024/05/06/why-acid.html",
    "title": "This is a test for ACID",
    "body": "2024/05/06 - Why ACID in postgres "
    }, {
    "id": 49,
    "url": "http://localhost:4000/2024/05/06/what-is-vacum.html",
    "title": "This is a test for Relational Database",
    "body": "2024/05/06 - What is VACUM "
    }, {
    "id": 50,
    "url": "http://localhost:4000/2024/05/05/utf-8-bits-bytes-binary.html",
    "title": "UTF-8, bits, bytes and binary numbers!",
    "body": "2024/05/05 - Test 1 "
    }, {
    "id": 51,
    "url": "http://localhost:4000/2024/03/12/stimulus-controller-life-cycle.html",
    "title": "Stimulus controller - life cycle",
    "body": "2024/03/12 - "
    }, {
    "id": 52,
    "url": "http://localhost:4000/2024/02/17/refactoring-and-testing.html",
    "title": "Refactoring and testing a long method in Ruby on Rails",
    "body": "2024/02/17 - Recently, we had the opportunity to refactor a lengthy method in a Ruby on Rails project. The method had multiple conditional statements (around 6) that checked various aspects of a project, such as whether it was discarded, on time, accepting entries, and more. Refactoring this method required careful planning and testing to ensure that the functionality remained intact while improving the code‚Äôs maintainability and readability. Before diving into the refactoring process, we first focused on writing tests that covered all the edge and corner cases. To do this, we wrote tests that checked the opposite of what the method was currently doing. For each conditional statement, we created a test that verified the expected behavior when the condition was met and when it was not. Here‚Äôs an example of how we tested a condition that checked if a project was able to receive entries using FactoryBot: # In the test filedescribe 'Project entries' do it 'should not accept entries when the project is not set to receive entries' do  project = FactoryBot. create(:project, receive_entries: false)  # Assert that the project does not accept entries  expect(project. accept_entries?). to be_falsey end it 'should accept entries when the project is set to receive entries' do  project = FactoryBot. create(:project, receive_entries: true)  # Assert that the project accepts entries  expect(project. accept_entries?). to be_truthy endendBy writing tests for both scenarios (project accepting entries and not accepting entries), we ensured that the refactored method would handle these cases correctly. Once we had a comprehensive test suite in place and all the tests were passing, we started the refactoring process. It‚Äôs important to remember that refactoring aims to modify the internal structure of the code without changing its external behavior. The goal is to improve performance, maintainability, and readability while adhering to the DRY (Don‚Äôt Repeat Yourself) principle. During the refactoring, we focused on breaking down the long method into smaller, more manageable chunks. we extracted common functionality into separate methods and aimed to reduce the complexity of the conditional statements. Here‚Äôs a simplified example of how the refactored method might look: def process_project(project) return if project. discarded? return unless project. on_time? return unless project. accept_entries? # Process the project # . . . endBy separating the conditions into individual guard clauses, the method becomes more readable and easier to understand. Throughout the refactoring process, we continuously ran the tests to ensure that the functionality remained intact and that we didn‚Äôt introduce any unintended changes. Refactoring a long method can be a challenging task, especially for beginners. However, by following a systematic approach of writing comprehensive tests, breaking down the method into smaller parts, and focusing on improving maintainability and readability, you can successfully refactor your code and make it more manageable for future changes. Remember üéóÔ∏è, refactoring is an iterative process, and it‚Äôs okay to take small steps and gradually improve your code over time. By consistently applying good coding practices and seeking feedback from more experienced developers, you can continuously enhance your refactoring skills and write cleaner, more maintainable code.  Breaking down the method into smaller, more manageable pieces.  Applying the DRY (Don‚Äôt Repeat Yourself) principle to eliminate redundancy.  Enhancing performance and maintainability to ensure the code could be easily modified in the future. "
    }, {
    "id": 53,
    "url": "http://localhost:4000/2024/02/14/difference-between-buttonto-linkto-formwith.html",
    "title": "What's the difference behing button_to link_to form_with",
    "body": "2024/02/14 - In this blog post I‚Äôll share my findings when developing a Like model and how I got to find these differences very particular. remote: true "
    }, {
    "id": 54,
    "url": "http://localhost:4000/2024/02/07/follow-as-polymorphic.html",
    "title": "Follow as Polymorphic",
    "body": "2024/02/07 - In this blog post I‚Äôll share my findings when developing a Follow model (User can follow another User, Post, Comapny) with a polymorphic property. With the next models you can create a ‚ÄòFollowing‚Äô feature that can be applied to almost any model you want, just add one line of code. class User &lt; ApplicationRecord # Users that follow this user 'Followers' has_many :followers, class_name: 'Follow', as: :followable # Entities this user follows 'Following' has_many :following, class_name: 'Follow', foreign_key: 'user_id'endclass Follow &lt; ApplicationRecord belongs_to :user # who is making/pushing the button  Follow  (doing the following) belongs_to :followable, polymorphic: true # This validation doesn't allow that user_1 follow user_2 twice validates :user_id, uniqueness: { scope: [:followable_type, :followable_id] }endLet‚Äôs try out the code in rails console rails consoleu1 = User. firstu2 = User. lastfollow = u1. following. create(followable: u2)Follow Create (3. 8ms) INSERT INTO  follows  ( user_id ,  followable_type ,  followable_id ,  created_at ,  updated_at ) VALUES ($1, $2, $3, $4, $5) RETURNING  id  [[ user_id , 1], [ followable_type ,  User ], [ followable_id , 18], [ created_at ,  2024-02-29 05:25:28. 228037 ], [ updated_at ,  2024-02-29 05:25:28. 228037 ]] TRANSACTION (0. 6ms) COMMIT=&gt; #&lt;Follow:0x0000000102d226e0 id: 6, user_id: 1, followable_type:  User , followable_id: 18, created_at: Thu, 29 Feb 2024 05:25:28. 228037000 UTC +00:00, updated_at: Thu, 29 Feb 2024 05:25:28. 228037000 UTC +00:00&gt;Follow. count=&gt; 1u1. following. create(followable: u2)=&gt; TRANSACTION (0. 8ms) ROLLBACK (due to model validation)# class User# def follows?(user)#  following. exists?(followable: user)# endu1. follows? u2=&gt; trueu2. followers=&gt; [#&lt;Follow:0x000000012eb126d0 id: 6, user_id: 1, followable_type:  User , followable_id: 18, created_at: Thu, 29 Feb 2024 05:12:17. 215129000 UTC +00:00, updated_at: Thu, 29 Feb 2024 05:12:17. 215129000 UTC +00:00&gt;]u1. following[#&lt;Follow:0x0000000102b63fc0 id: 6, user_id: 1, followable_type:  User , followable_id: 18, created_at: Thu, 29 Feb 2024 05:12:17. 215129000 UTC +00:00, updated_at: Thu, 29 Feb 2024 05:12:17. 215129000 UTC +00:00&gt;, #&lt;Follow:0x0000000102d226e0 . . . ]And it worked for other models like (Post, Company, etc) class Post &lt; ApplicationRecord has_many :followers, class_name: 'Follow', as: :followableenduser = User. find(user_id)post = Post. find(post_id)user. following. create(followable: post) TRANSACTION (0. 6ms) COMMIT=&gt; #&lt;Follow:0x0000000150038080 id: 8, user_id: 1, followable_type:  Post , followable_id: 92, created_at: Thu, 29 Feb 2024 05:56:29. 921783000 UTC +00:00, updated_at: Thu, 29 Feb 2024 05:56:29. 921783000 UTC +00:00&gt;We‚Äôve explored creating a follower system in Rails, showcasing the flexibility of polymorphic associations and the importance of validations. This guide provides a solid foundation for adding social functionalities to your Rails applications, ensuring a robust and scalable feature set. "
    }, {
    "id": 55,
    "url": "http://localhost:4000/2024/01/28/beginner-guide-docker.html",
    "title": "Beginner guide to Docker üê≥",
    "body": "2024/01/28 - This is a guide to explore what is Docker and also when it‚Äôs useful. "
    }, {
    "id": 56,
    "url": "http://localhost:4000/2024/01/26/action-policy-cache.html",
    "title": "Action policy gem + Cache",
    "body": "2024/01/26 - Recently I worked with an app that was using Action Policy, I noticed that those policies were being called almost everywhere! So I started a small research and found that there was a section for cache authorizations. Let‚Äôs dive in with Redis and how policies are saved in memory. Here are the official (docs)[https://actionpolicy. evilmartians. io/#/caching] for combinig action policy + cache. "
    }, {
    "id": 57,
    "url": "http://localhost:4000/2024/01/22/when-you-see-the-count.html",
    "title": "When you see the `.count` in a Rails view üëÄ",
    "body": "2024/01/22 - I‚Äôve been working on improving the app performance and have learnt about how. count works and how it can slow down the app. As a solution we have counter_cacheprovided by default by rails and also something more advance like counter_culturegem! Let‚Äôs see how it can improve you app as well! "
    }, {
    "id": 58,
    "url": "http://localhost:4000/2024/01/18/the-where-clause.html",
    "title": "Avoiding N+1 Queries üöì",
    "body": "2024/01/18 - When optimizing an app, I recently learned to pay attention to the . where or . find methods inside . each loops because they can be potential candidates for association preloading. The reason is that for each element we iterate over, another operation will be executed, in this case . where or . find, which can lead to an N+1 query problem. Let‚Äôs see how it works. # Controller actiondef index @posts = Post. allend# View template&lt;% @posts. each do |post| %&gt; &lt;h2&gt;&lt;%= post. title %&gt;&lt;/h2&gt; # This will trigger separate query for each post to fetch the author &lt;p&gt;Author: &lt;%= post. author. name %&gt;&lt;/p&gt; # This will trigger separate query for each post to fetch the comments &lt;p&gt;Comments: &lt;%= post. comments. count %&gt;&lt;/p&gt;&lt;% end %&gt;SQL produced: -- 1 for Post. allSELECT  posts . * FROM  posts -- 2 for each post's author and comments count, this can get really worseSELECT  authors . * FROM  authors  WHERE  authors .  id  = ? LIMIT 1 [[ id , 1]]SELECT COUNT(*) FROM  comments  WHERE  comments .  post_id  = ? [[ post_id , 1]]To avoid this we can use . includes # Controller actiondef index # we eagerly load the author and comments for all the posts in a single query @posts = Post. includes(:author, :comments). allend# View template&lt;% @posts. each do |post| %&gt; &lt;h2&gt;&lt;%= post. title %&gt;&lt;/h2&gt; &lt;p&gt;Author: &lt;%= post. author. name %&gt;&lt;/p&gt; &lt;p&gt;Comments: &lt;%= post. comments. count %&gt;&lt;/p&gt;&lt;% end %&gt;SQL produced: -- 1 for Post. includes(:author, :comments), which eagerly loads the associated author and comments-- The number of queries is reduced to 3 (1 for posts, 1 for authors, 1 for comments), regardless of the number of posts. SELECT  posts . * FROM  posts SELECT  authors . * FROM  authors  WHERE  authors .  id  IN (1, 2, 3)SELECT  comments . * FROM  comments  WHERE  comments .  post_id  IN (1, 2, 3)Another alternative is to use . eager_load instead of . includes. The difference is that . includes uses separate queries to load the associations, while . eager_load uses a single query with a LEFT_OUTER_JOIN. Here I have a deeper blog about it! Just wanted to highlight that you must be careful of those where, find and find_by inside of loops! "
    }, {
    "id": 59,
    "url": "http://localhost:4000/2024/01/16/cache-and-redis.html",
    "title": "Key concepts for Redis and cache üíΩ",
    "body": "2024/01/16 - Expire Bust Cache hit Cache miss user. touch Setting up redis in production since developers want a slower app in development rails dev:cache type of redies: volatile (cache data that can be retrieve at some point again) or non-volatile (sidekiq because it cannot be recreated since we loose the jobs that are queued) "
    }, {
    "id": 60,
    "url": "http://localhost:4000/2024/01/14/what-is-cache.html",
    "title": "What is cache? üíµ üí∞",
    "body": "2024/01/14 - Currently, I‚Äôm focusing on enhancing the performance of an application, and one of the key areas I‚Äôve explored in-depth is caching. Although I was aware of caching before, I didn‚Äôt fully grasp its concept or have the opportunity to apply it, so I never felt compelled to delve into it. If you find yourself in a similar position, here are some initial steps to build a strong understanding of caching :) What is cache? The term ‚Äòcache‚Äô is an English word meaning a secure place where items are stored and hidden. Now this concept will make more sense in computing. Cache is a method of storing frequently accessed data in fast memory to keep it closer to the user. This fast memory can be found either on hard drives, processors (like CPUs and GPUs) or web browser, web server, databases, client-side, CDNs and it goes from KBs to MBs and in different layers (L1, L2, etc). In browser for example, the first time you visit a web site it will download the HTML, CSS and images then computer will save a copy of those files. The next time you visit that page, it will retrieve a local copy instead of requesting a web server, which speeds up the process. Think of a coffee shop where the barista keeps commonly used items like milk and sugar at hand, rather than going to the storage room for each order. This is like 'caching', where frequently used data is kept readily accessible. ‚òïÔ∏è Fun fact: The concept of caching was originally proposed in 1965 by Maurice Wilkes. Paper When is it useful? There are 2 main ways so far to implement with Ruby on Rails app.    HTTP Caching - Web browser can cache HTTP responses to enable faster retrieval data. It improves response time and reduce load on back-end. By storing copies of frequently accessed data, caching reduces the need for repeated requests to the server, thereby enhancing overall performance and user experience. (Mostly for Static assets and JSON APIs and AJAX endpoints. )     This involves caching within the application itself and can be tailored to the specific needs of your Rails application. Rails provides several caching techniques like page caching, action caching, and fragment caching.  How to use it in rails? Rails has 3 ways of caching data: page, action and fragment. Each of them has different purposes.    Page caching stores the entire HTML response, serving it directly from the web server without hitting the Rails stack.     Action caching caches the output of controller actions.     Fragment caching is more granular and caches smaller pieces of a view.  Also there are different techniques as well like Russian Doll Caching, Shared partial caching, Low-Level Caching and Key-based cache expiration. Extra tools you need. üõ†Ô∏è Rails caching is designed to be backend agnostic. This means you can implement custom caching solutions or adapters for other storage mechanisms. Redis: Advanced in-memory data store, supports complex structures, ensures data persistence, replication, and integrity. Memcached: Efficient, simple key-value store, ideal for caching static data, quick setup. Memory Store: Caches data in the Rails server‚Äôs memory. This is a good option for single-server setups and development environments. File Store: Caches data as files on the disk. This can be useful in environments where memory is limited. Is it truly beneficial for your App? Currently in the implementation phase, the improvements are evident on the pages where it has been applied. It is advisable to compare response times before and after implementing these changes. If feasible, establish a Maximum Average Response Time (MART) as a benchmark. More when we complete this process! "
    }, {
    "id": 61,
    "url": "http://localhost:4000/2023/12/17/kasper-product-focused-ruby.html",
    "title": "Product Focused Ruby - Kasper Timm Hansen.",
    "body": "2023/12/17 - Sketching and mental model of programming. I recently attended a live session with Kasper Timm Hansen, he unfolded his approach to product-focused development, blending technical prowess with real-world problem solving. 1st session notes: How to start sketching out a new feature development. 1. - Have a problem definition. 2. - In a rails context, start with a controller and start figuring out how to pass stuff to the view (it will give you a lot of constraints already). 3. - Then sketch stuff out like write methods that reflect ‚Äúcomplete‚Äù and ‚Äúuncomplete‚Äù (for a Todo app and task feature), don‚Äôt focus on assigning instance variables, inheritance of the controller (you save this for later). 4. - At this point we have how routes are going to be. What are going to be the ‚Äúresources‚Äù are they going to be nested? We have figured out the organizational stuff around things. So now we know how to put into business logic and complete it. 5. - Take a break from it like an outside view of like, okay, can I name this differently because. So far, it's just more meant to have a direct communication with what I intend to code and my own mental model rather than the code that I'm ending up generating. If the problem definition has a known unknown that would be one thing to start tackling, or it can help reveal unknown unknowns. And and then figure out, if it's something involved with like TCP connections, and we haven't worked with those before. Use method you know how they work to keep sketching things out (inheritance from ApplicationController or RESTful methods). 6. - Delineate between what‚Äôs the feature, and what‚Äôs the architecture? User model would be architecture and User and its Invite (User::Invite) would be the feature. This prorcess should be really flexible, really fluid, like having a conversation and not to be attached to the code you've written. Also play around with `irb`, read the Ruby docs and seek. Making abstractions by finding concepts through ‚Äònaming‚Äô. 1. - Now that you have a sense of the concept and know how things fit together. 2. - You can build solid blocks of knowledge that you can later use. In example, how a AssociationObject works and you find more similar cases in the rest of the app. 2nd session notes (more hands-on): 1. - At the very start of the feature cycle, what you essentially do is a deep dive. You try to keep going for about half an hour, maybe an hour and you‚Äôre just trying to fire off ideas. 2. - Try to take full advantage of the fact that Ruby reads somewhat like pseudocode. It‚Äôs a case of ‚Äòfirst thought, best thought‚Äô, allowing for a more rapid-fire approach. 3. - What you actually want is to quickly formulate a hypothesis. Figure out how to disprove or prove it, at least, and then keep making rapid changes. "
    }, {
    "id": 62,
    "url": "http://localhost:4000/2023/12/14/how-to-explore-a-new-codebase.html",
    "title": "How to quickly deep dive into a new code base.",
    "body": "2023/12/14 -    Utilize the user interface (UI) to create domain model objects (Posts, Books, Reservations, etc), followed by monitoring the server-side Rails logs.     Examine the generated SQL and then directly access the database using either psql or the rails dbconsole.     Read the Models file (book. rb), search for associations, callbacks, scopes.     Lastly look up the most recent record that has been saved or added to the database rails c and play with it.  "
    }, {
    "id": 63,
    "url": "http://localhost:4000/2023/12/12/always-have-a-question-in-mind.html",
    "title": "Always have a question to solve in mind.",
    "body": "2023/12/12 - I recently explored a new code base, which was challenging, but focusing on a specific question helped me to direct my research more effectively‚Ä¶. . "
    }, {
    "id": 64,
    "url": "http://localhost:4000/2023/12/06/n-+-1-queries.html",
    "title": "N + 1 queries and how to fix them.",
    "body": "2023/12/06 - I recently had to deal with a n + 1 query‚Ä¶. Firstly let‚Äôs understand why does this happen? The N+1 query problem is like inviting friends to a party and then calling each one separately to ask if they‚Äôre coming. If you have 10 friends, you make 1 call to decide to invite them and then 10 more calls to each friend. So, for 10 friends, you make 11 calls in total. In databases, this is like fetching a list of items (like blog posts), and then for each item, making another query to fetch related data (like comments on each post). If you have 10 posts and you fetch comments for each one by one, you end up making 1 query to get all posts plus 10 more queries for comments, leading to 11 queries. But why in db happens this?? The First Query (N): When you ask for the list of posts, the ORM makes one query to fetch all posts. This is your ‚ÄúN‚Äù part of the problem, where ‚ÄúN‚Äù is the number of posts. The Plus One (+1) Part: For each post, when you try to access its comments, the ORM realizes it hasn‚Äôt fetched those yet. So, it makes a new query for each post to fetch its comments. If you have 10 posts, this approach results in 10 additional queries - one for each post to get its comments. The ORM‚Äôs default behavior is to load data on demand (lazy loading). It avoids fetching related data until you explicitly access it, which can be efficient in scenarios where the related data is not needed. However, when you do need related data for each item in a list, it leads to multiple queries, creating the N+1 problem. Example: # rails console@events = Event. all Event Load (0. 5ms) SELECT  events . *  FROM  events  /* loading for pp */ LIMIT ? [[ LIMIT , 11]]# Each call to `event. attendees` for an `event` triggers a separate query to fetch the `attendees` for just that `event`. @events. each do |event| puts  Event: #{event. name}  üëâevent. attendees. each do |attendee|  puts   Attendee: #{attendee. name}  endend# Logs:üëâEvent Load (0. 2ms) SELECT  events . * FROM  events  Event: Tech Conference üëâAttendee Load (0. 1ms) SELECT  attendees . * FROM  attendees  INNER JOIN  registrations  ON  attendees .  id  =  registrations .  attendee_id  WHERE  registrations .  event_id  = ? [[ event_id , 1]]  Attendee: Alice  Attendee: Bob  Attendee: Charlie Event: Music Festival üëâAttendee Load (0. 0ms) SELECT  attendees . * FROM  attendees  INNER JOIN  registrations  ON  attendees .  id  =  registrations .  attendee_id  WHERE  registrations .  event_id  = ? [[ event_id , 2]]  Attendee: Bob  Attendee: DanaData to recreate a small excercise: Let‚Äôs create a small app so we can see in detail what is being produced by each active record method. # Create app with name `preload_demo_app`rails new preload_demo_app# Go to `preload_demo_app` dircd preload_demo_appThen let‚Äôs create models and add the associations we need needed. # Create `Event` modelrails generate model Event name:string location:string start_time:datetime# Create `Attendee` modelrails generate model Attendee name:string# Create `Registration` modelrails generate model Registration event:references attendee:referencesActive Record Associations üëá # app/models/event. rbclass Event &lt; ApplicationRecord has_many :registrations has_many :attendees, through: :registrationsend# app/models/attendee. rbclass Attendee &lt; ApplicationRecord has_many :registrations has_many :events, through: :registrationsend# app/models/registration. rbclass Registration &lt; ApplicationRecord belongs_to :event belongs_to :attendeeendOne last step, we need some data to play with: # eventsevent1 = Event. create(name:  Tech Conference , location:  Conference Center , start_time: DateTime. new(2024, 5, 20, 10, 0, 0))event2 = Event. create(name:  Music Festival , location:  Outdoor Park , start_time: DateTime. new(2024, 6, 15, 12, 0, 0))# attendeesattendee1 = Attendee. create(name:  Alice )attendee2 = Attendee. create(name:  Bob )attendee3 = Attendee. create(name:  Charlie )attendee4 = Attendee. create(name:  Dana )# registrations Registration. create(event: event1, attendee: attendee1)Registration. create(event: event1, attendee: attendee2)Registration. create(event: event1, attendee: attendee3)Registration. create(event: event2, attendee: attendee2)Registration. create(event: event2, attendee: attendee4)With this in place we can start playing with the model by opening ‚Äòrails c‚Äô üî∫ Let‚Äôs see includes behavior: # `. includes` is designed to minimize the number of queries and the overall load on the database by preloading associated dataEvent. includes(:attendees) # See the `IN` SQL keyword in the query for both `registrations` and `attendees` # A single SQL query that retrieves both in a single database roundtrip.  Event Load (0. 3ms) SELECT  events . * FROM  events  /* loading for pp */ LIMIT ? [[ LIMIT , 11]]  Registration Load (0. 4ms) SELECT  registrations . * FROM  registrations     WHERE  registrations .  event_id  IN (?, ?) [[ event_id , 1], [ event_id , 2]]  Attendee Load (0. 1ms) SELECT  attendees . * FROM  attendees     WHERE  attendees .  id  IN (?, ?, ?, ?) [[ id , 1], [ id , 2], [ id , 3], [ id , 4]]üî∫ Now preload: Event. preload(:attendees) # See the `IN` SQL keyword as well, here the key difference is how you apply the `. where` Event Load (0. 1ms) SELECT  events . * FROM  events  /* loading for pp */ LIMIT ? [[ LIMIT , 11]] Registration Load (0. 3ms) SELECT  registrations . * FROM  registrations   WHERE  registrations .  event_id  IN (?, ?) [[ event_id , 1], [ event_id , 2]] Attendee Load (0. 1ms) SELECT  attendees . * FROM  attendees   WHERE  attendees .  id  IN (?, ?, ?, ?) [[ id , 1], [ id , 2], [ id , 3], [ id , 4]]üî∫ eager_load: Event. eager_load(:attendees) # See the LEFT OUTER JOIN, it ensures that even `events` without any attendees are included in the result SQL (0. 1ms) SELECT DISTINCT  events .  id  FROM  events   LEFT OUTER JOIN  registrations  ON  registrations .  event_id  =  events .  id   LEFT OUTER JOIN  attendees  ON  attendees .  id  =  registrations .  attendee_id  /* loading for pp */ LIMIT ? [[ LIMIT , 11]] SQL (0. 1ms) SELECT  events .  id  AS t0_r0,  events .  name  AS t0_r1,  events .  location  AS t0_r2,   events .  start_time  AS t0_r3,  events .  created_at  AS t0_r4,  events .  updated_at  AS t0_r5,   attendees .  id  AS t1_r0,  attendees .  name  AS t1_r1,  attendees .  created_at  AS t1_r2,    attendees .  updated_at  AS t1_r3 FROM  events  LEFT OUTER JOIN  registrations    ON  registrations .  event_id  =  events .  id  LEFT OUTER JOIN  attendees    ON  attendees .  id  =  registrations .  attendee_id  WHERE  events .  id    IN (?, ?) /* loading for pp */ [[ id , 1], [ id , 2]]üî∫ What happens with . joins: event = Event. find_by(name:  Tech Conference )Event Load (0. 1ms) SELECT  events . * FROM  events  WHERE  events .  name  = ? LIMIT ? [[ name ,  Tech Conference ], [ LIMIT , 1]]# Usage of `. joins`Attendee. joins(:registrations). where(registrations: {event_id: event. id}) # an `INNER JOIN` is performed between `attendees` and `registrations`.  # It uses the association named `registrations` defined in the `Attendee` model.  Attendee Load (0. 2ms) SELECT  attendees . * FROM  attendees   INNER JOIN  registrations  ON  registrations .  attendee_id  =  attendees .  id   WHERE  registrations .  event_id  = ? /* loading for pp */ LIMIT ? [[ event_id , 1], [ LIMIT , 11]]Event. joins(:registrations). distinct # See the `DISTINCT` in the `SELECT` statement (ensures that events are listed uniquely).  SELECT DISTINCT  events . * FROM  events   INNER JOIN  registrations  ON  registrations .  event_id  =  events .  id  Summary: Hope you get more understanding on this topic! More blog posts here: üëá Bhumi‚Äôs N + 1 blog postarunyadav N + 1Benito Serna N + 1 ebookSo you need a sort at database level or just with ruby is enough? "
    }, {
    "id": 65,
    "url": "http://localhost:4000/2023/12/01/debugging-libraries.html",
    "title": "Debugging libraries for Ruby and Rails",
    "body": "2023/12/01 - Exploring Ruby Debugging Tools Section 1: Pry Pry GitHub Section 2: Pry-Rails Pry-Rails GitHub Difference between ‚Äúpry‚Äù and ‚Äúpry-rails‚Äù Stackoverflow response Section 3: Debug Debug GitHub Section 4: Byebug Byebug GitHub "
    }, {
    "id": 66,
    "url": "http://localhost:4000/2023/11/21/hotwire-codex.html",
    "title": "The Rails and Hotwire Codex üåÄ",
    "body": "2023/11/21 - Notes: Turbo Native is the core of Hotwire‚Äôs native extensions. It orchestrates a native web view through multiple screens within native navigation. This way the app has a native feel, despite all the content being rendered using the same HTML views as the web app. Native navigation: Navigation in a Turbo Native app is completely native. When the user taps a link, a native method is called to handle the visit proposal. If a fully native screen is preferred for a given URL, this method is where that choice can be made. More commonly, we‚Äôll want to visit the destination URL. 1) When a link is tapped, 2) Turbo Native creates a new screen, 3) injects the web view into it, 4) drives the web view to the new location using Turbo, and 5) displays the screen to the user. Authentication: Turbo Native apps use cookie based authentication for requests originating in a web view. If you have purely native screens and need to make HTTP requests from native code, you‚Äôll need to implement a form of token based authentication on the server. Session: A session co-ordinates a single native web view. It‚Äôs responsible for triggering URL visits using Turbo, and for inserting the web view into new screens when displayed to the user, we‚Äôll use a different session for each tab so the navigation in each tab is totally independent. Path Configuration: The path configuration is a JSON file stored in the app bundle. This file specifies a set of rules that match URLs, using regex patterns, to a set of properties. These properties define how a URL should be displayed in the app. If a particular URL has a fully native screen, this is where we tell Turbo Native about that. Feature flags and other settings can also be defined making it simple to turn features on and off remotely. All of this content was taken from book below, they‚Äôre personal notes. I encourage you buy it. Book link is here. "
    }, {
    "id": 67,
    "url": "http://localhost:4000/2023/11/13/conf-7.html",
    "title": "Ruby conf @ San Diego, CA.",
    "body": "2023/11/13 - Blog about this conf is pending. "
    }, {
    "id": 68,
    "url": "http://localhost:4000/2023/11/08/shape-up.html",
    "title": "Shape up üé¢",
    "body": "2023/11/08 - Shaping Up Methodology Notes: These are some insights I‚Äôve gathered from the ‚ÄúShaping Up‚Äù methodology, which is neither Scrum nor dependent on Kanban boards. The Challenge of Building Software: In the realm of software development, there‚Äôs a substantial element of the unknown, given that what we‚Äôre building hasn‚Äôt existed before. Waiting six months to realize we‚Äôre on the wrong path is excessively long, while a two-week span is typically too brief to produce anything substantial. The Solution: Defining Scope and Time: The solution lies in defining smaller projects that are actionable and testable. A period of six weeks is sufficient to both complete and deliver a project and short enough to allow for directional changes should they be necessary. Key Idea #1: Estimate vs. Appetite: Instead of attaching a time estimate to a technical task, we should ask ourselves how much time we actually want to spend on this project. Consider the analogy of setting a budget before choosing a restaurant for dinner; it‚Äôs a strategic approach that takes into account the value, urgency, and business context. We should strive for an agreement between product teams and technical staff to ensure the time is fixed and the scope is adaptable. Key Idea #2: Shaping: ‚ÄúShaping‚Äù considers two major questions about scope: ‚ÄúWhat is included?‚Äù and ‚ÄúWhat is excluded?‚Äù It also addresses the detail required upfront versus what can be delegated to the team to resolve later. ‚ÄúLatitude‚Äù refers to the level of freedom or specificity given to the team. A key part of shaping is the willingness to abandon features that are either technically impractical or not critical to the user interface. Key Idea #3: Autonomy: Teams, consisting of two to three members, collaborate within a six-week cycle to deliver the complete project, not merely pieces of it. These teams maintain their focus without being burdened by unrelated tasks and are self-managed, operating at their own pace. Work is distinguished as either planned (strategic) or unplanned (reactive). Further Learning:  Shaping in a Nutshell Applying Shape Up in the Real World - Rails World 2023"
    }, {
    "id": 69,
    "url": "http://localhost:4000/2023/11/07/decompose-for-method-call.html",
    "title": "Decompose for method calls",
    "body": "2023/11/07 - In Ruby, it is possible to decompose the elements of arrays/hashes into distinct variables. Since values appear within arrays in a index order, they are unpacked into variables in the same order. # Decompose of an array&gt;&gt; fruits = [ apple ,  banana ,  cherry ]&gt;&gt; x, y, z = fruits&gt;&gt; x=&gt;  apple In this case we are going to use decompose for a method call, (with arrays only one splat needed *). def send_welcome_email(name, email, signup_date) puts  Sending welcome email to: #{name}  puts  Email: #{email}  puts  Signed up on: #{signup_date} end# Array of user informationuser_data = ['Jane Doe', 'jane. doe@example. com', '2023-04-01']# Using splat to pass an array of elementssend_welcome_email(*user_data) üëà# This code will output:Sending welcome email to: Jane DoeEmail: jane. doe@example. comSigned up on: 2023-04-01Now we are going to decompose for a hash, (two splats needed **). def configure_user(profile:, preferences:, settings:) puts  Configuring user profile:  puts  Profile: #{profile}  puts  Preferences: #{preferences}  puts  Settings: #{settings} end# Hash of user configurationuser_configuration = { profile: { username: 'johndoe', language: 'EN' }, preferences: { theme: 'dark', notifications: true }, settings: { privacy: 'high', location: 'off' }}# Using 2 splats to pass a hashconfigure_user(**user_configuration) üëà# This code will output:Configuring user profile:Profile: {:username=&gt; johndoe , :language=&gt; EN }Preferences: {:theme=&gt; dark , :notifications=&gt;true}Settings: {:privacy=&gt; high , :location=&gt; off }"
    }, {
    "id": 70,
    "url": "http://localhost:4000/2023/11/02/positional-vs-keyword-params.html",
    "title": "Positional vs Keyword arguments",
    "body": "2023/11/02 - When I began programming, I was puzzled by why some parameters were named and others not. Seeing *argument_name or **argument_name threw me for a loop. üò≥ Here you‚Äôll find the definitive guide to understand both! Positional arguments: # This method takes any number of user names as positional arguments. üôãüôã‚Äç‚ôÄÔ∏èdef greet_users(*users) users. each { |user| puts  Hello, #{user}!  }end# Passing individual user names to the method, which are packed into an array. greet_users( Alice ,  Bob ,  Carlos )# Outputs:# Hello, Alice!# Hello, Bob!# Hello, Carlos!# This method can take a variable number of fruit names. üçéüçådef list_fruits(*fruits) fruits. join(', ')end# Passing a list of fruits to the method. puts list_fruits( Apple ,  Banana ,  Cherry )# Outputs: Apple, Banana, CherryKeyword arguments: # Usage of ** for keyword arguments: üôãüôã‚Äç‚ôÄÔ∏èdef greet_users(**users) users. each do |identifier, user_info|  puts  Hello, #{user_info[:name]}!  endend# Passing user details as keyword arguments. # The keys `:user1`, `:user2`, and `:user3` are identifiers for each user's hash. greet_users( user1: { name:  Alice , age: 30 }, user2: { name:  Bob , age: 22 }, user3: { name:  Carlos , age: 25 })# Outputs:# Hello, Alice!# Hello, Bob!# Hello, Carlos!# This method takes a variable number of fruit names with details. üçéüçådef list_fruits(**fruits_with_details) fruits_with_details. map { |fruit, color|  #{fruit}: #{color}  }. join(', ')end# Passing a hash of fruits with details to the method. puts list_fruits(Apple:  Green , Banana:  Yellow , Cherry:  Red )# Outputs: Apple: Green, Banana: Yellow, Cherry: Red# More real example of user attributes as keyword arguments. üôãüôã‚Äç‚ôÄÔ∏èdef create_user_profile(**attributes) puts  Creating a profile for: #{attributes[:name]}  puts  Email: #{attributes[:email]}  if attributes[:email] puts  Signup Date: #{attributes[:signup_date]}  if attributes[:signup_date]end# Passing attributes as a hash, packed with a double splat. create_user_profile(name:  Jane Doe , email:  jane. doe@example. com , signup_date:  2023-04-01 )# Outputs:# Creating a profile for: Jane Doe# Email: jane. doe@example. com# Signup Date: 2023-04-01Passing objects üôãüôã‚Äç‚ôÄÔ∏è: class User attr_reader :name def initialize(name)  @name = name endend# Create an array of User instancesusers = [ User. new( Alice ), User. new( Bob ), User. new( Carlos )]# Define the greet_users method to accept multiple user objectsdef greet_users(*users) users. each { |user| puts  Hello, #{user. name}!  }end# Call greet_users with the array of User instancesgreet_users(*users)# Outputs:# Hello, Alice!# Hello, Bob!# Hello, CarlosIf you already have a hash with the appropriate keys, you can pass it to the method using the double splat operator **, which will convert the hash into keyword arguments. Docs for reference: *positional_argument **keyword_argument "
    }, {
    "id": 71,
    "url": "http://localhost:4000/2023/10/26/lastest-tips-and-tricks.html",
    "title": "Latest tips & tricks | Ruby & Rails",
    "body": "2023/10/26 - First filter then map: When you first filter a collection, you‚Äôre reducing its size by selecting only the elements that meet a certain condition. This step inherently decreases the number of items that will subsequently be processed by the map operation. Imagine you have an array of user records, and you‚Äôre only interested in processing active users with an age above 18, where the processing involves a complex calculation. users = User. allactive_adult_users = users. filter { |user| user. active? &amp;&amp; user. age &gt; 18 }processed_users = active_adult_users. map { |user| complex_calculation(user) }In this case, filtering out inactive users or those under 18 before applying the complex calculation minimizes the number of calculations, thus improving the performance. If you were to map first and then filter, every element in the collection, this means potentially performing a lot of unnecessary work. Remember: . select, . filter and find_all are Enumerable methods that do the same thing! Similar methods are . collect and . map! filter_map vs filter + map: The filter_map method iterates over an enumerable, applying a block to each element. This approach eliminates the need to iterate over a collection twice (once for filtering and once for mapping). Performance Benefits filter_map is more efficient than using filter and map separately because:  It reduces the number of iterations over the collection to just one.  It avoids creating an intermediate array that would result from the first operation (filter or map) before passing it to the second operation. fruits = ['apple', 'pear', 'banana', 'cherry', nil, 'fig', 'grape']uppercase_fruits = fruits. filter_map { |fruit| fruit. upcase if fruit&amp;. length &gt; 4 }puts uppercase_fruits # Output: [ APPLE ,  BANANA ,  CHERRY ,  GRAPE ]With both methods separate filter + map fruits = ['apple', 'pear', 'banana', 'cherry', nil, 'fig', 'grape']# First, filter out the fruits with more than 4 letters, excluding nil valuesfiltered_fruits = fruits. filter { |fruit| fruit&amp;. length &gt; 4 }# Then, map the filtered fruits to uppercaseuppercase_fruits = filtered_fruits. map(&amp;:upcase)puts uppercase_fruits # Output: [ APPLE ,  BANANA ,  CHERRY ,  GRAPE ]find_each vs all + each: When dealing with ActiveRecord objects, understanding the difference between find_each and using all followed by each is crucial for optimizing database interactions and memory usage. Using all followed by each is a straightforward way to iterate over a collection of records from the database. all retrieves all the records and loads them into memory, and each then iterates over these records one by one. Student. all. each do |student| puts student. nameendThings to consider:  Memory Usage: If the students table contains a large number of records, loading all of them with all can consume a significant amount of memory,find_each find_each is specifically designed to manage memory consumption and efficiency when processing large numbers of records. Instead of loading all records into memory at once, find_each retrieves and loads records in batches, processing each batch before moving on to the next. By default, the batch size is 1000 records, but you can specify a different batch size if needed. # Students records are proccesed in batches of 100, significantly reducing memory usage. Student. find_each(batch_size: 100) do |student| puts student. name endfind_each has different options to apply more details. Student. find_each(batch_size: 200, start: 1000, finish: 5000, order: :desc, error_on_ignore: true) do |student| # Your processing logic hereend. count vs . length vs . size: count directly translates to a SELECT COUNT(*) SQL query against the database. It asks the database to count the number of entries that match the query and does not load the objects into memory. This makes it very efficient for large datasets. Every time you call count, it performs a database query, which could be a downside if called repeatedly without a need for real-time accuracy. It will make an SQL COUNT regardless of the state of the collection in memory. (See this article to know how to tackle count efficiently) book = Book. first# Book Load . . . book. comments. load# Comment Load (0. 3ms) SELECT  comments . * FROM  comments  WHERE  comments .  book_id  = $1 [[ book_id , 1]]book. comments. count# Comment Count (0. 5ms) SELECT COUNT(*) FROM  comments  WHERE  comments .  book_id  = $1 [[ book_id , 1]]length loads the entire collection of objects into memory and then counts the number of elements. This can be memory-intensive for large datasets because it initializes all the objects. It does not trigger an extra database query if the collection is already loaded. ActiveRecord loads the comments from the database (if they haven‚Äôt been loaded already) to count them. The count is done by Ruby in memory after loading the records. blogpost = BlogPost. first# BlogPost Load . . . blogpost. comments. to_a # Comment Load (0. 2ms) SELECT  comments . * FROM  comments  WHERE  comments .  blog_post_id  = $1 [[ blog_post_id , 1]] [[ blog_post_id , 1]]blogpost. comments. length# (no additional database query is executed, comments are already loaded into memory. )size combines the behaviors of both count and length. If the collection has already been loaded, size will calculate the number of elements in-memory, avoiding a database query. If the collection has not been loaded, it will perform a SELECT COUNT(*) query, similar to count. When a counter cache is implemented, . size uses the cached value for the count, eliminating the need for database queries to count the records. With data loaded: # `size` if loaded, calculates the length with Rubyblogpost = BlogPost. first# BlogPost Load . . . blogpost. comments. load# Comment Load (0. 5ms) SELECT  comments . * FROM  comments  WHERE  comments .  blog_post_id  = $1 [[ blog_post_id , 1]]puts blogpost. comments. size# (no db hit) - Uses Ruby to calculate the size from the loaded collectionWithout data loaded: # `size` if not loaded, performs an SQL COUNT queryblogpost = BlogPost. first# BlogPost Load . . . puts blogpost. comments. size# Comment Count (0. 4ms) SELECT COUNT(*) FROM  comments  WHERE  comments .  blog_post_id  = $1 [[ blog_post_id , 1]]With counter cache: # Scenario 6: `size` if there is a counter cache, uses the cached countblogpost = BlogPost. first# BlogPost Load . . . puts blogpost. likes. size# (no db hit) - Uses counter cacheputs blogpost. likes. size# (no db hit) - Uses counter cache again without additional queriesorder vs sort_by: order method is used with ActiveRecord relations to specify the order of records returned by a query. It translates directly into an SQL ORDER BY clause, meaning the sorting is done by the database before the records are returned to your Rails application. Since order operates at the database level, it is generally more efficient for large datasets. Databases are optimized for sorting operations, especially when working with indexes. Book. order(publication_year: :desc)When you use sort_by (Ruby Enumerable), the entire collection needs to be loaded into memory first. Only then does sort_by reorder the collection based on the specified attributes or criteria. Use sort_by for smaller datasets or when you need to sort based on computed values. Here, the trick is to work on a ActiveRecord relation otherwhise Rails loads the entire collection into memory. This is because . sort_by is an Enumerable method that operates on arrays, not on database queries. So, the first step is converting the ActiveRecord relation into an array of model instances and after loading, . sort_by then iterates over the in-memory array: posts = Post. where(published: true)# This line implicitly loads all published posts into memory and then sorts them by titlesorted_posts = posts. sort_by(&amp;:title)This is just an advice I got and wanted to keep it here.  Try to make the calculations and queries even if they become big in controllers or models and in view just sort them in memory.  Better to ship the wrong thing today than the right thing in 2 weeks! Because then you can get feedback and learn 14 things in 2 weeks instead of 1 thing. And you are as useful as the code you ship. So try to ship every day, multiple times if possible :smile: @books. shuffle (in-memory): The . shuffle method is a Ruby Array method that randomly reorders the elements of the array. It operates in memory, meaning the entire array needs to be loaded. Ideal for situations where you have a relatively small dataset already loaded. Ruby API. @books. order(‚Äòrandom()‚Äô) (in db): random() operation is performed by the database engine, which means it does not require loading all the data into your application‚Äôs memory to shuffle it. More details. any? =&gt; exist? vs present? =&gt; in memory: "
    }, {
    "id": 72,
    "url": "http://localhost:4000/2023/10/09/financial-wisdom-over-forks.html",
    "title": "Financial Wisdom Over Forks.",
    "body": "2023/10/09 - A Dinner Chat with 2 experienced developers. Recently, I had the opportunity to have dinner and engage in conversation with Chris O. and Harry L. at Rails World. Eager to delve into the nitty-gritty of consulting, I was particularly interested in uncovering the secrets of how to increase chances of success in this field. Among the insights shared by DHH was ‚ÄúThe One-Person Framework‚Äù which enables one to achieve remarkable productivity with Rails. This framework allows for a comprehensive understanding of everything from backend to frontend to deployment, all while Rails navigates through the complexities aiming for simplicity. Inspired by DHH‚Äôs insights, I‚Äôm keen on taking advantage of ‚ÄúThe One-Person Framework‚Äù to enhance my consulting practice. The discussion unfolded as follows: Accounting:    Always set aside 30% of each income you receive from consulting to cushion yourself when it‚Äôs time to pay taxes. 30 is a good figure; it‚Äôs enough.     Hire an accountant; don‚Äôt do it yourself, as it can become difficult.  Accounts:    The money that a business generates is one thing, and it must be in an exclusive account. Separate it from everything else (LLC or whatever structure).     Create a personal account for personal expenses, and avoid mixing expenses. It might seem easy initially, but it can become difficult to handle.  Sales:    Get with your referals, friends, uncles, cousins, people you were in school with and offer your services, it‚Äôd more easy if they own a company or have a decision makier position.     When it comes to consulting, once you finish a project and haven‚Äôt worked on securing another project, it‚Äôs very likely that you‚Äôll end up doing nothing.     Therefore, in the hypothetical case that you finish ‚ÄúProject A‚Äù in December, dedicate 80% of your time to the project to get it done, and 20% on sales activities (attending meetups, calls, creating content, follow-ups).     Then, as you get closer to finishing the project, switch to spending 80% of your time on selling and 20% on the project so that when you finish ‚ÄúProject A‚Äù in December, you have ‚ÄúProject B‚Äù waiting in January.  Always Work with Contracts:  Include a clause specifying that if the client tells you not to finish, he has to pay you at the point or progress where you leave the projectWork on Building Trust with Clients:    When you develop for a customer, aim to either cut their costs or increase their revenue/productivity or help them have more control over their business therefore you‚Äôll gain their trust.      Cut their costs: ‚ÄúOptimize processes to save your customer money. ‚Äù   Increase their revenue or productivity: ‚ÄúEnhance features to boost customer revenue and efficiency. ‚Äù   Help them have more control: ‚ÄúEmpower customers with tools for informed business decisions. ‚Äù      Earned trust will increase eventually like compound interest over the years, as they will share with others how you helped them and how efficient you are.  Where to Find Potential Customers:    One approach is to get in touch with local marketing agencies and offer to outsource their work to you, whether it‚Äôs web apps or web pages. This is beneficial as it‚Äôs easier to secure payments from organizations than individuals, and it also enhances your portfolio and reputation.     For the point above üëÜ, show up! Don‚Äôt just email them; meet them in person, attend meetups, even those not related to tech.     Another approach is to reconnect with previous customers and inquire if there‚Äôs another department you can assist; this should happen naturally if you‚Äôve had a good working relationship.  Don‚Äôt Convince Customers to Have a Rails App When They Don‚Äôt Really Need It (Avoid This üö´):    One individual secured a contract where the customer apparently needed a WordPress management system, but he kept pushing for a Rails application.     Somehow, the customer paid him in advance, and after a few months, rejected the project and asked for a refund. By then, he had already spent the money without setting aside funds for taxes, and found himself having to answer to both the customer and the tax authorities.  "
    }, {
    "id": 73,
    "url": "http://localhost:4000/2023/10/05/conf-6.html",
    "title": "Rails World @ Amsterdam, NL.",
    "body": "2023/10/05 - Blog about this conf is pending. "
    }, {
    "id": 74,
    "url": "http://localhost:4000/2023/09/30/how-to-crack-you-next-code-challenges.html",
    "title": "How to crack your next code challenge üßÆ",
    "body": "2023/09/30 - Notes that will help you understand and then solve a code challenge interview. "
    }, {
    "id": 75,
    "url": "http://localhost:4000/2023/09/22/apprenticeship-patterns.html",
    "title": "Apprenticeship Patterns üåå",
    "body": "2023/09/22 - "
    }, {
    "id": 76,
    "url": "http://localhost:4000/2023/09/15/conf-5.html",
    "title": "Rails Camp @ Honolulu, HI.",
    "body": "2023/09/15 - Blog about this conf is pending. "
    }, {
    "id": 77,
    "url": "http://localhost:4000/2023/09/10/search-bar-rails.html",
    "title": "Search bar in Rails üîç",
    "body": "2023/09/10 - Notes from building a Search bar. Justin Weiss search bar using scopes. Search bar using turbo frames. Search bar Test double. "
    }, {
    "id": 78,
    "url": "http://localhost:4000/2023/08/20/chartkick-gem.html",
    "title": "Chartkick gem vs chart.js",
    "body": "2023/08/20 - Notes from chartkick gem implementation "
    }, {
    "id": 79,
    "url": "http://localhost:4000/2023/08/01/llm-langchain-rb.html",
    "title": "LLM Langchain.rb ü¶ú | Andrei Bondarev",
    "body": "2023/08/01 - While I was in New York I had the opportunity to attend a nyc. rb webinar where the main subject to discuss was going to be LLMs and what is the Ruby community doing about, Andrei Bondarev was the speaker. I know it was a webinar you can attend it wherever you are! However I found it because I was looking for a monthly meeting in NY, also I found that NYC on rails is about to start, so folks from NY please support Avi in this journey üôè. Tweet where Avi anounces that he is going to take up rails monthly meeting (they were held off since 2016). OK moving on from ads, here I‚Äôll share with you the resources that I have gone over the last week so I got my feet wet with this new topic called LLMs (Large Language Models). What is LLMs? It‚Äôs a subset of Deep Learning as well as Generative AI, both belong to AI. Google video that explains it very neat What is langchain then? ü¶ú How LLMs work? Why are they useful? Use cases? Andrei NYC. rb slides Main Langchain ruby repo Chatbot Proof of Concept: Multi-Agent Chatbot developed by Flexport member (Ben Zhang) Courses: LangChain for LLM Application Development from Deep Learning AI "
    }, {
    "id": 80,
    "url": "http://localhost:4000/2023/07/27/conf-4.html",
    "title": "Ruby For Good @ Washington, DC.",
    "body": "2023/07/27 - Blog about this conf is pending. "
    }, {
    "id": 81,
    "url": "http://localhost:4000/2023/07/24/NYU-startup-summer.html",
    "title": "NYU Startup Summer program",
    "body": "2023/07/24 - Notes from NYU clases "
    }, {
    "id": 82,
    "url": "http://localhost:4000/2023/06/14/how_i_learned_rspec.html",
    "title": "How I learned rpsec",
    "body": "2023/06/14 - Rspec learning resources I believe that the best way to get a grasp of testing in general and rspec is to start from scratch a project and start writing down each test, that way you‚Äôll be able to see what happens if you forget to close either a context block or an it block or even more intricate subjects like what‚Äôs the difference between describe and context. While developing a freelance project I wanted to add testing as a way to push myself to learn more about testing and also give rspec a try and by doing it I learned how to use gems like: faker, shoulda-matchers, factory_bot and finally rspec. üé≤ You‚Äôll additionally acquire: ‚Äì how to read the output of the test suite in the console. ‚Äì difference between create and build more details. ; # build doesn't persist user = build(:user, name:  John )expect(user. name). to eq( John )# create does persist user = create(:user, name:  Jane )expect(user. persisted?). to be true‚Äì How to include Devise‚Äôs test helpers class PostsControllerTest &lt; ActionController::TestCase config. include Devise::Test::ControllerHelpers, type: :requestsendblog; ‚Äì difference between fixtures and factories; ‚Äì and finally learn how to integrate FactoryBot with RSpec link. class Test::Unit::TestCase include FactoryBot::Syntax::MethodsendHere are also another resources that I followed in order to cement more my knowledge.    2 hours long video from Type Fast a Youtube channel that makes rails tutorials. The video is very thorough. Covers model, requests, background job testing and system tests. Fairly comprehensive starter guide to RSpec     1 hour long rspec tutorial from Type Fast was well (it‚Äôs more on the setup for an app) testing setup with rspec     How to test models CJ Avila     How to use factory_bot Deanin, short tutorial     Full marathon of rspec tutorial (reading not video) from syntax, how to test a model and installing rspec Remi rspec tutorials     The Complete Guide to Rails Testing by Jason Swett link  Learn by doing is the best way to learn rspec DSL, development stack, learn what to test and why it‚Äôs important to test and avoid technical debt. So give it a try, it wont be difficult after all. Lately, I have completed a few books on testing, inclding Professional Rails Testing by Jason Swett, Hands-On Test Driven Development by Greg Donald, Effective Testing with RSpec by Myron Marston and Ian Dees and even attended a testing workshop by Lucian Ghinda. "
    }, {
    "id": 83,
    "url": "http://localhost:4000/2023/06/05/conf-3.html",
    "title": "Blue Ridge Ruby @ Asheville, NC.",
    "body": "2023/06/05 - Blog about this conf is pending. "
    }, {
    "id": 84,
    "url": "http://localhost:4000/2023/04/24/conf-2.html",
    "title": "Rails Conf @ Atlanta, GA.",
    "body": "2023/04/24 - Blog about this conf is pending. "
    }, {
    "id": 85,
    "url": "http://localhost:4000/2022/10/04/conf-1.html",
    "title": "Rails Saas @ Los Angeles, CA.",
    "body": "2022/10/04 - Blog about this conf is pending. "
    }, {
    "id": 86,
    "url": "http://localhost:4000/2022/03/26/practicing_rails.html",
    "title": "Practicing Rails | Justin Weiss",
    "body": "2022/03/26 - Introduction It is possible to learn Rails without having the things you learn abandon you as soon as you try to grab ahold of them. That‚Äôs what this book is about. It‚Äôs a second book of Rails. A companion. It‚Äôll show you how to learn the most in the least amount of time, using the resources and knowledge you already have. And in the process, I‚Äôll guide you through some of the toughest lessons I‚Äôve learned during my programming and Rails career. Embrace struggle, failure, and reward. Learning to become a great Rails developer is hard work. And, being hard work, the only way to learn is to struggle. I‚Äôve heard programming described as ‚ÄúRunning into a brick wall, constantly. ‚Äù So don‚Äôt worry if you feel that way ‚Äì we all do. Learning isn‚Äôt just about reading. It‚Äôs also about action. And that is why you can‚Äôt learn Rails without practicing Rails. Chapter 1 Tiny Apps: The best way to study new Rails ideas The best way to learn new Rails ideas and techniques is to use them. Right away. Practice them, internalize them, and make those techniques yours. When you‚Äôre working with such small apps, you focus on the single thing you want to learn. That way, you don‚Äôt have to worry about learning that new idea inside your existing, more complicated apps. For example, if you‚Äôre trying to learn ActiveModel::Serializers, and your controller isn‚Äôt serializing the model correctly, you can never be sure if the problem‚Äôs a gap in your knowledge, a problem with Rails, or a problem with your app. If you tried this out in a tiny test app, you could be pretty sure the problem was just a simple mistake or a misunderstanding. You can catch these mistakes on a small scale before you fight the bugs that appear when you use them into a larger app. I care about getting the most knowledge in the least amount of time, and scaffolds and other Rails code generators are a great way to do just that. Using the console and Tests for learning. The console is great for messing with objects, but getting those objects set up can be hard. Tests are great for getting objects set up, but hard for messing with them. Most Rails books and videos are good at showing you what‚Äôs possible. But they can‚Äôt explain everything. Those gaps will raise questions, and you‚Äôll naturally want to have those questions answered. ‚ÄúWhy does it work that way?‚Äù ‚ÄúHow could this possibly work?‚Äù ‚ÄúWhat if I tried using it with this other idea I just learned about?‚Äù So, when I say ‚Äúplay with and modify the things you learn‚Äù, I mean ‚ÄúAnswer the questions you have about the things you learn, using code. ‚Äù Chapter 2 How to build your own Rails app This feeling is totally normal. Whenever I‚Äôm about to start a new Rails app, I still feel like I want to give up computers forever and run into the woods or something. But I have a process to share with you that will help you get past this, so you can turn your ideas into real, working apps. When you face a large, fuzzy, overwhelming task like this, the answer is always the same: Break it apart! Break your big idea into small tasks that lead you to where you want to be. You‚Äôll have a path you can take that, no matter what, will get you closer to finishing your app. How do you choose the first thing to work on? When you start a new project, try this short process to help decide which thing to work on first: Take a few minutes and think what you‚Äôre trying to build. Write down every feature that comes to mind. Think of the different paths a user could take through your application, the different things they could do. Describe each one in a single sentence. Then, focus on just the paths where, if you didn‚Äôt have them, your app couldn‚Äôt exist. Core paths. Core paths are the things you‚Äôd talk about if someone asked you to describe your app in 30 seconds. Which part of the feature should you start with? Once you‚Äôre ready to build your first core path, you might feel like writing models for all the objects you have in mind. Maybe you want to create migrations, add attributes, and connect everything together. But soon, you‚Äôll have a ton of pieces that may not all fit. It‚Äôll take a long time before you can actually use your app. And if you didn‚Äôt design your models well, you‚Äôll just have to do that work over again when you build your UI and actually start playing with your app. So, start with UI, and infer your data model from what you see in the UI. When you begin work on a single, small feature, start with the UI:    Take the small feature, or core path, from earlier.     Think of one simple thing someone could do with that feature.     Draw just enough screens for that user to be able to do that thing.     Describe the path through that action, as if you were telling someone what you were going to do.     As you describe that path, write out the objects, properties of those objects, and other actions you think you need to develop that path.  "
    }, {
    "id": 87,
    "url": "http://localhost:4000/2022/03/04/testing_waterloo.html",
    "title": "Rails Testing | University of Waterloo",
    "body": "2022/03/04 - This is a series of lectures about rails testing -Databases &amp; Software Engineering course. How to test? Mike Cohn in his book Succeeding with agile. You should spend most of your time in Unit. End to end is manual and it means a person goes through all the user flow to reach a user acceptance criteria, click buttons, links, add stuff to the shopping cart, make a payment. This can be Manual test, actually using the interface, this is what the customer will see/use. Template:Given: that I‚Äôm a logged in user in ‚Äúhome page‚ÄùWhen: when I click on ‚Äúlog out‚ÄùThen: I‚Äôm logged out Only the basics here, for example: I can create an account but don‚Äôt extensively, send an email, one happy path and one sad path. In Rails End to end tests are called system tests Integration, tests multiple components but exclude user interface. In Rails it tests the controller. what does it respond? what does it send? POST to this path with this params (we can see if a form is going to the right path) Unit, it isolates one single object or method from the rest of the system and test it by itself. This help us see where the problem is. Models, and classes we create, First I need to make sure my individual pieces work, then i put them together and see if that larger system works and eventually we‚Äôre going to check out and test the whole entire system. Testing Pyramid and Rails Video Lecture MSCI 245 : Testing Is my app free of bugs?Does the program work as specified? Write a specification or a test that specifies expected behavior. Test case: average_rating Arrange - what is the input?Act - run the programAssert - check the output against the expected output Then we need 2 cases:  For a Book with 1 or more rating, it should return the average of that book‚Äôs ratings     known gotchas: integers vs float division, off by one (when you skip 1st element of the loop).     For a Book with 0 rating, it should return nilThis is the arrangeBob rated 5Sue rated -2Ali rated 4total 7 Run the program total 7 / 3 = 2. 333 Asserttotal vs expected_value https://www. youtube. com/watch?v=2yYSR6ftxUo Testing fundamentals - equivalence classes You cannot test all inputs. You need to carefully pick inputs to find your mistakes. ‚Äú‚Ä¶ testing can be used very effectively to show the presence of bugs, but never to show their absence‚Äù E. W. Dijkstra if 2 inputs produce the same output, they are said to be member of the same equivalence class. if the net method is tested correctly, the behavior of the method should be the same, there are only 2 inputs that we must use: [1, 2, 3] and [0, -12] def absolute_value(x)	if x &lt;= 0		return -1 * x	else		return x	endendInterior &amp; boundary values. Values that sit on either side of a division between equivalence classes are boundary valuer -&gt; where bugs hide. Other values are the interior values. [minimum. . . -1]|[0 . . . maximum] the boundary is between -1 and 0Test cases: (try to put all below in just one test) Equivalence test case min(a, b) Test:  a == b a &lt; b a &gt; bhttps://www. youtube. com/watch?v=-1kCdERz1sMBase, Edge, and Corner Cases; Happy and Sad Paths Base case - normal expected inputsEdge case - inputs approach limits or outside limitsCorner case - crazy values, should never see in real world Example: user interface - e commerce - shopping cart Base -&gt; user adds a few itemsEdge -&gt; user surprises us with a large order 100-1000 thingsCorner -&gt; whole store in cart (we don‚Äôt want the whole site to fail, we should put a limit) We can think of a form for creating a user name, nick names, emails, domains, capitalization Success &amp; failure (code should handle both) Test both good input (success). Test bad inputs (failure) to test proper error handling. Black box, you test the software and don‚Äôt get a look at the code, you cannot call the code White box, you test the software and get a look at the code to see what is happening https://www. youtube. com/watch?v=NoP3am8ipYw Hunting for bugs Logic errors  boundaries common inputs to test     some minimum   zero   one                         empty - zero       length       list       empty                     negative numbers   first/last element of an array   Most common working with arrays or any sort of list:  skip first/last element don‚Äôt process last elementNumerical erros  accidental truncation of floating point to integer divide by zero (think of a way how a user can input a 0 as denominator and catch the error) bad floating behavior (try to add a lot of small numbers to a larger numbers) assume the sum of the computer is correct sqrt(2) != ‚àö2Integrating boundaries  one system talking to another misunderstandings about proper inputs/outputsOther  null values -nil handling of exceptions loss of networks/disk/power?https://www. youtube. com/watch?v=crFl2K1bOhI MSCI 245 : A quick intro to Minitest and automated testing  testing framework enabled by default in Rails automated testing at 3 levels     Unit (individual methods or objects, this part works correctly)   Controller (integration) (we reproduce a browser with http verbs POST, GET)   System - end to end (E2E) user interface (manual, buttons)   To do unit testing we make a class that inherits from ActiveSupport::TestCase. We make one test case for every class we want to unit test. test/models/book_test. rbArrangeActAssertrequire 'test_helper' # brings test/test_helper. rbclass BookTest &lt; ActiveSupport::TestCase	# (always start with  test_ )	# The DB within test is empty	def test_average_rating_multiple_ratings		# you have to build up the case in the database		card = Author. create!(name:  Orson Scott Card ) arrange		ender_game = Book. create!(title:  Ender's Game , year:  1985 , author: card arrange		. . . 		. . . add ratings/ users				assert_in_delta(2. 333, ender_game. average_rating, 0. 001,  should return 2. 333 for Ender's Game )	end	def test_average_rating_no_ratings		christie = Author. create!(name:  Agatha Christie )		fire_pigs = Book. create!(title:  Fire Pigs , year:  1942 , author: christie)				# first the expected, then the actual		assert_nil(fire_pigs. average_nil,  this should be nil )	endThings to note:  File that start with ‚Äútest_‚Äù are run with ‚Äúrails test‚Äù You can create other methods You have access to all Rails You can use debugger Each test should be independent of other tests You can define a setup method in the beginning and call it before every method, (to create data)https://www. youtube. com/watch?v=JYbHurKGzM0 Testing - Test Cases - Minitest - Capybara Arrange - setup the input codeAct - execute the code w/ inputAssert - check the result against our expected output Example: we are testing addition, the input is 1 and 2, the expected result is 3. E2E or systems tests: Arrange  - sometimes could be add items to DBAct - visit the home page, click a link to create accountAssert - did i end up in the home page? seeds. rb is not for tests, is for using the app, like: admin. FIRST properties of good tests Fast - run fastI - independent | isolated, a test should not depend on another test that has run before it; what went wrong and where (try one idea per test)R - repeatable, every time you run a test it behaves the sameS - self validating, tests reports pass or fail by automatic T - timely | thorough, write the test when your write the code; coverage Test Frameworks - Minitest (will help us write FIRST tests)  resetting the Rails app and DB after each test (repeatable, independent) run tests in randomly order (independent) provide assert statements &amp; reports of pass and fail (self validating)Fast is mainly a property of this type of test, low overhead (faster than Rspec)Timely &amp; Through this is about developer behavior and skills Basics of Minitest  You write classes that inherit from Minitest.  Each method of the class that star with ‚Äútest_‚Äù is run as independent test .  You can write a ‚Äúsetup‚Äù method, it will run before every test within that class (for creating user for instance).  Rails and Minitest restore state after each test, includes the DB.  Everything in Minitest in plain Ruby (only new methods like assert) (not like Rspec or cucumber).  Your class can have non-test methods.  You have access to all Rails, models methods and so on.  Separate test DB to avoid contamination.  There are a lots of ways to assert. assert(test = must be a boolean, message to display) - &gt; assert(expected == results) assert_equal(expected, actual) assert_nil(nil) flunk (msg) make the test fail in purpose skip (msg)       Capybara   url = root_pathvisit url ‚Äî‚Äîassert_current_path url‚Äî‚Äìclick_link(‚Äòid-of-link‚Äô) # id‚Äôs from HTMLclick_link(‚ÄòBooks‚Äô)click_button(‚ÄòSubmit‚Äô) # it‚Äôs better to click on idfill_in(‚ÄòName‚Äô, with: ‚ÄòBob‚Äô)‚Äî‚Äî-assert page. has_content?(‚ÄòSorry Invalid. ‚Äô) You can search element on the page and interact with them or inspect thempage. find(:css, ‚Äòa[href=‚Äôsign_up_path‚Äô]‚Äô). click assert_text (‚ÄòCreate an account. ‚Äô) =&gt; all about UI. If you wont access session &amp; other ‚Äúlower stuff‚Äù then write an integration. Example: class LinkTest &lt; ApplicationSystemTestCase	def test_nav_root_to_create_account		visit root_path		click_link('Create Account')		assert_current_path sign_up_path	endendhttps://www. youtube. com/watch?v=DxIoWJKYxIg&amp;t=1278s Demo of TDD ArrangeActAssertclass StatFunction	def self. median(values)		if values. nil? || values. length == 0 			raise ArgumentError( it needs at least one element )		end				if values. length == 1			return values[0]		end				values = values. sort		if values. length. even?			left_of_mid = (values. length / 2) - 1			result = ( values[left_of_mid] + values[left_of_mid] + 1 ) / 2. 0			return result		else			mid = (values. length / 2 )			return values[mid]		end	endendTest def test_median_one_element	# arrange	elements = [1]	# act	result = TestingExample::StatFunction. median( elements)	# assert	assert_equal( 1, result)enddef test_median_two_elements	elements = [1, 2]	result = TestingExample::StatFunction. median( elements)	assert_in_delta( 1. 5, result)enddef test_median_three_elements	elements = [1, 2, 3]	result = TestingExample::StatFunction. median( elements)	assert_equal(2enddef test_median_zero_elements	elements = []	assert_raises(ArgumentError) do		result = TestingExample::StatFunction. median( elements)	endenddef test_median_zero_elements	elements = []	assert_raises(ArgumentError) do		result = TestingExample::StatFunction. median( elements)	endenddef test_median_nil	elements = nil	assert_raises(ArgumentError) do		result = TestingExample::StatFunction. median( elements)	endendhttps://www. youtube. com/watch?v=sOT2FgD22VI What is Minitest? https://semaphoreci. com/community/tutorials/getting-started-with-minitest How to Test Rails Models with Minitest https://semaphoreci. com/community/tutorials/how-to-test-rails-models-with-minitest Getting Started With Testing In Rails (Using Minitest and RSpec) https://medium. com/@ethanryan/getting-started-with-testing-in-rails-using-minitest-and-rspec-113fe1f866a Getting Started With System Tests in Rails With Minitest In Rails jargon, system testing refers to ‚Äútesting an application as a whole system‚Äù. That is done by using a browser in the tests. Instead of testing separate parts, with system tests, we can test a whole ‚Äòworkflow‚Äô, just like what a user goes through while interacting with our app, including the JavaScript parts. In practice, it means that we don‚Äôt want a system test to check if a record is created in the database when a user clicks a button; we just test if that new record appears on their screen. These kinds of user interaction tests are also called feature tests or acceptance tests. They are different from integration tests: integration tests are for testing the behavior, especially of all the parts of the app together, but not via the user interface. https://blog. appsignal. com/2020/02/12/getting-started-with-system-tests-in-ruby-with-minitest. html Official Docs https://guides. rubyonrails. org/testing. html#rails-meets-minitest Minitest vs. RSpec in Rails https://www. honeybadger. io/blog/minitest-rspec-rails/ "
    }, {
    "id": 88,
    "url": "http://localhost:4000/2022/02/14/test_jason_swett.html",
    "title": "The Beginner‚Äôs Guide to Rails Testing Jason Swett",
    "body": "2022/02/14 - Here I wrote the parts I considered most important from this book, Jason goes from explaining different types of tests, which ones he uses, DSL, how to think on testing from a specification perspective not validation, make testing a habit that compound down the road and increase productivity even though it feels in the begining that it deters you from coding faster.  Introduction Intro to Testing Principles Rails Testing Tools Your First Practice Tests Factory Bot: Introduction Factory Bot: Getting Started Factory Bot: Build Strategies and Faker Factory Bot: Advanced Usage RSpec Syntax: Introduction RSpec Syntax: The Structure of a Test RSpec Syntax: Let, Let! and Instance Variables RSpec Syntax: The Parts of an RSpec Test RSpec Syntax: Build Your Own RSpec, Part 1 RSpec Syntax: Build Your Own RSpec, Part 2 RSpec Syntax: Describe and Contex Model specs: Introduction Model specs: Tutorial, Part One Model Specs: Tutorial, Part TwoChapter 1 Introduction: Who this book is for, what‚Äôs in this book and how to use this book Chapter 2 Fundamentals: Intro to Testing Principles: First I capture what to do in the form of a test. Then I follow my own instructions by getting the test to pass. Then I repeat. This is a much lighter cognitive burden than if I were to juggle these different mental jobs and allows me to be productive for longer because I don‚Äôt run out of mental energy as early in the day. The first truth is that it‚Äôs impossible to write a piece of code cleanly on the first try. Some amount of refactoring, typically a lot of refactoring, is necessary in order to get the code into a reasonably good state. The second truth is that it‚Äôs impossible to do non-trivial refactorings without having automated tests. The feedback cycle is just too long when all the testing is done manually. Either that or the risk of refactoring without testing afterward is just too large to be justified. ‚ÄúWhat level of test coverage should I shoot for?‚Äù is one of the questions most commonly asked by beginners to Rails testing. My answer is that you shouldn‚Äôt shoot for a particular level of test coverage. I recommend that instead you make testing a habitual part of your development workflow. A healthy level of test coverage will flow from there. All software has bugs, but if you feel like the rate of new bugs appearing in production is unacceptably high, it may be a symptom of too little test coverage. The only alternative to using automated tests, aside from not testing at all, is to test manually. Infrequent deployments can arise as a symptom of too few tests for a couple different reasons. One possible reason is that the need for manual testing bottlenecks the deployment timing. If it takes two days for manual testers to do a full regression test on the application, you can of course only deploy a fully-tested version of your application once every two days at maximum. Inability to refactor or make big changes. Testing != TDD TDD is a specific kind of testing practice where you write the tests before you write the code that makes the test pass. Chapter 3 Fundamentals: Rails Testing Tools: A common Rails testing question is which testing framework to use. RSpec and Minitest are the two options that most people are deciding between. Most of us don‚Äôt have much choice as to whether to use RSpec or Minitest at work. For better or worse, it‚Äôs my experience and the experience of most Rails developers I‚Äôve talked with that most commercial projects use RSpec. (Note how I said most commerical projects. Most commercial projects use RSpec and most OSS Ruby projects, in my experience, use Minitest. I do not know why this is the way it is. ) What does this mean? My take is that this means if your goal is to get a Rails job, learning RSpec over Minitest will give you a higher probability that your skills match the tech stack that‚Äôs used at any particular company RSpec and Minitest differ syntactically but they don‚Äôt really have meaningful conceptual differences. I‚Äôll explain what the major tools are but I want to preface it by saying that the most important thing to learn to be a successful tester is testing principles, not testing tools.    RSpec. RSpec is a test framework. A test framework is what gives us a structure for writing our tests as well as the ability to run our tests.     Factory Bot. One of the challenges of Rails testing is generating test data. There are two common ways of generating test data in Rails tests: fixtures and factories.          Fixtures typically take the form of one or more YAML files with some hard-coded data. The data is translated into database records one time, before any of the tests are run, and then deleted afterward. (This happens in a separate test database instance of course. )           With factories, database data is generated specifically for each test. Instead of loading all the data once at the beginning and deleting it at the end, data is inserted before each test case and then deleted before the next test case starts. (More precisely, the data isn‚Äôt deleted, but rather the test is run inside a database transaction and the data is never committed in the first place, but that‚Äôs a mechanical detail that‚Äôs not important right now. )       I tend to prefer factories because I like having my data generation right inside my test, close to where the test is happening. With fixtures the data setup is too distant from where the test happens.    Capybara. Some Rails tests only exercise Ruby code. Other tests actually open up a browser and simulate user clicks and keystrokes. Simulating user input this way requires us to use some sort of tool to manipulate the browser. Capybara is a library that uses Ruby to wrap a driver (usually the Selenium driver), letting us simulate clicks and keystrokes using convenient Ruby methods.     VCR and WebMock. One principle of testing is that tests should be deterministic, meaning they run the same way every time no matter what. When an application‚Äôs behavior depends on external services (e. g. a third-party API like Stripe) it makes it harder to have deterministic tests. The tests can be made to fail by an internet connection failure or a temporary outage of the external service.      VCR can let us run our tests against the real external service, but capture all the service‚Äôs responses in local files so that subsequent test runs don‚Äôt talk to the external service but rather just go off of the saved responses. That way, even if the internet connection fails or the service goes down, the tests still work   The different kinds of RSpec tests and when to use each: The eight types of RSpec specs ‚Ä¢ Model specs‚Ä¢ System specs‚Ä¢ Request specs‚Ä¢ Helper specs‚Ä¢ View specs‚Ä¢ Routing specs‚Ä¢ Mailer specs‚Ä¢ Job specs Jason usage: ‚Ä¢ Model specs always‚Ä¢ System specs always‚Ä¢ Request specs rarely‚Ä¢ Helper specs rarely‚Ä¢ View specs never‚Ä¢ Routing specs never‚Ä¢ Mailer specs never‚Ä¢ Job specs never  Model specI use model specs to test my models‚Äô methods. When I do so, I tend to use a test-first approach and write a failing test before I add a new line of code so that I‚Äôm sure every bit of code in my model is covered by a test.  System specSystem specs are the only type of test that give me confidence my whole application really works. Even though system specs are indispensable, they‚Äôre not without drawbacks. System specs are somewhat ‚Äúheavy‚Äù  Request specI tend not to use request specs much because in most cases they would be redundant to my system specs. If I have system specs covering all my features, then of course a broken controller would fail one or more of my tests, making tests specifically for my controllers unnecessary. I also try to keep my controllers sufficiently simple as to not call for tests of their own. There are just three scenarios in which I do use request specs.    If I‚Äôm working on a legacy project with fat controllers, sometimes I‚Äôll use request specs to help me harness and refactor all that controller code.     If I‚Äôm working on an API-only Rails app, then system specs are physically impossible and I drop down to request specs instead.     if it‚Äôs just too awkward or expensive to use a system spec in a certain case then I‚Äôll use a request spec instead.  View and routing spec I find view specs and routing specs to be redundant to system specs. If something is wrong with one of my views or routes, it‚Äôs highly likely that one of my system specs will catch the problem. What are all the Rails testing tools and how do I use them? RSpec is a test framework. A test framework is what gives us a structure for writing our tests as well as the ability to run our tests. How do I add tests to an existing Rails project? If you have little testing experience, I would suggest getting some practice on a fresh Rails app before trying to introduce testing to the existing Rails project you want to add tests to. Adding tests to an existing project is a distinct skill from writing tests for new projects. If you‚Äôre already comfortable with testing 1) develop a shared vision with your team, To improve test coverage, a team must first create a shared vision. They need to agree on what ‚Äúgood testing‚Äù means for them, choose the tools and approach they‚Äôll use, and define clear goals and steps to reach their desired level of testing. 2) start with what‚Äôs easiest, then When introducing tests to an untested codebase, don‚Äôt start with the most important or complex features, as those are usually hardest to test. Also, requiring tests for every new change can be impractical because new code often depends on untested parts. Instead, begin with the easiest areas‚Äîlike simple CRUD operations‚Äîto build basic testing habits and infrastructure. This creates a foundation (‚Äúa beachhead‚Äù) to gradually expand test coverage later. 3) expand your test coverage After establishing tests for simple features, gradually move on to more complex ones. This step-by-step approach makes it easier to achieve solid test coverage than starting with the hardest or most valuable parts right away. With the foundational principles and tools in place, it‚Äôs time to begin writing your first practice tests. Chapter 4 Fundamentals: Your First Practice Tests: I‚Äôll describe how to set up a new Rails application for testing in three parts:  An application template that can add all the necessary gems and configuration My setup process (commands I run to create a new Rails app) A breakdown of the gems I useTemplate: Application template I created that will do two things:  1) install a handful of testing-related gems and  2) add a config file that will tell RSpec not to generate certain types of files gem_group :development, :test do gem 'rspec-rails' gem 'factory_bot_rails' gem 'capybara' gem 'webdrivers' gem 'faker'endinitializer 'generators. rb', &lt;&lt;-CODE Rails. application. config. generators do |g|  g. test_framework :rspec,  fixtures: false,  view_specs: false,  helper_specs: false,  routing_specs: false,  request_specs: false,  controller_specs: false endCODEafter_bundle do generate 'rspec:install'endYou can see the code that will be run within your app if you go to the next link https://raw. githubusercontent. com/jasonswett/testing_application_template/master/application_template. rb Setup process: When I run rails new, I always use the -T flag for ‚Äúskip test files‚Äù because I always use RSpec instead of the Minitest that Rails comes with by default. Also, incidentally, I always use PostgreSQL. This choice of course has little to do with testing but I‚Äôm including it for completeness. I‚Äôm also using the -m flag so I can pass in my application template. rails new my_project -T -d postgresql \  -m https://raw. githubusercontent. com/\ jasonswett/testing_application_template\ /master/application_template. rbThe Gems:  rspec-rails: The rspec-rails gem is the version of the RSpec gem that‚Äôs specifically fitted to Rails factory_bot_rails: Factory Bot is a tool for generating test data.  capybara: Capybara is a tool for writing acceptance tests, i. e. tests that interact with the browser and simulate clicks and keystrokes.  webdrivers: In order for Selenium to work with a browser, Selenium needs drivers.  faker: By default, Factory Bot (the tool for generating test data) will give us factories that look something like this:FactoryBot. define do factory :customer do  first_name {  MyString  }  last_name {  MyString  }  email {  MyString  } endendWhen collision on attribute first_name arise due to uniqueness, we use Faker: FactoryBot. define do factory :customer do  first_name { Faker::Name. first_name }  last_name { Faker::Name. last_name }  email { Faker::Internet. email } endendI also often end up adding the VCR and WebMock gems when I need to test functionality that makes external network requests. Next steps After I initialize my Rails app, I usually create a walking skeleton by deploying my application to a production and staging environment and adding one small feature, for example the ability to sign in. Building the sign-in feature will prompt me to write my first tests. By working in this way I front-load all the difficult and mysterious work of the project‚Äôs early life. A Rails testing ‚Äúhello world‚Äù using RSpec and Capybara Jason encourages the reader to start a rails app and add a controller and a test to have a quick win. # step 1:rails new my_project -T -d postgresql -m https://raw. githubusercontent. com/jasonswett/testing_application_template/master/application_template. rb# step 2:$ rails g controller hello_world index# step 3: within the view app/views/hello_world/index. html. erb add the following:Hello, world!# step 4: boot up rails server and go to the url ` open http://localhost:3000/hello_world/index`$ rails server# step 5: create the next file spec/hello_world_spec. rbrequire 'rails_helper'RSpec. describe 'Hello world', type: :system do  describe 'index page' do   it 'shows the right content' do   visit hello_world_index_path   expect(page). to have_content('Hello, world!')  end endend# step 6: run the test !rspec spec/hello_world_spec. rbHere is a Jason explanation on what we just wrote as a test: # This pulls in the config from spec/rails_helper. rb# that's needed in order for the test to run. require 'rails_helper'# RSpec. describe, or just describe, is how all RSpec tests start. # The 'Hello world' part is an arbitrary string and could have been anything. # In this case we have something extra in our describe block, type: :system. # The type: :system setting does have a functional purpose. It's what# triggers RSpec to bring Capybara into the picture when we run the test. RSpec. describe 'Hello world', type: :system do describe 'index page' do it 'shows the right content' do  # This is where Capybara starts to come into the picture.  visit  is a  # Capybara method. hello_world_index_path is just a Rails routing  # helper method and has nothing to do with RSpec or Capybara.   visit hello_world_index_path  # The following is a mix of RSpec syntax and Capybara syntax.  expect   # and  to  are RSpec,  page  and  have_content  are Capybara. Newcomers  # to RSpec and Capybara's English-sentence-like constructions often  # have difficulty remembering when two words are separated by a dot or  # an underscore or parenthesis, myself included. Don't worry, you'll  # get familiar over time.   expect(page). to have_content('Hello, world!')  end endendBefore trusting a passing test, you must first see it fail to confirm it‚Äôs actually testing what you think it is. A test that passes even when the code is broken is a false positive. By intentionally breaking the feature and ensuring the test fails, you verify that the test correctly distinguishes between working and broken behavior. # change the text in the view app/views/hello_world/index. html. erbJello, world!When we run our test now it should see it fail with an error message like expected to findtext ‚ÄúHello, world!‚Äù in ‚ÄúJello, world!‚Äù. Chapter 14 Factory Bot: Introduction: What Factory Bot is One of the biggest challenges to a new tester is the question of how to generate test data. Most features in a web application will require you to have some certain database records in place first, but it‚Äôs not always clear the best way to bring those records into existence. There are multiple ways to accomplish this. For users of RSpec, the de facto standard way to create test data is to use a tool called Factory Bot. Factory Bot is a Ruby library that allows for convenient generation of database data for tests. There are three ways to generate test data in Rails:  Manually Factories FixturesLet‚Äôs first explore manual creation. Manual data creation can be convenient enough if you only have a few attributes on a model and no dependencies. valid_payment_type = PaymentType. new(name: 'Visa')invalid_payment_type = PaymentType. new(name: '')But now let‚Äôs say we have the idea of an Order which is made up of multiple LineItems and Payments, each of which has a PaymentType. order = Order. create!( line_items: [  LineItem. create!(name: 'Electric dog polisher', price_cents: 40000) ], payments: [  Payment. create!(   amount_cents: 40000,   payment_method: PaymentMethod. create!(name: 'Visa')  ) ])That‚Äôs annoying. This is where factories come in handy. Factories The idea with a factory is basically that you have a method/function that generatesnew class instances for you. Here‚Äôs an example of how the setup for an Order instance might look if we used a factory, specifically Factory Bot. order = FactoryBot. create( :order, # üëà model Order line_items: [FactoryBot. create(:line_item, price_cents: 40000)], # üëà associations with LineItems payments: [FactoryBot. create(:payment, amount_cents: 40000)]# üëà associations with Payments)In this case we‚Äôre specifying only the details that are relevant to the test. We don‚Äôt care about the line item name or the payment method. As long as we have a payment total that matches the line item total, that‚Äôs all where care about. Fixtures Typically fixtures are expressed in terms of YAML files. # orders. ymlpayments_equal_line_item_total: # no attributes needed# line_items. ymlelectric_dog_polisher: order: payments_equal_line_item_total name: 'Electric dog polisher' price_cents: 40000# payment_methods. ymlvisa: name: 'Visa'# payments. ymlfirst: order: payments_equal_line_item_total payment_method: visa amount_cents: 40000Once the fixture data is established, instantiating an object that uses the data is as simple as referring to the key for that piece of data: order = orders(:payments_equal_line_item_total)Which is best? Summary Manual Data Generation  Quickly becomes tedious but useful for small, simple cases Benefits: clarity and low overheadFactories vs FixturesThe author prefers factories for several reasons:  Test data specification and usage are close together in the code With fixtures, the setup is hidden in YAML files, making it tedious to verify what data is being generated Fixtures often lead teams to create a large, complicated ‚Äúworld of data‚Äù reused across all testsTesting Philosophy  Prefers starting each test with a clean slate Generates only the bare minimum data needed per test Makes tests easier to understandPractical Recommendation  Factories are the go-to method and general recommendation Acknowledges the fixture issues are usage problems, not inherent flaws Open to using fixtures for specific use cases (e. g. , fixed baseline data like payment types) Both approaches could be combined in a project when appropriateThe key takeaway: factories are preferred for their transparency and encouraging minimal, test-specific data generation, but the author remains pragmatic about using the right tool for the situation. Chapter 15 Factory Bot: Getting started: To install Factory Bot, add the factory_bot_rails gem to the :development, :test group of your Gemfile. group :development, :test do gem 'factory_bot_rails'endFactory definitions: user = FactoryBot. create(:user)Notice how we don‚Äôt have to specify anything at all about the record‚Äôs attributes. We only had to pass in :user as an argument. Factory Bot will automatically take care of the details for the user record based on the instructions we specify in the user factory. FactoryBot. define do factory :user do  first_name { 'John' }  last_name { 'Smith' }  email { 'john. smith@example. com' } endendAs you may have guessed, :user maps to our User model (assuming we have one) and first_name, last_name and email all map to attributes in the User model. Below is a more detailed explanation of what each part of the factory definition does. # FactoryBot is the name of a class. #  define  is a class method on the FactoryBot class. FactoryBot. define do #  factory  is a method. It takes, as an argument, the name of the factory # we're defining. By convention, the argument we pass gets matched up with # an ActiveRecord class, e. g. :user gets matched up with User.  factory :user do  # Each attribute in our ActiveRecord model can have a corresponding line  # in our factory definition. In this case, first_name, last_name and  # email are all dynamically-defined methods. Each of these methods  # takes a block which supplies the value of the attribute.   first_name { 'John' }  last_name { 'Smith' }  email { 'john. smith@example. com' } endendWhere to put factory definitions I put all my factory definitions in spec/factories and I generally use a convention of putting just one factory in each file. For example, if I were to have a factory for a Product model, I would put it in spec/factories/products. rb. There‚Äôs unfortunately a problem with our configuration: if we do FactoryBot. create(:user) again, we‚Äôll just get an exact duplicate with all the same attribute values, which is of course often not desirable. We‚Äôll address this issue later on though. Chapter 16. Factory Bot: Build Strategies and Faker: For creating objects using Factory Bot, there are two main methods offered: create and build. Let‚Äôs take a look at each, continuing to use our User factory as an example.    If we were to run FactoryBot. create(:user), it would return a persisted instance of aUser model.     If we were to run FactoryBot. build(:user), it would return an unpersistedinstance of a User model.  Whenever possible, we‚Äôre going to favor . build over . create, as persisting to the database is one of the slowest operations in our tests. If we go to the terminal and instantiate the next model with different methods: # we try out `. create`=&gt; user = FactoryBot. create(:user)=&gt; user. persisted? # true=&gt; user. id # an ID value 45700# then we try out `. build`&gt; user = FactoryBot. build(:user)&gt; user. persisted? # false&gt; user. id # nilUsing Factory Bot with Faker There‚Äôs a problem with using hard-coded values in factory definitions. What if our users table had a unique constraint on the email column? In that case, the first usage of FactoryBot. create(:user) would work fine, but the second time we did it, the database wouldn‚Äôt allow the duplicate record to be created, and we‚Äôd have a problem. Here‚Äôs an example of how that would go using Faker: FactoryBot. define do factory :user do  first_name { 'John' }  last_name { 'Smith' }  email { Faker::Internet. email } endendFaker::Internet. email will return values like kris@hoeger. io or marionstroman@hamill. io. I find these sorts of values nicer to work with than a hard-coded value with a number or hash slapped on the end of it. Entire Factory for User model using Faker. FactoryBot. define do factory :user do  first_name { Faker::Name. first_name }  last_name { Faker::Name. last_name }  email { Faker::Internet. email } endendChapter 17 Factory Bot: Advanced Usage: Nested factories Sometimes you want to be able to create records that are 95% the same as the ‚Äúdefault‚Äù buthave one or two small differences.  Physician user exampleThe Problem:  30 tests need regular users 6 tests need physician users (users with role set to 'physician') How do you handle this variation without problems?Three Options Evaluated  Set role individually in each test ‚ùå     Bad: Code duplication   If physician user requirements change, you‚Äôd need to update all 6 places   Maintenance nightmare    Make all users physician users by default ‚ùå     Bad: Misleading and violates best practices   Creates unnecessary setup data for 30 tests that don‚Äôt need it   Test maintainers can‚Äôt tell which setup data is actually necessary   Principle: Create the minimum amount of setup data and no more    Create a nested factory that inherits from the base user factory ‚úÖ     This is the right answer   No duplication   Doesn‚Äôt modify the default factory   Clear and maintainable   In Factory Bot, this is called ‚Äúnested factories‚Äù   Key Testing PrincipleTests should only include the minimum necessary setup data. Extraneous data misleads future maintainers who can‚Äôt distinguish between essential and superfluous setup. # Normal Factory for User modelFactoryBot. define do factory :user do  username { Faker::Internet. username }  password { Faker::Internet. password } endend# Nested factoryFactoryBot. define do factory :user do  username { Faker::Internet. username }  password { Faker::Internet. password }  factory :physician_user do   role { 'physician' }  end endend# Usage of that nested FactoryFactoryBot. create(:physician_user)Traits Traits solve a similar problem to the one nested factories solve, but in a different way. With nested factories, you‚Äôre defining a child factory inside an existing factory, with the child factory inheriting from the parent factory. With traits, you‚Äôre defining additional qualities that can optionally be added to an existingobject. &lt;/b&gt; # Normal Factory for User modelFactoryBot. define do factory :user do  username { Faker::Internet. username }  password { Faker::Internet. password } endend# TraitsFactoryBot. define do factory :user do  username { Faker::Internet. username }  password { Faker::Internet. password }  trait :with_name do   first_name {  John  }   last_name {  Smith  }  end  trait :with_phone_number do   phone_number {  (555) 555-5555  }  end endend# Usage of that TraitsFactoryBot. create(:user, traits: [:with_name, :with_phone_number]). When to use traits versus nested factories My method is pretty simple: If the factory I‚Äôm considering has something, I use a trait. If the factory is something, I use a nested factory. Let‚Äôs look at a concrete example. ‚ÄúHas‚Äù example (trait) # The user is still conceptually a regular old `user`. The only difference is that this user happens to have a value for its `phone_number` attribute. FactoryBot. define do factory :user do  username { Faker::Internet. username }  password { Faker::Internet. password }  trait :with_phone_number do   phone_number {  (555) 555-5555  }  end endend# Usage of that TraitsFactoryBot. create(:user, :with_phone_number)‚ÄúIs‚Äù example (nested factory) # A `physician` user has different capabilities from a regular `user` and is used in different ways from a regular `user`. FactoryBot. define do factory :user do  username { Faker::Internet. username }  password { Faker::Internet. password }  factory :physician_user do   role { 'physician' }  end endend# Usage of that nested FactoryFactoryBot. create(:physician_user)Callbacks Imagine you need to create a User record that has a Message associated with it. This is an option: user = FactoryBot. create(:user)create(:message, user: user)But if you need to create such users over and over, your code could get repetitive. You can create a more convenient way to meet your needs by using callbacks. Below is a concrete example. We have a :user factory and then, inside that, a nestedfactory called :user_with_message. FactoryBot. define do factory :user do  username { Faker::Internet. username }  password { Faker::Internet. password }  factory :user_with_message do   after(:create) do |user|    create(:message, user: user)   end  end endendWhen FactoryBot. create(:user_with_message) is run, everything happens that would happen when FactoryBot. create(:user) is run, plus the stuff in the after(:create) callback is executed. The various callback types: ‚Ä¢ after(:create) - called after a factory is saved (via FactoryBot. create)‚Ä¢ after(:build) - called after a factory is built (via FactoryBot. build or FactoryBot. create)‚Ä¢ before(:create) - called before a factory is saved (via FactoryBot. create)‚Ä¢ after(:create) - called after a factory is saved (via FactoryBot. create)‚Ä¢ after(:stub) - called after a factory is stubbed (via FactoryBot. build_stubbed) Transient attributes Transient attributes are values that are passed into the factory but not directly set on the object‚Äôs attributes. PDF file attachment example Let‚Äôs say we have an InsuranceDeposit class that has PDF file attachments. class InsuranceDeposit has_many_attached :pdf_filesendAn example without using transient attributes insurance_deposit = create(:insurance_deposit)# This setup is noisy and hard to understandfile = Tempfile. newpdf = Prawn::Document. newpdf. text  my arbitrary PDF content pdf. render_file file. pathinsurance_deposit. pdf_files. attach( io: File. open(file. path), filename:  file. pdf )This way is non-ideal because a) the code is hard to understand and b) if we use these steps end more than one place, we‚Äôll have duplication An example with transient attributes FactoryBot. define do factory :insurance_deposit do  transient do   pdf_content {    }  end  after(:create) do |insurance_deposit, evaluator|   file = Tempfile. new   pdf = Prawn::Document. new   pdf. text evaluator. pdf_content   pdf. render_file file. path   insurance_deposit. pdf_files. attach(    io: File. open(file. path),    filename:  file. pdf     )  end endend# usage of transientcreate(:insurance_deposit, pdf_content:  my arbitrary PDF content )This is much tidier than the original. If we want to see how pdf_content works, we can open up the insurance_deposit factory and have a look. Chapter 18. RSpec Syntax: Introduction: RSpec Syntax: Introduction In this section we‚Äôll address both the RSpec DSL and the underlying Ruby concepts that are helpful to understand in order to understand RSpec‚Äôs DSL. Here‚Äôs what we‚Äôre going to cover in this section:  The Structure of a Test Understanding Blocks Let, Let! and Instance Variables The Parts of an RSpec Test Build Your Own RSpec, Part 1 Build Your Own RSpec, Part 2 Describe and ContextChapter 19. RSpec Syntax: The Structure of a Test: No matter what test framework is being used, a test tends to contain four basic parts, or phases:  Setup Exercise Assertion TeardownWe can illustrate these four phases using an example. Let‚Äôs say we have an application that has a list of users that can receive messages. Only active users are allowed to receive messages. So, we need to assert that when a user is inactive, that user can‚Äôt receive messages. Here‚Äôs how this test might go:  Create a User record (setup) Set the user‚Äôs ‚Äúactive‚Äù status to false (exercise) Assert that the user is not ‚Äúmessageable‚Äù (assertion) Delete the User record we created in step 1 (teardown)The purpose of each test phase  SetupThe setup phase typically creates all the data that‚Äôs needed in order for the test to operate. (There are other things that could conceivably happen during a setup phase but for our current purposes we can think of the setup phase‚Äôs role as being to put data in place). In our case, the creation of the User record is all that‚Äôs involved in the setup step, although more complicated tests could of course create any number of database records and potentially establish relationships among them.  ExerciseThe exercise phase walks through the motions of the feature we want to test. With our messaging example, the exercise phase is when the user gets put in an inactive state. Side note: the distinction between setup and exercise may seem blurry, and indeed it sometimes is, especially in low-level tests like our current example. If someone were to argue that setting the user to inactive should actually be part of the setup, I‚Äôm not sure how I‚Äôd refute them.  AssertionThe assertion phase is basically what all the other phases exist in support of. The assertion is the actual test part of the test, the thing that determines whether the test passes or fails.  TeardownEach test needs to clean up after itself. If it didn‚Äôt, then each test would potentially pollute the world in which the test is running and affect the outcome of later tests, making the tests non-deterministic. We don‚Äôt want this. We want deterministic tests, i. e. tests that behave the same exact way every single time no matter what. The only thing that should make a test go from passing to failing or vice-versa is if the behavior that the test tests changes. In reality, Rails tests tend not to have an explicit teardown step. The main pollutant we have to worry about with our tests is database data that gets left behind. RSpec is capable of taking care of this problem for us by running each test in a database transaction. The transaction starts before each test is run and aborts after the test finishes. So really, the data never gets permanently persisted in the first place. A concrete example RSpec. describe User do let!(:user) { User. create!(email: 'test@example. com') } # setup  describe '#messageable?' do   context 'is inactive' do    it 'is false' do     user. update!(active: false)      # exercise     expect(user. messageable?). to be false # assertion     user. destroy!             # teardown   end  end endendChapter 20. RSpec Syntax: Let, Let! and Instance Variables {chapter-20}: The purpose of let and the differences between let and instance variables RSpec‚Äôs let helper method is a way of defining values that are used in tests. Below is a typical example. require 'rspec' RSpec. describe User do  let(:user) { User. new }  it 'does not have an id when first instantiated' do   expect(user. id). to be nil endend# here we use a before hook https://rspec. info/features/3-12/rspec-core/hooks/before-and-after-hooks/require 'rspec'RSpec. describe User do before { @user = User. new } it 'does not have an id when first instantiated' do  expect(@user. id). to be nil endendDifferences between let and instance variables Summary Stylistic Differences  Syntax varies: instance variables use @ prefix Author personally finds let syntax slightly tidierMechanical Differences  Error Detection     Instance variables: Ruby doesn‚Äôt complain if you use an undefined one‚Äîit just returns nil         Danger: You might accidentally pass nil to a method and test the wrong behavior     Risk is relatively low          let helper: Defines a memoized method, not an instance variable         If you typo the method name, Ruby will raise an error (good!)           Lazy Evaluation     let can create values that are evaluated lazily   Author considers this dangerous and a bad idea (more explanation promised later)   Most Important Difference: Test Isolation  Instance variables in before blocks can leak between test files     Example: @customer set in ‚ÄúFile A‚Äù can be referenced in ‚ÄúFile B‚Äù   This is bad: Tests should be completely deterministic and independent    Implication: let is safer for maintaining test isolationBottom Line: let provides better error detection and test isolation compared to instance variables. How let works let is NOT a variable, it‚Äôs a method that returns a memoized method (a method that only runs once). def my_name puts 'thinking about what my name is. . . ' 'Jason Swett'endputs my_name# output:thinking about what my name is. . . Jason SwettSame thing using let require 'rspec'describe 'my_name' do let(:my_name) do  puts 'thinking about what my name is. . . '  'Jason Swett' end it 'returns my name' do  puts my_name endend# output:thinking about what my name is. . . Jason SwettMemoization in action The method body only executes once, but returns the value twice. require 'rspec'describe 'my_name' do let(:my_name) do  puts 'thinking about what my name is. . . '  'Jason Swett' end it 'returns my name' do  puts my_name  puts my_name # Called twice endend# output:thinking about what my name is. . .  # Only prints once!Jason SwettJason SwettLazy Evaluation let require 'rspec'describe 'let' do let(:message) do  puts 'let block is running'  'VALUE' end it 'does stuff' do  puts 'start of example'  puts message  puts 'end of example' endend# output:start of examplelet block is running # Runs only when message is calledVALUEend of exampleImmediate Evaluation let! require 'rspec'describe 'let!' do let!(:message) do  puts 'let block is running'  'VALUE' end it 'does stuff' do  puts 'start of example'  puts message  puts 'end of example' endend# output:let block is running # Runs BEFORE test startsstart of exampleVALUEend of exampleAuthor‚Äôs RecommendationAlways use let! instead of letWhy?  Lazy evaluation (let) can be subtly confusing     Example: A database record might be saved at an unclear point in execution    No real-world benefit to lazy evaluation Performance gains are negligible Confusion is more expensive than slownessPractical takeaways: ‚Ä¢ The biggest advantage to using let over instance variables is that instance variables can leak from test to test, which isn‚Äôt true of let. ‚Ä¢ The difference between let and let! is that the former is lazily evaluated while the latter is immediately evaluated. ‚Ä¢ I always use the let! version because I find the execution path to be more easily understandable. Chapter 21. RSpec Syntax: The Parts of an RSpec Test: In this chapter we‚Äôre going to write a small test and thoroughly examine it. We‚Äôll look at the parts of the test bit-by-bit so we can understand each piece as well as the whole. By the end of this chapter, the syntax of an RSpec file will look much less mysterious. We‚Äôre going to write a small, trivial method and then write an RSpec test for the method. Our method, called emphasize, will convert a string to uppercase and add an exclamation point at the end. For example, the emphasize method would convert awesome to AWESOME!. def emphasize(text)  #{text. upcase}! endHere is the test for that method: RSpec. describe 'emphasizing text' do it 'makes the text uppercase and adds an exclamation point' do  expect(emphasize('hello')). to eq('HELLO!') endendWe‚Äôre going to examine each part of this test, but first let‚Äôs talk about some terminology. Specs, examples, ‚Äúexample groups‚Äù and ‚Äúit blocks‚Äù Tests vs. specs In RSpec, the contents of an RSpec file are referred to as a spec, short for specification. Spec files in RSpec are suffixed with _spec. These files must be suffixed so in order for the RSpec runner to recognize them as spec files. An example spec filename would be patient_spec. rb. Each spec usually contains a number of example groups. Example groups are a way of putting related tests into groups. The example group is the outermost block which starts with RSpec. describe. RSpec. describe 'emphasizing text' do # ‚¨Ö this is the example group  it 'makes the text uppercase and adds an exclamation point' do  expect(emphasize('hello')). to eq('HELLO!') endend# they can be nested tooRSpec. describe 'emphasizing text' do # ‚¨Ö this is the example group for valid input describe  valid input  do  it 'makes the text uppercase and adds an exclamation point' do   expect(emphasize('hello')). to eq('HELLO!')  end end describe  invalid input  do # ‚¨Ö this is the example group for invalid input  it 'returns nil when input is not String' do   expect(emphasize(7)). to eq(nil)  end endendExamples and ‚Äúit blocks‚Äù Each individual test in RSpec is known as an example. A single spec (which, remember, means a single RSpec file) may contain any number of examples: Why it blocks? My interpretation is that the it blocks help make each example read like an English sentence. In the example above the English sentence would of course be ‚Äúit makes the text uppercase and adds an exclamation point‚Äù RSpec. describe 'emphasizing text' do it 'makes the text uppercase and adds an exclamation point' do # ‚¨Ö this is the it block or example or test case  expect(emphasize('hello')). to eq('HELLO!') endendThe expect keyword The expect is the part of the test (or, more precisely, the part of the example) where the test itself actually happens. In the snippet below we‚Äôre expecting that the return value of emphasize('hello') is equal to 'HELLO!'. If this expectation is met when we run the spec, then this example will pass. Otherwise the example will fail and the RSpec test runner will let us know exactly how the example failed. RSpec. describe 'emphasizing text' do it 'makes the text uppercase and adds an exclamation point' do   expect(emphasize('hello')). to eq('HELLO!') # ‚¨Ö this is the expect keyword for this test case endendThe eq matcher The syntax of . to eq() often looks strange and arbitrary to RSpec beginners. Much of the RSpec syntax (which we‚Äôll see a lot more of soon) can look like a soup of dots, spaces and underscores, with no apparent rhyme or reason as to what‚Äôs what. Luckily, I assure you that this confusion goes away as you get more familiar with what the RSpec DSL is made of and as you get practice writing RSpec tests. For the . to part of expect(emphasize('hello')). to eq('HELLO!'), it helps to recognize that to is just a method. In fact, we can add the missing optional parentheses on the to method to make it clearer that to is just a method. expect(emphasize('hello')). to(eq('HELLO!'))eq is also a method. The argument that we pass to the to method is eq('HELLO!'), so inother words, whatever the return value of eq('HELLO') is is what gets passed to to. What‚Äôsthe return value of eq('HELLO')? Chapter 22. RSpec Syntax: Build Your Own RSpec, Part 1: What we‚Äôre going to do: In this chapter we‚Äôre going to build our own RSpec-like test framework called MySpec. By the end of this chapter you‚Äôll be able to run the following test file # Our desired test filerequire_relative '. /my_spec'def emphasize(text)  #{text. upcase}! end# Above this line is the  application code # and below this line is the test code# -----------------------------------------MySpec. describe 'emphasizing text' do it 'makes the text uppercase and adds an exclamation point' do  expect(emphasize('hello')). to eq('HELLO!') endendStep 1: expect For convenience, we‚Äôll include the ‚Äúapplication code‚Äù (i. e. the emphasize method) right in the same file as the test code. # emphasize_spec. rbdef emphasize(text)  #{text. upcase}! endexpect(emphasize('hello')). to eq('HELLO!')Throughout this process, we‚Äôre going to use the method of ‚Äúerror-driven development‚Äù (not a real thing, just something I made up). We‚Äôll write some code, run the code, see what errors we get, fix the errors, and repeat. if we run the file $ ruby emphasize_spec. rb we get the next error: emphasize_spec. rb:5:in `&lt;main&gt;': undefined method `expect' for main:Object (NoMethodError)The error is telling us expect is an undefined method, which is true. We haven‚Äôt defined a method called expect yet. Let‚Äôs define it. def emphasize(text)  #{text. upcase}! enddef expect(things) # we added the method expect with an argumentendexpect(emphasize('hello')). to eq('HELLO!')Now, if we run the file we get a different error: emphasize_spec. rb:8:in `&lt;main&gt;': undefined method `eq' for main:Object (NoMethodError)`It‚Äôs time to add eq to the file: def emphasize(text) #{text. upcase}! enddef expect(things)enddef eq(thing)# we added the method eq with an argumentendexpect(emphasize('hello')). to eq('HELLO!')Now that we have defined both expect and eq we get another error: emphasize_spec. rb:11:in `&lt;main&gt;': undefined method `to' for nil:NilClass (NoMethodError)This one is perhaps less straightforward, so I‚Äôll explain what‚Äôs happening. This error means that the object we‚Äôre calling to on is nil. We‚Äôre calling to on expect(emphasize('hello')), so it must be that the return value of expect(emphasize('hello')) is nil. This is indeed the case. When we defined expect, we didn‚Äôt put a body in the method definition, so the return value of expect is nil. To fix this error, we need to change expect from returning nil to returning an object that will respond to a method called to. The only mystery is exactly what we should return. def emphasize(text) #{text. upcase}! enddef expect(things) ExpectationTarget. new # we added this new class so that we don't call . to on nil objectenddef eq(thing)endexpect(emphasize('hello')). to eq('HELLO!')Now, the error is: emphasize_spec. rb:15:in `&lt;main&gt;': undefined method `to'for #&lt;ExpectationTarget:0x00007fe3020271b8&gt; (NoMethodError)And that‚Äôs because we have not even defined the ExpectationTarget class def emphasize(text) #{text. upcase}! endclass ExpectationTarget def initialize(output)  @output = output end def to(expected_output)  if @output == expected_output   puts '. '  else   raise  Expected #{@output} to equal #{expected_output}   end endenddef expect(output) ExpectationTarget. new(output)enddef eq(expected_output) expected_outputendexpect(emphasize('hello')). to eq('HELLO!')If we run the file now we see an output of just a dot (. ). This is because our expected output, HELLO!, does indeed match the actual output. We can organize our code better in different files, for example the MySpec framework in my_spec. rb and the emphasize method in emphasize_spec. rb. In the next chapter we‚Äôre going to make our syntax more closely match the real RSpec syntax. In addition to our expect, we‚Äôre going to have surrounding it and describe blocks. Chapter 23. RSpec Syntax: Build Your Own RSpec, Part 2: In the last chapter we got as far as re-implementing RSpec‚Äôs expect, to and eq. Now let‚Äôs make our test look even more like a real RSpec test by implementing describe and it. Within the file emphasize_spec. rb require_relative '. /my_spec'def emphasize(text) #{text. upcase}! end MySpec. describe 'emphasizing text' do it 'makes the text uppercase and adds an exclamation point' do  expect(emphasize('hello')). to eq('HELLO!') endendWe‚Äôll start with just the inner part, the it block. Now, if we run emphasize_spec. rb, we get the following error. The it method we referred to is of course undefined. emphasize_spec. rb:27:in `&lt;main&gt;': undefined method `it' for main:Object (NoMethodError)Let‚Äôs add the it method with a yield keyword since it block doesn‚Äôt actually need to do anything, it‚Äôs just a wrapper for the benefit of the human reader. def emphasize(text) #{text. upcase}! endclass ExpectationTarget def initialize(output)  @output = output end def to(expected_output)  if @output == expected_output   puts '. '  else   raise  Expected #{@output} to equal #{expected_output}   end endenddef expect(output) ExpectationTarget. new(output)enddef eq(expected_output) expected_outputenddef it(description) yieldendexpect(emphasize('hello')). to eq('HELLO!')Adding the outer block MySpec. describe Within emphasize_spec. rb we add the outer block and run the file. require_relative '. /my_spec'def emphasize(text) #{text. upcase}! endMySpec. describe 'emphasizing text' do it 'makes the text uppercase and adds an exclamation point' do  expect(emphasize('hello')). to(eq('HELLO!')) endendthe error is our friend and we have seen it many times before: emphasize_spec. rb:31:in '&lt;main&gt;': uninitialized constant MySpec (NameError) Let‚Äôs add that MySpec class. class MySpecenddef emphasize(text) #{text. upcase}! endclass ExpectationTarget def initialize(output)  @output = output end def to(expected_output)  if @output == expected_output   puts '. '  else   raise  Expected #{@output} to equal #{expected_output}   end endenddef expect(output) ExpectationTarget. new(output)enddef eq(expected_output) expected_outputenddef it(description) yieldendexpect(emphasize('hello')). to eq('HELLO!')If we run the file, we get the next error emphasize_spec. rb:34:in '&lt;main&gt;': undefined method 'describe' for MySpec:Class (NoMethodError) class MySpec def self. describe(description)  yield endenddef emphasize(text) #{text. upcase}! endclass ExpectationTarget def initialize(output)  @output = output end def to(expected_output)  if @output == expected_output   puts '. '  else   raise  Expected #{@output} to equal #{expected_output}   end endenddef expect(output) ExpectationTarget. new(output)enddef eq(expected_output) expected_outputenddef it(description) yieldendexpect(emphasize('hello')). to eq('HELLO!')Now everything works, and we now have a complete test that very much resembles an RSpec test! Chapter 24. RSpec Syntax: Describe and Context: The describe and context keywords are just aliases for one another. Mechanically, they‚Äôre 100% equivalent. The only reason the two keywords exist is for the benefit of the human reader. When I use describe I tend to use describe when I‚Äôm describing a method or a feature. If I were to write a test for a method called first_name, I might write it something like this: RSpec. describe User do describe '#first_name' do # ‚¨Ö here is the method first_name declared  it 'returns the first name' do   # test code goes here  end endend# Sometimes I want to test a feature that doesn‚Äôt have a neat one-to-one relationship with a method. RSpec. describe User do describe 'phone format' do # ‚¨Ö here is the feature we test  it 'strips the non-numeric characters' do   # test code goes here  end endendWhen I use context I tend to use context when I want to test various permutations of a behavior. RSpec. describe User do # ‚¨Ö group example for User class describe 'phone format' do # ‚¨Ö describre block to group two nested blocks  context 'phone number is not the right length' do # ‚¨Ö here a context block to describe a behavior   # test code goes here  end  context 'containers non-numeric characters' do # ‚¨Ö here a context block to describe a behavior   # test code goes here  end endendChapter 31. Model Specs: Introduction: The purpose of model specs Model specs are for testing the behavior of your application. This may sound obvious, but many programmers seem to misunderstand the meaning of ‚Äúbehavior‚Äù and instead test the implementation of their application‚Äôs features, which unfortunately misses the point of testing altogether. Let‚Äôs talk about the difference between testing implementation and testing behavior. Implementation vs. behavior An example of an implementation test might be: ‚ÄúDoes the Patient model have a has_many :payment_entries association?‚Äù If you look at patient. rb and it contains the line has_many :payment_entries, then the test passes. An example of a behavior test might be ‚ÄúWhen I add a payment entry for $50 for a patient, does the patient‚Äôs balance decrease by $50?‚Äù To perform this test you might check the patient‚Äôs balance, see that it‚Äôs $80, then enter a $50 payment into the system and finally navigate to the patient‚Äôs profile and verify that the patient‚Äôs balance is now $30 instead of $80. If you‚Äôve verified that adding a $50 payment entry decreases a patient‚Äôs balance by $50, then you‚Äôve also verified that a has_many :payment_entries association exists , since the feature can‚Äôt work without the payment_entries association. So having an additional test solely for the payment_entries association would be redundant and superfluous. Notice how the behavior test has nothing to do with how the feature is actually coded. We don‚Äôt care how it works, we only care that it works. Common errors of testing implementation instead of behavior ‚Ä¢ Verifying that validations exist‚Ä¢ Verifying that associations exist‚Ä¢ Verifying that a class responds to certain methods‚Ä¢ Verifying that callbacks exist‚Ä¢ Verifying that a database table has certain columns and indexes These are all examples of testing implementation rather than behavior. All such tests are quite frankly, pointless. Instead of testing these things directly, it‚Äôs more helpful to test the behaviors that these things enable. The value of loose coupling One benefit of testing behavior rather than implementation is loose coupling. Two things are loosely coupled to the degree that you can change one without having to change the other. If you write tests that test implementation, you‚Äôve guaranteed tight coupling. Loose coupling is only possible with tests that test behavior. Testing that a model responds to certain methods it { expect(factory_instance). to respond_to(:public_method_name) }There‚Äôs negligible value in simply testing that a model responds to a method. Better to test that that method does the right thing. Testing for the presence of callbacks it { expect(user). to callback(:calculate_some_metrics). after(:save) }it { expect(user). to callback(:track_new_user_signup). after(:create) }Don‚Äôt verify that the callback got called. Verify that you got the result you expected the callback to produce. Tips for writing valuable RSpec tests Here‚Äôs how I tend to write model specs: for every method I create on a model, I try to poke at that method from every possible angle and make sure it returns the desired result. For example, I recently added a feature in an application that made it impossible to schedule an appointment for a patient who has been inactivated. So I wrote three test cases:  one where the patient is active (expect success), one where the patient is inactive (expect an error to get added to the object), and one where the patient was missing altogether (expect a different error on the object). Chapter 32. Model Specs: Tutorial, Part One: It may seem obvious what a Rails model is. To many Rails developers, the model is the MVC layer that talks to the database. But in my experience, there are actually a lot of different conceptions as to what Rails models are, and not all of them agree with each other. I think it‚Äôs important for us to firmly establish what a Rails model is before we start talking about how to test Rails models. To me, a model is an abstraction that represents a small corner of reality in a simplified way. Models exist to make it easier for a programmer to think about and work with the concepts in a program. Models are not a Rails idea or even an OOP idea. A model could be represented in any programming language and in any programming paradigm. Why model specs are different from other types of specs Because models aren‚Äôt a Rails idea but rather a programming idea, testing models in Rails isn‚Äôt that conceptually different from testing models in any other language or framework. In a way this is a great benefit to a learner because it means that if you know how to test models in one language, your testing skills will easily translate to any other language. System specs are relatively easy to get started with because you can more or less follow a certain step-by-step formula for writing system specs for CRUD features and be well on your way. There‚Äôs not as much of a step-by-step formula for writing model tests The tutorial Here are the things you can expect to have a better understanding of after completing this tutorial.  How to come up with test cases for a model based on the model‚Äôs desired behavior.  How to translate those test cases into actual working test code, in a methodical and repeatable manner.  How to use a test-first approach to make it easier both to write the tests and to write the application code. The scenario We want our phone number model to be able to take phone numbers in any of the following formats: 555-856-8075(555) 856-8075+1 555 856 8075 And strip them down to look like this: 5558568075 Our PhoneNumber class won‚Äôt know anything about databases, it will just be responsible for converting a ‚Äúmessy‚Äù phone number to a normalized one. Our first test A big part of the art of model testing is coming up with various scenarios and deciding how our code should behave under those scenarios. The first scenario we‚Äôll test here is: ‚ÄúWhen we have a phone number where the digits are separated by dashes, the dashes should all get stripped out. ‚Äù require_relative '. /phone_number. rb'RSpec. describe PhoneNumber do # test for scenario 1 context  phone number contains dashes  do  it  strips out the dashes  do  phone_number = PhoneNumber. new( 555-856-8075 )  expect(phone_number. value). to eq( 5558568075 )  end end # test for scenario 2 context  phone number contains parentheses  do  it  strips out the non-numeric characters  do   phone_number = PhoneNumber. new( (555) 856-8075 )   expect(phone_number. value). to eq( 5558568075 )  end end # test for scenario 3 context  phone number contains country code   do  it  strips out the country code  do  phone_number = PhoneNumber. new( +1 555 856 8075 )  expect(phone_number. value). to eq( 5558568075 )  end endendclass PhoneNumber attr_reader :value EXPECTED_NUMBER_OF_DIGITS = 10 def initialize(value)  @value = value. gsub(/\D/,   ). split(  ). last(EXPECTED_NUMBER_OF_DIGITS). join endendChapter 33. Model Specs: Tutorial, Part Two: Learning objectives  How to come up with test cases for a model based on the model‚Äôs desired behavior.  How to translate those test cases into actual working test code, in a methodical and repeatable manner.  How to use a test-first approach to make it easier both to write the tests and to write the application code. The scenario We‚Äôll be working on the exact same scenario as Part One: normalizing messy phone numbers. We‚Äôll even be using all the exact same test cases. The reason we‚Äôre keeping those things the same is to show the Rails-models-versus-POROs differences in sharp relief. The PhoneNumber model $ rails g model phone_number value:string$ rails db:migrate# spec/models/phone_number_spec. rbrequire  rails_helper RSpec. describe PhoneNumber, type: :model do # Our first test case context  phone number contains dashes  :model do  it  strips out the dashes  do  phone_number = FactoryBot. create(:phone_number, value:  555-856-8075 )  expect(phone_number. value). to eq( 5558568075 )  end end # Our second test case context  phone number contains parentheses  do  it  strips out non-numeric characters  do  phone_number = FactoryBot. create(:phone_number, value:  (555) 856-8075 )    expect(phone_number. value). to eq( 5558568075 )  end end # Our third test case context  phone number contains country code  do  it  strips out country code  do  phone_number = FactoryBot. create(:phone_number, value:  +1 555 856 8075 )    expect(phone_number. value). to eq( 5558568075 )  end endend# app/models/phone_number. rbclass PhoneNumber &lt; ApplicationRecord before_validation :strip_non_numeric_from_value EXPECTED_NUMBER_OF_DIGITS = 10  def :strip_non_numeric_from_value  self. value = self. value. gsub(/\D/,   ). split(  ). last(EXPECTED_NUMBER_OF_DIGITS). join endendRefactoring Rather than repeatedly creating a new phone_number variable using FactoryBot. create, we can DRY up our code a little by putting the FactoryBot. create in a let! block at the beginning and then updating the phone number value for each test. require  rails_helper RSpec. describe PhoneNumber, type: :model do let!(:phone_number) do  FactoryBot. create(:phone_number) endcontext  phone number contains dashes  do before { phone_number. update!(value:  555-856-8075 ) }  it  strips out the dashes  do  expect(phone_number. value). to eq( 5558568075 ) endendcontext  phone number contains parentheses  do before { phone_number. update!(value:  (555) 856-8075 ) }  it  strips out the non-numeric characters  do  expect(phone_number. value). to eq( 5558568075 ) endendcontext  phone number contains country code  do before { phone_number. update!(value:  +1 555 856 8075 ) }  it  strips out the country code  do  expect(phone_number. value). to eq( 5558568075 )  end endendTakeawaysRails model tests can be written by coming up with a list of desired behaviors and translating that list into test code. When learning how to write Rails model tests, it can be helpful to first do some tests with plain old Ruby objects (POROs) for practice. Writing tests before we write the application code can make the process of writing the application code easier. "
    }, {
    "id": 89,
    "url": "http://localhost:4000/2022/02/05/the_man_in_the_arena.html",
    "title": "The man in the arena",
    "body": "2022/02/05 - The GOAT üêê  Chastising the Spanish artist for painting unrepresentative cubistic abstractions, a layman withdrew a photograph of his wife from his pocket and held it up to Picasso with the admonition, ‚ÄúWhy can‚Äôt you paint realistically, like that?‚Äù ‚ÄúIs that what your wife really looks like?‚Äù Picasso asked. ‚ÄúYes,‚Äù replied the man. ‚ÄúWell, she‚Äôs very small, and quite flat. ‚Äù First of all i need to be clear that I‚Äôm neither a football follower nor fanatic but somehow TB (Tom Brady) caught me up with his ‚Äúunderdog/rejection‚Äù story. Chapter 1 On naming the series. The meaning behind the title of this series is because that quote was on the weight room at Michigan University and TB saw it for almost 5 years (it was coined by Theodore Roosevelt) and for him was that eventually you become that man where all eyes are on you and only you know what is all about. All began in 1993-1996 when Patriots were playing good football however they were not winning, they lost 1 super bowl, new coach; then Mr. Brady appeared in 1999 with a very solid foundation from Michigan state, - ‚Äúthe team, the team is first‚Äù was the guideline he was trained. He defines it as a combination of talent, what you can add on a daily/weekly basis; at this time he didn‚Äôt know what were his strengths, everynight he looked up what phase was the draft on in order to know his position. Something worth mentioning is that 5 rounds passed and no one chose him, his attributes were not even close to what a pro football team expects, finally he was picked at #199 (only 200 are allowed). Main QB (quarterback, D. Bledsoe) at that time describe him as ‚Äúinquisitive‚Äù, asking about everything, everyone thought that he‚Äôd be just a backup, was not perceived as a threat; on the other side TB defined himself either ‚Äújust being naive‚Äù or ‚Äútoo much confidence‚Äù but he was determined to play pro üèà.  ‚ÄúWorking hard is a very sustainable trait. Part of your character. If you don‚Äôt have that, at some point the talent does wear off, you‚Äôre drafted based on both therefore you must work hard . ‚Äù Tom Brady. Second season with Brady on board started, Bledsoe signed the highest contract ever for the next 10 years, TB was on the bench until Bledsoe was hit, time to take the grid. Despite of the very low expectation people had on him, he felt ready to do the job. TB continued playing good waiting Bledsoe to get back of his injury however Bill Belichick (coach) made the decision of giving that role to TB, seeking the best for the team. At the AFC finale (one game before Super Bowl) TB had an ankle injury, Bledsoe took his role back, made a couple of touchdowns and won the game, this only remarks how mentally strong was TB since the beginning, everything came down to Bledsoe would be the starting QB, coach thought different, Tom will play the SB. As always all odds against Patriots, however the Pats won being the most underdogs üèÜ.  You gotta be ready when your opportunity presents itself. I don‚Äôt think I was physically prepared. Was I mentally and emotionally ready? Absolutely. It‚Äôs like anything. Its progress and its evolution. It‚Äôs a series of small steps that seem so insignificant. ‚Äù Tom Brady. Chapter 2 On team culture. TB describes how people, teammates, competitors have been such impactful in his life, on and off the field, those people must help you create the best version of you, if not you gotta move on. After winning the SB they lost the next season, it was time to regroup the team, they had to have more consistency; following season Belichick cut the defense leader (L. Malloy, best friend of TB) no one understood that decision which gave room to the media to start creating news about the feelings within the team, thing that TB refused with the next phrase ‚Äúignore the noise, focus on tactics‚Äù. ‚ÄúPatriots is not collecting talent, is building a team‚Äù B. Belichick. With that being said, TB worked his way to carefully listen to every advice from his coach that gave him structure and confidence, it enabled him to execute selfishness, caring about all his teammates, no one care about who takes the credit.  ‚ÄúWinning is probably the outcome but the process of winning was what the culture was all about. What are you willing to commit to be your the very best?‚Äù Tom Brady. TB learned to study every top player, take the good stuff, fine tune it and put it on practice. He used the next metaphor: ‚ÄúBe the best husband you could be, the best father, the best in your job, because you cannot control everything. If you have perspective in the end nothing bad really happens because out of the bad comes the really good things. ‚Äù  Mental toughness is how you deal with adversity. What‚Äôs the attitude of your heart? Embrace challenge? Failure?‚Äù Rodney Harrison. Chapter 3 The edge. This episode was on motivational style, TB put a statement about how their mentality was - one game at the time, this was tough to put into practice due to they had more than 20 wins in a row. The main responsibility of any leader is to know how to motivate each member of his team, some of them like hard coaching others need just a push and in this sports the QB is the chief; this time Belichick worked to create a competitive environment where all the players wanted to give more, here are some phrases he shares:    It was not the more you can do it. It was who could do the most.     You came 6:30 am? I‚Äôve already got a half hour on you.     I‚Äôm getting the edge on you.     This is what I did. What‚Äôd you do?  -Are you leaving already? -Still not doing the extra, huh? I‚Äôm getting the edge on you today I think is worth pointing out the good outcome that Belichick achieved by building this environment, it‚Äôs only as good as the ability of the players to receive it. The team at that time had a high level cohesiveness and the feedback, communication was on point to keep the culture up.  ‚ÄúYou don‚Äôt know what kind of culture you have until things aren‚Äôt going well. ‚Äù When you have failure, when you don‚Äôt do what you were supposed to do, you‚Äôll define how your culture looks like. ‚Äù Mike Vrabel. TB also mentioned how people think there are going to be more opportunities and that is a mistake because it lowers the bar and keeps you away from doing your best effort, you may miss a chance and will disappoint you next time, it will create fear, you‚Äôll want a lower level to play in order to avoid frustration. Chapter 4 The goliaths. In this episode you‚Äôll find how the Patriots reached its highest level and passed from being the underdogs to the goliaths. Many new team members Randy Moss, Wes Welker amongst others; they knew they were the team to defeat which I think played against them this time. Pats had a first time ever record with 16 wins and 0 loses, no team had accomplished this before, they made football look easy, then the ‚Äúspygate‚Äù got and again TB spoke up with his phrase ‚Äúignore the noise‚Äù. ‚ÄúSo much of the success in the life is about that journey and it‚Äôs not about whether you win or lose always. It‚Äôs about how hard you try and what you put into it, thr relationships, the learnings you develop. ‚Äù Tom Brady. In the end Pats lost the Super Bowl against New York Giants, this time Giants were the weaker. Chapter 5 No guarantees. This episode covers 4 seasons and Tom describes how are the relationships he was able to develop throughout these years, friendships, the born of his 2 kids, how supportive and stabilizer was Gisselle for him and how you must overcome failure, learn from it and move on. Some highlights of this episode are the union of NFL players took place for the first time, they couldn‚Äôt attend training however TB convoked to train in one college field without coaches with gave the team an advantage over the others, ultimately the got the conditions they were after. And finally Patriots faced Giants in the finale and they lost, after a series of inconvenient events, Eli Manning won the SB.  ‚ÄúChallenges are opportunities in disguise‚Äù. Gisele B√ºndchen. Chapter 6 Stop the bleeding. Things were not clear for this season, the media started pressing on TB retirement, a new draft for his position had been picked. Pats did a comeback throuthroug the season to reach the SB with a record of 12 - 4 gaining confidence game after game, ignoring the noise and building momentum, they did their job and stop the bleeding; suddenly another scandal arose the ‚Äúdeflategate‚Äù just a few days before the SB, they faced the best defense at that time Seattle Seahawks with Richard Sherman. Notwithstanding the dire comments about them, the conquered their 4th Super Bowl üèÜ  ‚ÄúGreatness come with taking chances‚Äù. Vince Wilfork. Chapter 7 Surrender. For this chapter Tom invited his 3 sisters in order to lay out how his childhood was, they were a typical California family, attending all 49‚Äôs games, Tom Brady being the youngest felt always protected by his 3 sisters and his parents, they did a pretty well job, until he left to attend Michigan University. The season covered here was on year 2017 when Tom had to defend himself against the ‚Äúdeflategate‚Äù, he was penalized, suspended and the worst; his mom was detected with cancer, the quimio and radiation started so his mind was cut on two sides. Tom depicts this Super Bowl as the greatest game ever played (I didn‚Äôt know why until I watched how it unfold); this finale had the biggest difference in points ever, 28 to be precise despite that, Pats did comeback and scored as many touchdowns as needed to defeat Atlanta Falcons (play after play). ‚ÄúI think he lives his life to really be the best at something. He is a hundred, a thousand % committed to being the better than he was a day before. ‚Äù Tom Brady sister. ‚ÄãChapter 8 No body‚Äôs business. Tom introduced his rehab clinic and method along his coach body Alex Guerrero; it seems to be his secret weapon after finishing each game as well as every recovery. From my perspective Alex is an alternative physician who uses natural healing and different methods to prepare the muscles, also he goes over emotional and mental subjects trying to get up to an integral readiness. After years working on theses methods and proving they really work, Tom convinced Rob Gronkowski to get to Alex and try out his alternatives methods, thing that Belichick didn‚Äôt agree with and sent Tom and the trainer to remain outside each meeting and game. These supplemental activities seemed to gained relevance when Tom suffered a dire injury in his thumb days before the AFC final, he needed punctures and the recovery appeared to be beyond Sunday however after several treatments he was able to flex and use his hand for Sunday and passed to the SB LII. The super Bowl was fought by the two teams but Pats couldn‚Äôt beat the Philadelphia Eagles, another lose for Tom Brady üëé. Chapter 9 Maybe. Last episode of this series goes over the season 2018 and 2019 where Pats had to face Kansas City and Patrick Mahomes, I think they highlight this game because KC started to show how good they were and the pro football they play, also because some key teammates were out so regular season was not great. The Super bowl was against Los Angeles Rams which was meant to be a tough game, very physical, low opportunities, in the end Tom was bearing in mind that it was going to be his last season playing with New England because he didn‚Äôt get a new contract.  ‚ÄúAll comes down to the people and relationship what I value the most. Tom Brady. Conclusion. It definitely is a combination of different factors that take you to succeed or to the place you want to be, those factors may be hard work, readiness, persistence and of course luck or how tom said a few times ‚Äúsituacional football‚Äù which is when something completely out of your control plays in favor of you, kicker missed the goal, the receiver couldn‚Äôt catch the pass, you name them and here is the part of commitment you need to place in every activity, relationship you want to develop because if everything derails and nothing comes to the place you planned was the best; you must be satisfied that you gave everything you could in order to accomplish but luck this time was not on your side. Having lost so many SB‚Äôs being the most prestigious sports in America has to be tough as well, it‚Äôs said very easy, -he won 7 Super Bowls. But how manys he lost?! It‚Äôs tough to miss a flight, to be rejected by the company you would have loved to work for, imagine how hard is to lose the most important event in the year, after having practiced and played 9 months in a row without being with your family. Tom developed a resilient mentality which was key for his journey, to keep his feet on earth and to overcome those setbacks, never look back and learn the most from them. "
    }, {
    "id": 90,
    "url": "http://localhost:4000/2022/01/05/minitest_cookbook.html",
    "title": "The Minitest Cookbook",
    "body": "2022/01/05 - Today though, the separation between development and testing has largely disappeared - at least in the universe that most Ruby and Rails programmers occupy. In many if not most cases now, the one writing the code is also responsible for producing automated tests that cover the workdone. And while you‚Äôre probably sick of hearing it, this is a good thing for all kinds of reasons. Why? ‚Ä¢ Tests demonstrate that your code actually works. ‚Ä¢ The pattern of thinking needed to write tests for code is very close tothat needed to design it. ‚Ä¢ Testing and developing in parallel tends to surface more bugs early in the development process when fixing them is cheap and easy. ‚Ä¢ Well-tested code tends to be better designed with reduced coupling and greater cohesion. ‚Ä¢ A good test suite acts as a detailed specification. ‚Ä¢ Writing tests during development increases programmer engagement and efficiency. ‚Ä¢ A test suite with good coverage aids in maintenance, refactoring, and upgrades with reduced risk of breakage and regression. ‚Ä¢ It‚Äôs faster to write code with tests than without. ‚Ä¢ Having automated tests reduces or removes the need for manual testing Best tests will have a few important characteristics in common:‚Ä¢ Clarity: The name of each test suggests what it‚Äôs about at a glance. ‚Ä¢ Purpose: The intent and meaning of the test is obvious and unambiguous from the testing logic. ‚Ä¢ Eloquence: The test logic is expressed through fluent use of the language and the testing framework. ‚Ä¢ Readability: Tests are written and formatted in a way that promotes rapid discovery and comprehension. ‚Ä¢ Efficiency: All other things being equal, automated tests should use the minimum possible system resources Unlike a lot of books on testing, this one won‚Äôt dwell on the mechanics of test-driven development. TDD has become so prevalent and popular among the Ruby and Rails development community that you‚Äôd be hard pressed to find a book on testing or development that doesn‚Äôt take it as a starting point for everything taught. But TDD is primarily about development and only incidentally about testing, and it often treats the tests that fall out of it as a by-product rather than as first-class citizens of your project. That tends to result in test suites that are neglected after they‚Äôve served the purpose of driving out features. ‚Ä¢ Fact: The entire framework weighs in at less than 1600 lines of code. RSpec is almost 8 times as large. With a code base that size, the source practically becomes its own documentation. ‚Ä¢ Fact: Minitest has been singled out as a very readable project because it‚Äôs written in plain Ruby that developers of all experiencelevels can dig into and understand. ‚Ä¢ Fact: The project has remained small and simple because of conscious decisions to keep it that way in spite of frequent requestsfor expanded features. ‚Ä¢ Fact: The source code showcases Ruby‚Äôs power and elegance with great uses of closures, metaprogramming, concurrent programming, and others. ‚Ä¢ Fact: Since the Minitest framework also happens to be tested with Minitest, it includes some exceptional practical examples illustrating good testing technique To really get comfortable with Minitest‚Äôs internals, there are four basic abstractions that you‚Äôll need to understand: plugins, reporters, runnables and the Minitest runner. Plugins In Minitest, plugins are modules that extend or modify the behavior of Minitest. They can be used to add new features, customize the test runner, or modify the output of test results. Examples of plugins in Minitest include pride (a colorful test runner), parallel (for parallel test execution), and focus (to run specific tests or test suites). Minitest plugins are usually packaged as RubyGems which implement a simple framework-defined contract that allows them to be loaded an initialized by the framework. Specifically speaking, every plugin includes a loader file that follows a standard naming convention - ex: minitest/ foo_plugin. rb where foo is the name of the plugin. minitest-rails is a plugin for Minitest that adds some additional features for working with Ruby on Rails applications. It provides some additional test generators that can create test files for your Rails application‚Äôs models, controllers, views, and helpers. It also includes support for testing Rails-specific features like routes and controllers. In addition to the generators, minitest-rails also provides a Rails-specific test runner that sets up the Rails environment before running the tests. This can be helpful if your tests need to access Rails configuration or other Rails-specific features. Overall, minitest-rails is a helpful plugin for anyone working with Ruby on Rails applications and using Minitest as their testing framework. Another example: the minitest/pride plugin adds colorful output to your test results in the terminal. Reporters A test suite is a map for directing development effort to the parts of your project that need it. From this perspective, the results reported by your test suite act as its user interface and indicate the state of your code base. Each test Minitest runs passes a result to a Reporter object which is responsible for acting on it. Depending on the Reporter, it might:‚Ä¢ Display information to the console. ‚Ä¢ Store the result for later processing. ‚Ä¢ Increment counters or compile statistics. ‚Ä¢ Send the result to another system - ex: a CI, a database, etc. As an abstraction, a Reporter is just an object that implements four methods that allow it to accept and operate on test results:‚Ä¢ #start - called before the first test is run‚Ä¢ #record - accept and process a single test result‚Ä¢ #report - deliver a detailed report after the test run‚Ä¢ #passed? - indicate passed/failed/errored/skipped tests In Minitest, reporters are used to generate output of the test results. They provide various types of outputs such as progress bar, detailed documentation, and colorized output. Runnables In Minitest, runners are classes that run a set of tests. Assert-style tests and Spec-style tests are two different styles of writing tests in Minitest. Assert-style tests are based on assertions that verify the expected result of a test. They are usually written using methods such as assert, assert_equal, assert_match, etc. The focus is on verifying specific outcomes and behavior of the code being tested. Spec-style tests are based on specifying the expected behavior of a system or component. They are usually written using describe and it blocks that describe the behavior of the code being tested. The focus is on describing the behavior and intent of the code, rather than just verifying specific outcomes. Assert-style tests are based on the idea of making assertions about the state of the system under test. These tests usually follow the ‚ÄúArrange-Act-Assert‚Äù pattern, where the test sets up the system‚Äôs initial state, performs some action, and then makes one or more assertions about the system‚Äôs final state. (This uses instance methods starting with the string ‚Äútest_‚Äù). Spec-style tests, on the other hand, are based on the idea of describing the behavior of the system under test using a domain-specific language (DSL). In these tests, the focus is on describing what the system should do rather than how it should do it. Spec-style tests often use ‚Äúdescribe‚Äù and ‚Äúit‚Äù blocks to structure the test code. Both styles of testing have their pros and cons, and the choice of which one to use often comes down to personal preference and the requirements of the project. Some developers prefer the clarity and simplicity of Assert-style tests, while others find the expressiveness and readability of Spec-style tests to be more appealing. Ultimately, the most important thing is to choose a style that works for you and your team and allows you to write effective, maintainable tests. The Minitest Runner The Minitest Runner is the component responsible for running Minitest test suites. It loads the test files, executes the tests, and reports the results. By default, Minitest uses the Minitest::Runnable and Minitest::Test classes to define and run tests, respectively. However, the runner can be customized to use other classes or to change the way the tests are run. The runner is a key part of Minitest‚Äôs flexibility and extensibility. The runner and Runnables fit together like the layers of an onion where each layer represents a Ruby block or method. The inner layers represent the Runnables where the tests are actually executed, and the outer layers represent the runner - the code that gives the onion its shape. Minitest. runNext, Minitest sets up the environment for the test run along with all the necessary supporting objects. All the framework‚Äôs major responsibilities are handled right here as it:‚Ä¢ Parses the command line arguments. ‚Ä¢ Loads and initializes all detected Minitest plugins. ‚Ä¢ Instantiates and runs the reporters. ‚Ä¢ Runs tests by passing control on to the next layer. ‚Ä¢ Ensures that parallel worker threads are shut down gracefully. Basic Recipes Problem:class FizzBuzz	def convert(number)		if number % 15 == 0			 FizzBuzz 		elsif number % 5 == 0			 Buzz 		elsif number % 3 == 0			 Fizz 		else		number. to_s		end	endendTakeawaysYou need four things to develop a Ruby project with Minitest:‚Ä¢ Install Minitest as a project dependency with Bundler. ‚Ä¢ Create a test directory at test/ . ‚Ä¢ Create a test helper to include all global configuration and customization at test/test_helper. rb . ‚Ä¢ Create a new Rakefile or update the existing one with a Rake::TestTask configured to suit your needs (by convention to run tests you use the command rake) Writing Tests All the tests that we write follow the same basic four-phase structure. 	1. Setup the inputs and data objects prior to running the test. 	2. Exercise the logic under test. 	3. Verify that the tested code produces the expected results. 	4. Teardown or reset application state before running the next test. require 'test_helper'require 'fizz_buzz'class FizzBuzzTest &lt; Minitest::Test	def setup 		@fb = FizzBuzz. new	end	def test_converts_multiples_of_fifteen_to_fizzbuzz		# fb = FizzBuzz. new		assert_equal 'FizzBuzz', @fb. convert(15)		assert_equal 'FizzBuzz', @fb. convert(45)		assert_equal 'FizzBuzz', @fb. convert(90)		[15, 45, 90]. each do |i|			assert_equal 'FizzBuzz', @fb. convert(i)		end	end	def test_converts_multiples_of_five_to_buzz		# fb = FizzBuzz. new		assert_equal 'Buzz', @fb. convert(5)		assert_equal 'Buzz', @fb. convert(10)		assert_equal 'Buzz', 2fb. convert(20)	end	def test_converts_multiples_of_three_to_fizz		# fb = FizzBuzz. new		assert_equal 'Fizz', @fb. convert(3)		assert_equal 'Fizz', @fb. convert(12)		assert_equal 'Fizz', @fb. convert(48)		# another example could have been assert 'Fizz' == fb. convert(3)	end	def test_returns_same_number_for_other_numbers		assert_equal '1', @fb. convert(1)		assert_equal '101', @fb. convert(101)		assert_equal '2014', @fb. convert(2014)	endendAnother example of syntaxis: class ArticleTest &lt; ActiveSupport::TestCase	test  should not save article without title  do		article = Article. new		assert_not article. save	endendThat‚Äôs why many developers follow a strict one assertion per test policy - so that each assertion has exactly one chance to succeed or fail. It‚Äôs true that your tests will be better and more maintainable when each test verifies a single behavior of the system, but writing a single test for each of the assertions above seems like overkill to me since they‚Äôre all testing the same general behavior. setup runs before each test. teardown runs after each test. It‚Äôs better to favor readability over DRY-ness when writing tests. Usage of skip Skip can be useful in situations where you want to write a test that specs out some future work that you‚Äôre notquite ready to code just yet. For example, FizzBuzzTest doesn‚Äôt currently check to see what happens when we pass it an unexpected input. def test_raises_argument_error_for_bad_argument	skip 'not yet implemented'	assert_raises(ArgumentError) { @fb. convert(-1) }	assert_raises(ArgumentError) { @fb. convert(0) }	assert_raises(ArgumentError) { @fb. convert(1. 0) }	assert_raises(ArgumentError) { @fb. convert('foo') }	assert_raises(ArgumentError) { @fb. convert(nil) }endTakeaways	‚Ä¢ Assert-style test cases are classes that inherit from Minitest::Test. 	‚Ä¢ Public instance methods of those classes whose names begin with test_ are treated as tests by the runner. 	‚Ä¢ Minitest provides a small set of assertions out of the box, and of those, about half are used frequently. 	‚Ä¢ Override the setup and teardown methods to include code that should be executed before or, respectively, after each test is	executed. 	‚Ä¢ If you have to choose between readability and DRY-ness in your tests, you should almost always choose readability. Writing Specs class FizzBuzzIterator	def initialize(start = 1)		@counter = start		@fb = FizzBuzz. new	end	def next		input = @counter		@counter += 1		@fb. convert(input)	endendrequire 'test_helper'require 'fizz_buzz_iterator'describe FizzBuzzIterator do	it 'outputs sequential FizzBuzz values starting from 1 when initialized without a starting value' do		iterator = FizzBuzzIterator. new				expect(iterator. next). must_equal '1'		expect(iterator. next). must_equal '2'		expect(iterator. next). must_equal 'Fizz'		expect(iterator. next). must_equal '4'		expect(iterator. next). must_equal 'Buzz'		expect(iterator. next). must_equal 'Fizz'	end	it 'outputs sequential FizzBuzz values starting from the starting value when initialized with a starting value' do		iterator = FizzBuzzIterator. new(10)				expect(iterator. next). must_equal 'Buzz'		expect(iterator. next). must_equal '11'		expect(iterator. next). must_equal 'Fizz'		expect(iterator. next). must_equal '13'		expect(iterator. next). must_equal '14'		expect(iterator. next). must_equal 'FizzBuzz'	endend# Other alternativesexpect(iterator. next). must_equal 'Fizz'value(iteratory. next). must_equal '11'_(iterator. next). must_equal 'Buzz'Assertion vs Expectation Like most powerful tools, this one can be abused. As a general rule, try to limit describe block nesting to at most two or three layers deep. More than that and the specs hard to follow and less readable for future developers (including future you). Before and After for Spec-Style before blocks for all enclosing scopes will be called before the test logic in order from outermost to innermost. after blocks for all enclosing scopes will be called after the test logic in order from innermost to outermost. In practical terms, this lets us define blocks with increasingly specific setup and teardown logic that cascade or override previous operations require 'test_helper'require 'fizz_buzz_iterator'describe FizzBuzzIterator do	before do		@iterator = FizzBuzzIterator. new	end		it 'outputs sequential FizzBuzz values starting from 1' do		expect(@iterator. next). must_equal '1'		expect(@iterator. next). must_equal '2'		expect(@iterator. next). must_equal 'Fizz'		expect(@iterator. next). must_equal '4'		expect(@iterator. next). must_equal 'Buzz'		expect(@iterator. next). must_equal 'Fizz'	end		describe 'when initialized with a starting value' do		before do			@iterator = FizzBuzzIterator. new(10)		end		it 'outputs sequential FizzBuzz values starting from the starting value' do			expect(@iterator. next). must_equal 'Buzz'			expect(@iterator. next). must_equal '11'			expect(@iterator. next). must_equal 'Fizz'			expect(@iterator. next). must_equal '13'			expect(@iterator. next). must_equal '14'			expect(@iterator. next). must_equal 'FizzBuzz'		end	endendThe let function provides an alternate and some would say more elegant way of setting up testing state with a more declarative syntax. describe FizzBuzzIterator do	let(:iterator) { FizzBuzzIterator. new }	# . . . enddescribe FizzBuzzIterator do	let(:iterator) { FizzBuzzIterator. new(10) }	# . . . endEach call to let dynamically defines a new method with the specified name that executes the block argument upon the first invocation and caches the result for later access - in other words, a lazy initializer. Takeaways ‚Ä¢ Create a new test case in Minitest::Spec using a top-level describe block with a String or Class argument. ‚Ä¢ Define a test using an it block with a descriptive String passed as a parameter. ‚Ä¢ Make assertions on the values of expressions by wrapping them in a Minitest::Expectation object using expect or one of its aliases. ‚Ä¢ Use nested describe blocks to define scopes within a test case as a way of grouping related tests. ‚Ä¢ Implement before and after blocks for shared setup and teardown logic specific to a block context. ‚Ä¢ Create named lazy initializers using let blocks. : Configure Pre-Test State As explained back in Writing Tests, each test run under Minitest follows a common progression of steps: Setup, Exercise, Verify, and Teardown. Of these, Setup usually accounts for more lines of code and can be the toughest for new developers to understand. There are several options for setting the state, and knowing which one is the best fit requires familiarity with all of them. Method 1: Set up the same state before each test. Method 2: Configure different state before each test. Method 3: Using a memoized helper method. Method 4: Create data objects within the test. Collections Enumerable types where order doesn‚Äôt matter like Hash and Set count two instances as being equal if they contain the same elements regardless of the order in which the elements were added or passed during initialization. Relations (active record) Just as with Arrays though, order matters, so you‚Äôll need to ensure that both the actual and the expected values are sorted the same way when performing comparisons. ActiveRecord::Relation objects compare mostly like Arrays except when compared with others of the same type, and then according to the SQL representation. Dates and Times Intermediate Recipes Mocks: mocks test the behavior of an object toward the objects to which it sends messages. Use mocks sparingly and only after careful consideration. The more collaborators you mock, the greater your risk of false positives. ‚Ä¢ Only mock what you own. If you don‚Äôt own it, the API could change, and you‚Äôd never detect it in your tests. ‚Ä¢ Only mock immediate collaborators and avoid deep mocking (mocks returning mocks returning mocks). ‚Ä¢ Ideally, only use mocks to solve specific difficult problems like:‚ó¶ Connecting to unreliable or uncontrollable external resources‚ó¶ Real object performance is prohibitively slow‚ó¶ Expensive setup and/or configuration‚ó¶ Avoiding other undesirable side effects StubsStubs provide the context needed to fully exercise an object through a given test scenario ‚Ä¢ Use stubs wherever and whenever they‚Äôre needed, but recognize that needing too many is probably a code smell. ‚Ä¢ Don‚Äôt use stubs where they‚Äôre not needed, and apply them as narrowly as possible where you do use them. (See Mocha‚Äôs stub_everything and any_instance. stub as prime examples of mocking framework features promoting bad coding practices. )‚Ä¢ Never ever, ever stub the object under test. More often than not, you‚Äôll end up testing the stub and not the object itself. Fake Objects A fake is an alternate version of a given class intended for testing only. It exposes an interface resembling that of the real thing it replaces but with an implementation that‚Äôs either simplified or hollowed out which allowsthem to:‚Ä¢ Capture and verify interactions between the object under test and the fake object (like a mock). ‚Ä¢ Maintain consistent interactions between the object under test and the fake object (like a stub). ‚Ä¢ Avoid resource-intensive or otherwise undesirable processing (like both mocks and stubs). We could have gotten the same result using mocking or stubbing, but it might have taken many more lines of setup code. A fake can be a great fit when dealing with complex APIs since it comes ready-made and pre-programmed with the behavior we want and need for running our tests. Testing Mixin Behavior Testing something that can‚Äôt be instantiated on its own confuses many developers. two types of mixins: Those that are coupled with the classes that include them, and those that aren‚Äôt (non-coupled modules) Takeaways ‚Ä¢ Use Object#extend to patch a mixin‚Äôs method into a simple Object for easy testing. ‚Ä¢ Try mixing into a Ruby Struct in cases where you need the including class to have some specific attributes or behavior of its own. Sharing Code Between Tests One point that should be clear to you by now is this: a self-contained test is a readable test. Minitest provides a nice, narrow vocabulary for writing tests, and when we stick to that vocabulary, life becomes better for the developers that follow. When it comes to organizing tests:‚Ä¢ Extracting code into a new helper methods‚Ä¢ Extracting helper methods into a new module‚Ä¢ Extracting tests into a new module Extracting helper methods by:‚Ä¢ Using descriptive names for helper methods and variable arguments‚Ä¢ Updating the extracted code to ensure that it‚Äôs still comprehensible, even outside the previous context Takeaways ‚Ä¢ Code shared within a single test case can be extracted to a private helper method in the same class. ‚Ä¢ Code shared across multiple test cases can be extracted to a module that may be included in all. 	‚ó¶ Sharing tests between test cases is a special case of this Managing Test Data ‚Ä¢ Whenever persistence isn‚Äôt important to your test, use Object. new to create a new instance. ‚Ä¢ Rails fixtures have a lot going for them including great performance and a reliable set of known models for your tests. ‚Ä¢ Use both functional and memorable names for your fixtures. ‚Ä¢ Configure your fixtures carefully, and try to cover at least:‚ó¶ One minimal valid configuration‚ó¶ One or two realistic models‚ó¶ Other well-defined object states‚Ä¢ Use advanced ERB and YAML features to define fixtures dynamically. Testing Active Record Models Active Record maps the application database to Ruby objects that manage attributes, relationships, queries, and lifecycle methods among other things. ‚Ä¢ Test public methods, not private ones. ‚Ä¢ Test interfaces, not implementations. ‚Ä¢ Don‚Äôt test Active Record (or the rest of Rails, for that matter). ‚Ä¢ You need to test some of the typical aspects of Active Record models:	‚ó¶ Complex validations	‚ó¶ Scopes	‚ó¶ Callback targets and hooks‚Ä¢ Make assertions about the results and side effects of public instance methods. ‚Ä¢ Make (selective) assertions an object‚Äôs behavior toward collaborators. Testing Controllers There‚Äôs been a faction of the Rails community that has become vocal about skipping controller testing completely. They usually argue that simulating more realistic user interactions eliminates the need for more focused controller tests which tend to be very repetitive and dull to write anyway. Even the core team has started a gradual move away from controller testing. ‚ó¶ Controller tests should include assertions for the visible side effects that controller actions produce including:	‚ó¶ HTTP response code	‚ó¶ Redirect location	‚ó¶ System state changes (models created, updated, or destroyed)	‚ó¶ Flash variables, session variables, and cookies set or changed‚Ä¢ You should write tests for complex or generated routes. ‚Ä¢ Controllers should specifically not make assertions about any of the following:	‚ó¶ Rendered templates	‚ó¶ Instance variables passed to the view "
    }, {
    "id": 91,
    "url": "http://localhost:4000/2021/12/24/how_to_set_right_obj.html",
    "title": "How to set the right objectives",
    "body": "2021/12/24 - Why Greatness Cannot Be Planned: The Myth of the Objective. Kenneth Stanley Knowledge Project Podcast AI Researcher Reveals How to Set the Right Objectives Objectives are good when they are modest, but things get complicated when they are more ambitious. We as society believe that setting objectives and pursuing them it‚Äôs going to help us make new discoveries comma new accomplishments, achievements. Some great ideas were never an objective until they were discovered. (Rock and roll, penicillin) Serendipity are discoveries that you were not planning to make it. The core problem with ambitious objectives is that many cases trying harder won‚Äôt help you achieve the outcome you‚Äôre seeking. You can‚Äôt be so tied to your vision of accomplishment that you‚Äôre not open to the unexpected or unplanned. You can block your own ability to reach an objective by setting it. Assessment feels like we‚Äôre moving towards our objective; the problem is that even if the metric shows that you‚Äôre moving up in the short run it doesn‚Äôt mean it will lead to the point all the way down. Example: increasing the tests scores in the US schools. (Universal global achievement. Incredible complex) The metric is the assessment and year over year can be going up but it doesn‚Äôt solve the fundamental problem. It needs accountability and assessment with a different approach (an approach that recognizes how you actually make innovative progress in a extreme complex problem) If stepping stones are counter-intuitive (they are not what you would expect) then the metrics are useless because they (metrics) won‚Äôt detect those stepping stones If stepping stones are not counter-intuitive then it‚Äôs not a hard problem, we would have solved already; that‚Äôs what makes the problem hard to solve that you don‚Äôt know the steps. So we need to proliferate stepping stones. It‚Äôs like investing portfolio, they are just ideas, you don‚Äôt know what is going to pay off but you do need that portfolio and make that kind of prediction; some of them will not work out and we need to tolerate. Traditional metrics don‚Äôt allow stepping stones that won‚Äôt lead to the objective. Accountability must thrive interesting steppingstone, even when they won‚Äôt go up. What is not a stepping stone is having everyone getting better than prior year. A solution for the education problem is dissemination of the network teachers, see what on teacher did and work and build from that; it may lead to an end road buy we can‚Äôt find out if not try. We need to find interesting things that are not objectively detectable through the usual assessment. Peer review allows to see from the global optic to the individual. (Academic publishing is an example)Innovations happen through individual connections. With ambitious goals they are far off in the future and we don‚Äôt know what the next stepping stone is so it‚Äôs better to almost take like an evolutionary approach where we are creating these mutations or copying errors or trying all these little experiments and then we see which of those experiments leads to some interesting insights or conclusions and then the idea being, we take those conclusions and then we propagate it to and we propagate it to all other nodes almost like nature sort of rewarding. Subjective judgments are interesting because objective judgments are easy. One example is when we got through this pandemic we should have chosen the best 5th grade teachers (State level or city) and gave them the opportunity to teach all 5th grade students because they were the best, and have best practices however this implies two things: subjection (this is teacher than these others) and failure (which we as a humankind are afraid of). Security blanket is provided by assessments, it makes sure nothing really bad happen. Reality is inconvenient, scary, and difficult. A visionary is someone who in contrast who has recognized when the stepping stones actually have stepped into place now that‚Äôs a person you should follow and that‚Äôs a very interesting and kind of person. Within the corp-life one of the best ways to innovate is to pursue your dream, quit your job and start a start-up this is because the whole society is trapped in this ‚Äúset goals minded‚Äù instead of capturing and developing the idea, they just let it go. "
    }, {
    "id": 92,
    "url": "http://localhost:4000/2021/09/25/refactoring.html",
    "title": "Refactoring",
    "body": "2021/09/25 - This book will take you from beginner to advanced in terms of refactoring. It‚Äôs recommended to have prior knowledge of either one Object Oriented language or Ruby however the Ruby language is very idiomatic so you don‚Äôt need to have a deep understanding of it in order to identify what is the author trying to teach. Firstly let‚Äôs bring up what ‚ÄúRefactoring‚Äù means: Verb: To restructure software by applying a series of refactorings without changing its observable behavior. Noun: A change made to the internal structure of software to make it easier to understand and cheaper to modify without changing its observable behavior. The book has around 70 examples of how you can clean your code up and some others well known ‚Äúgood practices‚Äù. What are the main benefits of doing it and also it considers its downsides so that you can see the whole picture, bearing in mind that the code you write today must be easy to understand and even change tomorrow. The first chapter begins with a good example of a Movie theater system, on the left side you may find some spaghetti code and on the right the code after applying some refactoring twists. Also, he brings some step by step methodology which consists in small changes, test, another small change, test in order to make sure nothing has been broken. He gives you a brief example and then provides a small image, the motivation, the mechanics and the example. For visual learners, the book has plenty of diagrams, before the Refactoring and after so you can see how a requests is sent from the user/browser and pass through different methods and by doing that you may see how an object is modified and what methods intervene and also how clean is the new diagram. There is a section called ‚ÄúTip‚Äù where the author gives you some advices in order to perform better; this is the first: When you find you have to add a feature to a program, and the programs code is not structured in a convenient way to add the feature, first refactor the program to make it easy to add the feature, then add the feature. He goes over about the ROI (return of investment), the technical debt, how to manage it in the case we have tight deadlines and how much we should invest in order to write good code in the first attempts. Notes. Instance methods should not be too long nor does too much. Even if it works, it‚Äôs until we want to change the system when we notice there‚Äôs a bad smell. Code is written by humans and humans need to understand it also care about it. A poorly design system is hard to change. If it‚Äôs hard to figure out what to change is very likely that programmer will make a mistake and introduce bugs. The only guarantee you‚Äôre going to have is that they will change it again within six months. The first to refactor is always the same. I need to build a solid set of tests for that section of code. Decomposing and Refactoring the Statement Method I am looking to decompose the method into smaller pieces. Smaller pieces of code tend to make things more manageable. They are easier to work and to move around. My first step is to find a logical clump of code and use Extract Method. When I extract, I need to know what could go wrong. If I take a larger piece, I can introduce a bug into the program. So before doing it try to figure out how to do it safely. Any non modified variable can be passed as parameter. Modified variables need more care. Never be afraid to change names of things to improve clarity. Good programmers write code that humans can understand. In most cases a method should be on the object whose data it uses. While Refactoring you should focus on clarity, and then later focus on performance as a separate activity. Replacing the Conditional Logic with Polymorphism. If you must use a case statement should be your own data, not on someone else‚Äôs. Using subclasses, we can get rid of the case statement using Polymorphism. Example: Movie (as main class) then subclasses: RegularMovie, Children‚ÄôsMovie and NewMovie. An object cannot change its class during its lifetime. All these lead to better-distributed responsibilities and code that is easier to maintain. The purpose of refactoring is to make software easier to understand and modify. You can make many changes in software that make little or no change in the observable behavior. It only alters the internal structure. Any user, whether an end user or another programmer, cannot tell that things have changed. The two hats by Kent Beck. When you add a function, you should not modify existing code, you‚Äôre just adding new features (hat #1), on the other hand when you are refactoring, you should not add code, just restructure the code (hat #2). Refactoring is not the silver bullet for all software development issues. Loss of the structure of code has a cumulative effect. The harder it‚Äôs to see the design in the code, the harder it‚Äôs to preserve it. Refactoring helps you spot bugs. When I‚Äôm studying code, I find Refactoring leads me to higher levels of understanding that otherwise I would miss. You don‚Äôt decide to refactor, you refactor because you want to do something else, and refactoring helps you do that other thing. I ask myself if I can refactor the code to make that understanding more immediately apparent. Then I refactor it. The other driver of Refactoring is a design that does not help me add a feature easily Developers often to both things, to remove existing pain points and experiment with new solutions. When developers have a deeper understanding of the code base they can ne more effective at adding to it and suggesting how to improve it. Refactoring tends to break big objects and big methods into several smaller ones. When shouldn‚Äôt you refactor? A compromise route is to refactor a large piece of software into components with strong encapsulation. Then you can make a refactor-versus-rebuild decision for one component at a time. Another time you should avoid refactoring is when you are close to a deadline. At that point the productivity gain from refactoring would appear after the deadline and thus be too late. With refactoring the emphasis changes. You still do up-front design, but now you don‚Äôt try to find the perfect solution. You may find that the solution is different from the one you previously came up. Always look for flexible solutions. Refactoring can lead to simpler designs without sacrificing flexibility. The secret to fast software is to write tunable software first and then to tune it for sufficient speed. Since the early days of programming people have realized that the longer a procedure is, the more difficult it is to understand. If you have a good name for a method, you should not look at the body. Ninety-nine percent of the time, all you have to do to shorten a method is Extract method. Find the parts of the method that seem to go nicely together and make a new method. A block of code with a comment that tells you what it is doing can be replaced by a method whose name is based on the comment. When a class is trying to do too much, it often shows up as too many instance variables. When a class has too many instances variables, duplicated code cannot be far behind. As with a class with a huge wad of variables, the usual solution for a class with too much code is either to Extract class, Extract module or extract subclass. A Useful trick is to determine how clients use the class and to use the Extract module for each of these uses. That may give you ideas of how you can break up the class. A class smell is a method that seems more interested in a class other than the one it actually is in. You can shrink a lot of parameter lists and simplify method calling. Bunches of data that hang around together really ought to be made into their own object. Most times when you see a case statement it may be replaced by Polymorphism. Each class you create costs money to maintain and to understand. A class that isn‚Äôt doing enough to pay for itself should be eliminated. Inheritance often leads to over-intimacy. One of the prime features of Objects is encapsulation ‚Äì hiding internal details form the rest of the world. Comments are used as deodorant to somehow mask the bad smell. If you want to refactor, the essential precondition is having solid tests. If you don‚Äôt write self-testing code, you‚Äôll end up spending most time debugging. When you get a bug report, start by writing a unit test that exposes the bug. Write isolated tests that do not depend on each other. You should concentrate on where the risk is. Look at the code and see where it becomes more complex. I emphasize the safe way of doing the refactoring, which is to take small steps and test after every one. A large part of refactoring is composing methods to package code properly. Almost all the time the problems come from methods that are too long. Long methods are troublesome because they often contain a lot of information which gets buried by the complex logic that usually gets dragged in. The key refactoring is Extract method, which takes a clump of code and turns it into its own method. Inline method which does the opposite. I prefer short, well-named methods. It increases the chances that other methods can use a method and also allows you to read from a higher level as a series of comments. Comments often identify pieces of a method that can be extracted. In such situation temporary variables can be helpful to break down the expression into something more manageable. The difficulty in decomposing a method lies in local variables. Refactoring can break down something complex into simpler pieces, but sometimes you just reach the point at which you have to remove the whole algorithm and replace it with something simpler. Moving methods is the bread and butter of refactoring. I move methods when classes have too much behavior or when classes are collaborating too much and are highly coupled. I consider moving a field if I see more methods on another class using the information in the field than the class itself. You‚Äôve Probably heard that a class should be a crisp abstraction, handle a few clear responsibilities, or some similar guideline. You need to consider where it can be split, and you split it. A good sign that a subset of the data and a subset of the methods seem to go together. Other good signs are subsets of data that usually change together or are particularly dependent on each other. One of the keys, if not the key; to objects is encapsulation. Encapsulation means that object need to know less about other parts of the system. A class is doing too much, remove the middleman with method delegation. Each object stands for one object in the real world. Having many two-way links also makes it easy for mistakes to lead to zombies: objects that should be dead but still hang around because of a reference that was not cleared. Replacing case-like or conditional statements with Polymorphism involves blowing away the original class and replacing it with a new class for each type code. If the original class has a large chunk of code that doesn‚Äôt use the type code, I choose either Replace Type code with Module Extension or Replace Type code with State/Strategy. Replace Type code with Module Extension aims to remove conditional logic. Both the original class and the module that is being extended can access the same instance variables. Modules cannot be unmixed easily. When the code is changed at the runtime and the type changes are complex enough that I cant get away with Module Extension I use State/Strategy. I often find conditionals expressions come in two forms. The first form is a check where either course is part of the normal behavior. The second is a form situation in which one answer from the conditional indicates normal behavior and the other indicates an unusual condition. You have a conditional that chooses different behavior depending on the type of an object. One of the grandest sounding words in object jargon is polymorphism. The essence of polymorphism is that it allows you to avoid writing an explicit conditional when you have objects whose behavior varies depending on their types. You can achieve polymorphism in two ways in Ruby, one by implementing the same method signature on multiples objects and call these methods polymorphically and the second by introducing inheritance hierarchy and have the method that is to be called polymorphically on the subclasses. The essence of polymorphism is that instead of asking an object what type it is and the invoking some behavior based on the answer you just invoke the behavior. An assertion technique is a conditional statement that is assumed to be always true. Goal of interface is to show only what they have to and no more. Remember your code is for a human first and a computer second. Methods should be named in a way that communicates their intention. A good way to do this is to think about the comment you would use to describe the method and turn that comment into the name of the method. A good rule to follow is to say that any method that returns a value should not have observable side effects. If you come across a method that returns a value that is used by the caller and also has side effects, you should try to separate the query from the modifier. There are two motivations here for using Replace Constructor with Factory Method. The first comes about if we need to perform this construction login in more than one place. And the second motivation is encapsulation. Exceptions are better because they clearly separate normal processing form error processing. A module should have one single responsibility, just like a class. A module that is difficult to name with the words ‚Äúhelper‚Äù or ‚Äúassistant‚Äù is probably doing too much. The main trigger for use of Extract Subclass is the realization that a class has behavior used for some instances of the class and not for others. A Ruby Class can only inherit from one superclass directly. If you want the class to vary in several different ways, you have to use delegation or module extension for all but one of them. Notice that the implementation using extension of modules is similar to the inheritance example. So why use extend instead of inheritance? The answer is that you would use extend if the modules you were creating could be used to extend various classes. By using delegation instead, you make it clear that you are making only partial use of the delegated class. Book examples: https://github. com/DominicLizarraga/refactoring_ruby_edition "
    }, {
    "id": 93,
    "url": "http://localhost:4000/2021/06/15/well_grounded_rubyist.html",
    "title": "The Well-Grounded Rubyist",
    "body": "2021/06/15 - The book is on its 3rd edition and it‚Äôs comprised of 3 parts and 16 chapters:  Ruby foundations: (chapters 1-6)The syntax is introduced, key concepts and semantics that Ruby uses, also the construction of objects, classes, modules and identifiers, code conventions, also, how to execute files from the console, how to use Gem files and finally using the Ruby interpreter (irb).  Built-in Classes and methods: (chapters 7-12)The most used built-in classes, including: String, Array, Hash, Numeric, Range, Date, Time and Regular Expressions are presented with many examples, what should you expect out of it? How to use it? How the Boolean logic works. The book has a very digested way of reading how the code is flowing, it has a numerical series where you can read from 1 to 12, step by step, line by line so that you can see how the program reads variables, re-assign them and lastly how the output reached that level, instead of jumping from one line to another.  Ruby dynamics (chapters 12-16)Here you will find the metaprogramming basics, as well as handlers for non-existing methods, how to catch up those exceptions, callbacks, hook messages and finally a functional programming example. Notes. false and cause I conditional expression to evaluate as false; all other objects including true, of course, but also including 0 an ‚Äúempty strings‚Äù caused it to evaluate to true . Variables types: locals, instance, class, global. Every object is capable of understanding a certain set of messages. Each message that an object understands corresponds directly to a- method, a name, executable routine whose execution the object has the ability to trigger. A class defines an object functionality, and every object is an instance of exactly one class period every time you create a string object, you have created an instance of the class string. Although every object is an instance of a class, the concept of class is less important than the concept of object. That‚Äôs because objects can change acquiring methods and behaviors that were not defined in their class period the class is responsible for launching object into existence, a process known as instantiation, but they‚Äôre after the object has a life of its own. The ability of objects to adopt behaviors that their class did not give them is one of the most central defining principles of design of Ruby as a language. Rather than asking in the abstract weather a = b, you ask whether it considers itself equal to B. If you want to know whether a given student is taking a class from a given teacher, you ask the student, are you student of this teacher ? There is room for debate as to whether this or that programming language, or even these or that kind of programming language, corresponds more closely than others to shape of the real world. A lot depends on how you perceive the world. Do you perceive it as people with things, each of which has task to do and waits for someone to request the task? If so, you may conclude that object oriented languages model the world best. Do you see life as a series of to-do items on a checklist, to be gone through in order? If so, you may see a strictly procedural programming language as having closer ties to the characteristics of the real world. In short there is no answer to the question of what the real world is. Designing object oriented software is largely a matter of figuring out what you want your objects to be: what they should do, how they will interact with each other, how many of each there should be . For example, many students, one register. And other such questions. To get an object to talk, you have to ask it to talk. But before you ask it to talk, you have to teach it how to talk. It‚Äôs all about asking objects to do things and tell you things. respond_to? is an example of introspection or reflection. Keywords are special reserved words that you cannot use as variable names. For example def is a keyword ; The only thing you can use it for is to start a method definition. Defining a class lets you group behaviors (methods) into convenient bundles, so that you can quickly create many objects that behave essentially the same way . You can also add methods to individual objects, if that‚Äôs appropriate for what you are trying to do in your program. But you don‚Äôt have to do that with every object if you model your domain into classes. A typical class consists of a collection of methods definition. Classes usually exist for the purpose of being instantiated that is, of having objects created instances of that class periodMovies about objects, and objects are instances of classes. The instance variable enables individual objects to remember state. Instance variables work much like other variables: you assign values to them, and you read those values back; You can add them together, print them out, and so on pivot but instance variables have a few differences: ‚Ä¢ Always start with a single @ ‚Ä¢ Are only visible to the object to which they belong ‚Ä¢ Instance variable initialized in one method inside a class can be used by any instance method defined within that class. An attribute is a property of an object whose value can be read and or written through the object. Every Ruby class can have only one superclass, in keeping with the principle of single inheritance. Ruby provides modules, which art bundles of programming functionality similar to classes (except that they don‚Äôt have instances), that you can easily graft onto your class family tree to provide as many methods for your objects as you need. Your line the idea of a class method is that you send a message to the object that‚Äôs the class rather than the one of the class instances. Like classes, modules are bundles of methods and constants. Unlike classes, models don‚Äôt have instances; Instead, you specify that you want to add the functionality of a particular module to that of a class or a specific object. No class can inherit from more than one class. In cases where you want numerous extra behaviors for a class instances and you don‚Äôt want to stash them all in the class superclass and its ancestral classes, you can use modules to organize your code in a more granular weight. When you are designing a program and you identify a behavior or set of behaviors that may be exhibited by more than one kind of entity or object, you have found a good candidate for a module. The practice of arranging objects that talk to one another in a complete program is called object-oriented design. You learn in chapter 3 that you define a method twice inside the same class, the second definition takes precedence over the first. If the object‚Äôs method lookup path includes two or more same name methods, the first one encounter is the winner and is executed. Include will make a module‚Äôs methods available as instance method. extend on the other hand, will make a modules method available as class methods. The kernel module provides an instance method called _missing. This method is executed whenever an object receives a method that it does not know how to respond to that is, a message that does not match a method anywhere in the object‚Äôs method look-up path. ‚Ä¢ Modules don‚Äôt have instances. It follows that entities or things are generally best modeled in classes, while characteristics, shared behaviors, and properties of entities or things are best encapsulated in modules. ‚Ä¢ A class can have only one superclass, but it means in as many modules as it wants. If you are using inheritance, give priority to create a sensible superclass/subclass relationship. To know which object itself, you need to know what context you are in. In practice, there are not many contexts to worry about. There is the top level ( before you have entered or after you have left any other context, such as a class definition). There are class definition blocks, model definition blocks, and method definition blocks. It‚Äôs all about self switching from one object to another, which it does when you enter a class or module definition, an instance method definition, or a Singleton method (including class method) definition. As soon as you cross a class or module keyword boundary , the class or module whose definition block you‚Äôve entered ‚Äì the Class or Module object becomes self. A simple rule governs instance variables and their resolution: every instance variable you will ever see in a Ruby program belongs to whatever object is the current object (self) at that point in the program. Using global variables tends to end up being a substitute for solid, flexible program design , rather than contributing to it. One of the main points of object oriented programming is that data and actions are encapsulated in objects. You are supposed to have to query objects for information and to request that they perform actions. And objects are supposed to have a certain privacy. When you ask an object to do something, you are not supposed to care what the object does internally to get the job done. Even if you yourself wrote the code for the objects method, when you send the object a message, you treat the object as a black box that works behind the scenes and provides a response. Global variables these sort the landscape by providing a layer information shared by every object in every context. Globally scoped data is fundamentally in conflict with the object oriented philosophy of endowing objects with abilities and then getting things done by sending request to those objects. Every definition block whether for a class, a model, a method, starts a new local scope, a new local variable, scratch pad, and get its own variable. At its simplest, idea behind a class variable is that it provides a storage mechanism that‚Äôs shared between a class and instance of that class, and that‚Äôs not visible to any other objects. No other entity can fill this role. Local variables don‚Äôt survive the scope change between class definition and their inner method definition. Globals do but they are also visible and mutual everywhere else in the program someone not just in one class. So class variables have a niche to feel: visibility to a class and its instances, and to no one else. The main business of Ruby program is to send messages to objects. And the main business of an object is to respond to messages. Sometimes, and object wants to be able to send itself messages that it does not want anyone else to be able to send it. For this scenario, Ruby provides the ability to make a method private. If you don‚Äôt use an explicit receiver for a method call, Ruby assumes that you want to send the message to the current object , self. Ruby control flow techniques include the following: Conditional execution. Execution depends on the truth of an expression. Looping. A single segment of code is executed repeatedly Iteration. a call to a method is supplemented with a segment of code that the method can call one or more times during its own execution. Exceptions. Error conditions are handled by special control for rules. After all, when you call a method on an object, control is passed to the body of the method ( 8 different scope); And when the method has finished executing, control returns to the point right after the point where the method call took place. The difference between a method call with a block and a method call without a block comes down to whether or not the method can deal. If there is a block, then it can; If not it cannot, because there is nothing to deal to. An Exception is a special kind of object, an instance of the class exception or a descendant of that class period raising an exception means stopping normal execution of the program and either dealing with the problem that‚Äôs being encountered or existing the program completely. It‚Äôs generally considered good practice to catch a specific exceptions rather than simply using rescue to catch all exceptions. ensure clause is executed whether an exception is raised or not. In short it is packed to begin/end structure of which it is a part, and its execution is unconditional. The fact that you can define an even redefine elements like the + -, and square brackets means that Ruby has a great deal of flexibility. But there are limits of what you can redefining will be. You can‚Äôt where they find any of the literal object constructors: {} it‚Äôs always a hash literal (or a code block, if it appears in that context), ‚Äú‚Äù we‚Äôll always delimit a string, and so forth. One consideration, weighing in on the side of modifying objects instead of creating new ones, is efficiency, creating new objects is expensive in terms of memory and processing. All that matters is what the object can do, what methods it can execute. Nil does exist. Single values, such as integer and strings, as opposed to collection or container objects that hold multiple values are considered as a scalar. Symbols aren‚Äôt unique. Whenever you see xyz, you are seeing a representation of the same object. Again, symbols are more like integers than strings in this respect. When you see the notation ‚Äúxyz‚Äù in two places, you are looking at representations of two different string objects; The literal string constructor ‚Äú‚Äù creates a new string. But :xyz is always the same Symbol object, just as 100 is always the same object. Symbols are immutable. There is no such thing as appending characters to a symbol; Once the symbol exists, that‚Äôs it. You will never see :abc ¬´¬†:d or anything of that kind. Symbols have a number of users, but most appearance fall into one of two categories, method arguments and hash keys. Well we can process symbol faster. Whereas the strings have a malleability that‚Äôs a good fit for their presentation of arbitrary values. Strings being mutual, symbols not. Symbols share with integers not only immutability and uniqueness but also immediacy: a variable to which a symbol is bound provides the actual symbol value, not a reference tweet. Any class that aspires to be innumerable must have an each method whose job is to yield items to a supply code block , one at a time periodNumerators are closely related to eaters, but they are not the same thing period and iterate are is a method that yields one or more values to a code block. And enumerator is an object, not a method, therefore maintain state. An Enumerator can add innumerably to objects that don‚Äôt have it. It‚Äôs a matter of wiring: if you hook up and enumerators each method to any iterate are, then you can use the numerator to perform innumerable operations on the object that owns the iterator, whether that object considers itself innumerable or not. Here is the source code https://github. com/jleo3/twgr "
    }, {
    "id": 94,
    "url": "http://localhost:4000/2021/05/30/practical_oriented.html",
    "title": "Practical Object-Oriented Design (POODR)",
    "body": "2021/05/30 - This book is the second edition that Sandi Metz publishes and it‚Äôs even considered as a must-read by the RoR community, give it a shot you won‚Äôt regret at all no matter what language you‚Äôre coming from. The introduction gives you why we want to work at a place where we feel as if we had some real impact, without being painful and why not make it funny as well, also explores the idea of increasing the productivity and reducing costs associated with poor design software. It goes over some agile methodology; it brings up the ‚ÄúAgile Manifesto‚Äù and explores its points of intersection between project management and software development. The core example of the book is a Bicycle store and it starts with the most simple but thorough class and it gradually increases its complexity always by giving you the reason why would you for instance need to add spare parts method to the main class or create a new one from scratch, what are the benefits and downsides? Is the customer really requesting this? What if we go beyond the scope of the app and make it flexible since the beginning? And finally, you end up with a Bicycle store and an app to book trips. üö≤ üèî It offers many examples of all the good practices or rules you may find below and gives you the before and after of each scenario, and you can find the most important examples in my repository. https://github. com/DominicLizarraga/refactoring_ruby_edition Chapter 1. ‚ÄúObject-Oriented Design‚Äù Encourages you to shift your thinking from a world of collection of predefined procedures to modeling the world as a series of messages that pass between objects. It depicts that statement with an example of a woman waking up at the same hour, preparing her coffee and suddenly steps on the cat, causing a reaction that was not on the normal routine. üêà It also elaborates on the idea that the only sure thing that will happen is that your app will need some changes, it‚Äôs impossible to never change. It includes some customer perspective and how the client doesn‚Äôt not even know what they want so you must be ready for progressive modifications. ‚ÄúYou must combine an overall understanding of your application‚Äôs requirements with knowledge of the costs and benefits of design alternatives and then devise an arrangement of code that is cost effective in the present and will continue to be so I the future. ‚Äù ‚ÄúThe purpose of design is to allow you to design later, and its primary goal is to reduce the cost of change. ‚Äù The chapter 2. ‚ÄúDesigning Classes with a single responsibility‚Äù The foundation of an object-oriented system is the message, but the most visible organizational structure is the class. Your goal is to model your application, using classes, such that it does what it is supposed to do right now and is also easy to change later. Creating an easy-to-change application, however, is a different matter. Your application needs to work right now just once; it must be easy to change forever. The problem is not one of technical knowledge but of organization; you know how to write the code but not where to put it. When it says easy to change it means the following: ‚Ä¢ changes have no unexpected side effects, ‚Ä¢ small changes in requirements require correspondingly small changes in code, ‚Ä¢ existing code is easy to reuse, and ‚Ä¢ the easiest way to make a change is to add code that in itself is easy to change. A class should do the smallest possible useful thing; that is, it should have a single responsibility. Chapter 3. ‚ÄúManaging Dependencies‚Äù Because well-designed objects have a single responsibility, their very nature requires that they collaborate to accomplish complex tasks. This collaboration is powerful and perilous. To collaborate, an object must know something know about others. Knowing creates a dependency. Ig not managed carefully; these dependencies will strangle your application. Your design challenge is to manage dependencies so that each class has the fewest possible; a class should know just enough to do its job and not one thing more. To some degree of dependency between these two classes is inevitable; after all, they must collaborate. When two (or more) objects are so tightly coupled that they behave as a unit, it‚Äôs impossible to reuse just one. Every dependency is like a little dot of glue that causes your class to stick to the things it touches. A few dots are necessary. If prevented from achieving perfection, your goals should switch to improving the overall situation by leaving the code better than you found it. If you get this right, your application will be pleasant to work on and easy to maintain. If you get it wrong, the dependencies will gradually take over and the application will become harder to change. Depend on things that change less often than you do. Injecting dependencies creates loosely coupled objects that can be reused in novel ways. Isolating dependencies allows objects to quickly adapt to unexpected changes. The key to managing dependencies is to control their direction. Chapter 4. ‚ÄúCreating Flexible Interfaces‚Äù It‚Äôs easy to think about object-oriented applications as being the sum of their classes, they are so very visible; and they spin around responsibilities and dependencies. There is design detail that must be captured at that level, but an object-oriented application is more than just classes. It is made up of classes but defined by messages. Classes control what‚Äôs in your source code repository; messages reflect the living, animated application. Design therefore, must be concerned with the messages that pass between objects. It deals not only with what objects know (their responsibilities) but also with how they talk to one another. The conversation between objects takes place using their interfaces; this chapter explores creating flexible interfaces that allow applications to grow and to change. Imagine two running applications. Each consists of objects and the messages that pass between them. In the first application, the messages have no apparent pattern. Every object may send any message to any other object. If the message left visible trails, there trails would eventually draw a woven mat, with each object connected to every other. In the second application, the messages have a clearly defined pattern. Here the object communicates in specific and well-defined ways. If these messages left a trail, the trails would accumulate to create a set of islands with occasional bridges between them. The second application is composed of a pluggable, component-like objects. Each reveals as little about itself, and knows as little about others, as possible. The design goal, as always, is to retain maximum future flexibility while writing only enough code to meet today‚Äôs requirements. Drawing this sequence diagram exposes the message passing between the objects. The best possible situation is for an object to be completely independent of its context. An object that could collaborate with others without knowing who they are or what they do could be reused in novel and unanticipated ways. Your goal is to write code that works today, that can easily be reused, and that can be adapted for unexpected use in the future. Object-oriented applications are defined by the messages that pass between objects. This message passing takes place along ‚Äúpublic‚Äù interfaces; well-defined public interfaces consists of stable method that expose the responsibilities of their underlying classes and provide maximal benefit at minimal cost. Chapter 5. ‚ÄúReducing Costs with Duck Typing‚Äù The purpose of object-oriented design is to reduce the cost of change. Duck typed objects are chameleons that are defined more by their behavior than by their class. Avoid getting sidetracked by your knowledge of what each argument class already does; think instead about what the object needs. Concrete code is easy to understand but costly to extend. Abstract code may initially seem more obscure, but once understood is far easier to change. Recognizing hidden ducks. Case statements that switch on class Uses of method: kind_of? and is_a? responds_to? Polymorphism in OOP refers to the ability of many different objects to respond to the same message. Duck typing reveals virtual underlying abstractions that might otherwise be invisible. Depending on these abstractions reduces risks and increases flexibility, making your application cheaper to maintain and easier to change. Chapter 6. ‚ÄúAcquiring Behavior through Inheritance‚Äù This chapters offers a detailed example of how to write code that properly uses inheritance. The idea of inheritance may seem complicated, but as with all complexity, there‚Äôs a simplifying abstraction. Inheritance is, at its core, a mechanism for automatic message delegation, if and object cannot respond to a received message, it delegates that message to another. A superclass can have many subclasses, but each subclass is permitted have one superclass. Creating hierarchy has costs; the best way to minimize these costs is to maximize your chance of getting the abstraction right before allowing subclasses to depend on it. The best way to create an abstract superclass Is by pushing code up from concrete subclasses. Chapter 7. ‚Äúsharing Role Behavior with Modules‚Äù To reap benefits from using inheritance you must understand not only how to write inheritable code but also when it makes sense to do so. Use of inheritance is always optional; every problem that it solves can be solved another way. Because no design technique is free, creating the most cost-effective application requires making informed tradeoffs between the relative costs and likely benefits alternatives. When formerly unrelated objects begin to play a common role, they enter into a relationship with the objects for whom they play the role. Many object-oriented languages provide a way to define a named group of methods that are independent of class and can be mixed in to any object. In ruby these mix-ins are called modules. When objects that play a common role need to share behavior, they do so via a Ruby module. When a class includes a module, the methods in that module get put into the same look path as methods acquired via inheritance. Chapter 8. ‚ÄúCombining Objects with Composition‚Äù Composition is the act of combining distinct parts into a complex whole such that the whole becomes more than the sum of its parts. Music for example, is composed. You can create software this same way, by using object-oriented composition to combine simple, independent objects into larger, more complex wholes. A bicycle has parts. Bicycle is the containing object, the parts are contained within a bicycle. The Bicycle class is responsible for responding to the spares message. This spares message should return a list of spare parts. The more parts an object has, the more likely it is that it should be modeled with composition. Composition, classical inheritance and behavior sharing via modules are competing techniques for arranging code. Each has different costs and benefits; these differences predispose them to be better at solving slightly different problems. Chapter 9. ‚ÄúDesigning Cost-Effective Tests‚Äù Without tests, these applications can be neither understood nor safely changed. They add value without increasing costs. These are notes I took from the book, nothing is mine. "
    }, {
    "id": 95,
    "url": "http://localhost:4000/2021/05/29/example.html",
    "title": "Example",
    "body": "2021/05/29 - Test photo! "
    }, {
    "id": 96,
    "url": "http://localhost:4000/2021/05/23/eloquent-ruby.html",
    "title": "Eloquent Ruby",
    "body": "2021/05/23 - This is book is not for learning the very basics of Ruby, it‚Äôs more for people who have played with the language, the console and maybe built simple web app, I say this because it assumes you know what is an array, how you can manipulate or work with it therefore the book only shows shortcuts for instance methods on arrays, the correct usage of bang (!). I contains 3 sections after each chapter, staying out of trouble, in the wild and to wrap up, which has the most important takeaway after the lesson, i. e. ‚ÄúChoose the right control structure‚Äù, a real example from a codebase and finally a summary of what it went over. The book navigates each lesson through a kind of library system where a Document is created with its author, it plays with the first name and last name of the author, then it adds it to an array, then to a hash in order to have it more well organized. It will refresh you some basics methods like inject, map, sort, reverse, push, pop, delete, shift with the bang and without it always keeping in mind that Ruby is an idiomatic language. The book dedicates one chapter to learn how to work and mutilate this String class which is something Ruby is pretty smart and after that String brush up it goes to the Regular Expression, It shows you only the basics of how to validate an e-mail, address how to format a date, and it helps you find it easy to use instead of the intimidating appearance it seems to be. It has a deep chapter on the usage of symbols, it shows you the difference between a symbol and just string, it brings the symbol characteristics, it‚Äôs immutability, its better performance and it‚Äôs memory space utilization. The core of Ruby on Rails, everything is an object, shows you the keywords, how to treat the self, some instance methods in order to know what class is the object you are evaluating, it also presents why treating everything as an object is a good way because it provides consistency to your application, the difference between public, private, protected methods. how to require external libraries like date for instance and it closes remembering us that virtually everything in Ruby is an object, and virtually all of those objects inherit the basic set of methods from the Object class. Engineering is all about tradeoffs. just about every engineering decision involves getting something, but at a price, and there is a price to be paid for dynamic typing. In the chapter 8 lays out the difference between dynamic and static programming languages and encourages you to write tests which is the best way 2 make sure your code works as it should, do you need to test it early, you need to test it often, and you certainly need to test it whenever you change it. The tests framework used on this book are Unit::Test and RSpec it shows you how to start those tests and make them work with their document class. The author Hardly stresses how important is to write test in order to know how your code is working there is no shortcut, there is no easy way it would save you tons of hours if you do it often. The part II of the books goes over the back bone of the language, in this case Classes, Modules and Blocks. Despite shelves full of books on software architecture, and UML diagrams to fill an Art Museum and design meeting that seem to last longer than the pyramids, building software mostly comes down to writing one method after another, methods that stick to doing one thing and doing it well. Composing methods for humans, this technique advocates dividing your class up into methods that have three characteristics. first, each message should do a single thing , focus on solving a single aspect of the problem. by concentrating on one thing, your methods are not only easier to write, they are also easier to understand. second, each method needs to operate at a single conceptual level: Simply put, don‚Äôt mix high level logic with the nitty-gritty details. a method that implements their business logic around say, currency conversions, should not suddenly veer off into the details of how the various accounts are sorted in the database. Finally, each method needs to have a name that reflects its purpose. nothing new here, we have all heard endless lectures about picking good method names. the time to listen to all of them haranguing is when you are creating lots of little methods that you are trying to put together into a functional whole. Why is building small, well named methods that do one thing such a good idea? it‚Äôs not about writing better code for the computer, because the computer does not care. you can code the same algorithm in a handful of large methods or in a myriad of little message and , as long as you‚Äôve gotten the details right, the computer will give you exactly the same answer. the reason you should lean towards smaller methods is that all those compact, easy-to-comprehend methods will help you get the details right. Short, easily comprehending methods also have some secondary advantages as well. take the old bit of coding advice that every message should have exactly one way out, so that all of the logic converges at the bottom for a single return. the key to preventing your compose methods from turning on you is to remember that every method should have two things going for it. First, it should be short. and second, it should be coherent. In plain English, your method should be compact, but it should also do something. Unfortunately, since short is so much easier to remember than coherent, programmers will sometimes go too far in breaking up their methods. There is also a chapter that teaches you how to modify normal operators (&lt;, &gt;, +, -, =, %, *) and change their behavior totally, it demonstrates the ups and downs of defining your own operators, and what are they consequences for others users if they don‚Äôt know what outcome will they get. Chapter 12 and 13 explore the idea behind equality classes, how you can leverage the custom operator by giving them another behavior, how equal? is different from ==, or even ===; all of them have different meaning and the author breaks them all down, next it touches the Singleton and class methods what are their uses, when should you use them, how are they built and again they differences. The usage of Class instance variables, instance variables and modules, what are the benefits , the caveats, what happen if a name collision takes place, what can they hold, what are the risks of over using a module and one of the keys of programming which is naming these instances, those classes, these modules. How to include that module into a Class, how to extend the usage of that module, and also how is the look-up procedure when you call a method (Inheritance tree). An easy rule of thumb for naming modules is that if you find yourself creating a lot of names that all start with the same word, perhaps ‚ÄòTonsOTonerPrintQueue‚Äô and ‚ÄòTonsOTonerPrintAdministration‚Äô, then you just may need a ‚ÄòTonsOToner‚Äô module. The book also covers iterators with 3 chapters, they‚Äôre different ways of calling, the usage of yield (Execute around), the naming convention, how to enable a class to use more than 40 methods coming from the enumerable module, the usage of rescue, begin, raise; Come on errors when using execute around which can be for instance forget about exceptions; because execute around is all about warranties. The whole idea of execute around is that the color is warranty that this will happen before the code fires and that will happen after. The technique ‚Äúexecute later ‚Äú is when you add a parameter prefix with an ampersand, some practical examples of lambdas and procs as well and lastly it touches some of the metaprogramming topics to modify subclasses, to use the method_missing method In order to rescue one execution and provide an exception. Updating existing classes, fixing broken classes, what is the monkey patching? Dealing with DSL and XML, what are the Gems package, how to consume them, nuts and bolts of gems, where are they located and also how to build a gem publish them and make it public. "
    }, {
    "id": 97,
    "url": "http://localhost:4000/2021/04/01/beginning.html",
    "title": "Beginning Rails 6 üöá",
    "body": "2021/04/01 - This book takes you from the straightforward ‚Äúrails new blog ‚Äìd=postgrsql‚Äù to adding active jobs and sending automated emails; it goes step by step so that you can see gradually the app development, it has more than 500 pages with 18 chapters; it touches the very basics of Ruby in the 4th just in case the reader has no experience with this language however Rails is very intuitive and easy to follow along. As you may read the main web app that is built along with this book is a blog where an user can sign-in/ log-in with email and password, can post with ‚ÄúRich Text‚Äù (attach images, modify font, color, size), can edit its own posts, can comment on other‚Äôs posts and finally can delete only posts that user has created. Articles are the epicenter of the application. It uses the most common Gems in order to get the app up and running, it helps you add the gem to translate the app into different languages (Spanish, Portuguese, etc. ), it helps you enable the active storage gem which is used like a cloud storage (comes by default with Rails), explains you the differences between CSS and SCSS, also how to connect JavaScript, what is it for?, action text, Ajax, Action Cable and finally it uploads the app to Heroku (Cloud platform to host your app) in order to grant access anyone in the world. It was also the first book I‚Äôve read that contains the whole Action Pack broken down, routes, controllers, views, which means Action Controller, Action View and Action Dispatch respectively in addition the whole request cycle, who are the actors, what is DNS for? And lands all of this with a CD player in a car example, pretty clear for me. Notes. ‚úçüèª A framework is a collection of libraries and tools intended to facilitate development. Design with productivity in mind a good framework provides a basic but complete infrastructure on top of which to build an application. Why choose Rails? üõ§ It provides a powerful database abstraction layer called active records, which works with all popular data based systems. It chips with a sensible set of defaults and provides a well-proven, multi-layer system for organizing programs files and concerns. Its goal as a framework is to solve 80% of the problems that occur in web development, assuming that the remaining 20% are problems that are unique to the applications domain; you get to focus on just 20% which is what really matters. With rails, you can respond to the needs of customers quickly and easily, and rails works well during collaborative development. It has the famous convention over configuration, ‚Äúdon‚Äôt repeat yourself‚Äù (DRY), the concepts of rapid prototyping and that ‚Äúyou ain‚Äôt gonna need it‚Äù (YAGNI) Philosophy, closing the gap between customer and programmer. Programming is all about making decisions. If you were to write a system from scratch, without the aid of rails, you would have to make a lot of decisions: how to organize your files, what naming conventions to adopt, and how to handle databases access are only a few. Rails lets you start right away by encompassing a set of intelligent decisions about how you program should work and alleviating theamount of low-level decisions making you need to do up front. As a result, you can focus on the problems direct trying to solve and get the job done more quickly. Although you can manipulate most things in the Rails setup and environment, the more you accept the defaults, the faster you can develop applications and predict how they will work. If you put your files in the right place and name them according to the right conventions, things just work. If you are willing to agree to the defaults, you‚Äôre generally have less code to write. The more duplication exists in a system, the more room box has to hide. Ruby is known for making certain programmatic constructs look more natural by way of what‚Äôs called syntactic sugar. Rails has popularized the term synthetic vinegar coma is the exact opposite of syntactic sugar: awkward programmatic constructs are discouraged by making their syntax look sour. Rails employs a time honored and well-established architectural pattern that advocates dividing application logic and labor into three distinct categories: the model, view, and controller. In the MVC pattern, the model represents the data, the view represents the user interface, and the controller directs all the action. The real power lies in the combination of the MVC layers. Using the pain of maintenance considerably while increasing the level of ability among components. Models. in rails, the model layer represents the database. For example, a model called User convention, would map to a table called users. All the rules for data access, associations, validation, calculations and routines that should be executed before and after save, update or destroy operation and nearly encapsulated in get model. Controllers. It is the controller‚Äôs job to fill with requests coma like processing server variables and formatting data, asking the model for information, and sending information back to the model to be saved in the database. It sets up variables to be used in the view, and then proceeds to render or redirect to another action after processing is complete. Controllers typically manage a single area of an application. For example, in a recipe application, you probably have a controller just for managing recipes. Inside the recipes controller, you can define what are called actions. Actions describe what a controller can do. If you want to be able to create, read coma update and delete recipes, you create appropriately named actions in the recipe‚Äôs controller. When a request comes into a controller, it uses a URL parameter to identify the action to execute; And when it is done, it‚Äôs sensory response to the browser. Their response is what you look at next. Views. The view layer in the MVC forms the visible part of the application. In rails, views are the templates that (most of the time) contain HTML markup to be rendered in a browser. It‚Äôs important to note that views are meant to be free of all but the simplest programming logic. Any direct interaction with the model layer it should be delegated to the controller layer, to keep the view clean and decouple from the applications business logic. active_record: a library that handles database abstraction and interaction. Action view: a templating system that generates the HTML documents the visitor gets back as a result of a request to a rails application. Action controller: a library for manipulating both application flow and the data coming from the database on its way to being displayed in a view. New lane these libraries can be used independently of rails one of another. Together, they form the rails MVC development stack. Rails is modular. One of the greatest features of rails is that it was built with modularity in mind from the ground up. Although many developers appreciate the fact that they get a full stack, you may have your own preferences in libraries. In the real world, specifications above as we learn how real users interact with our web applications. Chapter 3, goes to explain how is the rails architecture distributed, what are the files inside of each folder, how to start writing our first migration, execute it, how to add validations to the model, add more fields to the model, and also, how to rollback a migration in case you make a mistake or you did not add something important, it is always reversible. Chapter 4, explains why Ruby is dynamic, how you can use the IRB prompt, what are the Ruby data types such as string, numbers, symbols, arrays and hashes. what are variables, what are they for, and they need do not specify a data type for the variable or the find it in your code before you use it. What are the best practices for naming variables, in this case long and descriptive. Blocks and iterators, comments, control structures, methods. And finally, a brief introduction to object-oriented programming, objects and classes. A key feature of active record which maps table to classes, table rows to object, and table columns to object attributes. This practice is commonly known as object relational mapping (ORM). rails db:system:change -Which makes it easy to switch databases. Active Record provides the link between these classes and your tables, allowing you to work with what look like regular objects, which, in turn, can be persisted to the database. This frees you from having to write low level SQL to talk to the database. Object oriented programming is all about objects. You create a class that encapsulates all the logic required to create an object, along with its properties and attributes, and use the class to produce new objects, each of which is in unique instance, distinct from other objects of the same class. That means sound a little abstract (and with good reason abstraction, after all, is the name of the game) but if it helps you can think of a class as being an object factory. Classes are used to create objects, and objects have attributes. Every object has a unique set of attributes different from other objects of the same class. A return of nil always represents nothing. The new constructor creates a new object, but it is your responsibility to save it. If you forget to save the object, it will never be written to the database. To summarize, when you want to create a new object and save it manually, use the new constructor; When you want to create and save in one operation, use create. update_attributes is an instance variable if you want to update attributes in just one operation. The following call works for deleting or what‚Äôs inside the array Article. delete([1, 2, 3]) The primary way in which you enhance models is by adding methods to them. This is referred to as adding domain logic. With active record, all the logic for a particular table is contained in one place that model. This is why the model is set to encapsulate all the domain logic. This logic includes access rules, validations, relationships, and well, just about anything else you feel like adding. user. build_profile(attributes={}) Returns a new profile object that has been instantiated with attributes and linked to user through a foreign key but has not yet been saved. user. create_profile(attributes={}) Returns a new profile object that has been instantiated with attributes and linked to user through a foreign key that has already been saved. Their rule of thumb is that belongs_to declaration always go in the class with the foreign key rails db:setup Command recreates the database and adds the seat data as you may expect. Whenever you want to add a validation error to the list of errors, you just type errors. add(column_name, error_message). Action Controller. Orchestrate your applications flow. Every time a user requests a page, submits a form, or clicks a link, that request is handled in one way or another by a controller. A typical controller is most often a collection of actions that relates to a specific area of concern. For example, consider the blog application you have been building in the previous chapters. The controller that manages articles has the class name articles controller and has action methods for listing, creating, updating, reading, and deleting articles. The controller looks for a view whose name matches they requested name action. Action View. this library is another important part of action pack. Given that controllers are responsible for handling the request and issuing a response, views are responsible for rendering the output of a response in a way a browser or any other user agent can understand. The primary mechanism by which they do is through shared variables. All instance variables that you may see in a view comes from the controller; look at the view is not handling any logic to fetch the list of these articles. Action Pack. routing salt this problem by decoupling the URL from the underlying program implementation. Request cycle Then type request to response process is called the action pack request cycle. They request cycle consists of the following steps:Rails receives a request from the outside world (usually a browser). routing picks apart the request to determine the controller and action to invoke. A new controller object is instantiated, and an action method is called. The controller interacts with the model (usually performing a CRUD operation in a database with an Active Record model, but not necessarily). A response is sent back to the browser, in the form of either a render or a red direct. HTTP verbs The HTTP protocol defines several request methods, the most popular of which art GET and POST. Both our method for requesting a webpage; The differences in how the request is sent. GET is the simpler of the two period it includes all the information about the request as a part of the URL. POST sends information in visibly, which is to say as a part of the request header and not part of the URL so you cannot type a post request into your browser‚Äôs locations bar. How do you know when to use each? The best way to think of this is to consider GET high as read method. It should never do anything destructive, such as modifying a database record. POST, on the other hand, can be thought of as a writer method. When you need to create data, use POST. PATCH is used when you need to update a record partially, for instance, only changing your e-mail address. PUT is used to update a record completely. Most of the time, our controllers handle interactions with a collection of things, so we reflected by using a plural name. Comments are interesting because they are a little different from our other models so far. Comments depend on a particular article; They never exist on their own because they are conceptually meaningless if they are not tight to an article. Remember that you always have the article_id in your parameters because it is always included in your nested name routes. Also notice how you find they assign comment you do so using @article. comments. HTTP is a stateless so how can the application remember you are logged in if HTTP is a stateless? The answer is that you fake state with session object. Example: session[:account_id] = @account. id. Notice that you define session as a resource and not resources, because you never deal a set of sessions at once. The rule of thumb is that whenever you have data that are provided by the user, you cannot trust them blindly . You need to escape it. This includes model attributes as well ask parameters. Fortunately, railes escapes all rendered as strings for you. html_safe method skips the HTML escaping process. simple_fromat method Convert text to HTML using simple formatting rules. The chapters of Active Storage, how to implement Ajax (was implemented for creating and deleting comments, interacted with the DOM with a . js file where all the code for doing this was placed) and sending and receiving email (Action Mailer and Action Mailbox) is difficult to describe but overall those chapters are pretty neat, I‚Äôd say more than https://guides. rubyonrails. org/. Active Job chapter covers the configuration, the creation, the exception handling, retry, discard and finally it has a benchmark exercise where the perform_later method on the mail delivery improved significantly the app performance. This is the first time I faced Active Model, before this one I didn‚Äôt know it existed, the book take that module to build an EmailAFriend without the need to create the whole model as Article for example and with all the benefits a model implies, Active Record, callbacks, validations, attributes and so on. The Action Cable chapter is short, explains how HTTP is the normal way the web works, then how web sockets were introduced as a bidirectional server communication and after that it just lays out the four main concepts as connections, channels, streams, broadcasting, subscription and so on, it configures it and apply the broadcast to Article so every time one article is published it will appear at the top without refreshing and start the cycle from the beginning. The last 3 chapters covers testing, internationalization and the upload to Heroku, the first on them emphasize the importance of always test after each small change, and why the didn‚Äôt apply test to follow along, they bring up the technical debt, refactoring. what tools are outside to automate the testing like Unit::Test, fixtures, validations and lastly the 4 types of tests, for models, for controllers, mailers and system, it doesn‚Äôt go deep into the weeds, it only explain what they are. "
    }, {
    "id": 98,
    "url": "http://localhost:4000/2021/02/21/ruby_way.html",
    "title": "The Ruby Way",
    "body": "2021/02/21 - The book is on its third edition, it has had plenty of space as the must-read for every Ruby programmer, many great personalities in the software development community have commented, praised, written about this book (including Yukihiro ‚ÄúMatz‚Äù Matsumoto, the creator of Ruby) because a few years after Ruby was conceived the first edition was published, and as everything evolved, the book has done as well. This time the background of the beginning of this language is presented, how Matz thought in terms of design and usage for building this language, it went from the approach machine-centered paradigm to a human-centered one. Ruby strives to be friendly to the programmer, and with that in mind, we can rely on a completely new style of software development, more strategically then tactic, easier to read, needlessly to add comments. This piece has 22 chapters, and more than 700 pages; it covers the conception of the language, introduction to object orientation, basic syntax and semantics, working with strings, symbols, ranges, numbers, times and dates and of course our arrays, hashes and other Enumerables, also, goes over more advanced data structures like trees, graphs, sets, stacks and queues. It brings the difference between static and dynamic languages, testing, how to handle different data formats, how is related Ruby and web applications, and more stuff that you can leverage in order to cement draw Ruby fundamentals. To me it was the longest book I‚Äôd ever had in my hands, quite hard to start to be honest but as soon as you pass the first pages you get caught, it refreshed me a ton of built in methods for the most important data structures, and when I say a ton, it‚Äôs about 80% of all what you need (very comfy way to read these methods on the book, and with the method description more friendlier) , so very well thought from the author perspective, not hard theory to digest, only practical examples and a few debates between 2 different points of view but nothing abstract. I think is a good start for people who want to harden their programming skills because it covers many topics of software development, it doesn‚Äôt matter what language you come from, it works for processing text files, web development, graphical interfaces, some algorithms to get familiarized with. Notes. ‚úçüèª An object is an entity that serves as a container for data and also controls access to the data. Associated with the object is a set of attributes, which are essentially no more than variables belonging to the object. Also associated with an object is a set of functions that provide an interface to the functionality of the object, called methods. It is a essential that any OOP language to provide encapsulation. The class may be thought of as the blueprint or pattern; The object itself is the thing created from that blueprint or pattern. A class is often thought of as an abstract type, a more complex type than, for example, an integer or character string. Inheritance is a mechanism that allows us to extend previously existing entity by adding features to create a new entity. In short, inheritance is a way of reusing code. Easy effective code reuse has long been the Holy Grail of computer science, resulting in the invention decades ago of parameterized subroutines and code libraries. Multiple inheritance he‚Äôs probably the most controversial area in OOP; one camp will point out the potential for ambiguity that must be resolved. It is conceivable that a new class could inherit from more than one class. Diamond inheritance problem, so-called because of the shape of its inheritance diagram, with both super classes inheriting from a single common superclass. The literal meaning of polymorphism is the ability to take on multiple forms or shapes. In its broadest sense, this refers to the ability to different objects to respond in different ways to the same message (or method invocation). The first, inheritance polymorphism, is what most programmers are referring to when they talk about polymorphism. When a class inherits from its superclass we know that any method present in the superclass is also present in the subclass. The second kind of polymorphism Conway identifies is interface polymorphism. This does not require any inheritance relationship between classes; It only requires that the interface of the object have met thoughts of a certain name. A module consists of methods or constants that may be used as though they were actually part of the class or object; When a module is mixed in via the include statement this is considered to be a restrictive form of multiple inheritance. By rivals are used to hold reference to objects. A module is a collection of methods and constants that is external to the Ruby program. The private level means that the method is accessible only within the class or its subclass. Ruby is a dynamic language in the sense that objects and classes may be altered at runtime. Will be has the capability to construct and evaluate pieces of gold in the course of executing the existing statically coded program. This is perhaps the most difficult area a programmer will encounter in learning Ruby. Everything is intuitive once you understand it. Everything is true except false and nil. many languages have some kind of for loop, as does Ruby. The question sooner or later arises as to whether the index variable can be modified. Any object can be in principle converted to some kind of string representation; That is why nearly every quarter class has a to_s method. A symbol is like a string in that it corresponds to a sequence of chapters. It is unlikely string in that each symbol has only one instance (just as a fixed number works). Therefore there is a memory or performance issue to be aware of. The &amp; notation allows us to pass a proc instead of an explicit attached block if we want. Because we use the &amp; on an object that is not a problem interpreter tries to call to_call on that object. It will call it repeatedly, once for each element in the right. The collect method (part of innumerable) is a useful tool that proves to be a time and labor saver in many circumstances. If you want to delete all instances of a certain piece of data, delete would do the job. The compact method (or it‚Äôs in place version compact!) removes nil values from an array, leaving the rest untouched. The delete_if passes every element into the supply block and delete the elements for which the block evaluates to true. It behaves similarly to reject!, except that the latter can return when the array remains unchanged. They reject method takes a block and produces a new array without the elements for which the block returns true. Bear in mind that +, concat, and even +=always create a new array object. Also bear in mind that while ¬´¬†adds to the existing array, it happens a new array element (which may itself be an array). What makes a collection enumerable ? Largely it is just the fact of being a collection. The module enumerable has the requirements that the default iterate each should be defined. Sequence as such is not an issue because even on unordered collection can have any generator. And enumerator is basically an object that can be used for external or internal iteration. In internal iteration, we simply iterate over each item in the collection and execute the block for each item in the sequence; External iteration means that the code can grab the next item in the sequence ‚Äúon demand‚Äù. There are many other methods on Enumerable, and I cover most of them here. For convenience, I have divided them a little arbitrarily in four areas: searching and selecting, counting and comparing, iterating, and finally extracting and converting . The purpose of inheritance, of course, is to add or enhance functionality. It‚Äôs not always necessary to use super in such a way, but it is often convenient. Every attribute and method of the point is reflected in the child. The child can have additional attributes and methods, as you have already seen. The child can override or redefine any of the attributes and methods of the parents. If we invoke a method on a subclass, the method for that class will be called if it exists. If it does not the method in the superclass will be called, and so on. When we create a new structure template by calling Struct . New we may pass a string with the class name as the first argument. If we do come a new class is created where in class Struct itself, with the name passed in as the first parameter and the attributes given as the rest of the parameters. Every time you invoke a method, you are sending a message to an object. "
    }, {
    "id": 99,
    "url": "http://localhost:4000/2021/01/22/agile.html",
    "title": "Agile web Development with Rails 6 üõ§",
    "body": "2021/01/22 - This was the first Rails book I read and caught me with the real example it takes you through, you‚Äôll be building an online shop and the author goes from installing Rails, ruby and other libraries to finally code some automations and uploading to Heroku, you can either follow the book or at the beginning of each chapter you can download the final version of the app so that you will never lose track of what is being presented, also, brings a summary after lesson and has a playtime section where you can push yourself to do a bit more of the exercises. In addition something I find very interesting in the book is that the foreword and some sections in each chapter DHH had the opportunity to share either his experience or advice regarding the current topic and he, being the creator of this framework and having built a company on top of it (Basecamp and Hey), I consider it as a nugget of information. Lastly, this is the book that has the best explanation about how Action Pack, Action Controller, Action View, Action Dispatch work together; it dedicates 1 chapter to just explain how routes get match to the controller and their actions and how are they converted into views. Very immaculate. Let‚Äôs begin with chapter 2 (1st is about installing all the stuff) The first example is to show the reader how to use the rails command, in this case the author creates a demo app with two views and one controller, after that it creates a couple of links in order to show how works, nothing fancy so far. Next chapter goes over the MVC architecture, the model is responsible for maintaining the state of the application. Is more than data; It enforces all the business rules that apply to the that data. For example, if a discount should not be applied to orders of less than $20, the model enforces the constraint. The model acts as both a gatekeeper and a data stored. That view is responsible for generating a user interface, normally based on data in the model. For example, an online store has a list of products to be displayed on a catalog screen. The list is accessible via the model, but it is a view that formats the list for the end user. Debut itself never handles incoming data. Controllers on the other side, orchestrate the application. They receive events from the outside world (normally, user input), interact with the model, and display an appropriate view to the user. The MVC architecture was originally intended for conventional GUI applications, where developers found that the separation of concerns led to far less coupling which in turn made the code easier to write and maintain. Each concept or action was expressed in a single, well known place. In a Rails application, an incoming request is first sent to a router, which works out where in the application the request should be sent and how the request should be parsed. Ultimately, these face identifies a particular method (called an action in rails parlance) somewhere in the controller code. The action might look at data in the request it might interact with the model, and it might cause other actions to be invoked. Eventually the action prepares information for the view, renders something to the user. The routing component receives the incoming request and immediately picks it apart. The request contains a path (/line_items?product_id=2) and a method (this button does a POST operation; Other commands methods are GET, PUT, PATCH and DELETE). In this case, Rails takes the first part of the path line_items as the name of the controller and the product_id as the id of the product . By convention, POST methods are associated with create actions. They create method handles user requests. In this case, it finds the current user shopping cart when parentheses which is an object managed by the model). It also asks the model to find the information for product 2. It then tells the shopping cart to add the product to itself. Object relational mapping (ORM) libraries map database tables to classes. If a database has a table called orders, our program will have a class name Order. Rows in this table correspond to objects of the class - a particular order is represented as an object of the Order class. Within that object, attributes are used to get and set the individual columns . Our order object has methods to get and set the amount, sales tax, and so on. So, and ORM layer maps tables to classes, rows to objects, and columns to attributes of those objects. Class methods are used to perform table level operations, and instance method perform operations on individual rows. Active record is the ORM layer supplied with rails. It closely follows the standard model: tables map 2 classes, roast two objects, and columns to object attributes. Action pack: the view and controller When you think about it, and controller parts of the MVC are pretty intimate. The controller supplies their data to the view and the controller receives events from the pages generated by the abuse. Because of these interactions, support for views and controllers in rails is bundled into a single component, Action pack. The view is responsible for creating all or part of the response to the displayed in a browser, to be processed by an application, or to be sent as an e-mail. At its simplest , is a chunk of HTML code that displays some fixed text. More typically, you will want to include dynamic content created by the action method in the controller. The controller in rails is the logical center of your applications. It coordinates the interaction among the user, the abuse, and the model . however, rails handles most of this interaction behind the scenes; The code you write concentrates on application level functionality . This makes rails controller code remarkably easy to develop and maintain. The controller is also home to a number of important ancillary services: ‚Ä¢ It is responsible for routing external requests to internal actions. It handles people friendly you are extremely well. ‚Ä¢ It manages catching, which can give application orders of magnitude performance boosts. ‚Ä¢ It manages helper modules, which extend the capabilities of the view templates without walking up their code. ‚Ä¢ It manages sessions, giving the users the impression of ongoing traction with our applications. Chapter 4 goes on to what is an object oriented language, will we names for local variables, methods parameters, and methods names, it provides the general rules of syntax, the kind of data types you will find in groovy like strings, array, hashes. The core of the Ruby language, which is blocks and iterators, control structures with the if statements, while loops, unless, until. Chapter 5: incremental development, use cases, page flow, data and priorities are covered. The first sketch of the shopping cart is shown, the user stories are broken down for instance: the buyer uses the web app to browse products we have to sell , select some of to purchase, and supply the information needed to create an order. On the other side the seller journey is as well described and something important is how the data is it going to be handled, how many controllers are we planning to code, the schemas are presented as well and finally the author emphasizes that all of these planning will become outdated because we must get customer feedback and most of these will change. The book pushes you to develop the web app in incremental changes called iterations. Chapter 6, it starts with the application ‚Äúrails new depot‚Äù and creating the first model in this case the product , it shows you how to migrate, the addition of CSS for the forms, it explains the HTTP verbs and this is the first commit to GitHub. Next chapter added some model validations in order to ensure the user input, also, introduced the first unit test examples and explain how they work; the importance of naming self-explanatory variables, tests. Chapter 8, builds the 2nd controller in this case is a Store and it added some CSS to the index view, also, went over the layout, using partials files in order to create the navbar, and continued with the testing now including the front end (what should the &lt;H2&gt; tag title contain or how many items &lt;li&gt; should have). The following chapter creates the Cart model, line_item, by a scaffolding them, and connect the line_item model to product and to cart, becoming a joint table; another feature added here is the introduction to sessions , it explains how they work, how much they can carry on and what are they useful. Chapter 10 covers how to deploy a new migration because in the first one, something was forgotten and leveraging how you can juggle with migrations there are four decided to add a new one instead of creating everything from scratch. Some flash notice modifications took place, and a strong parameter adjustment as well, finally the CSS was at refined to the new changes. The next chapter introduced they AJAX and it explains it very well, the book contains why Ajax exist how can I change the flow of the views, then Ajax feature it‚Äôs just highlighting some data without refreshing the whole page and finally action cable is presented with the core concepts. Within the next iteration the add_order_to_line_item model is created, a new form for capturing the lines items for the order as well and linking Line items 2 one order, after each addition a test is deployed and passed. In order to make more dynamic our rails app we need to add React which is a JavaScript view library designed to quickly create dynamic user interfaces. We will use it to create a dynamic payment method details form coma and Webpacker will ensure that the configuration and set-up for all these is as simple as possible. That said, there is a bit of setup we need to do. Web Packer essentially is the decisions made by the rail steam and bundled up into a gem. React dynamically renders HTML. Unlike ERB, react does this in the browser, and it is optimized to do it fast. React re render each field of the form instead of having this server re render the entire thing. the core concept in react is components. A component is a view, backed by some sort of state. When the state changes, the rear Enders. The view can behave differently depending on the current state inside the component. Chapter 14 goes on the e-mail module of Rails and explain why sending e-mail normally is slow, why would you choose Action Mailer and then you put on top of it Active Job to offload the work. In a Rails app, when a bit of logic becomes more complex than a line or two of code, you want to move that out of the controller and put it into a model. The chapter 15, 16, 17, are about logging in, internationalization, and responding emails with rich text this is almost as straight out as you may find it in the rails guide so I won‚Äôt go deeper due to is configuration, set-up and little adjustments. The last part of the book (III) contains 6 chapters and they are under a title called ‚ÄúRails in depth‚Äù I consider this very helpful if you want to go deep into the weeds and explore how is rails composed? why does rails app contain many default files? What are they for? When is correct to use a helper from there app file or from the model? Where does rail put the logs? Naming conventions? Where do you configure the environments? And many interesting methods that I didn‚Äôt know. Active record he‚Äôs also touched in this chapter and with more detail the CRUD actions are explained, also, using like classes, order, limit, using the word keyword, joins coma scopes, writing your own SQL, What are the 16 call backs Rails includes. Action Pack lies at the heart of rails applications. It consists of three Ruby modules: action dispatch, action controller and action view. Action dispatch routes request to controllers. Action controller converts requests into responses. Action view is used by action controller to format those responses. Components such as action controller, action view, and active record handled the processing of request, and the rails environments needs them together into a coherent and easy to use whole. At its most basic, a web application accepts an incoming request from my browser, process it, and sends a response. The first question that springs to mind is, how does the application know what to do with the incoming request? A shopping cart application will receive requests to display a catalog, add items to a part, create an order, and so on. How does it route these requests to the appropriate code?it turns out that Rails provides two ways to define how to route a request: a comprehensive way that you will use when you need to and a convenient way that you will generally use whenever you can. The comprehensive way lets you define a direct mapping of URLs to actions based on pattern matching, requirements and conditions. The convenient way lets you define routes based on resources, such as the models that you define. And because the convenient weight is built on the comprehensive way, you can freely mix and match the two approaches. A controller always responds to they use exactly one time per request. This means you should have just one call to a render(), redirect_to() or send() method in the processing of any request. Because the controller must respond exactly once, it checks to see whether a response has been generated just before it finishes handling a request. If not, the controller looks for a template named after the controller and action and automatically renders it. This is the most common way that rendering takes place. You may have noticed that in most of the actions north shopping cart tutorial we never explicitly rendered anything. Instead, or action methods set-up the context for the view and return. The controller notices that no rendering has taken place and automatically invokes the appropriate template. A real session is a hash-like structure that persists across request. Unlike raw cookies, sessions can hold any objects as long as those objects can be marshaled, which makes them ideal for holding state information in web applications. Rails encourages and agile, iterative style of development. We don‚Äôt expect to get everything right the first time period instead, we write tests and interact with our customer to refine our understanding as we go. For that to work, we need any supporting set of practices. We write tests to help us design our interfaces and to act as a safety net when we change things, and we use a version control to store our application source files, allowing us to undo mistakes and to monitor what changes day today. The database schema in a rails application constantly evolves as we progress through the development column we add a table here, rename a column there, and so on the database changes in step with the applications code. With rails, each of those steps is made possible through the use of migration. A migration is simply a Ruby source file in your applications and You can modify column types, renaming columns, changing columns, defining indices, renaming tables, the usage of primary keys, and even using native SQL and always you can rollback their migrations when they go bad. "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,120)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}
</script>

<style>
    .lunrsearchresult .title {color: #0f4fd9;}
    .lunrsearchresult .url {color: rgb(149, 165, 169);}
    .lunrsearchresult a {display: block; color: #4f4d4d; text-decoration: none;}
    .lunrsearchresult a:hover, .lunrsearchresult a:focus {text-decoration: none;}
    .lunrsearchresult a:hover .title {text-decoration: underline dotted;}
</style>

<form onSubmit="return lunr_search(document.getElementById('lunrsearch').value);">
  <div class="search-input-container">
    <input
      type="text"
      class="search-input"
      id="lunrsearch"
      name="q"
      maxlength="120"
      placeholder="Search"
    />
  </div>
</form>

<div class="limiter">
  <div id="lunrsearchresults">
    <ul></ul>
  </div>
</div>
  </div>
  <div class='' style='position:relative'>
    
    <div class='only-print'>
      <h2>dom lizarraga</h2>
      <div style='margin-top:0;'>dominiclizarraga@hotmail.com</div>
    </div>
    <nav class='header-wrap'>
      <div class='header nu limiter no-print'>
        <h1 style='line-height:1.6;font-size:1rem;margin:0 0 0.25em 0;'>dom lizarraga</h1>
        <ul style='list-style:none;padding:0;margin:0;'>
          <li style='margin:0.5rem 0;'><a href='/'>Notes</a>‚á†</li>
          <li style='margin:0.5rem 0;'><a href='/reading/'>Reading</a></li>
          <li style='margin:0.5rem 0;'><a href='/projects/'>Projects</a></li>
          <li style='margin:0.5rem 0;'><a href='/computer-science/'>Computer <br>Science</a></li>
          <li style='margin:0.5rem 0;'><a href='/pood/'>Object-Oriented <br>Design</a></li>          <li style='margin:0.5rem 0;'><a href='/confs/'>Confs</a></li>
          <li style='margin:0.5rem 0;'><a href='/about/'>About</a></li>
        </ul>
      </div>
    </nav>
    <div class='limiter content '>
      <h1>How I learned rpsec</h1>

<nav class="post-nav">
  <a href="javascript:history.back()" class="no-underline back-link" aria-label="Go back one page">
    <i aria-hidden="true">‚Üê</i>
    <span class="underline">Back one page</span>
  </a>
</nav>

<div class="reading-time">
  


  
  
    3 minutes to read
  


</div>

<div class='body'><p><strong>Rspec learning resources</strong></p>

<p>I believe that the best way to get a grasp of testing  in general and <em>rspec</em> is to start from scratch a project and start writing down each test, that way you‚Äôll be able to see what happens if you forget to close either a <code class="language-plaintext highlighter-rouge">context</code> block or an <code class="language-plaintext highlighter-rouge">it</code> block or even more intricate subjects like what‚Äôs the difference between <code class="language-plaintext highlighter-rouge">describe</code> and <code class="language-plaintext highlighter-rouge">context</code>.</p>

<p>While developing a freelance project I wanted to add testing as a way to push myself to learn more about testing and also give <em>rspec</em> a try and by doing it I learned how to use gems like: <a href="https://github.com/faker-ruby/faker">faker</a>, <a href="https://github.com/thoughtbot/shoulda-matchers">shoulda-matchers</a>, <a href="https://github.com/thoughtbot/factory_bot_rails">factory_bot</a> and finally <a href="https://github.com/rspec/rspec-rails">rspec</a>. üé≤</p>

<p>You‚Äôll additionally acquire:</p>

<p>‚Äì how to read the output of the test suite in the console.</p>

<p>‚Äì difference between <code class="language-plaintext highlighter-rouge">create</code> and <code class="language-plaintext highlighter-rouge">build</code> <a href="https://stackoverflow.com/questions/14098031/whats-the-difference-between-the-build-and-create-methods-in-factorygirl">more details.</a>;</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">#</span><span class="w"> </span><span class="err">build</span><span class="w"> </span><span class="err">doesn't</span><span class="w"> </span><span class="err">persist</span><span class="w"> 
</span><span class="err">user</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">build(:user,</span><span class="w"> </span><span class="err">name:</span><span class="w"> </span><span class="s2">"John"</span><span class="err">)</span><span class="w">
</span><span class="err">expect(user.name).to</span><span class="w"> </span><span class="err">eq(</span><span class="s2">"John"</span><span class="err">)</span><span class="w">

</span><span class="err">#</span><span class="w"> </span><span class="err">create</span><span class="w"> </span><span class="err">does</span><span class="w"> </span><span class="err">persist</span><span class="w"> 
</span><span class="err">user</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="err">create(:user,</span><span class="w"> </span><span class="err">name:</span><span class="w"> </span><span class="s2">"Jane"</span><span class="err">)</span><span class="w">
</span><span class="err">expect(user.persisted?).to</span><span class="w"> </span><span class="err">be</span><span class="w"> </span><span class="kc">true</span><span class="w">
</span></code></pre></div></div>
<p>‚Äì How to include Devise‚Äôs test helpers</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">class</span><span class="w"> </span><span class="err">PostsControllerTest</span><span class="w"> </span><span class="err">&lt;</span><span class="w"> </span><span class="err">ActionController::TestCase</span><span class="w">
  </span><span class="err">config.include</span><span class="w"> </span><span class="err">Devise::Test::ControllerHelpers,</span><span class="w"> </span><span class="err">type:</span><span class="w"> </span><span class="err">:requests</span><span class="w">
</span><span class="err">end</span><span class="w">

</span></code></pre></div></div>
<p><a href="https://henrytabima.github.io/rails-setup/docs/devise/test-helpers">blog</a>;</p>

<p>‚Äì difference between <code class="language-plaintext highlighter-rouge">fixtures</code> and <code class="language-plaintext highlighter-rouge">factories</code>;</p>

<p>‚Äì and finally learn how to integrate FactoryBot with RSpec <a href="https://github.com/thoughtbot/factory_bot/blob/main/GETTING_STARTED.md#configure-your-test-suite">link</a>.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">class</span><span class="w"> </span><span class="err">Test::Unit::TestCase</span><span class="w">
  </span><span class="err">include</span><span class="w"> </span><span class="err">FactoryBot::Syntax::Methods</span><span class="w">
</span><span class="err">end</span><span class="w">
</span></code></pre></div></div>

<p><ins>Here are also another resources that I followed in order to cement more my knowledge.</ins></p>

<ul>
  <li>
    <p>2 hours long video from Type Fast a Youtube channel that makes rails tutorials. The video is very thorough. Covers model, requests, background job testing and system tests. <a href="https://www.youtube.com/watch?v=BXaMRm1FDa8&amp;list=PPSV">Fairly comprehensive starter guide to RSpec</a></p>
  </li>
  <li>
    <p>1 hour long rspec tutorial from Type Fast was well (it‚Äôs more on the setup for an app) <a href="https://www.youtube.com/watch?v=D889P37r3bc&amp;list=PPSV">testing setup with rspec</a></p>
  </li>
  <li>
    <p>How to test models <a href="https://www.youtube.com/watch?v=Spogv4o8haM&amp;list=PPSV">CJ Avila</a></p>
  </li>
  <li>
    <p>How to use factory_bot <a href="https://www.youtube.com/watch?v=7JdyQEcZ7F8&amp;list=PPSV">Deanin, short tutorial</a></p>
  </li>
  <li>
    <p>Full marathon of rspec tutorial (reading not video) from syntax, how to test a model and installing rspec <a href="https://remimercier.com/series/rspec/">Remi rspec tutorials</a></p>
  </li>
  <li>
    <p>The Complete Guide to Rails Testing by Jason Swett <a href="The Complete Guide to Rails Testing">link</a></p>
  </li>
</ul>

<p>Learn by doing is the best way to learn rspec DSL, development stack, learn what to test and why it‚Äôs important to test and avoid technical debt.</p>

<p>So give it a try, it wont be difficult after all.</p>

<p>Lately, I have completed a few books on testing, inclding <a href="/2025/02/05/professional-rails-testing.html">Professional Rails Testing by Jason Swett</a>, <a href="/2025/03/16-hands-on-tdd-rails.html">Hands-On Test Driven Development by Greg Donald</a>, <a href="/2025/04/11-effective-testing-with-rspec.html">Effective Testing with RSpec by Myron Marston and Ian Dees</a> and even attended a <a href="https://goodenoughtesting.com/">testing workshop by Lucian Ghinda</a>.</p>

</div>

<div class='breaker'></div>


<div class="personal-elements-container">
  <postamble datetime="2023-06-14">
    June 14, 2023
  </postamble>
  <a href="https://twitter.com/intent/follow?screen_name=domlizarraga_&user_id=domlizarraga_" 
      rel="nofollow" rel="noopener"
      target="_blank"
      title="Follow me on Twitter">
    @domlizarraga_
  </a>
  <a href="/rss.xml" class="rss-link" title="RSS feed">
    <span class="rss-text">Find the RSS link</span>
    <svg height="32" width="32" version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="-45.57 -45.57 546.87 546.87" xml:space="preserve">
      <g>
        <rect x="0" y="0" style="fill:#F78422;" width="455.731" height="455.731"/>
        <g>
          <path style="fill:#FFFFFF;" d="M296.208,159.16C234.445,97.397,152.266,63.382,64.81,63.382v64.348 c70.268,0,136.288,27.321,185.898,76.931c49.609,49.61,76.931,115.63,76.931,185.898h64.348 C391.986,303.103,357.971,220.923,296.208,159.16z"/>
          <path style="fill:#FFFFFF;" d="M64.143,172.273v64.348c84.881,0,153.938,69.056,153.938,153.939h64.348 C282.429,270.196,184.507,172.273,64.143,172.273z"/>
          <circle style="fill:#FFFFFF;" cx="109.833" cy="346.26" r="46.088"/>
        </g>
      </g>
    </svg>
  </a>
</div>

<div class="mobile-only-button">
  <!-- <script type="text/javascript" src="https://cdnjs.buymeacoffee.com/1.0.0/button.prod.min.js" data-name="bmc-button" data-slug="domlizarrraga" data-color="#5F7FFF" data-emoji="üçï" data-font="Comic" data-text="Buy me a pizza" data-outline-color="#000000" data-font-color="#ffffff" data-coffee-color="#FFDD00" ></script> -->
</div>

<script src="https://giscus.app/client.js"
        data-repo="dominiclizarraga/dominiclizarraga.github.io"
        data-repo-id="R_kgDOJ601Dg"
        data-category="General"
        data-category-id="DIC_kwDOJ601Ds4CliRX"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="light"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>

    </div>
  </div>
</body>
</html>
