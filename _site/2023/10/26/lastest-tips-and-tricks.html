<!doctype html>
<html lang=en>
<head>
  <meta charset=utf-8>
  <meta name=author content='dom lizarraga' />
  <meta name='theme-color' content='#fff' />
  <meta name='twitter:title' content="Latest tips &amp; tricks | Ruby &amp; Rails" />
  <meta name=description content="" />
  <meta name=viewport content='width=device-width,minimum-scale=1'>
  <meta property='og:site_name' content="dominiclizarraga.github.io"/>
  <meta property='og:email' content="dominiclizarraga@hotmail.com"/>
  <meta property='og:type' content=blog />
  <meta property='twitter:account_id' content=domlizarraga_ />
  
  
  <script type='application/ld+json'>{"@context": "http://schema.org","@type": "CreativeWork","author": "dom lizarraga"}</script>
  
    <link rel=alternate type='application/rss+xml' title="dominiclizarraga.github.io" href="http://localhost:4000/rss.xml" />
    <link rel=alternate type='application/atom+xml' title="dominiclizarraga.github.io" href="http://localhost:4000/atom.xml" />
  
  <link rel=icon type=image/x-icon href=/css/favicon.png />
  <style>:root {
  --mono-font: San Francisco Mono, Monaco, "Consolas", "Lucida Console",
    "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace;
  --sans-font: -apple-system, BlinkMacSystemFont, "avenir next", avenir,
    helvetica, "helvetica neue", ubuntu, roboto, noto, "segoe ui", arial,
    sans-serif;
}

.star {
  width: 13px;
  height: 12px;
  display: inline-block;
  background: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTMiIGhlaWdodD0iMTIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTYuMzA5IDkuMjJMMi40MDkgMTJsMS40NC00LjU2N0wwIDQuNTgzbDQuNzg4LS4wNDJMNi4zMDggMCA3LjgzIDQuNTRsNC43ODkuMDQ0LTMuODUgMi44NDlMMTAuMjA5IDEyeiIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9zdmc+");
}

body {
  color: #111;
  margin: 0px auto;
  -webkit-font-smoothing: antialiased;
  text-rendering: optimizeLegibility;
  line-height: 1.6;
  font-size: 1rem;
  font-family: var(--sans-font);
  background-color: #f1e4c1;
}

/* Print tweaks ------------------------------------------------------------- */
.only-print {
  display: none;
}

.notitle .body p:first-child {
  margin-top: 0.25rem;
}

.body img {
  width: 100%;
  max-width: 640px;
}

/* Element styles ----------------------------------------------------------- */
sup,
sub {
  vertical-align: baseline;
  position: relative;
  top: -0.4em;
}

sub {
  top: 0.4em;
}

a {
  color: #000;
  text-decoration-skip-ink: auto;
  text-decoration: underline;
}

a:visited {
  color: #333;
}

ol,
ul {
  margin: 1rem 0;
}

ul ul {
  margin: 0;
}

ol li ul {
  margin: 5px 10px;
}

iframe {
  border: 0;
}

small,
.small {
  font-size: 14px;
}

br {
  line-height: 1em;
}

h1 a {
  color: #111;
}

em {
  font-style: italic;
}

h1 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 32px;
  letter-spacing: 0.004em;
}

h2 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 1.5rem;
  letter-spacing: 0.009em;
}

h3 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 1.25rem;
  letter-spacing: 0.009em;
}

h4 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 1rem;
}

h5 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 0.875rem;
}

p {
  margin: 1rem 0;
}

blockquote {
  font-size: 16px;
  line-height: 25px;
}

td {
  vertical-align: top;
}

hr {
  background: #000;
  height: 1px;
  border: 0;
}

summary {
  cursor: pointer;
}

.body table {
  border-collapse: collapse;
  border-spacing: 0;
  width: 100%;
}

.body th {
  text-align: left;
}

.body td,
.body th {
  padding: 0.5rem;
}

.body td {
  border: 1px solid #cfcfcf;
}

.limiter {
  max-width: 640px;
  padding-left: 20px;
  padding-right: 20px;
  margin-left: auto;
  margin-right: auto;
}

/* Padding --------------------------------------- */
.pad2y {
  padding-top: 20px;
  padding-bottom: 20px;
}

span.image-credit {
  float: right;
  margin: 0 0 10px 10px;
  font-size: 12px;
}

span.image-credit:before {
  content: "↑";
  margin-right: 5px;
}

figcaption {
  font-size: 11px;
  text-align: center;
  font-size: 0.8rem;
  margin-top: -1.2rem;
}

div.post blockquote p {
  margin: 0;
}

/** Writing ----------------------------------------------------------------- */
.writing,
.books {
  display: grid;
  grid-column-gap: 5px;
  grid-row-gap: 5px;
}

.writing {
  grid-template-columns: 1fr min-content;
}

.books {
  grid-template-columns: 1fr 0.75fr min-content 70px;
}

.writing a,
.books a {
  font-weight: 500;
  letter-spacing: -0.015em;
}

.writing > div,
.books > div {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.writing time,
.books time {
  padding-right: 0.25em;
  color: #333;
  font-variant-numeric: tabular-nums;
  letter-spacing: -0.012em;
  white-space: pre;
}

.project-box {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-gap: 30px;
}

.project-box a.project {
  text-decoration: none;
  color: #666;
}
.project-box a.project:hover {
  color: #000;
}
.project-box a.project img {
  display: block;
  margin-bottom: 10px;
}

/** Responsive -------------------------------------------------------------- */

@media screen and (max-width: 480px) {
  .project-box {
    grid-template-columns: repeat(1, 1fr);
  }
}

@media screen and (max-width: 640px) {
  .limiter {
    width: auto;
  }
  .project-box {
    grid-template-columns: repeat(2, 1fr);
  }
  .writing,
  .books {
    grid-template-columns: 1fr;
    grid-row-gap: 0px;
  }

  .writing div,
  .books div {
    white-space: normal;
  }

  .writing time,
  .books div:nth-child(4n) {
    padding-bottom: 20px;
  }
}

@media screen and (min-width: 640px) {
  .nu a {
    text-decoration: none;
  }

  .nu a:hover {
    text-decoration: underline;
  }
}

@media screen and (max-width: 1024px) {
  .header-wrap {
    border-bottom: 1px solid #000;
    padding-bottom: 20px;
  }
  .sigil {
    display: none;
  }
}

@media screen and (min-width: 1025px) {
  .header {
    position: absolute;
    top: 40px;
    right: 50%;
    margin-right: 340px !important;
    letter-spacing: -0.009em;
  }
  .content h1:first-child {
    margin-top: 0;
  }
}

@media print {
  .no-print {
    display: none;
  }
  .only-print {
    display: block;
  }
  body {
    margin: 0;
  }
  .limiter {
    max-width: 100% !important;
    margin: 0 !important;
    padding: 0 !important;
  }
}

/** Code highlighting ------------------------------------------------------- */
p code,
pre code,
li code,
g.highlight,
.code {
  font-family: var(--mono-font);
}

p code {
  font-size: 90%;
}

pre code {
  font-size: 0.8rem;
  line-height: 1.5;
}

.highlight,
blockquote {
  overflow-x: auto;
  padding: 10px 20px;
  margin: 0;
  background: #fff;
  border-radius: 10px;
}

blockquote {
  font-style: italic;
}

blockquote p:first-child {
  margin-top: 0;
}

blockquote p:last-child {
  margin-bottom: 0;
}

/* pygments theme. does not support generics. .highlight class omitted */
.highlight {
  margin: 10px 0;
}

.highlight .hll {
  background-color: #ffffcc;
}

.c, /* Comment */
.cm, /* Comment.Multiline */
.cp, /* Comment.Preproc */
.cs, /* Comment.Special */
.c1 {
  color: #999988;
} /* Comment.Single */

.o, /* Operator */
.ow, /* Operator.Word */
.ge {
  color: #000000;
} /* Generic.Emph */

.kc, /* Keyword.Constant */
.kd, /* Keyword.Declaration */
.kn, /* Keyword.Namespace */
.kp, /* Keyword.Pseudo */
.kr, /* Keyword.Reserved */
.kt {
  color: #445588;
} /* Keyword.Type */

.err {
  color: #a61717;
} /* Error */

.m {
  color: #007f7f;
} /* Literal.Number */
.s {
  color: #d01040;
} /* Literal.String */

.na, /* Name.Attribute */
.nb, /* Name.Builtin */
.nc, /* Name.Class */
.no, /* Name.Constant */
.nd, /* Name.Decorator */
.ni, /* Name.Entity */
.ne, /* Name.Exception */
.nf, /* Name.Function */
.nn, /* Name.Namespace */
.nt, /* Name.Tag */
.nl {
  color: #990000;
} /* Name.Label */

.k, /* Keyword */
.nv {
  color: #008080;
} /* Name.Variable */

.mf, /* Literal.Number.Float */
.mh, /* Literal.Number.Hex */
.mi, /* Literal.Number.Integer */
.mo {
  color: #009999;
} /* Literal.Number.Oct */

.sb, /* Literal.String.Backtick */
.sc, /* Literal.String.Char */
.sd, /* Literal.String.Doc */
.s2, /* Literal.String.Double */
.se, /* Literal.String.Escape */
.sh, /* Literal.String.Heredoc */
.s1, /* Literal.String.Single */
.si, /* Literal.String.Interpol */
.ss, /* Literal.String.Symbol */
.bp, /* Name.Builtin.Pseudo */
.sx {
  color: #d01040;
} /* Literal.String.Other */

.sr, /* Literal.String.Regex */
.vc, /* Name.Variable.Class */
.vg, /* Name.Variable.Global */
.vi, /* Name.Variable.Instance */
.il {
  color: #009999;
} /* Literal.Number.Integer.Long */

.mobile-only-button {
  display: none;
}

@media screen and (max-width: 480px) {
  .mobile-only-button {
    display: flex;
    justify-content: center;
    align-items: center;
    margin-bottom: 50px;
  }
  
  /* Style for the generated iframe */
  .mobile-only-button iframe {
    margin: 0 auto;
  }
}</style>
  <title>Latest tips & tricks | Ruby & Rails - dominiclizarraga.github.io</title>
  
  <link rel="canonical" href="http://localhost:4000/2023/10/26/lastest-tips-and-tricks.html">
  <script data-name="BMC-Widget" data-cfasync="false" src="https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js" data-id="domlizarrraga" data-description="Support me on Buy me a coffee!" data-message="" data-color="#5F7FFF" data-position="Right" data-x_margin="18" data-y_margin="18"></script>
</head>
<body>
  <div class='pad2y' style='position:relative'>
    
    <div class='only-print'>
      <h2>dom lizarraga</h2>
      <div style='margin-top:0;'>dominiclizarraga@hotmail.com</div>
    </div>
    <nav class='header-wrap'>
      <div class='header nu limiter no-print'>
        <h1 style='line-height:1.6;font-size:1rem;margin:0 0 0.25em 0;'>dom lizarraga</h1>
        <ul style='list-style:none;padding:0;margin:0;'>
          <li style='margin:0.5rem 0;'><a href='/'>Notes</a>⇠</li>
          <li style='margin:0.5rem 0;'><a href='/reading/'>Reading</a></li>
          <li style='margin:0.5rem 0;'><a href='/projects/'>Projects</a></li>
          <li style='margin:0.5rem 0;'><a href='/computer_science/'>Computer <br>Science</a></li>
          <li style='margin:0.5rem 0;'><a href='/confs/'>Confs</a></li>
          <li style='margin:0.5rem 0;'><a href='/about/'>About</a></li>
        </ul>
      </div>
    </nav>
    <div class='pad2y limiter content '>
      <h1>Latest tips & tricks | Ruby & Rails</h1>
<div class='body'><h4 id="first-filter-then-map">First <code class="language-plaintext highlighter-rouge">filter</code> then <code class="language-plaintext highlighter-rouge">map</code></h4>

<p>When you first filter a collection, you’re reducing its size by selecting only the elements that meet a certain condition. This step inherently decreases the number of items that will subsequently be processed by the map operation.</p>

<p>Imagine you have an array of user records, and you’re only interested in processing active users with an age above 18, where the processing involves a complex calculation.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">users</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">all</span>
<span class="n">active_adult_users</span> <span class="o">=</span> <span class="n">users</span><span class="p">.</span><span class="nf">filter</span> <span class="p">{</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span> <span class="n">user</span><span class="p">.</span><span class="nf">active?</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="p">.</span><span class="nf">age</span> <span class="o">&gt;</span> <span class="mi">18</span> <span class="p">}</span>
<span class="n">processed_users</span> <span class="o">=</span> <span class="n">active_adult_users</span><span class="p">.</span><span class="nf">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">user</span><span class="o">|</span> <span class="n">complex_calculation</span><span class="p">(</span><span class="n">user</span><span class="p">)</span> <span class="p">}</span>
</code></pre></div></div>

<p>In this case, filtering out inactive users or those under 18 before applying the complex calculation minimizes the number of calculations, thus improving the performance.</p>

<p>If you were to map first and then filter, every element in the collection, this means potentially performing a lot of unnecessary work.</p>

<p>Remember: <a href="https://rubyapi.org/3.3/o/enumerable#method-i-select">.select</a>, <a href="https://rubyapi.org/3.3/o/enumerable#method-i-filter">.filter</a> and <a href="https://rubyapi.org/3.3/o/enumerable#method-i-find_all">find_all</a> are Enumerable methods that do the same thing!</p>

<p>Similar methods are <a href="https://rubyapi.org/3.3/o/enumerable#method-i-collect">.collect</a> and <a href="https://rubyapi.org/3.3/o/enumerable#method-i-map">.map</a>!</p>

<hr style="height: 4px; border-width: 0; color: gray; background-color: blue; opacity: 0.5;" />

<h4 id="filter_map-vs-filter--map"><code class="language-plaintext highlighter-rouge">filter_map</code> vs <code class="language-plaintext highlighter-rouge">filter</code> + <code class="language-plaintext highlighter-rouge">map</code></h4>

<p>The <code class="language-plaintext highlighter-rouge">filter_map</code> method iterates over an enumerable, applying a block to each element.</p>

<p>This approach eliminates the need to iterate over a collection twice (once for filtering and once for mapping).</p>

<p>Performance Benefits</p>

<p><code class="language-plaintext highlighter-rouge">filter_map</code> is more efficient than using <code class="language-plaintext highlighter-rouge">filter</code> and <code class="language-plaintext highlighter-rouge">map</code> separately because:</p>

<ul>
  <li>It reduces the number of iterations over the collection to just one.</li>
  <li>It avoids creating an intermediate array that would result from the first operation (filter or map) before passing it to the second operation.</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fruits</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'apple'</span><span class="p">,</span> <span class="s1">'pear'</span><span class="p">,</span> <span class="s1">'banana'</span><span class="p">,</span> <span class="s1">'cherry'</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="s1">'fig'</span><span class="p">,</span> <span class="s1">'grape'</span><span class="p">]</span>

<span class="n">uppercase_fruits</span> <span class="o">=</span> <span class="n">fruits</span><span class="p">.</span><span class="nf">filter_map</span> <span class="p">{</span> <span class="o">|</span><span class="n">fruit</span><span class="o">|</span> <span class="n">fruit</span><span class="p">.</span><span class="nf">upcase</span> <span class="k">if</span> <span class="n">fruit</span><span class="o">&amp;</span><span class="p">.</span><span class="nf">length</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="p">}</span>

<span class="nb">puts</span> <span class="n">uppercase_fruits</span> <span class="c1"># Output: ["APPLE", "BANANA", "CHERRY", "GRAPE"]</span>
</code></pre></div></div>

<p>With both methods separate <code class="language-plaintext highlighter-rouge">filter</code> + <code class="language-plaintext highlighter-rouge">map</code></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fruits</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'apple'</span><span class="p">,</span> <span class="s1">'pear'</span><span class="p">,</span> <span class="s1">'banana'</span><span class="p">,</span> <span class="s1">'cherry'</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="s1">'fig'</span><span class="p">,</span> <span class="s1">'grape'</span><span class="p">]</span>

<span class="c1"># First, filter out the fruits with more than 4 letters, excluding nil values</span>
<span class="n">filtered_fruits</span> <span class="o">=</span> <span class="n">fruits</span><span class="p">.</span><span class="nf">filter</span> <span class="p">{</span> <span class="o">|</span><span class="n">fruit</span><span class="o">|</span> <span class="n">fruit</span><span class="o">&amp;</span><span class="p">.</span><span class="nf">length</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="p">}</span>

<span class="c1"># Then, map the filtered fruits to uppercase</span>
<span class="n">uppercase_fruits</span> <span class="o">=</span> <span class="n">filtered_fruits</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:upcase</span><span class="p">)</span>

<span class="nb">puts</span> <span class="n">uppercase_fruits</span> <span class="c1"># Output: ["APPLE", "BANANA", "CHERRY", "GRAPE"]</span>

</code></pre></div></div>

<hr style="height: 4px; border-width: 0; color: gray; background-color: blue; opacity: 0.5;" />

<h4 id="find_each-vs-all--each">find_each vs all + each</h4>

<p>When dealing with ActiveRecord objects, understanding the difference between find_each and using all followed by each is crucial for optimizing database interactions and memory usage.</p>

<p>Using <code class="language-plaintext highlighter-rouge">all</code> followed by <code class="language-plaintext highlighter-rouge">each</code> is a straightforward way to iterate over a collection of records from the database. <code class="language-plaintext highlighter-rouge">all</code> retrieves all the records and loads them into memory, and <code class="language-plaintext highlighter-rouge">each</code> then iterates over these records one by one.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Student</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">student</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">student</span><span class="p">.</span><span class="nf">name</span>
<span class="k">end</span>
</code></pre></div></div>
<p>Things to consider:</p>

<ul>
  <li>Memory Usage: If the students table contains a large number of records, loading all of them with all can consume a significant amount of memory,</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">find_each</code></p>

<p><code class="language-plaintext highlighter-rouge">find_each</code> is specifically designed to manage memory consumption and efficiency when processing large numbers of records. Instead of loading all records into memory at once, <code class="language-plaintext highlighter-rouge">find_each</code> retrieves and loads records in batches, processing each batch before moving on to the next. <strong>By default, the batch size is 1000 records, but you can specify a different batch size if needed.</strong></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Students records are proccesed in batches of 100, significantly reducing memory usage.</span>
<span class="no">Student</span><span class="p">.</span><span class="nf">find_each</span><span class="p">(</span><span class="ss">batch_size: </span><span class="mi">100</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">student</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="n">student</span><span class="p">.</span><span class="nf">name</span> 
<span class="k">end</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">find_each</code> has different options to apply <a href="https://api.rubyonrails.org/classes/ActiveRecord/Batches.html#method-i-find_each">more details.</a></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Student</span><span class="p">.</span><span class="nf">find_each</span><span class="p">(</span><span class="ss">batch_size: </span><span class="mi">200</span><span class="p">,</span> <span class="ss">start: </span><span class="mi">1000</span><span class="p">,</span> <span class="ss">finish: </span><span class="mi">5000</span><span class="p">,</span> <span class="ss">order: :desc</span><span class="p">,</span> <span class="ss">error_on_ignore: </span><span class="kp">true</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">student</span><span class="o">|</span>
  <span class="c1"># Your processing logic here</span>
<span class="k">end</span>
</code></pre></div></div>

<hr style="height: 4px; border-width: 0; color: gray; background-color: blue; opacity: 0.5;" />

<h4 id="count-vs-length-vs-size">.count vs .length vs .size</h4>

<p><strong><code class="language-plaintext highlighter-rouge">count</code></strong> directly translates to a <code class="language-plaintext highlighter-rouge">SELECT COUNT(*) SQL</code> query against the database. It asks the database to count the number of entries that match the query and does not load the objects into memory. This makes it very efficient for large datasets.</p>

<p>Every time you call <code class="language-plaintext highlighter-rouge">count</code>, it performs a database query, which could be a downside if called repeatedly without a need for real-time accuracy. It will make an SQL COUNT regardless of the state of the collection in memory. <a href="https://dominiclizarraga.github.io/2024/01/22/when-you-see-the-count.html">(See this article to know how to tackle <code class="language-plaintext highlighter-rouge">count</code> efficiently)</a></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">book</span> <span class="o">=</span> <span class="no">Book</span><span class="p">.</span><span class="nf">first</span>
<span class="c1"># Book Load ...</span>
<span class="n">book</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">load</span>
<span class="c1"># Comment Load (0.3ms) SELECT "comments".* FROM "comments" WHERE "comments"."book_id" = $1 [["book_id", 1]]</span>
<span class="n">book</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">count</span>
<span class="c1"># Comment Count (0.5ms) SELECT COUNT(*) FROM "comments" WHERE "comments"."book_id" = $1 [["book_id", 1]]</span>
</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">length</code></strong> loads the entire collection of objects into memory and then counts the number of elements. This can be memory-intensive for large datasets because it initializes all the objects. It does not trigger an extra database query if the collection is already loaded.</p>

<p><code class="language-plaintext highlighter-rouge">ActiveRecord</code> loads the comments from the database (if they haven’t been loaded already) to count them. The count is done by Ruby in memory after loading the records.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">blogpost</span> <span class="o">=</span> <span class="no">BlogPost</span><span class="p">.</span><span class="nf">first</span>
<span class="c1"># BlogPost Load ...</span>
<span class="n">blogpost</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">to_a</span> 
<span class="c1"># Comment Load (0.2ms) SELECT "comments".* FROM "comments" WHERE "comments"."blog_post_id" = $1 [["blog_post_id", 1]]</span>
 <span class="p">[[</span><span class="s2">"blog_post_id"</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="n">blogpost</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">length</span>
<span class="c1"># (no additional database query is executed, comments are already loaded into memory.)</span>
</code></pre></div></div>

<p><strong>size</strong> combines the behaviors of both <code class="language-plaintext highlighter-rouge">count</code> and <code class="language-plaintext highlighter-rouge">length</code>. If the collection has already been loaded, size will calculate the number of elements in-memory, avoiding a database query.</p>

<p>If the collection has not been loaded, it will perform a <code class="language-plaintext highlighter-rouge">SELECT COUNT(*) query</code>, similar to <code class="language-plaintext highlighter-rouge">count</code>.</p>

<p>When a counter cache is implemented, <code class="language-plaintext highlighter-rouge">.size</code> uses the cached value for the count, eliminating the need for database queries to count the records.</p>

<p>With data loaded:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># `size` if loaded, calculates the length with Ruby</span>
<span class="n">blogpost</span> <span class="o">=</span> <span class="no">BlogPost</span><span class="p">.</span><span class="nf">first</span>
<span class="c1"># BlogPost Load ...</span>
<span class="n">blogpost</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">load</span>
<span class="c1"># Comment Load (0.5ms) SELECT "comments".* FROM "comments" WHERE "comments"."blog_post_id" = $1 [["blog_post_id", 1]]</span>
<span class="nb">puts</span> <span class="n">blogpost</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">size</span>
<span class="c1"># (no db hit) - Uses Ruby to calculate the size from the loaded collection</span>
</code></pre></div></div>

<p>Without data loaded:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># `size` if not loaded, performs an SQL COUNT query</span>
<span class="n">blogpost</span> <span class="o">=</span> <span class="no">BlogPost</span><span class="p">.</span><span class="nf">first</span>
<span class="c1"># BlogPost Load ...</span>
<span class="nb">puts</span> <span class="n">blogpost</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">size</span>
<span class="c1"># Comment Count (0.4ms) SELECT COUNT(*) FROM "comments" WHERE "comments"."blog_post_id" = $1 [["blog_post_id", 1]]</span>
</code></pre></div></div>
<p>With <strong>counter cache</strong>:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Scenario 6: `size` if there is a counter cache, uses the cached count</span>
<span class="n">blogpost</span> <span class="o">=</span> <span class="no">BlogPost</span><span class="p">.</span><span class="nf">first</span>
<span class="c1"># BlogPost Load ...</span>
<span class="nb">puts</span> <span class="n">blogpost</span><span class="p">.</span><span class="nf">likes</span><span class="p">.</span><span class="nf">size</span>
<span class="c1"># (no db hit) - Uses counter cache</span>
<span class="nb">puts</span> <span class="n">blogpost</span><span class="p">.</span><span class="nf">likes</span><span class="p">.</span><span class="nf">size</span>
<span class="c1"># (no db hit) - Uses counter cache again without additional queries</span>
</code></pre></div></div>

<hr style="height: 4px; border-width: 0; color: gray; background-color: blue; opacity: 0.5;" />

<h4 id="order-vs-sort_by">order vs sort_by</h4>

<p><code class="language-plaintext highlighter-rouge">order</code> method is used with ActiveRecord relations to specify the order of records returned by a query. It translates directly into an <code class="language-plaintext highlighter-rouge">SQL ORDER BY clause</code>, meaning the sorting is done by the database before the records are returned to your Rails application.</p>

<p>Since <code class="language-plaintext highlighter-rouge">order</code> operates at the database level, it is generally more efficient for large datasets. Databases are optimized for sorting operations, especially when working with indexes.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Book</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">publication_year: :desc</span><span class="p">)</span>
</code></pre></div></div>
<p>When you use <code class="language-plaintext highlighter-rouge">sort_by</code> (Ruby Enumerable), the entire collection needs to be loaded into memory first. Only then does sort_by reorder the collection based on the specified attributes or criteria.</p>

<p>Use <code class="language-plaintext highlighter-rouge">sort_by</code> for smaller datasets or when you need to sort based on computed values.</p>

<p>Here, the trick is to work on a ActiveRecord relation otherwhise Rails loads the entire collection into memory. This is because <code class="language-plaintext highlighter-rouge">.sort_by</code> is an Enumerable method that operates on arrays, not on database queries.</p>

<p>So, the first step is converting the ActiveRecord relation into an array of model instances and after loading, <code class="language-plaintext highlighter-rouge">.sort_by</code> then iterates over the in-memory array:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">posts</span> <span class="o">=</span> <span class="no">Post</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">published: </span><span class="kp">true</span><span class="p">)</span>
<span class="c1"># This line implicitly loads all published posts into memory and then sorts them by title</span>
<span class="n">sorted_posts</span> <span class="o">=</span> <span class="n">posts</span><span class="p">.</span><span class="nf">sort_by</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:title</span><span class="p">)</span>
</code></pre></div></div>

<hr style="height: 4px; border-width: 0; color: gray; background-color: blue; opacity: 0.5;" />

<p>This is just an advice I got and wanted to keep it here.</p>

<blockquote>
  <p>Try to make the calculations and queries even if they become big in controllers or models and in view just sort them in memory.</p>
</blockquote>

<blockquote>
  <p>Better to ship the wrong thing today than the right thing in 2 weeks! Because then you can get feedback and learn 14 things in 2 weeks instead of 1 thing. And you are as useful as the code you ship. So try to ship every day, multiple times if possible :smile:</p>
</blockquote>

<hr style="height: 4px; border-width: 0; color: gray; background-color: blue; opacity: 0.5;" />

<h4 id="booksshuffle-in-memory">@books.shuffle (in-memory)</h4>

<p>The <code class="language-plaintext highlighter-rouge">.shuffle</code> method is a Ruby Array method that randomly reorders the elements of the array. It operates in memory, meaning the entire array needs to be loaded.</p>

<p>Ideal for situations where you have a relatively small dataset already loaded. <a href="https://rubyapi.org/3.3/o/array#method-i-shuffle">Ruby API.</a></p>

<hr style="height: 4px; border-width: 0; color: gray; background-color: blue; opacity: 0.5;" />

<h4 id="booksorderrandom-in-db">@books.order(‘random()’) (in db)</h4>

<p><code class="language-plaintext highlighter-rouge">random()</code> operation is performed by the database engine, which means it does not require loading all the data into your application’s memory to shuffle it. <a href="https://stackoverflow.com/questions/2752231/random-record-in-activerecord">More details.</a></p>

<hr style="height: 4px; border-width: 0; color: gray; background-color: blue; opacity: 0.5;" />

<h4 id="any--exist-vs-present--in-memory">any? =&gt; exist? vs present? =&gt; in memory</h4>

</div>

<div class='breaker'></div>

<div class='pad2y'>
  <p>
    <postamble datetime="2023-10-26">
      October 26, 2023
    </postamble>
    &nbsp;
    <a href="https://twitter.com/intent/follow?screen_name=domlizarraga_&user_id=domlizarraga_" rel="nofollow" rel="noopener" target="_blank" title="Follow me on Twitter">
      @domlizarraga_
    </a>
  </p>
</div>

<div class="mobile-only-button">
  <script type="text/javascript" src="https://cdnjs.buymeacoffee.com/1.0.0/button.prod.min.js" data-name="bmc-button" data-slug="domlizarrraga" data-color="#5F7FFF" data-emoji="🍕" data-font="Comic" data-text="Buy me a pizza" data-outline-color="#000000" data-font-color="#ffffff" data-coffee-color="#FFDD00" ></script>
</div>

<script src="https://giscus.app/client.js"
        data-repo="dominiclizarraga/dominiclizarraga.github.io"
        data-repo-id="R_kgDOJ601Dg"
        data-category="General"
        data-category-id="DIC_kwDOJ601Ds4CliRX"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>

    </div>
  </div>
</body>
</html>
