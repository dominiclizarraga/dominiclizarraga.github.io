<!doctype html>
<html lang=en>
<head>
  <meta charset=utf-8>
  <meta name=author content='dom lizarraga' />
  <meta name='theme-color' content='#fff' />
  <meta name='twitter:title' content="The Minitest Cookbook" />
  <meta name=description content="" />
  <meta name=viewport content='width=device-width,minimum-scale=1'>
  <meta property='og:site_name' content="dominiclizarraga.github.io"/>
  <meta property='og:email' content="dominiclizarraga@hotmail.com"/>
  <meta property='og:type' content=blog />
  <meta property='twitter:account_id' content=domlizarraga_ />
  
  
  <script type='application/ld+json'>{"@context": "http://schema.org","@type": "CreativeWork","author": "dom lizarraga"}</script>
  
    <link rel=alternate type='application/rss+xml' title="dominiclizarraga.github.io - Reading" href="http://localhost:4000/reading/rss.xml" />
    <link rel=alternate type='application/atom+xml' title="dominiclizarraga.github.io - Reading" href="http://localhost:4000/reading/atom.xml" />
  
  <link rel=icon type=image/x-icon href=/css/favicon.png />
  <style>:root {
  --mono-font: San Francisco Mono, Monaco, "Consolas", "Lucida Console",
    "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace;
  --sans-font: -apple-system, BlinkMacSystemFont, "avenir next", avenir,
    helvetica, "helvetica neue", ubuntu, roboto, noto, "segoe ui", arial,
    sans-serif;
}

.star {
  width: 13px;
  height: 12px;
  display: inline-block;
  background: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTMiIGhlaWdodD0iMTIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTYuMzA5IDkuMjJMMi40MDkgMTJsMS40NC00LjU2N0wwIDQuNTgzbDQuNzg4LS4wNDJMNi4zMDggMCA3LjgzIDQuNTRsNC43ODkuMDQ0LTMuODUgMi44NDlMMTAuMjA5IDEyeiIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9zdmc+");
}

body {
  color: #111;
  margin: 0px auto;
  -webkit-font-smoothing: antialiased;
  text-rendering: optimizeLegibility;
  line-height: 1.6;
  font-size: 1rem;
  font-family: var(--sans-font);
  background-color: #f8f5d5;
}

/* Print tweaks ------------------------------------------------------------- */
.only-print {
  display: none;
}

.notitle .body p:first-child {
  margin-top: 0.25rem;
}

.body img {
  width: 100%;
  max-width: 640px;
}

/* Element styles ----------------------------------------------------------- */
sup,
sub {
  vertical-align: baseline;
  position: relative;
  top: -0.4em;
}

sub {
  top: 0.4em;
}

a {
  color: #000;
  text-decoration-skip-ink: auto;
  text-decoration: underline;
}

a:visited {
  color: #333;
}

ol,
ul {
  margin: 1rem 0;
}

ul ul {
  margin: 0;
}

ol li ul {
  margin: 5px 10px;
}

iframe {
  border: 0;
}

small,
.small {
  font-size: 14px;
}

br {
  line-height: 1em;
}

h1 a {
  color: #111;
}

em {
  font-style: italic;
}

h1 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 32px;
  letter-spacing: 0.004em;
}

h2 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 1.5rem;
  letter-spacing: 0.009em;
}

h3 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 1.25rem;
  letter-spacing: 0.009em;
}

h4 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 1rem;
}

h5 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 0.875rem;
}

p {
  margin: 1rem 0;
}

blockquote {
  font-size: 16px;
  line-height: 25px;
}

td {
  vertical-align: top;
}

hr {
  background: #000;
  height: 1px;
  border: 0;
}

summary {
  cursor: pointer;
}

.body table {
  border-collapse: collapse;
  border-spacing: 0;
  width: 100%;
}

.body th {
  text-align: left;
}

.body td,
.body th {
  padding: 0.5rem;
}

.body td {
  border: 1px solid #cfcfcf;
}

.limiter {
  max-width: 640px;
  padding-left: 20px;
  padding-right: 20px;
  margin-left: auto;
  margin-right: auto;
}

/* Padding --------------------------------------- */
.pad2y {
  padding-top: 20px;
  padding-bottom: 20px;
}

span.image-credit {
  float: right;
  margin: 0 0 10px 10px;
  font-size: 12px;
}

span.image-credit:before {
  content: "↑";
  margin-right: 5px;
}

figcaption {
  font-size: 11px;
  text-align: center;
  font-size: 0.8rem;
  margin-top: -1.2rem;
}

div.post blockquote p {
  margin: 0;
}

/** Writing ----------------------------------------------------------------- */
.writing,
.books {
  display: grid;
  grid-column-gap: 5px;
  grid-row-gap: 5px;
}

.writing {
  grid-template-columns: 1fr min-content;
}

.books {
  grid-template-columns: 1fr 0.75fr min-content 70px;
}

.writing a,
.books a {
  font-weight: 500;
  letter-spacing: -0.015em;
}

.writing > div,
.books > div {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.writing time,
.books time {
  padding-right: 0.25em;
  color: #333;
  font-variant-numeric: tabular-nums;
  letter-spacing: -0.012em;
  white-space: pre;
}

.project-box {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-gap: 30px;
}

.project-box a.project {
  text-decoration: none;
  color: #666;
}
.project-box a.project:hover {
  color: #000;
}
.project-box a.project img {
  display: block;
  margin-bottom: 10px;
}

/** Responsive -------------------------------------------------------------- */

@media screen and (max-width: 480px) {
  .project-box {
    grid-template-columns: repeat(1, 1fr);
  }
}

@media screen and (max-width: 640px) {
  .limiter {
    width: auto;
  }
  .project-box {
    grid-template-columns: repeat(2, 1fr);
  }
  .writing,
  .books {
    grid-template-columns: 1fr;
    grid-row-gap: 0px;
  }

  .writing div,
  .books div {
    white-space: normal;
  }

  .writing time,
  .books div:nth-child(4n) {
    padding-bottom: 20px;
  }
}

@media screen and (min-width: 640px) {
  .nu a {
    text-decoration: none;
  }

  .nu a:hover {
    text-decoration: underline;
  }
}

@media screen and (max-width: 1024px) {
  .header-wrap {
    border-bottom: 1px solid #000;
    padding-bottom: 20px;
  }
  .sigil {
    display: none;
  }
}

@media screen and (min-width: 1025px) {
  .header {
    position: absolute;
    /* top: 40px; */
    right: 50%;
    margin-right: 340px !important;
    letter-spacing: -0.009em;
  }
  .content h1:first-child {
    margin-top: 0;
  }
}

@media print {
  .no-print {
    display: none;
  }
  .only-print {
    display: block;
  }
  body {
    margin: 0;
  }
  .limiter {
    max-width: 100% !important;
    margin: 0 !important;
    padding: 0 !important;
  }
}

/** Code highlighting ------------------------------------------------------- */
p code,
pre code,
li code,
g.highlight,
.code {
  font-family: var(--mono-font);
}

p code {
  font-size: 90%;
}

pre code {
  font-size: 0.8rem;
  line-height: 1.5;
}

.highlight,
blockquote {
  overflow-x: auto;
  padding: 10px 20px;
  margin: 0;
  background: #fff;
  border-radius: 10px;
}

blockquote {
  font-style: italic;
}

blockquote p:first-child {
  margin-top: 0;
}

blockquote p:last-child {
  margin-bottom: 0;
}

/* pygments theme. does not support generics. .highlight class omitted */
.highlight {
  margin: 10px 0;
}

.highlight .hll {
  background-color: #ffffcc;
}

.c, /* Comment */
.cm, /* Comment.Multiline */
.cp, /* Comment.Preproc */
.cs, /* Comment.Special */
.c1 {
  color: #999988;
} /* Comment.Single */

.o, /* Operator */
.ow, /* Operator.Word */
.ge {
  color: #000000;
} /* Generic.Emph */

.kc, /* Keyword.Constant */
.kd, /* Keyword.Declaration */
.kn, /* Keyword.Namespace */
.kp, /* Keyword.Pseudo */
.kr, /* Keyword.Reserved */
.kt {
  color: #445588;
} /* Keyword.Type */

.err {
  color: #a61717;
} /* Error */

.m {
  color: #007f7f;
} /* Literal.Number */
.s {
  color: #d01040;
} /* Literal.String */

.na, /* Name.Attribute */
.nb, /* Name.Builtin */
.nc, /* Name.Class */
.no, /* Name.Constant */
.nd, /* Name.Decorator */
.ni, /* Name.Entity */
.ne, /* Name.Exception */
.nf, /* Name.Function */
.nn, /* Name.Namespace */
.nt, /* Name.Tag */
.nl {
  color: #990000;
} /* Name.Label */

.k, /* Keyword */
.nv {
  color: #008080;
} /* Name.Variable */

.mf, /* Literal.Number.Float */
.mh, /* Literal.Number.Hex */
.mi, /* Literal.Number.Integer */
.mo {
  color: #009999;
} /* Literal.Number.Oct */

.sb, /* Literal.String.Backtick */
.sc, /* Literal.String.Char */
.sd, /* Literal.String.Doc */
.s2, /* Literal.String.Double */
.se, /* Literal.String.Escape */
.sh, /* Literal.String.Heredoc */
.s1, /* Literal.String.Single */
.si, /* Literal.String.Interpol */
.ss, /* Literal.String.Symbol */
.bp, /* Name.Builtin.Pseudo */
.sx {
  color: #d01040;
} /* Literal.String.Other */

.sr, /* Literal.String.Regex */
.vc, /* Name.Variable.Class */
.vg, /* Name.Variable.Global */
.vi, /* Name.Variable.Instance */
.il {
  color: #009999;
} /* Literal.Number.Integer.Long */

/** Code for buy me a coffe mobile version ------------------------------------------------------- */

.mobile-only-button {
  margin-top: 30px;
  display: none;
}

@media screen and (max-width: 480px) {
  .mobile-only-button {
    display: flex;
    justify-content: center;
    align-items: center;
    margin-bottom: 50px;
  }
  
  /* Style for the generated iframe */
  .mobile-only-button iframe {
    margin: 0 auto;
  }
}

/** Code for styling reading time ------------------------------------------------------- */

.reading-time {
  color: #475569;
  text-align: right;
  font-style: italic;
}

/** Code for footer + RSS svg ------------------------------------------------------- */

.personal-elements-container, a[rel="nofollow"], .rss-text {
  color:rgb(71, 95, 105);
  font-style: italic;
  display: flex;
  /* align-items: center; */
  flex-direction: column;
  gap: 10px;
}

.rss-link {
  display: flex;
  align-items: flex-end;
}

.search-bar-desktop {
  display: flex;
  justify-content: center;
  margin: auto;
}</style>
  <title>The Minitest Cookbook - dominiclizarraga.github.io</title>
  
  <link rel="canonical" href="http://localhost:4000/2022/01/05/minitest_cookbook.html">
  <script data-name="BMC-Widget" data-cfasync="false" src="https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js" data-id="domlizarrraga" data-description="Support me on Buy me a coffee!" data-message="" data-color="#5F7FFF" data-position="Right" data-x_margin="18" data-y_margin="18"></script>
</head>
<body>
  <div class="search-bar-desktop">
    <script src="/js/lunr.js"></script>

<script>

var documents = [{
    "id": 0,
    "url": "http://localhost:4000/404",
    "title": "",
    "body": "404!"
    }, {
    "id": 1,
    "url": "http://localhost:4000/about/index.html",
    "title": "About",
    "body": "👋 Hey there! I’m Dominic a software developer proficient in Ruby on Rails, Hotwire (including Turbo + Stimulus), JS, APIs, Minitest, Capybara, Postgres, HTML, CSS(bootstrap) &amp; Tailwind. 🚀 I’m currently looking for my next adventure, my last job was with Oblsk where we worked on some amazing projects like PLT4M where I solved user stories from developing new features, creating models, involving ORM queries Sequel, testing with Mini &amp; Capy &amp; CSS responsiveness. 🏃 Then we moved to work on H4H a non-profit org that needed a solution for its marketing team so they can create content easily, here we implemented Strapi API as a headless CMS and Tailwind design (fully-responsive). 🥊 I’m currently working on a Ruby for good project called CASA where I help them to solve stakeholders tickets, I’ve been doing this as a way of giving back to the community and keep learning since this project uses Rspec, bootstrap, JavaScript and bits of jQuery ✨. I consider myself as very resilient and resourceful also I have learnt how to manage my emotional state and communicate efficiently and on time. 🔑 Here you may find my resume, LinkedIn, GitHub or if you want to drop me a line :) Tech stack  Ruby on Rails - Hotwire (Turbo &amp; Stimulus) Tailwind / Bootstrap Minitest &amp; Rspec - Capybara API’s - Agile methodologies SQL &amp; PostgreSQL AWS S3 - JavaScript HTML, CSS - GitHub - HerokuLanguages 🇺🇸 English - Professional 🇲🇽 Spanish - Native 🇩🇪 German - Basic "
    }, {
    "id": 2,
    "url": "http://localhost:4000/confs/index.html",
    "title": "Conferences",
    "body": "Here you'll find the confs that I have attended or will be attending in the future. : {% for conf in page. confs %} {{conf. name}} {{conf. description}}{% endfor %}"
    }, {
    "id": 3,
    "url": "http://localhost:4000/",
    "title": "",
    "body": "{% for post in site. categories. blog %} {{ post. title }} {{ post. date | date:  %Y-%m-%d  }}{% endfor %}"
    }, {
    "id": 4,
    "url": "http://localhost:4000/computer_science/",
    "title": "Computer Science Notes",
    "body": " I've committed to gaining depth in computer science, and here are the notes I'm taking along with the lessons on csprimer. com. :  1st module: Computes Systems.  {% for post in site. categories. computer_science %}  {{ post. title }}  {{ post. date | date:  %Y-%m-%d  }} {% endfor %}"
    }, {
    "id": 5,
    "url": "http://localhost:4000/projects/index.html",
    "title": "Projects",
    "body": "{% for project in page. projects %}  {{project. name}} {{project. description}}{% endfor %}"
    }, {
    "id": 6,
    "url": "http://localhost:4000/reading/index.html",
    "title": "Reading",
    "body": "{% for book in site. categories. book %}   {{ book. title }}  {{ book. author }} {{ book. date | date:  %Y-%m-%d  }}    {% endfor %}"
    }, {
    "id": 7,
    "url": "http://localhost:4000/2024/10/12/intercom-off-scripts.html",
    "title": "Intercom Off Scripts note",
    "body": "2024/10/12 - Here I wrote down some notes after watcihng the Intercom Off-script series about how they are facing the AI age and how the see it playlit Video #1  technology comes and goes,you gotta fall in love with the problem think of the core problem of your business, not the tech stack or framework work is always the same, if you want to send something you used to send it on a horse, now you use ups or fedex, want to entertain people? first it was newspaper now it’s smartphones.  the quickest to adapt, not the strongest does AI would change something in my process?It will blow up the total address of all Market because it will and I will customers or users who know what they want to do however they don’t know how to do it for instance in Excel or monday. com, salesforce who are great product very robust products but not so many people know how to use them, AI will enable them to use them at its maximum We need to rebuild our products our societies around this new technology and it is day one Video #2 Being disturbing pollution change and reshape our society because before that everything was made by hand and after that breakthrough moment we were able to have houses cars clothing Also technology is like a one-way street that once you go and cross that door you never look back before for instance once we had the iPhone in our hands we did not think about the traditional phone call or mail post What matters the most is that customers and businesses get greater experiences, it boils down to it Video #3 Attention algorithm and then wrap up with a Transformer machine learning technique Then the Transformer was trained with the huge amount of data that never before And finally it seems like it is understanding and it is capable to do some summarizing words follow some instructions An example of what AI needs was when governments increase their budget in order to roll out new highways because they saw that as much highways and streets interconnected you have the more trade Commerce and tourist activity you will get in this case AI needs more compute infrastructure and so on (Things happen fast when the value is there and apparently AI is delivering some value) Apparently it is learning because it is paying attention to the important things It’s got some limitations but you can’t work around those limitations People say that it is just a talking prediction like predicting the next word on the sentence RAG Is given the llm more context in order to make it understand the current situation therefore it will provide a more accurate answer Take a small series of tasks That you can really over-delivery on, not too broad. We have used openAI models as building blocks, Maybe five or 10 different prompts Underneath the hood, Each of them doing a specific task like search for this customer in the db, then get their last order, then disambiguate this question From an engineering perspective take five things your product should do and isolate them And get AI to do that task separately Video #4 Mother sauce and software in general seems to be very complicated and clunky because they serve a broad amount of users, It’s like cities in general they are designed for a general audience not for cyclist or pet owners or car drivers Now with AI you can have UI design that is generated on the Fly based on the user request instead of having a form where users submits email phone number number order it will go and retrieve those data from the database and make up a new form just to confirm that the information is correct and it will be completely Custom Tailor to each requested and even to each user It raises the floor for the designers, the human touch becomes more valued If you wear a drummer in the 80s and you see that a rhythm controller has come out you would thought that you are cooked but it happened all the opposite more drummers came to play their songs (democratizacion of music) So you don’t need to become a master at your craft in order to make music however there still need of people who are a master at the craft even when AI provides shortcuts Embrace the squiggle (process of designing something, converge, diverge ideas, discussions, etc) Video #5 Better, faster cheaper on online business Customer service in businesses prior the war was more personal they made individual transactions, and then as the business expanded they needed to hire more customer service in order to make it more Global more professional and then after that the 01800 phone lines came up and that was the time that the call centers started then with computers and internet the email and then the CRM too, chatbots, etc, also how customers leave feedback from the service they got and that was a time where you needed a quality customer service. Easiest decision is to cut people in order to make profit…So in order to increase the quality of your customer service at the internet scale is very difficult Video #6 Big boys and small are no longer selling software seats to humans, but software doing the work. We don’t pay for CS, we pay what’s in the receipt, and CS is all around. Having a internet business bring the benefits of scales which is selling around the clock, around the globe Heretofore (before now, new word) Agents gen1 (conversation, text boxes) and gen 2 (more familiar, proactive and take action) Cannibalize themselves if they want to survive and Netflix did with their shipping DVD business before streaming. "
    }, {
    "id": 8,
    "url": "http://localhost:4000/2024/05/06/this-is-a-test-2.html",
    "title": "This is a test",
    "body": "2024/05/06 - Test 2 "
    }, {
    "id": 9,
    "url": "http://localhost:4000/2024/05/05/utf-8-bits-bytes-binary.html",
    "title": "UTF-8, bits, bytes and binary numbers!",
    "body": "2024/05/05 - Test 1 "
    }, {
    "id": 10,
    "url": "http://localhost:4000/2024/03/12/stimulus-controller-life-cycle.html",
    "title": "Stimulus controller - life cycle",
    "body": "2024/03/12 - "
    }, {
    "id": 11,
    "url": "http://localhost:4000/2024/02/17/refactoring-and-testing.html",
    "title": "Refactoring and testing a long method in Ruby on Rails",
    "body": "2024/02/17 - Recently, we had the opportunity to refactor a lengthy method in a Ruby on Rails project. The method had multiple conditional statements (around 6) that checked various aspects of a project, such as whether it was discarded, on time, accepting entries, and more. Refactoring this method required careful planning and testing to ensure that the functionality remained intact while improving the code’s maintainability and readability. Before diving into the refactoring process, we first focused on writing tests that covered all the edge and corner cases. To do this, we wrote tests that checked the opposite of what the method was currently doing. For each conditional statement, we created a test that verified the expected behavior when the condition was met and when it was not. Here’s an example of how we tested a condition that checked if a project was able to receive entries using FactoryBot: # In the test filedescribe 'Project entries' do it 'should not accept entries when the project is not set to receive entries' do  project = FactoryBot. create(:project, receive_entries: false)  # Assert that the project does not accept entries  expect(project. accept_entries?). to be_falsey end it 'should accept entries when the project is set to receive entries' do  project = FactoryBot. create(:project, receive_entries: true)  # Assert that the project accepts entries  expect(project. accept_entries?). to be_truthy endendBy writing tests for both scenarios (project accepting entries and not accepting entries), we ensured that the refactored method would handle these cases correctly. Once we had a comprehensive test suite in place and all the tests were passing, we started the refactoring process. It’s important to remember that refactoring aims to modify the internal structure of the code without changing its external behavior. The goal is to improve performance, maintainability, and readability while adhering to the DRY (Don’t Repeat Yourself) principle. During the refactoring, we focused on breaking down the long method into smaller, more manageable chunks. we extracted common functionality into separate methods and aimed to reduce the complexity of the conditional statements. Here’s a simplified example of how the refactored method might look: def process_project(project) return if project. discarded? return unless project. on_time? return unless project. accept_entries? # Process the project # . . . endBy separating the conditions into individual guard clauses, the method becomes more readable and easier to understand. Throughout the refactoring process, we continuously ran the tests to ensure that the functionality remained intact and that we didn’t introduce any unintended changes. Refactoring a long method can be a challenging task, especially for beginners. However, by following a systematic approach of writing comprehensive tests, breaking down the method into smaller parts, and focusing on improving maintainability and readability, you can successfully refactor your code and make it more manageable for future changes. Remember 🎗️, refactoring is an iterative process, and it’s okay to take small steps and gradually improve your code over time. By consistently applying good coding practices and seeking feedback from more experienced developers, you can continuously enhance your refactoring skills and write cleaner, more maintainable code.  Breaking down the method into smaller, more manageable pieces.  Applying the DRY (Don’t Repeat Yourself) principle to eliminate redundancy.  Enhancing performance and maintainability to ensure the code could be easily modified in the future. "
    }, {
    "id": 12,
    "url": "http://localhost:4000/2024/02/14/difference-between-buttonto-linkto-formwith.html",
    "title": "What's the difference behing button_to link_to form_with",
    "body": "2024/02/14 - In this blog post I’ll share my findings when developing a Like model and how I got to find these differences very particular. remote: true "
    }, {
    "id": 13,
    "url": "http://localhost:4000/2024/02/07/follow-as-polymorphic.html",
    "title": "Follow as Polymorphic",
    "body": "2024/02/07 - In this blog post I’ll share my findings when developing a Follow model (User can follow another User, Post, Comapny) with a polymorphic property. With the next models you can create a ‘Following’ feature that can be applied to almost any model you want, just add one line of code. class User &lt; ApplicationRecord # Users that follow this user 'Followers' has_many :followers, class_name: 'Follow', as: :followable # Entities this user follows 'Following' has_many :following, class_name: 'Follow', foreign_key: 'user_id'endclass Follow &lt; ApplicationRecord belongs_to :user # who is making/pushing the button  Follow  (doing the following) belongs_to :followable, polymorphic: true # This validation doesn't allow that user_1 follow user_2 twice validates :user_id, uniqueness: { scope: [:followable_type, :followable_id] }endLet’s try out the code in rails console rails consoleu1 = User. firstu2 = User. lastfollow = u1. following. create(followable: u2)Follow Create (3. 8ms) INSERT INTO  follows  ( user_id ,  followable_type ,  followable_id ,  created_at ,  updated_at ) VALUES ($1, $2, $3, $4, $5) RETURNING  id  [[ user_id , 1], [ followable_type ,  User ], [ followable_id , 18], [ created_at ,  2024-02-29 05:25:28. 228037 ], [ updated_at ,  2024-02-29 05:25:28. 228037 ]] TRANSACTION (0. 6ms) COMMIT=&gt; #&lt;Follow:0x0000000102d226e0 id: 6, user_id: 1, followable_type:  User , followable_id: 18, created_at: Thu, 29 Feb 2024 05:25:28. 228037000 UTC +00:00, updated_at: Thu, 29 Feb 2024 05:25:28. 228037000 UTC +00:00&gt;Follow. count=&gt; 1u1. following. create(followable: u2)=&gt; TRANSACTION (0. 8ms) ROLLBACK (due to model validation)# class User# def follows?(user)#  following. exists?(followable: user)# endu1. follows? u2=&gt; trueu2. followers=&gt; [#&lt;Follow:0x000000012eb126d0 id: 6, user_id: 1, followable_type:  User , followable_id: 18, created_at: Thu, 29 Feb 2024 05:12:17. 215129000 UTC +00:00, updated_at: Thu, 29 Feb 2024 05:12:17. 215129000 UTC +00:00&gt;]u1. following[#&lt;Follow:0x0000000102b63fc0 id: 6, user_id: 1, followable_type:  User , followable_id: 18, created_at: Thu, 29 Feb 2024 05:12:17. 215129000 UTC +00:00, updated_at: Thu, 29 Feb 2024 05:12:17. 215129000 UTC +00:00&gt;, #&lt;Follow:0x0000000102d226e0 . . . ]And it worked for other models like (Post, Company, etc) class Post &lt; ApplicationRecord has_many :followers, class_name: 'Follow', as: :followableenduser = User. find(user_id)post = Post. find(post_id)user. following. create(followable: post) TRANSACTION (0. 6ms) COMMIT=&gt; #&lt;Follow:0x0000000150038080 id: 8, user_id: 1, followable_type:  Post , followable_id: 92, created_at: Thu, 29 Feb 2024 05:56:29. 921783000 UTC +00:00, updated_at: Thu, 29 Feb 2024 05:56:29. 921783000 UTC +00:00&gt;We’ve explored creating a follower system in Rails, showcasing the flexibility of polymorphic associations and the importance of validations. This guide provides a solid foundation for adding social functionalities to your Rails applications, ensuring a robust and scalable feature set. "
    }, {
    "id": 14,
    "url": "http://localhost:4000/2024/01/28/beginner-guide-docker.html",
    "title": "Beginner guide to Docker 🐳",
    "body": "2024/01/28 - This is a guide to explore what is Docker and also when it’s useful. "
    }, {
    "id": 15,
    "url": "http://localhost:4000/2024/01/26/action-policy-cache.html",
    "title": "Action policy gem + Cache",
    "body": "2024/01/26 - Recently I worked with an app that was using Action Policy, I noticed that those policies were being called almost everywhere! So I started a small research and found that there was a section for cache authorizations. Let’s dive in with Redis and how policies are saved in memory. Here are the official (docs)[https://actionpolicy. evilmartians. io/#/caching] for combinig action policy + cache. "
    }, {
    "id": 16,
    "url": "http://localhost:4000/2024/01/22/when-you-see-the-count.html",
    "title": "When you see the `.count` in a Rails view 👀",
    "body": "2024/01/22 - I’ve been working on improving the app performance and have learnt about how. count works and how it can slow down the app. As a solution we have counter_cacheprovided by default by rails and also something more advance like counter_culturegem! Let’s see how it can improve you app as well! "
    }, {
    "id": 17,
    "url": "http://localhost:4000/2024/01/18/the-where-clause.html",
    "title": "Avoiding N+1 Queries 🚓",
    "body": "2024/01/18 - When optimizing an app, I recently learned to pay attention to the . where or . find methods inside . each loops because they can be potential candidates for association preloading. The reason is that for each element we iterate over, another operation will be executed, in this case . where or . find, which can lead to an N+1 query problem. Let’s see how it works. # Controller actiondef index @posts = Post. allend# View template&lt;% @posts. each do |post| %&gt; &lt;h2&gt;&lt;%= post. title %&gt;&lt;/h2&gt; # This will trigger separate query for each post to fetch the author &lt;p&gt;Author: &lt;%= post. author. name %&gt;&lt;/p&gt; # This will trigger separate query for each post to fetch the comments &lt;p&gt;Comments: &lt;%= post. comments. count %&gt;&lt;/p&gt;&lt;% end %&gt;SQL produced: -- 1 for Post. allSELECT  posts . * FROM  posts -- 2 for each post's author and comments count, this can get really worseSELECT  authors . * FROM  authors  WHERE  authors .  id  = ? LIMIT 1 [[ id , 1]]SELECT COUNT(*) FROM  comments  WHERE  comments .  post_id  = ? [[ post_id , 1]]To avoid this we can use . includes # Controller actiondef index # we eagerly load the author and comments for all the posts in a single query @posts = Post. includes(:author, :comments). allend# View template&lt;% @posts. each do |post| %&gt; &lt;h2&gt;&lt;%= post. title %&gt;&lt;/h2&gt; &lt;p&gt;Author: &lt;%= post. author. name %&gt;&lt;/p&gt; &lt;p&gt;Comments: &lt;%= post. comments. count %&gt;&lt;/p&gt;&lt;% end %&gt;SQL produced: -- 1 for Post. includes(:author, :comments), which eagerly loads the associated author and comments-- The number of queries is reduced to 3 (1 for posts, 1 for authors, 1 for comments), regardless of the number of posts. SELECT  posts . * FROM  posts SELECT  authors . * FROM  authors  WHERE  authors .  id  IN (1, 2, 3)SELECT  comments . * FROM  comments  WHERE  comments .  post_id  IN (1, 2, 3)Another alternative is to use . eager_load instead of . includes. The difference is that . includes uses separate queries to load the associations, while . eager_load uses a single query with a LEFT_OUTER_JOIN. Here I have a deeper blog about it! Just wanted to highlight that you must be careful of those where, find and find_by inside of loops! "
    }, {
    "id": 18,
    "url": "http://localhost:4000/2024/01/16/cache-and-redis.html",
    "title": "Key concepts for Redis and cache 💽",
    "body": "2024/01/16 - Expire Bust Cache hit Cache miss user. touch Setting up redis in production since developers want a slower app in development rails dev:cache "
    }, {
    "id": 19,
    "url": "http://localhost:4000/2024/01/14/what-is-cache.html",
    "title": "What is cache? 💵 💰",
    "body": "2024/01/14 - Currently, I’m focusing on enhancing the performance of an application, and one of the key areas I’ve explored in-depth is caching. Although I was aware of caching before, I didn’t fully grasp its concept or have the opportunity to apply it, so I never felt compelled to delve into it. If you find yourself in a similar position, here are some initial steps to build a strong understanding of caching :) What is cache? The term ‘cache’ is an English word meaning a secure place where items are stored and hidden. Now this concept will make more sense in computing. Cache is a method of storing frequently accessed data in fast memory to keep it closer to the user. This fast memory can be found either on hard drives, processors (like CPUs and GPUs) or web browser, web server, databases, client-side, CDNs and it goes from KBs to MBs and in different layers (L1, L2, etc). In browser for example, the first time you visit a web site it will download the HTML, CSS and images then computer will save a copy of those files. The next time you visit that page, it will retrieve a local copy instead of requesting a web server, which speeds up the process. Think of a coffee shop where the barista keeps commonly used items like milk and sugar at hand, rather than going to the storage room for each order. This is like 'caching', where frequently used data is kept readily accessible. ☕️ Fun fact: The concept of caching was originally proposed in 1965 by Maurice Wilkes. Paper When is it useful? There are 2 main ways so far to implement with Ruby on Rails app.    HTTP Caching - Web browser can cache HTTP responses to enable faster retrieval data. It improves response time and reduce load on back-end. By storing copies of frequently accessed data, caching reduces the need for repeated requests to the server, thereby enhancing overall performance and user experience. (Mostly for Static assets and JSON APIs and AJAX endpoints. )     This involves caching within the application itself and can be tailored to the specific needs of your Rails application. Rails provides several caching techniques like page caching, action caching, and fragment caching.  How to use it in rails? Rails has 3 ways of caching data: page, action and fragment. Each of them has different purposes.    Page caching stores the entire HTML response, serving it directly from the web server without hitting the Rails stack.     Action caching caches the output of controller actions.     Fragment caching is more granular and caches smaller pieces of a view.  Also there are different techniques as well like Russian Doll Caching, Shared partial caching, Low-Level Caching and Key-based cache expiration. Extra tools you need. 🛠️ Rails caching is designed to be backend agnostic. This means you can implement custom caching solutions or adapters for other storage mechanisms. Redis: Advanced in-memory data store, supports complex structures, ensures data persistence, replication, and integrity. Memcached: Efficient, simple key-value store, ideal for caching static data, quick setup. Memory Store: Caches data in the Rails server’s memory. This is a good option for single-server setups and development environments. File Store: Caches data as files on the disk. This can be useful in environments where memory is limited. Is it truly beneficial for your App? Currently in the implementation phase, the improvements are evident on the pages where it has been applied. It is advisable to compare response times before and after implementing these changes. If feasible, establish a Maximum Average Response Time (MART) as a benchmark. More when we complete this process! "
    }, {
    "id": 20,
    "url": "http://localhost:4000/2023/12/17/kasper-product-focused-ruby.html",
    "title": "Product Focused Ruby - Kasper Timm Hansen.",
    "body": "2023/12/17 - Sketching and mental model of programming. I recently attended a live session with Kasper Timm Hansen, he unfolded his approach to product-focused development, blending technical prowess with real-world problem solving. 1st session notes: How to start sketching out a new feature development. 1. - Have a problem definition. 2. - In a rails context, start with a controller and start figuring out how to pass stuff to the view (it will give you a lot of constraints already). 3. - Then sketch stuff out like write methods that reflect “complete” and “uncomplete” (for a Todo app and task feature), don’t focus on assigning instance variables, inheritance of the controller (you save this for later). 4. - At this point we have how routes are going to be. What are going to be the “resources” are they going to be nested? We have figured out the organizational stuff around things. So now we know how to put into business logic and complete it. 5. - Take a break from it like an outside view of like, okay, can I name this differently because. So far, it's just more meant to have a direct communication with what I intend to code and my own mental model rather than the code that I'm ending up generating. If the problem definition has a known unknown that would be one thing to start tackling, or it can help reveal unknown unknowns. And and then figure out, if it's something involved with like TCP connections, and we haven't worked with those before. Use method you know how they work to keep sketching things out (inheritance from ApplicationController or RESTful methods). 6. - Delineate between what’s the feature, and what’s the architecture? User model would be architecture and User and its Invite (User::Invite) would be the feature. This prorcess should be really flexible, really fluid, like having a conversation and not to be attached to the code you've written. Also play around with `irb`, read the Ruby docs and seek. Making abstractions by finding concepts through ‘naming’. 1. - Now that you have a sense of the concept and know how things fit together. 2. - You can build solid blocks of knowledge that you can later use. In example, how a AssociationObject works and you find more similar cases in the rest of the app. 2nd session notes (more hands-on): 1. - At the very start of the feature cycle, what you essentially do is a deep dive. You try to keep going for about half an hour, maybe an hour and you’re just trying to fire off ideas. 2. - Try to take full advantage of the fact that Ruby reads somewhat like pseudocode. It’s a case of ‘first thought, best thought’, allowing for a more rapid-fire approach. 3. - What you actually want is to quickly formulate a hypothesis. Figure out how to disprove or prove it, at least, and then keep making rapid changes. "
    }, {
    "id": 21,
    "url": "http://localhost:4000/2023/12/14/how-to-explore-a-new-codebase.html",
    "title": "How to quickly deep dive into a new code base.",
    "body": "2023/12/14 -    Utilize the user interface (UI) to create domain model objects (Posts, Books, Reservations, etc), followed by monitoring the server-side Rails logs.     Examine the generated SQL and then directly access the database using either psql or the rails dbconsole.     Read the Models file (book. rb), search for associations, callbacks, scopes.     Lastly look up the most recent record that has been saved or added to the database rails c and play with it.  "
    }, {
    "id": 22,
    "url": "http://localhost:4000/2023/12/12/always-have-a-question-in-mind.html",
    "title": "Always have a question to solve in mind.",
    "body": "2023/12/12 - I recently explored a new code base, which was challenging, but focusing on a specific question helped me to direct my research more effectively…. . "
    }, {
    "id": 23,
    "url": "http://localhost:4000/2023/12/06/n-+-1-queries.html",
    "title": "N + 1 queries and how to fix them.",
    "body": "2023/12/06 - I recently had to deal with a n + 1 query…. Firstly let’s understand why does this happen? The N+1 query problem is like inviting friends to a party and then calling each one separately to ask if they’re coming. If you have 10 friends, you make 1 call to decide to invite them and then 10 more calls to each friend. So, for 10 friends, you make 11 calls in total. In databases, this is like fetching a list of items (like blog posts), and then for each item, making another query to fetch related data (like comments on each post). If you have 10 posts and you fetch comments for each one by one, you end up making 1 query to get all posts plus 10 more queries for comments, leading to 11 queries. But why in db happens this?? The First Query (N): When you ask for the list of posts, the ORM makes one query to fetch all posts. This is your “N” part of the problem, where “N” is the number of posts. The Plus One (+1) Part: For each post, when you try to access its comments, the ORM realizes it hasn’t fetched those yet. So, it makes a new query for each post to fetch its comments. If you have 10 posts, this approach results in 10 additional queries - one for each post to get its comments. The ORM’s default behavior is to load data on demand (lazy loading). It avoids fetching related data until you explicitly access it, which can be efficient in scenarios where the related data is not needed. However, when you do need related data for each item in a list, it leads to multiple queries, creating the N+1 problem. Example: # rails console@events = Event. all Event Load (0. 5ms) SELECT  events . *  FROM  events  /* loading for pp */ LIMIT ? [[ LIMIT , 11]]# Each call to `event. attendees` for an `event` triggers a separate query to fetch the `attendees` for just that `event`. @events. each do |event| puts  Event: #{event. name}  👉event. attendees. each do |attendee|  puts   Attendee: #{attendee. name}  endend# Logs:👉Event Load (0. 2ms) SELECT  events . * FROM  events  Event: Tech Conference 👉Attendee Load (0. 1ms) SELECT  attendees . * FROM  attendees  INNER JOIN  registrations  ON  attendees .  id  =  registrations .  attendee_id  WHERE  registrations .  event_id  = ? [[ event_id , 1]]  Attendee: Alice  Attendee: Bob  Attendee: Charlie Event: Music Festival 👉Attendee Load (0. 0ms) SELECT  attendees . * FROM  attendees  INNER JOIN  registrations  ON  attendees .  id  =  registrations .  attendee_id  WHERE  registrations .  event_id  = ? [[ event_id , 2]]  Attendee: Bob  Attendee: DanaData to recreate a small excercise: Let’s create a small app so we can see in detail what is being produced by each active record method. # Create app with name `preload_demo_app`rails new preload_demo_app# Go to `preload_demo_app` dircd preload_demo_appThen let’s create models and add the associations we need needed. # Create `Event` modelrails generate model Event name:string location:string start_time:datetime# Create `Attendee` modelrails generate model Attendee name:string# Create `Registration` modelrails generate model Registration event:references attendee:referencesActive Record Associations 👇 # app/models/event. rbclass Event &lt; ApplicationRecord has_many :registrations has_many :attendees, through: :registrationsend# app/models/attendee. rbclass Attendee &lt; ApplicationRecord has_many :registrations has_many :events, through: :registrationsend# app/models/registration. rbclass Registration &lt; ApplicationRecord belongs_to :event belongs_to :attendeeendOne last step, we need some data to play with: # eventsevent1 = Event. create(name:  Tech Conference , location:  Conference Center , start_time: DateTime. new(2024, 5, 20, 10, 0, 0))event2 = Event. create(name:  Music Festival , location:  Outdoor Park , start_time: DateTime. new(2024, 6, 15, 12, 0, 0))# attendeesattendee1 = Attendee. create(name:  Alice )attendee2 = Attendee. create(name:  Bob )attendee3 = Attendee. create(name:  Charlie )attendee4 = Attendee. create(name:  Dana )# registrations Registration. create(event: event1, attendee: attendee1)Registration. create(event: event1, attendee: attendee2)Registration. create(event: event1, attendee: attendee3)Registration. create(event: event2, attendee: attendee2)Registration. create(event: event2, attendee: attendee4)With this in place we can start playing with the model by opening ‘rails c’ 🔺 Let’s see includes behavior: # `. includes` is designed to minimize the number of queries and the overall load on the database by preloading associated dataEvent. includes(:attendees) # See the `IN` SQL keyword in the query for both `registrations` and `attendees` # A single SQL query that retrieves both in a single database roundtrip.  Event Load (0. 3ms) SELECT  events . * FROM  events  /* loading for pp */ LIMIT ? [[ LIMIT , 11]]  Registration Load (0. 4ms) SELECT  registrations . * FROM  registrations     WHERE  registrations .  event_id  IN (?, ?) [[ event_id , 1], [ event_id , 2]]  Attendee Load (0. 1ms) SELECT  attendees . * FROM  attendees     WHERE  attendees .  id  IN (?, ?, ?, ?) [[ id , 1], [ id , 2], [ id , 3], [ id , 4]]🔺 Now preload: Event. preload(:attendees) # See the `IN` SQL keyword as well, here the key difference is how you apply the `. where` Event Load (0. 1ms) SELECT  events . * FROM  events  /* loading for pp */ LIMIT ? [[ LIMIT , 11]] Registration Load (0. 3ms) SELECT  registrations . * FROM  registrations   WHERE  registrations .  event_id  IN (?, ?) [[ event_id , 1], [ event_id , 2]] Attendee Load (0. 1ms) SELECT  attendees . * FROM  attendees   WHERE  attendees .  id  IN (?, ?, ?, ?) [[ id , 1], [ id , 2], [ id , 3], [ id , 4]]🔺 eager_load: Event. eager_load(:attendees) # See the LEFT OUTER JOIN, it ensures that even `events` without any attendees are included in the result SQL (0. 1ms) SELECT DISTINCT  events .  id  FROM  events   LEFT OUTER JOIN  registrations  ON  registrations .  event_id  =  events .  id   LEFT OUTER JOIN  attendees  ON  attendees .  id  =  registrations .  attendee_id  /* loading for pp */ LIMIT ? [[ LIMIT , 11]] SQL (0. 1ms) SELECT  events .  id  AS t0_r0,  events .  name  AS t0_r1,  events .  location  AS t0_r2,   events .  start_time  AS t0_r3,  events .  created_at  AS t0_r4,  events .  updated_at  AS t0_r5,   attendees .  id  AS t1_r0,  attendees .  name  AS t1_r1,  attendees .  created_at  AS t1_r2,    attendees .  updated_at  AS t1_r3 FROM  events  LEFT OUTER JOIN  registrations    ON  registrations .  event_id  =  events .  id  LEFT OUTER JOIN  attendees    ON  attendees .  id  =  registrations .  attendee_id  WHERE  events .  id    IN (?, ?) /* loading for pp */ [[ id , 1], [ id , 2]]🔺 What happens with . joins: event = Event. find_by(name:  Tech Conference )Event Load (0. 1ms) SELECT  events . * FROM  events  WHERE  events .  name  = ? LIMIT ? [[ name ,  Tech Conference ], [ LIMIT , 1]]# Usage of `. joins`Attendee. joins(:registrations). where(registrations: {event_id: event. id}) # an `INNER JOIN` is performed between `attendees` and `registrations`.  # It uses the association named `registrations` defined in the `Attendee` model.  Attendee Load (0. 2ms) SELECT  attendees . * FROM  attendees   INNER JOIN  registrations  ON  registrations .  attendee_id  =  attendees .  id   WHERE  registrations .  event_id  = ? /* loading for pp */ LIMIT ? [[ event_id , 1], [ LIMIT , 11]]Event. joins(:registrations). distinct # See the `DISTINCT` in the `SELECT` statement (ensures that events are listed uniquely).  SELECT DISTINCT  events . * FROM  events   INNER JOIN  registrations  ON  registrations .  event_id  =  events .  id  Summary: Hope you get more understanding on this topic! More blog posts here: 👇 Bhumi’s N + 1 blog postarunyadav N + 1Benito Serna N + 1 ebookSo you need a sort at database level or just with ruby is enough? "
    }, {
    "id": 24,
    "url": "http://localhost:4000/2023/12/01/debugging-libraries.html",
    "title": "Debugging libraries for Ruby and Rails",
    "body": "2023/12/01 - Exploring Ruby Debugging Tools Section 1: Pry Pry GitHub Section 2: Pry-Rails Pry-Rails GitHub Difference between “pry” and “pry-rails” Stackoverflow response Section 3: Debug Debug GitHub Section 4: Byebug Byebug GitHub "
    }, {
    "id": 25,
    "url": "http://localhost:4000/2023/11/21/hotwire-codex.html",
    "title": "The Rails and Hotwire Codex 🌀",
    "body": "2023/11/21 - Notes: Turbo Native is the core of Hotwire’s native extensions. It orchestrates a native web view through multiple screens within native navigation. This way the app has a native feel, despite all the content being rendered using the same HTML views as the web app. Native navigation: Navigation in a Turbo Native app is completely native. When the user taps a link, a native method is called to handle the visit proposal. If a fully native screen is preferred for a given URL, this method is where that choice can be made. More commonly, we’ll want to visit the destination URL. 1) When a link is tapped, 2) Turbo Native creates a new screen, 3) injects the web view into it, 4) drives the web view to the new location using Turbo, and 5) displays the screen to the user. Authentication: Turbo Native apps use cookie based authentication for requests originating in a web view. If you have purely native screens and need to make HTTP requests from native code, you’ll need to implement a form of token based authentication on the server. Session: A session co-ordinates a single native web view. It’s responsible for triggering URL visits using Turbo, and for inserting the web view into new screens when displayed to the user, we’ll use a different session for each tab so the navigation in each tab is totally independent. Path Configuration: The path configuration is a JSON file stored in the app bundle. This file specifies a set of rules that match URLs, using regex patterns, to a set of properties. These properties define how a URL should be displayed in the app. If a particular URL has a fully native screen, this is where we tell Turbo Native about that. Feature flags and other settings can also be defined making it simple to turn features on and off remotely. All of this content was taken from book below, they’re personal notes. I encourage you buy it. Book link is here. "
    }, {
    "id": 26,
    "url": "http://localhost:4000/2023/11/13/conf-7.html",
    "title": "Ruby conf @ San Diego, CA.",
    "body": "2023/11/13 - Blog about this conf is pending. "
    }, {
    "id": 27,
    "url": "http://localhost:4000/2023/11/08/shape-up.html",
    "title": "Shape up 🎢",
    "body": "2023/11/08 - Shaping Up Methodology Notes: These are some insights I’ve gathered from the “Shaping Up” methodology, which is neither Scrum nor dependent on Kanban boards. The Challenge of Building Software: In the realm of software development, there’s a substantial element of the unknown, given that what we’re building hasn’t existed before. Waiting six months to realize we’re on the wrong path is excessively long, while a two-week span is typically too brief to produce anything substantial. The Solution: Defining Scope and Time: The solution lies in defining smaller projects that are actionable and testable. A period of six weeks is sufficient to both complete and deliver a project and short enough to allow for directional changes should they be necessary. Key Idea #1: Estimate vs. Appetite: Instead of attaching a time estimate to a technical task, we should ask ourselves how much time we actually want to spend on this project. Consider the analogy of setting a budget before choosing a restaurant for dinner; it’s a strategic approach that takes into account the value, urgency, and business context. We should strive for an agreement between product teams and technical staff to ensure the time is fixed and the scope is adaptable. Key Idea #2: Shaping: “Shaping” considers two major questions about scope: “What is included?” and “What is excluded?” It also addresses the detail required upfront versus what can be delegated to the team to resolve later. “Latitude” refers to the level of freedom or specificity given to the team. A key part of shaping is the willingness to abandon features that are either technically impractical or not critical to the user interface. Key Idea #3: Autonomy: Teams, consisting of two to three members, collaborate within a six-week cycle to deliver the complete project, not merely pieces of it. These teams maintain their focus without being burdened by unrelated tasks and are self-managed, operating at their own pace. Work is distinguished as either planned (strategic) or unplanned (reactive). Further Learning:  Shaping in a Nutshell Applying Shape Up in the Real World - Rails World 2023"
    }, {
    "id": 28,
    "url": "http://localhost:4000/2023/11/07/decompose-for-method-call.html",
    "title": "Decompose for method calls",
    "body": "2023/11/07 - In Ruby, it is possible to decompose the elements of arrays/hashes into distinct variables. Since values appear within arrays in a index order, they are unpacked into variables in the same order. # Decompose of an array&gt;&gt; fruits = [ apple ,  banana ,  cherry ]&gt;&gt; x, y, z = fruits&gt;&gt; x=&gt;  apple In this case we are going to use decompose for a method call, (with arrays only one splat needed *). def send_welcome_email(name, email, signup_date) puts  Sending welcome email to: #{name}  puts  Email: #{email}  puts  Signed up on: #{signup_date} end# Array of user informationuser_data = ['Jane Doe', 'jane. doe@example. com', '2023-04-01']# Using splat to pass an array of elementssend_welcome_email(*user_data) 👈# This code will output:Sending welcome email to: Jane DoeEmail: jane. doe@example. comSigned up on: 2023-04-01Now we are going to decompose for a hash, (two splats needed **). def configure_user(profile:, preferences:, settings:) puts  Configuring user profile:  puts  Profile: #{profile}  puts  Preferences: #{preferences}  puts  Settings: #{settings} end# Hash of user configurationuser_configuration = { profile: { username: 'johndoe', language: 'EN' }, preferences: { theme: 'dark', notifications: true }, settings: { privacy: 'high', location: 'off' }}# Using 2 splats to pass a hashconfigure_user(**user_configuration) 👈# This code will output:Configuring user profile:Profile: {:username=&gt; johndoe , :language=&gt; EN }Preferences: {:theme=&gt; dark , :notifications=&gt;true}Settings: {:privacy=&gt; high , :location=&gt; off }"
    }, {
    "id": 29,
    "url": "http://localhost:4000/2023/11/02/positional-vs-keyword-params.html",
    "title": "Positional vs Keyword arguments",
    "body": "2023/11/02 - When I began programming, I was puzzled by why some parameters were named and others not. Seeing *argument_name or **argument_name threw me for a loop. 😳 Here you’ll find the definitive guide to understand both! Positional arguments: # This method takes any number of user names as positional arguments. 🙋🙋‍♀️def greet_users(*users) users. each { |user| puts  Hello, #{user}!  }end# Passing individual user names to the method, which are packed into an array. greet_users( Alice ,  Bob ,  Carlos )# Outputs:# Hello, Alice!# Hello, Bob!# Hello, Carlos!# This method can take a variable number of fruit names. 🍎🍌def list_fruits(*fruits) fruits. join(', ')end# Passing a list of fruits to the method. puts list_fruits( Apple ,  Banana ,  Cherry )# Outputs: Apple, Banana, CherryKeyword arguments: # Usage of ** for keyword arguments: 🙋🙋‍♀️def greet_users(**users) users. each do |identifier, user_info|  puts  Hello, #{user_info[:name]}!  endend# Passing user details as keyword arguments. # The keys `:user1`, `:user2`, and `:user3` are identifiers for each user's hash. greet_users( user1: { name:  Alice , age: 30 }, user2: { name:  Bob , age: 22 }, user3: { name:  Carlos , age: 25 })# Outputs:# Hello, Alice!# Hello, Bob!# Hello, Carlos!# This method takes a variable number of fruit names with details. 🍎🍌def list_fruits(**fruits_with_details) fruits_with_details. map { |fruit, color|  #{fruit}: #{color}  }. join(', ')end# Passing a hash of fruits with details to the method. puts list_fruits(Apple:  Green , Banana:  Yellow , Cherry:  Red )# Outputs: Apple: Green, Banana: Yellow, Cherry: Red# More real example of user attributes as keyword arguments. 🙋🙋‍♀️def create_user_profile(**attributes) puts  Creating a profile for: #{attributes[:name]}  puts  Email: #{attributes[:email]}  if attributes[:email] puts  Signup Date: #{attributes[:signup_date]}  if attributes[:signup_date]end# Passing attributes as a hash, packed with a double splat. create_user_profile(name:  Jane Doe , email:  jane. doe@example. com , signup_date:  2023-04-01 )# Outputs:# Creating a profile for: Jane Doe# Email: jane. doe@example. com# Signup Date: 2023-04-01Passing objects 🙋🙋‍♀️: class User attr_reader :name def initialize(name)  @name = name endend# Create an array of User instancesusers = [ User. new( Alice ), User. new( Bob ), User. new( Carlos )]# Define the greet_users method to accept multiple user objectsdef greet_users(*users) users. each { |user| puts  Hello, #{user. name}!  }end# Call greet_users with the array of User instancesgreet_users(*users)# Outputs:# Hello, Alice!# Hello, Bob!# Hello, CarlosIf you already have a hash with the appropriate keys, you can pass it to the method using the double splat operator **, which will convert the hash into keyword arguments. Docs for reference: *positional_argument **keyword_argument "
    }, {
    "id": 30,
    "url": "http://localhost:4000/2023/10/26/lastest-tips-and-tricks.html",
    "title": "Latest tips & tricks | Ruby & Rails",
    "body": "2023/10/26 - First filter then map: When you first filter a collection, you’re reducing its size by selecting only the elements that meet a certain condition. This step inherently decreases the number of items that will subsequently be processed by the map operation. Imagine you have an array of user records, and you’re only interested in processing active users with an age above 18, where the processing involves a complex calculation. users = User. allactive_adult_users = users. filter { |user| user. active? &amp;&amp; user. age &gt; 18 }processed_users = active_adult_users. map { |user| complex_calculation(user) }In this case, filtering out inactive users or those under 18 before applying the complex calculation minimizes the number of calculations, thus improving the performance. If you were to map first and then filter, every element in the collection, this means potentially performing a lot of unnecessary work. Remember: . select, . filter and find_all are Enumerable methods that do the same thing! Similar methods are . collect and . map! filter_map vs filter + map: The filter_map method iterates over an enumerable, applying a block to each element. This approach eliminates the need to iterate over a collection twice (once for filtering and once for mapping). Performance Benefits filter_map is more efficient than using filter and map separately because:  It reduces the number of iterations over the collection to just one.  It avoids creating an intermediate array that would result from the first operation (filter or map) before passing it to the second operation. fruits = ['apple', 'pear', 'banana', 'cherry', nil, 'fig', 'grape']uppercase_fruits = fruits. filter_map { |fruit| fruit. upcase if fruit&amp;. length &gt; 4 }puts uppercase_fruits # Output: [ APPLE ,  BANANA ,  CHERRY ,  GRAPE ]With both methods separate filter + map fruits = ['apple', 'pear', 'banana', 'cherry', nil, 'fig', 'grape']# First, filter out the fruits with more than 4 letters, excluding nil valuesfiltered_fruits = fruits. filter { |fruit| fruit&amp;. length &gt; 4 }# Then, map the filtered fruits to uppercaseuppercase_fruits = filtered_fruits. map(&amp;:upcase)puts uppercase_fruits # Output: [ APPLE ,  BANANA ,  CHERRY ,  GRAPE ]find_each vs all + each: When dealing with ActiveRecord objects, understanding the difference between find_each and using all followed by each is crucial for optimizing database interactions and memory usage. Using all followed by each is a straightforward way to iterate over a collection of records from the database. all retrieves all the records and loads them into memory, and each then iterates over these records one by one. Student. all. each do |student| puts student. nameendThings to consider:  Memory Usage: If the students table contains a large number of records, loading all of them with all can consume a significant amount of memory,find_each find_each is specifically designed to manage memory consumption and efficiency when processing large numbers of records. Instead of loading all records into memory at once, find_each retrieves and loads records in batches, processing each batch before moving on to the next. By default, the batch size is 1000 records, but you can specify a different batch size if needed. # Students records are proccesed in batches of 100, significantly reducing memory usage. Student. find_each(batch_size: 100) do |student| puts student. name endfind_each has different options to apply more details. Student. find_each(batch_size: 200, start: 1000, finish: 5000, order: :desc, error_on_ignore: true) do |student| # Your processing logic hereend. count vs . length vs . size: count directly translates to a SELECT COUNT(*) SQL query against the database. It asks the database to count the number of entries that match the query and does not load the objects into memory. This makes it very efficient for large datasets. Every time you call count, it performs a database query, which could be a downside if called repeatedly without a need for real-time accuracy. It will make an SQL COUNT regardless of the state of the collection in memory. (See this article to know how to tackle count efficiently) book = Book. first# Book Load . . . book. comments. load# Comment Load (0. 3ms) SELECT  comments . * FROM  comments  WHERE  comments .  book_id  = $1 [[ book_id , 1]]book. comments. count# Comment Count (0. 5ms) SELECT COUNT(*) FROM  comments  WHERE  comments .  book_id  = $1 [[ book_id , 1]]length loads the entire collection of objects into memory and then counts the number of elements. This can be memory-intensive for large datasets because it initializes all the objects. It does not trigger an extra database query if the collection is already loaded. ActiveRecord loads the comments from the database (if they haven’t been loaded already) to count them. The count is done by Ruby in memory after loading the records. blogpost = BlogPost. first# BlogPost Load . . . blogpost. comments. to_a # Comment Load (0. 2ms) SELECT  comments . * FROM  comments  WHERE  comments .  blog_post_id  = $1 [[ blog_post_id , 1]] [[ blog_post_id , 1]]blogpost. comments. length# (no additional database query is executed, comments are already loaded into memory. )size combines the behaviors of both count and length. If the collection has already been loaded, size will calculate the number of elements in-memory, avoiding a database query. If the collection has not been loaded, it will perform a SELECT COUNT(*) query, similar to count. When a counter cache is implemented, . size uses the cached value for the count, eliminating the need for database queries to count the records. With data loaded: # `size` if loaded, calculates the length with Rubyblogpost = BlogPost. first# BlogPost Load . . . blogpost. comments. load# Comment Load (0. 5ms) SELECT  comments . * FROM  comments  WHERE  comments .  blog_post_id  = $1 [[ blog_post_id , 1]]puts blogpost. comments. size# (no db hit) - Uses Ruby to calculate the size from the loaded collectionWithout data loaded: # `size` if not loaded, performs an SQL COUNT queryblogpost = BlogPost. first# BlogPost Load . . . puts blogpost. comments. size# Comment Count (0. 4ms) SELECT COUNT(*) FROM  comments  WHERE  comments .  blog_post_id  = $1 [[ blog_post_id , 1]]With counter cache: # Scenario 6: `size` if there is a counter cache, uses the cached countblogpost = BlogPost. first# BlogPost Load . . . puts blogpost. likes. size# (no db hit) - Uses counter cacheputs blogpost. likes. size# (no db hit) - Uses counter cache again without additional queriesorder vs sort_by: order method is used with ActiveRecord relations to specify the order of records returned by a query. It translates directly into an SQL ORDER BY clause, meaning the sorting is done by the database before the records are returned to your Rails application. Since order operates at the database level, it is generally more efficient for large datasets. Databases are optimized for sorting operations, especially when working with indexes. Book. order(publication_year: :desc)When you use sort_by (Ruby Enumerable), the entire collection needs to be loaded into memory first. Only then does sort_by reorder the collection based on the specified attributes or criteria. Use sort_by for smaller datasets or when you need to sort based on computed values. Here, the trick is to work on a ActiveRecord relation otherwhise Rails loads the entire collection into memory. This is because . sort_by is an Enumerable method that operates on arrays, not on database queries. So, the first step is converting the ActiveRecord relation into an array of model instances and after loading, . sort_by then iterates over the in-memory array: posts = Post. where(published: true)# This line implicitly loads all published posts into memory and then sorts them by titlesorted_posts = posts. sort_by(&amp;:title)This is just an advice I got and wanted to keep it here.  Try to make the calculations and queries even if they become big in controllers or models and in view just sort them in memory.  Better to ship the wrong thing today than the right thing in 2 weeks! Because then you can get feedback and learn 14 things in 2 weeks instead of 1 thing. And you are as useful as the code you ship. So try to ship every day, multiple times if possible :smile: @books. shuffle (in-memory): The . shuffle method is a Ruby Array method that randomly reorders the elements of the array. It operates in memory, meaning the entire array needs to be loaded. Ideal for situations where you have a relatively small dataset already loaded. Ruby API. @books. order(‘random()’) (in db): random() operation is performed by the database engine, which means it does not require loading all the data into your application’s memory to shuffle it. More details. any? =&gt; exist? vs present? =&gt; in memory: "
    }, {
    "id": 31,
    "url": "http://localhost:4000/2023/10/09/financial-wisdom-over-forks.html",
    "title": "Financial Wisdom Over Forks.",
    "body": "2023/10/09 - A Dinner Chat with 2 experienced developers. Recently, I had the opportunity to have dinner and engage in conversation with Chris O. and Harry L. at Rails World. Eager to delve into the nitty-gritty of consulting, I was particularly interested in uncovering the secrets of how to increase chances of success in this field. Among the insights shared by DHH was “The One-Person Framework” which enables one to achieve remarkable productivity with Rails. This framework allows for a comprehensive understanding of everything from backend to frontend to deployment, all while Rails navigates through the complexities aiming for simplicity. Inspired by DHH’s insights, I’m keen on taking advantage of “The One-Person Framework” to enhance my consulting practice. The discussion unfolded as follows: Accounting:    Always set aside 30% of each income you receive from consulting to cushion yourself when it’s time to pay taxes. 30 is a good figure; it’s enough.     Hire an accountant; don’t do it yourself, as it can become difficult.  Accounts:    The money that a business generates is one thing, and it must be in an exclusive account. Separate it from everything else (LLC or whatever structure).     Create a personal account for personal expenses, and avoid mixing expenses. It might seem easy initially, but it can become difficult to handle.  Sales:    Get with your referals, friends, uncles, cousins, people you were in school with and offer your services, it’d more easy if they own a company or have a decision makier position.     When it comes to consulting, once you finish a project and haven’t worked on securing another project, it’s very likely that you’ll end up doing nothing.     Therefore, in the hypothetical case that you finish “Project A” in December, dedicate 80% of your time to the project to get it done, and 20% on sales activities (attending meetups, calls, creating content, follow-ups).     Then, as you get closer to finishing the project, switch to spending 80% of your time on selling and 20% on the project so that when you finish “Project A” in December, you have “Project B” waiting in January.  Always Work with Contracts:  Include a clause specifying that if the client tells you not to finish, he has to pay you at the point or progress where you leave the projectWork on Building Trust with Clients:    When you develop for a customer, aim to either cut their costs or increase their revenue/productivity or help them have more control over their business therefore you’ll gain their trust.      Cut their costs: “Optimize processes to save your customer money. ”   Increase their revenue or productivity: “Enhance features to boost customer revenue and efficiency. ”   Help them have more control: “Empower customers with tools for informed business decisions. ”      Earned trust will increase eventually like compound interest over the years, as they will share with others how you helped them and how efficient you are.  Where to Find Potential Customers:    One approach is to get in touch with local marketing agencies and offer to outsource their work to you, whether it’s web apps or web pages. This is beneficial as it’s easier to secure payments from organizations than individuals, and it also enhances your portfolio and reputation.     For the point above 👆, show up! Don’t just email them; meet them in person, attend meetups, even those not related to tech.     Another approach is to reconnect with previous customers and inquire if there’s another department you can assist; this should happen naturally if you’ve had a good working relationship.  Don’t Convince Customers to Have a Rails App When They Don’t Really Need It (Avoid This 🚫):    One individual secured a contract where the customer apparently needed a WordPress management system, but he kept pushing for a Rails application.     Somehow, the customer paid him in advance, and after a few months, rejected the project and asked for a refund. By then, he had already spent the money without setting aside funds for taxes, and found himself having to answer to both the customer and the tax authorities.  "
    }, {
    "id": 32,
    "url": "http://localhost:4000/2023/10/05/conf-6.html",
    "title": "Rails World @ Amsterdam, NL.",
    "body": "2023/10/05 - Blog about this conf is pending. "
    }, {
    "id": 33,
    "url": "http://localhost:4000/2023/09/30/how-to-crack-you-next-code-challenges.html",
    "title": "How to crack your next code challenge 🧮",
    "body": "2023/09/30 - Notes that will help you understand and then solve a code challenge interview. "
    }, {
    "id": 34,
    "url": "http://localhost:4000/2023/09/22/apprenticeship-patterns.html",
    "title": "Apprenticeship Patterns 🌌",
    "body": "2023/09/22 - "
    }, {
    "id": 35,
    "url": "http://localhost:4000/2023/09/15/conf-5.html",
    "title": "Rails Camp @ Honolulu, HI.",
    "body": "2023/09/15 - Blog about this conf is pending. "
    }, {
    "id": 36,
    "url": "http://localhost:4000/2023/09/10/search-bar-rails.html",
    "title": "Search bar in Rails 🔍",
    "body": "2023/09/10 - Notes from building a Search bar. Justin Weiss search bar using scopes. Search bar using turbo frames. Search bar Test double. "
    }, {
    "id": 37,
    "url": "http://localhost:4000/2023/08/20/chartkick-gem.html",
    "title": "Chartkick gem vs chart.js",
    "body": "2023/08/20 - Notes from chartkick gem implementation "
    }, {
    "id": 38,
    "url": "http://localhost:4000/2023/08/01/llm-langchain-rb.html",
    "title": "LLM Langchain.rb 🦜 | Andrei Bondarev",
    "body": "2023/08/01 - While I was in New York I had the opportunity to attend a nyc. rb webinar where the main subject to discuss was going to be LLMs and what is the Ruby community doing about, Andrei Bondarev was the speaker. I know it was a webinar you can attend it wherever you are! However I found it because I was looking for a monthly meeting in NY, also I found that NYC on rails is about to start so folks from NY please support Avi in this journey 🙏. Tweet where Avi anounces that he is going to take up rails monthly meeting (they were held off since 2016). OK moving on from ads here I’ll share with you the resources that I have gone over the last week so I got my feet wet with this new topic called LLMs (Large Language Models). What is LLMs? It’s a subset of Deep Learning as well as Generative AI, both belong to AI. Google video that explains it very neat What is langchain then? 🦜 How LLMs work? Why are they useful? Use cases? Andrei NYC. rb slides Main Langchain ruby repo Chatbot Proof of Concept: Multi-Agent Chatbot developed by Flexport member (Ben Zhang) Courses: LangChain for LLM Application Development from Deep Learning AI "
    }, {
    "id": 39,
    "url": "http://localhost:4000/2023/07/27/conf-4.html",
    "title": "Ruby For Good @ Washington, DC.",
    "body": "2023/07/27 - Blog about this conf is pending. "
    }, {
    "id": 40,
    "url": "http://localhost:4000/2023/07/24/NYU-startup-summer.html",
    "title": "NYU Startup Summer program",
    "body": "2023/07/24 - Notes from NYU clases "
    }, {
    "id": 41,
    "url": "http://localhost:4000/2023/06/14/how_i_learned_rspec.html",
    "title": "How I learned rpsec",
    "body": "2023/06/14 - Rspec learning resources The best way to get a grasp of testing in general and rspec is to start from scratch a project and start writing down each test, that way you’ll be able to see what happens if you forget to close either a context block or an it block or even more intricate subjects like what’s the difference between describe and context. While developing a freelance project I wanted to add testing as a way to push myself to learn more about testing and also give rspec a try and by doing it I learned how to use gems like: faker, shoulda-matchers, factory_bot and finally rspec. 🎲 You’ll additionally acquire: – how to read the output of the test suite in the console. – difference between create and build more details. ; # build doesn't persist user = build(:user, name:  John )expect(user. name). to eq( John )# create does persist user = create(:user, name:  Jane )expect(user. persisted?). to be true– How to include Devise’s test helpers class PostsControllerTest &lt; ActionController::TestCase config. include Devise::Test::ControllerHelpers, type: :requestsendblog; – difference between fixtures and factories; – and finally learn how to integrate FactoryBot with RSpec link. class Test::Unit::TestCase include FactoryBot::Syntax::MethodsendHere are also another resources that I followed in order to cement more my knowledge.    2 hours long video from Type Fast a Youtube channel that makes rails tutorials. The video is very thorough. Covers model, requests, background job testing and system tests. Fairly comprehensive starter guide to RSpec     1 hour long rspec tutorial from Type Fast was well (it’s more on the setup for an app) testing setup with rspec     How to test models CJ Avila     How to use factory_bot Deanin, short tutorial     Full marathon of rspec tutorial (reading not video) from syntax, how to test a model and installing rspec Remi rspec tutorials     The Complete Guide to Rails Testing by Jason Swett link  Learn by doing is the best way to learn rspec DSL, development stack, learn what to test and why it’s important to test and avoid technical debt. So give it a try, it wont be difficult at all. "
    }, {
    "id": 42,
    "url": "http://localhost:4000/2023/06/05/conf-3.html",
    "title": "Blue Ridge Ruby @ Asheville, NC.",
    "body": "2023/06/05 - Blog about this conf is pending. "
    }, {
    "id": 43,
    "url": "http://localhost:4000/2023/04/24/conf-2.html",
    "title": "Rails Conf @ Atlanta, GA.",
    "body": "2023/04/24 - Blog about this conf is pending. "
    }, {
    "id": 44,
    "url": "http://localhost:4000/2022/10/04/conf-1.html",
    "title": "Rails Saas @ Los Angeles, CA.",
    "body": "2022/10/04 - Blog about this conf is pending. "
    }, {
    "id": 45,
    "url": "http://localhost:4000/2022/03/26/practicing_rails.html",
    "title": "Practicing Rails | Justin Weiss",
    "body": "2022/03/26 - Introduction It is possible to learn Rails without having the things you learn abandon you as soon as you try to grab ahold of them. That’s what this book is about. It’s a second book of Rails. A companion. It’ll show you how to learn the most in the least amount of time, using the resources and knowledge you already have. And in the process, I’ll guide you through some of the toughest lessons I’ve learned during my programming and Rails career. Embrace struggle, failure, and reward. Learning to become a great Rails developer is hard work. And, being hard work, the only way to learn is to struggle. I’ve heard programming described as “Running into a brick wall, constantly. ” So don’t worry if you feel that way – we all do. Learning isn’t just about reading. It’s also about action. And that is why you can’t learn Rails without practicing Rails. Chapter 1 Tiny Apps: The best way to study new Rails ideas The best way to learn new Rails ideas and techniques is to use them. Right away. Practice them, internalize them, and make those techniques yours. When you’re working with such small apps, you focus on the single thing you want to learn. That way, you don’t have to worry about learning that new idea inside your existing, more complicated apps. For example, if you’re trying to learn ActiveModel::Serializers, and your controller isn’t serializing the model correctly, you can never be sure if the problem’s a gap in your knowledge, a problem with Rails, or a problem with your app. If you tried this out in a tiny test app, you could be pretty sure the problem was just a simple mistake or a misunderstanding. You can catch these mistakes on a small scale before you fight the bugs that appear when you use them into a larger app. I care about getting the most knowledge in the least amount of time, and scaffolds and other Rails code generators are a great way to do just that. Using the console and Tests for learning. The console is great for messing with objects, but getting those objects set up can be hard. Tests are great for getting objects set up, but hard for messing with them. Most Rails books and videos are good at showing you what’s possible. But they can’t explain everything. Those gaps will raise questions, and you’ll naturally want to have those questions answered. “Why does it work that way?” “How could this possibly work?” “What if I tried using it with this other idea I just learned about?” So, when I say “play with and modify the things you learn”, I mean “Answer the questions you have about the things you learn, using code. ” Chapter 2 How to build your own Rails app This feeling is totally normal. Whenever I’m about to start a new Rails app, I still feel like I want to give up computers forever and run into the woods or something. But I have a process to share with you that will help you get past this, so you can turn your ideas into real, working apps. When you face a large, fuzzy, overwhelming task like this, the answer is always the same: Break it apart! Break your big idea into small tasks that lead you to where you want to be. You’ll have a path you can take that, no matter what, will get you closer to finishing your app. How do you choose the first thing to work on? When you start a new project, try this short process to help decide which thing to work on first: Take a few minutes and think what you’re trying to build. Write down every feature that comes to mind. Think of the different paths a user could take through your application, the different things they could do. Describe each one in a single sentence. Then, focus on just the paths where, if you didn’t have them, your app couldn’t exist. Core paths. Core paths are the things you’d talk about if someone asked you to describe your app in 30 seconds. Which part of the feature should you start with? Once you’re ready to build your first core path, you might feel like writing models for all the objects you have in mind. Maybe you want to create migrations, add attributes, and connect everything together. But soon, you’ll have a ton of pieces that may not all fit. It’ll take a long time before you can actually use your app. And if you didn’t design your models well, you’ll just have to do that work over again when you build your UI and actually start playing with your app. So, start with UI, and infer your data model from what you see in the UI. When you begin work on a single, small feature, start with the UI:    Take the small feature, or core path, from earlier.     Think of one simple thing someone could do with that feature.     Draw just enough screens for that user to be able to do that thing.     Describe the path through that action, as if you were telling someone what you were going to do.     As you describe that path, write out the objects, properties of those objects, and other actions you think you need to develop that path.  "
    }, {
    "id": 46,
    "url": "http://localhost:4000/2022/03/04/testing_waterloo.html",
    "title": "Rails Testing | University of Waterloo",
    "body": "2022/03/04 - This is a series of lectures about rails testing -Databases &amp; Software Engineering course. How to test? Mike Cohn in his book Succeeding with agile. You should spend most of your time in Unit. End to end is manual and it means a person goes through all the user flow to reach a user acceptance criteria, click buttons, links, add stuff to the shopping cart, make a payment. This can be Manual test, actually using the interface, this is what the customer will see/use. Template:Given: that I’m a logged in user in “home page”When: when I click on “log out”Then: I’m logged out Only the basics here, for example: I can create an account but don’t extensively, send an email, one happy path and one sad path. In Rails End to end tests are called system tests Integration, tests multiple components but exclude user interface. In Rails it tests the controller. what does it respond? what does it send? POST to this path with this params (we can see if a form is going to the right path) Unit, it isolates one single object or method from the rest of the system and test it by itself. This help us see where the problem is. Models, and classes we create, First I need to make sure my individual pieces work, then i put them together and see if that larger system works and eventually we’re going to check out and test the whole entire system. Testing Pyramid and Rails Video Lecture MSCI 245 : Testing Is my app free of bugs?Does the program work as specified? Write a specification or a test that specifies expected behavior. Test case: average_rating Arrange - what is the input?Act - run the programAssert - check the output against the expected output Then we need 2 cases:  For a Book with 1 or more rating, it should return the average of that book’s ratings     known gotchas: integers vs float division, off by one (when you skip 1st element of the loop).     For a Book with 0 rating, it should return nilThis is the arrangeBob rated 5Sue rated -2Ali rated 4total 7 Run the program total 7 / 3 = 2. 333 Asserttotal vs expected_value https://www. youtube. com/watch?v=2yYSR6ftxUo Testing fundamentals - equivalence classes You cannot test all inputs. You need to carefully pick inputs to find your mistakes. “… testing can be used very effectively to show the presence of bugs, but never to show their absence” E. W. Dijkstra if 2 inputs produce the same output, they are said to be member of the same equivalence class. if the net method is tested correctly, the behavior of the method should be the same, there are only 2 inputs that we must use: [1, 2, 3] and [0, -12] def absolute_value(x)	if x &lt;= 0		return -1 * x	else		return x	endendInterior &amp; boundary values. Values that sit on either side of a division between equivalence classes are boundary valuer -&gt; where bugs hide. Other values are the interior values. [minimum. . . -1]|[0 . . . maximum] the boundary is between -1 and 0Test cases: (try to put all below in just one test) Equivalence test case min(a, b) Test:  a == b a &lt; b a &gt; bhttps://www. youtube. com/watch?v=-1kCdERz1sMBase, Edge, and Corner Cases; Happy and Sad Paths Base case - normal expected inputsEdge case - inputs approach limits or outside limitsCorner case - crazy values, should never see in real world Example: user interface - e commerce - shopping cart Base -&gt; user adds a few itemsEdge -&gt; user surprises us with a large order 100-1000 thingsCorner -&gt; whole store in cart (we don’t want the whole site to fail, we should put a limit) We can think of a form for creating a user name, nick names, emails, domains, capitalization Success &amp; failure (code should handle both) Test both good input (success). Test bad inputs (failure) to test proper error handling. Black box, you test the software and don’t get a look at the code, you cannot call the code White box, you test the software and get a look at the code to see what is happening https://www. youtube. com/watch?v=NoP3am8ipYw Hunting for bugs Logic errors  boundaries common inputs to test     some minimum   zero   one                         empty - zero       length       list       empty                     negative numbers   first/last element of an array   Most common working with arrays or any sort of list:  skip first/last element don’t process last elementNumerical erros  accidental truncation of floating point to integer divide by zero (think of a way how a user can input a 0 as denominator and catch the error) bad floating behavior (try to add a lot of small numbers to a larger numbers) assume the sum of the computer is correct sqrt(2) != √2Integrating boundaries  one system talking to another misunderstandings about proper inputs/outputsOther  null values -nil handling of exceptions loss of networks/disk/power?https://www. youtube. com/watch?v=crFl2K1bOhI MSCI 245 : A quick intro to Minitest and automated testing  testing framework enabled by default in Rails automated testing at 3 levels     Unit (individual methods or objects, this part works correctly)   Controller (integration) (we reproduce a browser with http verbs POST, GET)   System - end to end (E2E) user interface (manual, buttons)   To do unit testing we make a class that inherits from ActiveSupport::TestCase. We make one test case for every class we want to unit test. test/models/book_test. rbArrangeActAssertrequire 'test_helper' # brings test/test_helper. rbclass BookTest &lt; ActiveSupport::TestCase	# (always start with  test_ )	# The DB within test is empty	def test_average_rating_multiple_ratings		# you have to build up the case in the database		card = Author. create!(name:  Orson Scott Card ) arrange		ender_game = Book. create!(title:  Ender's Game , year:  1985 , author: card arrange		. . . 		. . . add ratings/ users				assert_in_delta(2. 333, ender_game. average_rating, 0. 001,  should return 2. 333 for Ender's Game )	end	def test_average_rating_no_ratings		christie = Author. create!(name:  Agatha Christie )		fire_pigs = Book. create!(title:  Fire Pigs , year:  1942 , author: christie)				# first the expected, then the actual		assert_nil(fire_pigs. average_nil,  this should be nil )	endThings to note:  File that start with “test_” are run with “rails test” You can create other methods You have access to all Rails You can use debugger Each test should be independent of other tests You can define a setup method in the beginning and call it before every method, (to create data)https://www. youtube. com/watch?v=JYbHurKGzM0 Testing - Test Cases - Minitest - Capybara Arrange - setup the input codeAct - execute the code w/ inputAssert - check the result against our expected output Example: we are testing addition, the input is 1 and 2, the expected result is 3. E2E or systems tests: Arrange  - sometimes could be add items to DBAct - visit the home page, click a link to create accountAssert - did i end up in the home page? seeds. rb is not for tests, is for using the app, like: admin. FIRST properties of good tests Fast - run fastI - independent | isolated, a test should not depend on another test that has run before it; what went wrong and where (try one idea per test)R - repeatable, every time you run a test it behaves the sameS - self validating, tests reports pass or fail by automatic T - timely | thorough, write the test when your write the code; coverage Test Frameworks - Minitest (will help us write FIRST tests)  resetting the Rails app and DB after each test (repeatable, independent) run tests in randomly order (independent) provide assert statements &amp; reports of pass and fail (self validating)Fast is mainly a property of this type of test, low overhead (faster than Rspec)Timely &amp; Through this is about developer behavior and skills Basics of Minitest  You write classes that inherit from Minitest.  Each method of the class that star with “test_” is run as independent test .  You can write a “setup” method, it will run before every test within that class (for creating user for instance).  Rails and Minitest restore state after each test, includes the DB.  Everything in Minitest in plain Ruby (only new methods like assert) (not like Rspec or cucumber).  Your class can have non-test methods.  You have access to all Rails, models methods and so on.  Separate test DB to avoid contamination.  There are a lots of ways to assert. assert(test = must be a boolean, message to display) - &gt; assert(expected == results) assert_equal(expected, actual) assert_nil(nil) flunk (msg) make the test fail in purpose skip (msg)       Capybara   url = root_pathvisit url ——assert_current_path url—–click_link(‘id-of-link’) # id’s from HTMLclick_link(‘Books’)click_button(‘Submit’) # it’s better to click on idfill_in(‘Name’, with: ‘Bob’)——-assert page. has_content?(‘Sorry Invalid. ’) You can search element on the page and interact with them or inspect thempage. find(:css, ‘a[href=’sign_up_path’]’). click assert_text (‘Create an account. ’) =&gt; all about UI. If you wont access session &amp; other “lower stuff” then write an integration. Example: class LinkTest &lt; ApplicationSystemTestCase	def test_nav_root_to_create_account		visit root_path		click_link('Create Account')		assert_current_path sign_up_path	endendhttps://www. youtube. com/watch?v=DxIoWJKYxIg&amp;t=1278s Demo of TDD ArrangeActAssertclass StatFunction	def self. median(values)		if values. nil? || values. length == 0 			raise ArgumentError( it needs at least one element )		end				if values. length == 1			return values[0]		end				values = values. sort		if values. length. even?			left_of_mid = (values. length / 2) - 1			result = ( values[left_of_mid] + values[left_of_mid] + 1 ) / 2. 0			return result		else			mid = (values. length / 2 )			return values[mid]		end	endendTest def test_median_one_element	# arrange	elements = [1]	# act	result = TestingExample::StatFunction. median( elements)	# assert	assert_equal( 1, result)enddef test_median_two_elements	elements = [1, 2]	result = TestingExample::StatFunction. median( elements)	assert_in_delta( 1. 5, result)enddef test_median_three_elements	elements = [1, 2, 3]	result = TestingExample::StatFunction. median( elements)	assert_equal(2enddef test_median_zero_elements	elements = []	assert_raises(ArgumentError) do		result = TestingExample::StatFunction. median( elements)	endenddef test_median_zero_elements	elements = []	assert_raises(ArgumentError) do		result = TestingExample::StatFunction. median( elements)	endenddef test_median_nil	elements = nil	assert_raises(ArgumentError) do		result = TestingExample::StatFunction. median( elements)	endendhttps://www. youtube. com/watch?v=sOT2FgD22VI What is Minitest? https://semaphoreci. com/community/tutorials/getting-started-with-minitest How to Test Rails Models with Minitest https://semaphoreci. com/community/tutorials/how-to-test-rails-models-with-minitest Getting Started With Testing In Rails (Using Minitest and RSpec) https://medium. com/@ethanryan/getting-started-with-testing-in-rails-using-minitest-and-rspec-113fe1f866a Getting Started With System Tests in Rails With Minitest In Rails jargon, system testing refers to “testing an application as a whole system”. That is done by using a browser in the tests. Instead of testing separate parts, with system tests, we can test a whole ‘workflow’, just like what a user goes through while interacting with our app, including the JavaScript parts. In practice, it means that we don’t want a system test to check if a record is created in the database when a user clicks a button; we just test if that new record appears on their screen. These kinds of user interaction tests are also called feature tests or acceptance tests. They are different from integration tests: integration tests are for testing the behavior, especially of all the parts of the app together, but not via the user interface. https://blog. appsignal. com/2020/02/12/getting-started-with-system-tests-in-ruby-with-minitest. html Official Docs https://guides. rubyonrails. org/testing. html#rails-meets-minitest Minitest vs. RSpec in Rails https://www. honeybadger. io/blog/minitest-rspec-rails/ "
    }, {
    "id": 47,
    "url": "http://localhost:4000/2022/02/14/test_jason_swett.html",
    "title": "The Beginner’s Guide to Rails Testing Jason Swett",
    "body": "2022/02/14 - The eight types of RSpec specs • Model specs• System specs• Request specs• Helper specs• View specs• Routing specs• Mailer specs• Job specs Jason usage: • Model specs always• System specs always• Request specs rarely• Helper specs rarely• View specs never• Routing specs never• Mailer specs never• Job specs never Model spec I use model specs to test my models’ methods. When I do so, I tend to use a test-first approach and write a failing test before I add a new line of code so that I’m sure every bit of code in my model is covered by a test. System spec System specs are the only type of test that give me confidence my whole application really works. Even though system specs are indispensable, they’re not without drawbacks. System specs are somewhat “heavy” Request specI tend not to use request specs much because in most cases they would be redundant to my system specs. If I have system specs covering all my features, then of course a broken controller would fail one or more of my tests, making tests specifically for my controllers unnecessary. I also try to keep my controllers sufficiently simple as to not call for tests of their own. There are just three scenarios in which I do use request specs. First: If I’m working on a legacy project with fat controllers, sometimes I’ll use request specs to help me harness and refactor all that controller code. Second: If I’m working on an API-only Rails app, then system specs are physically impossible and I drop down to request specs instead. Lastly, if it’s just too awkward or expensive to use a system spec in a certain case then I’ll use a request spec instead. View and routing spec I find view specs and routing specs to be redundant to system specs. If something is wrong with one of my views or routes, it’s highly likely that one of my system specs will catch the problem. What are all the Rails testing tools and how do I use them? RSpec is a test framework. A test framework is what gives us a structure for writing our tests as well as the ability to run our tests. One of the challenges of Rails testing is generating test data. There are two common ways of generating test data in Rails tests: fixtures and factories. Fixtures typically take the form of one or more YAML files with some hardcoded data. The data is translated into database records one time, before any of the tests are run, and then deleted afterward. (This happens in a separate test database instance of course. ) With factories, database data is generated specifically for each test. Instead of loading all the data once at the beginning and deleting it at the end, data is inserted before each test case and then deleted before the next test case starts. One principle of testing is that tests should be deterministic, meaning they run the same way every time no matter what. Capybara: Some Rails tests only exercise Ruby code. Other tests actually open up a browser and simulate user clicks and keystrokes. VCR and WebMock: One principle of testing is that tests should be deterministic, meaning they run the same way every time no matter what. When an application’s behavior depends on external services (e. g. a thirdparty API like Stripe) it makes it harder to have deterministic tests. The tests can be made to fail by an internet connection failure or a temporary outage of the external service. VCR can let us run our tests against the real external service, but capture all the service’s responses in local files so that subsequent test runs don’t talk to the external service but rather just go off of the saved responses. That way, even if the internet connection fails or the service goes down, the tests still work. What keeps them (Rails devs) in the habit of writing tests consistently? Laziness, fear, and pride. Mental energy. If I write a feature without using tests, I’m often juggling the “deciding what to do” work and the “actually doing it” work at the same time, which has a cognitive cost more than twice as much as performing those two jobs separately in serial. When I build a feature with the aid of tests, the tests allow me to separate the “deciding what to do” work from the “actually doing it” work. it’s not possible to have clean, understandable code without having automated tests. Pains that tell you your test coverage might be insufficient? Too many bugs. Inability to refactor or make big changes When a change has a large footprint, like a Rails version upgrade or a broad refactoring, it’s basically impossible to gain sufficient confidence of the safety of the change without having a solid automated test suite. So on codebases without good test coverage, these types of improvements tend not to happen. How do I set up a new Rails project for testing? Start rails with template: https://guides. rubyonrails. org/rails_application_templates. html rails new my_project -T -d postgresql \ -m https://raw. githubusercontent. com/jasonswett/testing_application_template/master/applicatiOnceHow do I add tests to an existing Rails project? If you have little testing experience, I would suggest getting some practice on a fresh Rails app before trying to introduce testing to the existing Rails project you want to add tests to. Adding tests to an existing project is a distinct skill from writing tests for new projects "
    }, {
    "id": 48,
    "url": "http://localhost:4000/2022/02/05/the_man_in_the_arena.html",
    "title": "The man in the arena",
    "body": "2022/02/05 - The GOAT 🐐  Chastising the Spanish artist for painting unrepresentative cubistic abstractions, a layman withdrew a photograph of his wife from his pocket and held it up to Picasso with the admonition, “Why can’t you paint realistically, like that?” “Is that what your wife really looks like?” Picasso asked. “Yes,” replied the man. “Well, she’s very small, and quite flat. ” First of all i need to be clear that I’m neither a football follower nor fanatic but somehow TB (Tom Brady) caught me up with his “underdog/rejection” story. Chapter 1 On naming the series. The meaning behind the title of this series is because that quote was on the weight room at Michigan University and TB saw it for almost 5 years (it was coined by Theodore Roosevelt) and for him was that eventually you become that man where all eyes are on you and only you know what is all about. All began in 1993-1996 when Patriots were playing good football however they were not winning, they lost 1 super bowl, new coach; then Mr. Brady appeared in 1999 with a very solid foundation from Michigan state, - “the team, the team is first” was the guideline he was trained. He defines it as a combination of talent, what you can add on a daily/weekly basis; at this time he didn’t know what were his strengths, everynight he looked up what phase was the draft on in order to know his position. Something worth mentioning is that 5 rounds passed and no one chose him, his attributes were not even close to what a pro football team expects, finally he was picked at #199 (only 200 are allowed). Main QB (quarterback, D. Bledsoe) at that time describe him as “inquisitive”, asking about everything, everyone thought that he’d be just a backup, was not perceived as a threat; on the other side TB defined himself either “just being naive” or “too much confidence” but he was determined to play pro 🏈.  “Working hard is a very sustainable trait. Part of your character. If you don’t have that, at some point the talent does wear off, you’re drafted based on both therefore you must work hard . ” Tom Brady. Second season with Brady on board started, Bledsoe signed the highest contract ever for the next 10 years, TB was on the bench until Bledsoe was hit, time to take the grid. Despite of the very low expectation people had on him, he felt ready to do the job. TB continued playing good waiting Bledsoe to get back of his injury however Bill Belichick (coach) made the decision of giving that role to TB, seeking the best for the team. At the AFC finale (one game before Super Bowl) TB had an ankle injury, Bledsoe took his role back, made a couple of touchdowns and won the game, this only remarks how mentally strong was TB since the beginning, everything came down to Bledsoe would be the starting QB, coach thought different, Tom will play the SB. As always all odds against Patriots, however the Pats won being the most underdogs 🏆.  You gotta be ready when your opportunity presents itself. I don’t think I was physically prepared. Was I mentally and emotionally ready? Absolutely. It’s like anything. Its progress and its evolution. It’s a series of small steps that seem so insignificant. ” Tom Brady. Chapter 2 On team culture. TB describes how people, teammates, competitors have been such impactful in his life, on and off the field, those people must help you create the best version of you, if not you gotta move on. After winning the SB they lost the next season, it was time to regroup the team, they had to have more consistency; following season Belichick cut the defense leader (L. Malloy, best friend of TB) no one understood that decision which gave room to the media to start creating news about the feelings within the team, thing that TB refused with the next phrase “ignore the noise, focus on tactics”. “Patriots is not collecting talent, is building a team” B. Belichick. With that being said, TB worked his way to carefully listen to every advice from his coach that gave him structure and confidence, it enabled him to execute selfishness, caring about all his teammates, no one care about who takes the credit.  “Winning is probably the outcome but the process of winning was what the culture was all about. What are you willing to commit to be your the very best?” Tom Brady. TB learned to study every top player, take the good stuff, fine tune it and put it on practice. He used the next metaphor: “Be the best husband you could be, the best father, the best in your job, because you cannot control everything. If you have perspective in the end nothing bad really happens because out of the bad comes the really good things. ”  Mental toughness is how you deal with adversity. What’s the attitude of your heart? Embrace challenge? Failure?” Rodney Harrison. Chapter 3 The edge. This episode was on motivational style, TB put a statement about how their mentality was - one game at the time, this was tough to put into practice due to they had more than 20 wins in a row. The main responsibility of any leader is to know how to motivate each member of his team, some of them like hard coaching others need just a push and in this sports the QB is the chief; this time Belichick worked to create a competitive environment where all the players wanted to give more, here are some phrases he shares:    It was not the more you can do it. It was who could do the most.     You came 6:30 am? I’ve already got a half hour on you.     I’m getting the edge on you.     This is what I did. What’d you do?  -Are you leaving already? -Still not doing the extra, huh? I’m getting the edge on you today I think is worth pointing out the good outcome that Belichick achieved by building this environment, it’s only as good as the ability of the players to receive it. The team at that time had a high level cohesiveness and the feedback, communication was on point to keep the culture up.  “You don’t know what kind of culture you have until things aren’t going well. ” When you have failure, when you don’t do what you were supposed to do, you’ll define how your culture looks like. ” Mike Vrabel. TB also mentioned how people think there are going to be more opportunities and that is a mistake because it lowers the bar and keeps you away from doing your best effort, you may miss a chance and will disappoint you next time, it will create fear, you’ll want a lower level to play in order to avoid frustration. Chapter 4 The goliaths. In this episode you’ll find how the Patriots reached its highest level and passed from being the underdogs to the goliaths. Many new team members Randy Moss, Wes Welker amongst others; they knew they were the team to defeat which I think played against them this time. Pats had a first time ever record with 16 wins and 0 loses, no team had accomplished this before, they made football look easy, then the “spygate” got and again TB spoke up with his phrase “ignore the noise”. “So much of the success in the life is about that journey and it’s not about whether you win or lose always. It’s about how hard you try and what you put into it, thr relationships, the learnings you develop. ” Tom Brady. In the end Pats lost the Super Bowl against New York Giants, this time Giants were the weaker. Chapter 5 No guarantees. This episode covers 4 seasons and Tom describes how are the relationships he was able to develop throughout these years, friendships, the born of his 2 kids, how supportive and stabilizer was Gisselle for him and how you must overcome failure, learn from it and move on. Some highlights of this episode are the union of NFL players took place for the first time, they couldn’t attend training however TB convoked to train in one college field without coaches with gave the team an advantage over the others, ultimately the got the conditions they were after. And finally Patriots faced Giants in the finale and they lost, after a series of inconvenient events, Eli Manning won the SB.  “Challenges are opportunities in disguise”. Gisele Bündchen. Chapter 6 Stop the bleeding. Things were not clear for this season, the media started pressing on TB retirement, a new draft for his position had been picked. Pats did a comeback throuthroug the season to reach the SB with a record of 12 - 4 gaining confidence game after game, ignoring the noise and building momentum, they did their job and stop the bleeding; suddenly another scandal arose the “deflategate” just a few days before the SB, they faced the best defense at that time Seattle Seahawks with Richard Sherman. Notwithstanding the dire comments about them, the conquered their 4th Super Bowl 🏆  “Greatness come with taking chances”. Vince Wilfork. Chapter 7 Surrender. For this chapter Tom invited his 3 sisters in order to lay out how his childhood was, they were a typical California family, attending all 49’s games, Tom Brady being the youngest felt always protected by his 3 sisters and his parents, they did a pretty well job, until he left to attend Michigan University. The season covered here was on year 2017 when Tom had to defend himself against the “deflategate”, he was penalized, suspended and the worst; his mom was detected with cancer, the quimio and radiation started so his mind was cut on two sides. Tom depicts this Super Bowl as the greatest game ever played (I didn’t know why until I watched how it unfold); this finale had the biggest difference in points ever, 28 to be precise despite that, Pats did comeback and scored as many touchdowns as needed to defeat Atlanta Falcons (play after play). “I think he lives his life to really be the best at something. He is a hundred, a thousand % committed to being the better than he was a day before. ” Tom Brady sister. ​Chapter 8 No body’s business. Tom introduced his rehab clinic and method along his coach body Alex Guerrero; it seems to be his secret weapon after finishing each game as well as every recovery. From my perspective Alex is an alternative physician who uses natural healing and different methods to prepare the muscles, also he goes over emotional and mental subjects trying to get up to an integral readiness. After years working on theses methods and proving they really work, Tom convinced Rob Gronkowski to get to Alex and try out his alternatives methods, thing that Belichick didn’t agree with and sent Tom and the trainer to remain outside each meeting and game. These supplemental activities seemed to gained relevance when Tom suffered a dire injury in his thumb days before the AFC final, he needed punctures and the recovery appeared to be beyond Sunday however after several treatments he was able to flex and use his hand for Sunday and passed to the SB LII. The super Bowl was fought by the two teams but Pats couldn’t beat the Philadelphia Eagles, another lose for Tom Brady 👎. Chapter 9 Maybe. Last episode of this series goes over the season 2018 and 2019 where Pats had to face Kansas City and Patrick Mahomes, I think they highlight this game because KC started to show how good they were and the pro football they play, also because some key teammates were out so regular season was not great. The Super bowl was against Los Angeles Rams which was meant to be a tough game, very physical, low opportunities, in the end Tom was bearing in mind that it was going to be his last season playing with New England because he didn’t get a new contract.  “All comes down to the people and relationship what I value the most. Tom Brady. Conclusion. It definitely is a combination of different factors that take you to succeed or to the place you want to be, those factors may be hard work, readiness, persistence and of course luck or how tom said a few times “situacional football” which is when something completely out of your control plays in favor of you, kicker missed the goal, the receiver couldn’t catch the pass, you name them and here is the part of commitment you need to place in every activity, relationship you want to develop because if everything derails and nothing comes to the place you planned was the best; you must be satisfied that you gave everything you could in order to accomplish but luck this time was not on your side. Having lost so many SB’s being the most prestigious sports in America has to be tough as well, it’s said very easy, -he won 7 Super Bowls. But how manys he lost?! It’s tough to miss a flight, to be rejected by the company you would have loved to work for, imagine how hard is to lose the most important event in the year, after having practiced and played 9 months in a row without being with your family. Tom developed a resilient mentality which was key for his journey, to keep his feet on earth and to overcome those setbacks, never look back and learn the most from them. "
    }, {
    "id": 49,
    "url": "http://localhost:4000/2022/01/05/minitest_cookbook.html",
    "title": "The Minitest Cookbook",
    "body": "2022/01/05 - Today though, the separation between development and testing has largely disappeared - at least in the universe that most Ruby and Rails programmers occupy. In many if not most cases now, the one writing the code is also responsible for producing automated tests that cover the workdone. And while you’re probably sick of hearing it, this is a good thing for all kinds of reasons. Why? • Tests demonstrate that your code actually works. • The pattern of thinking needed to write tests for code is very close tothat needed to design it. • Testing and developing in parallel tends to surface more bugs early in the development process when fixing them is cheap and easy. • Well-tested code tends to be better designed with reduced coupling and greater cohesion. • A good test suite acts as a detailed specification. • Writing tests during development increases programmer engagement and efficiency. • A test suite with good coverage aids in maintenance, refactoring, and upgrades with reduced risk of breakage and regression. • It’s faster to write code with tests than without. • Having automated tests reduces or removes the need for manual testing Best tests will have a few important characteristics in common:• Clarity: The name of each test suggests what it’s about at a glance. • Purpose: The intent and meaning of the test is obvious and unambiguous from the testing logic. • Eloquence: The test logic is expressed through fluent use of the language and the testing framework. • Readability: Tests are written and formatted in a way that promotes rapid discovery and comprehension. • Efficiency: All other things being equal, automated tests should use the minimum possible system resources Unlike a lot of books on testing, this one won’t dwell on the mechanics of test-driven development. TDD has become so prevalent and popular among the Ruby and Rails development community that you’d be hard pressed to find a book on testing or development that doesn’t take it as a starting point for everything taught. But TDD is primarily about development and only incidentally about testing, and it often treats the tests that fall out of it as a by-product rather than as first-class citizens of your project. That tends to result in test suites that are neglected after they’ve served the purpose of driving out features. • Fact: The entire framework weighs in at less than 1600 lines of code. RSpec is almost 8 times as large. With a code base that size, the source practically becomes its own documentation. • Fact: Minitest has been singled out as a very readable project because it’s written in plain Ruby that developers of all experiencelevels can dig into and understand. • Fact: The project has remained small and simple because of conscious decisions to keep it that way in spite of frequent requestsfor expanded features. • Fact: The source code showcases Ruby’s power and elegance with great uses of closures, metaprogramming, concurrent programming, and others. • Fact: Since the Minitest framework also happens to be tested with Minitest, it includes some exceptional practical examples illustrating good testing technique To really get comfortable with Minitest’s internals, there are four basic abstractions that you’ll need to understand: plugins, reporters, runnables and the Minitest runner. Plugins In Minitest, plugins are modules that extend or modify the behavior of Minitest. They can be used to add new features, customize the test runner, or modify the output of test results. Examples of plugins in Minitest include pride (a colorful test runner), parallel (for parallel test execution), and focus (to run specific tests or test suites). Minitest plugins are usually packaged as RubyGems which implement a simple framework-defined contract that allows them to be loaded an initialized by the framework. Specifically speaking, every plugin includes a loader file that follows a standard naming convention - ex: minitest/ foo_plugin. rb where foo is the name of the plugin. minitest-rails is a plugin for Minitest that adds some additional features for working with Ruby on Rails applications. It provides some additional test generators that can create test files for your Rails application’s models, controllers, views, and helpers. It also includes support for testing Rails-specific features like routes and controllers. In addition to the generators, minitest-rails also provides a Rails-specific test runner that sets up the Rails environment before running the tests. This can be helpful if your tests need to access Rails configuration or other Rails-specific features. Overall, minitest-rails is a helpful plugin for anyone working with Ruby on Rails applications and using Minitest as their testing framework. Another example: the minitest/pride plugin adds colorful output to your test results in the terminal. Reporters A test suite is a map for directing development effort to the parts of your project that need it. From this perspective, the results reported by your test suite act as its user interface and indicate the state of your code base. Each test Minitest runs passes a result to a Reporter object which is responsible for acting on it. Depending on the Reporter, it might:• Display information to the console. • Store the result for later processing. • Increment counters or compile statistics. • Send the result to another system - ex: a CI, a database, etc. As an abstraction, a Reporter is just an object that implements four methods that allow it to accept and operate on test results:• #start - called before the first test is run• #record - accept and process a single test result• #report - deliver a detailed report after the test run• #passed? - indicate passed/failed/errored/skipped tests In Minitest, reporters are used to generate output of the test results. They provide various types of outputs such as progress bar, detailed documentation, and colorized output. Runnables In Minitest, runners are classes that run a set of tests. Assert-style tests and Spec-style tests are two different styles of writing tests in Minitest. Assert-style tests are based on assertions that verify the expected result of a test. They are usually written using methods such as assert, assert_equal, assert_match, etc. The focus is on verifying specific outcomes and behavior of the code being tested. Spec-style tests are based on specifying the expected behavior of a system or component. They are usually written using describe and it blocks that describe the behavior of the code being tested. The focus is on describing the behavior and intent of the code, rather than just verifying specific outcomes. Assert-style tests are based on the idea of making assertions about the state of the system under test. These tests usually follow the “Arrange-Act-Assert” pattern, where the test sets up the system’s initial state, performs some action, and then makes one or more assertions about the system’s final state. (This uses instance methods starting with the string “test_”). Spec-style tests, on the other hand, are based on the idea of describing the behavior of the system under test using a domain-specific language (DSL). In these tests, the focus is on describing what the system should do rather than how it should do it. Spec-style tests often use “describe” and “it” blocks to structure the test code. Both styles of testing have their pros and cons, and the choice of which one to use often comes down to personal preference and the requirements of the project. Some developers prefer the clarity and simplicity of Assert-style tests, while others find the expressiveness and readability of Spec-style tests to be more appealing. Ultimately, the most important thing is to choose a style that works for you and your team and allows you to write effective, maintainable tests. The Minitest Runner The Minitest Runner is the component responsible for running Minitest test suites. It loads the test files, executes the tests, and reports the results. By default, Minitest uses the Minitest::Runnable and Minitest::Test classes to define and run tests, respectively. However, the runner can be customized to use other classes or to change the way the tests are run. The runner is a key part of Minitest’s flexibility and extensibility. The runner and Runnables fit together like the layers of an onion where each layer represents a Ruby block or method. The inner layers represent the Runnables where the tests are actually executed, and the outer layers represent the runner - the code that gives the onion its shape. Minitest. runNext, Minitest sets up the environment for the test run along with all the necessary supporting objects. All the framework’s major responsibilities are handled right here as it:• Parses the command line arguments. • Loads and initializes all detected Minitest plugins. • Instantiates and runs the reporters. • Runs tests by passing control on to the next layer. • Ensures that parallel worker threads are shut down gracefully. Basic Recipes Problem:class FizzBuzz	def convert(number)		if number % 15 == 0			 FizzBuzz 		elsif number % 5 == 0			 Buzz 		elsif number % 3 == 0			 Fizz 		else		number. to_s		end	endendTakeawaysYou need four things to develop a Ruby project with Minitest:• Install Minitest as a project dependency with Bundler. • Create a test directory at test/ . • Create a test helper to include all global configuration and customization at test/test_helper. rb . • Create a new Rakefile or update the existing one with a Rake::TestTask configured to suit your needs (by convention to run tests you use the command rake) Writing Tests All the tests that we write follow the same basic four-phase structure. 	1. Setup the inputs and data objects prior to running the test. 	2. Exercise the logic under test. 	3. Verify that the tested code produces the expected results. 	4. Teardown or reset application state before running the next test. require 'test_helper'require 'fizz_buzz'class FizzBuzzTest &lt; Minitest::Test	def setup 		@fb = FizzBuzz. new	end	def test_converts_multiples_of_fifteen_to_fizzbuzz		# fb = FizzBuzz. new		assert_equal 'FizzBuzz', @fb. convert(15)		assert_equal 'FizzBuzz', @fb. convert(45)		assert_equal 'FizzBuzz', @fb. convert(90)		[15, 45, 90]. each do |i|			assert_equal 'FizzBuzz', @fb. convert(i)		end	end	def test_converts_multiples_of_five_to_buzz		# fb = FizzBuzz. new		assert_equal 'Buzz', @fb. convert(5)		assert_equal 'Buzz', @fb. convert(10)		assert_equal 'Buzz', 2fb. convert(20)	end	def test_converts_multiples_of_three_to_fizz		# fb = FizzBuzz. new		assert_equal 'Fizz', @fb. convert(3)		assert_equal 'Fizz', @fb. convert(12)		assert_equal 'Fizz', @fb. convert(48)		# another example could have been assert 'Fizz' == fb. convert(3)	end	def test_returns_same_number_for_other_numbers		assert_equal '1', @fb. convert(1)		assert_equal '101', @fb. convert(101)		assert_equal '2014', @fb. convert(2014)	endendAnother example of syntaxis: class ArticleTest &lt; ActiveSupport::TestCase	test  should not save article without title  do		article = Article. new		assert_not article. save	endendThat’s why many developers follow a strict one assertion per test policy - so that each assertion has exactly one chance to succeed or fail. It’s true that your tests will be better and more maintainable when each test verifies a single behavior of the system, but writing a single test for each of the assertions above seems like overkill to me since they’re all testing the same general behavior. setup runs before each test. teardown runs after each test. It’s better to favor readability over DRY-ness when writing tests. Usage of skip Skip can be useful in situations where you want to write a test that specs out some future work that you’re notquite ready to code just yet. For example, FizzBuzzTest doesn’t currently check to see what happens when we pass it an unexpected input. def test_raises_argument_error_for_bad_argument	skip 'not yet implemented'	assert_raises(ArgumentError) { @fb. convert(-1) }	assert_raises(ArgumentError) { @fb. convert(0) }	assert_raises(ArgumentError) { @fb. convert(1. 0) }	assert_raises(ArgumentError) { @fb. convert('foo') }	assert_raises(ArgumentError) { @fb. convert(nil) }endTakeaways	• Assert-style test cases are classes that inherit from Minitest::Test. 	• Public instance methods of those classes whose names begin with test_ are treated as tests by the runner. 	• Minitest provides a small set of assertions out of the box, and of those, about half are used frequently. 	• Override the setup and teardown methods to include code that should be executed before or, respectively, after each test is	executed. 	• If you have to choose between readability and DRY-ness in your tests, you should almost always choose readability. Writing Specs class FizzBuzzIterator	def initialize(start = 1)		@counter = start		@fb = FizzBuzz. new	end	def next		input = @counter		@counter += 1		@fb. convert(input)	endendrequire 'test_helper'require 'fizz_buzz_iterator'describe FizzBuzzIterator do	it 'outputs sequential FizzBuzz values starting from 1 when initialized without a starting value' do		iterator = FizzBuzzIterator. new				expect(iterator. next). must_equal '1'		expect(iterator. next). must_equal '2'		expect(iterator. next). must_equal 'Fizz'		expect(iterator. next). must_equal '4'		expect(iterator. next). must_equal 'Buzz'		expect(iterator. next). must_equal 'Fizz'	end	it 'outputs sequential FizzBuzz values starting from the starting value when initialized with a starting value' do		iterator = FizzBuzzIterator. new(10)				expect(iterator. next). must_equal 'Buzz'		expect(iterator. next). must_equal '11'		expect(iterator. next). must_equal 'Fizz'		expect(iterator. next). must_equal '13'		expect(iterator. next). must_equal '14'		expect(iterator. next). must_equal 'FizzBuzz'	endend# Other alternativesexpect(iterator. next). must_equal 'Fizz'value(iteratory. next). must_equal '11'_(iterator. next). must_equal 'Buzz'Assertion vs Expectation Like most powerful tools, this one can be abused. As a general rule, try to limit describe block nesting to at most two or three layers deep. More than that and the specs hard to follow and less readable for future developers (including future you). Before and After for Spec-Style before blocks for all enclosing scopes will be called before the test logic in order from outermost to innermost. after blocks for all enclosing scopes will be called after the test logic in order from innermost to outermost. In practical terms, this lets us define blocks with increasingly specific setup and teardown logic that cascade or override previous operations require 'test_helper'require 'fizz_buzz_iterator'describe FizzBuzzIterator do	before do		@iterator = FizzBuzzIterator. new	end		it 'outputs sequential FizzBuzz values starting from 1' do		expect(@iterator. next). must_equal '1'		expect(@iterator. next). must_equal '2'		expect(@iterator. next). must_equal 'Fizz'		expect(@iterator. next). must_equal '4'		expect(@iterator. next). must_equal 'Buzz'		expect(@iterator. next). must_equal 'Fizz'	end		describe 'when initialized with a starting value' do		before do			@iterator = FizzBuzzIterator. new(10)		end		it 'outputs sequential FizzBuzz values starting from the starting value' do			expect(@iterator. next). must_equal 'Buzz'			expect(@iterator. next). must_equal '11'			expect(@iterator. next). must_equal 'Fizz'			expect(@iterator. next). must_equal '13'			expect(@iterator. next). must_equal '14'			expect(@iterator. next). must_equal 'FizzBuzz'		end	endendThe let function provides an alternate and some would say more elegant way of setting up testing state with a more declarative syntax. describe FizzBuzzIterator do	let(:iterator) { FizzBuzzIterator. new }	# . . . enddescribe FizzBuzzIterator do	let(:iterator) { FizzBuzzIterator. new(10) }	# . . . endEach call to let dynamically defines a new method with the specified name that executes the block argument upon the first invocation and caches the result for later access - in other words, a lazy initializer. Takeaways • Create a new test case in Minitest::Spec using a top-level describe block with a String or Class argument. • Define a test using an it block with a descriptive String passed as a parameter. • Make assertions on the values of expressions by wrapping them in a Minitest::Expectation object using expect or one of its aliases. • Use nested describe blocks to define scopes within a test case as a way of grouping related tests. • Implement before and after blocks for shared setup and teardown logic specific to a block context. • Create named lazy initializers using let blocks. : Configure Pre-Test State As explained back in Writing Tests, each test run under Minitest follows a common progression of steps: Setup, Exercise, Verify, and Teardown. Of these, Setup usually accounts for more lines of code and can be the toughest for new developers to understand. There are several options for setting the state, and knowing which one is the best fit requires familiarity with all of them. Method 1: Set up the same state before each test. Method 2: Configure different state before each test. Method 3: Using a memoized helper method. Method 4: Create data objects within the test. Collections Enumerable types where order doesn’t matter like Hash and Set count two instances as being equal if they contain the same elements regardless of the order in which the elements were added or passed during initialization. Relations (active record) Just as with Arrays though, order matters, so you’ll need to ensure that both the actual and the expected values are sorted the same way when performing comparisons. ActiveRecord::Relation objects compare mostly like Arrays except when compared with others of the same type, and then according to the SQL representation. Dates and Times Intermediate Recipes Mocks: mocks test the behavior of an object toward the objects to which it sends messages. Use mocks sparingly and only after careful consideration. The more collaborators you mock, the greater your risk of false positives. • Only mock what you own. If you don’t own it, the API could change, and you’d never detect it in your tests. • Only mock immediate collaborators and avoid deep mocking (mocks returning mocks returning mocks). • Ideally, only use mocks to solve specific difficult problems like:◦ Connecting to unreliable or uncontrollable external resources◦ Real object performance is prohibitively slow◦ Expensive setup and/or configuration◦ Avoiding other undesirable side effects StubsStubs provide the context needed to fully exercise an object through a given test scenario • Use stubs wherever and whenever they’re needed, but recognize that needing too many is probably a code smell. • Don’t use stubs where they’re not needed, and apply them as narrowly as possible where you do use them. (See Mocha’s stub_everything and any_instance. stub as prime examples of mocking framework features promoting bad coding practices. )• Never ever, ever stub the object under test. More often than not, you’ll end up testing the stub and not the object itself. Fake Objects A fake is an alternate version of a given class intended for testing only. It exposes an interface resembling that of the real thing it replaces but with an implementation that’s either simplified or hollowed out which allowsthem to:• Capture and verify interactions between the object under test and the fake object (like a mock). • Maintain consistent interactions between the object under test and the fake object (like a stub). • Avoid resource-intensive or otherwise undesirable processing (like both mocks and stubs). We could have gotten the same result using mocking or stubbing, but it might have taken many more lines of setup code. A fake can be a great fit when dealing with complex APIs since it comes ready-made and pre-programmed with the behavior we want and need for running our tests. Testing Mixin Behavior Testing something that can’t be instantiated on its own confuses many developers. two types of mixins: Those that are coupled with the classes that include them, and those that aren’t (non-coupled modules) Takeaways • Use Object#extend to patch a mixin’s method into a simple Object for easy testing. • Try mixing into a Ruby Struct in cases where you need the including class to have some specific attributes or behavior of its own. Sharing Code Between Tests One point that should be clear to you by now is this: a self-contained test is a readable test. Minitest provides a nice, narrow vocabulary for writing tests, and when we stick to that vocabulary, life becomes better for the developers that follow. When it comes to organizing tests:• Extracting code into a new helper methods• Extracting helper methods into a new module• Extracting tests into a new module Extracting helper methods by:• Using descriptive names for helper methods and variable arguments• Updating the extracted code to ensure that it’s still comprehensible, even outside the previous context Takeaways • Code shared within a single test case can be extracted to a private helper method in the same class. • Code shared across multiple test cases can be extracted to a module that may be included in all. 	◦ Sharing tests between test cases is a special case of this Managing Test Data • Whenever persistence isn’t important to your test, use Object. new to create a new instance. • Rails fixtures have a lot going for them including great performance and a reliable set of known models for your tests. • Use both functional and memorable names for your fixtures. • Configure your fixtures carefully, and try to cover at least:◦ One minimal valid configuration◦ One or two realistic models◦ Other well-defined object states• Use advanced ERB and YAML features to define fixtures dynamically. Testing Active Record Models Active Record maps the application database to Ruby objects that manage attributes, relationships, queries, and lifecycle methods among other things. • Test public methods, not private ones. • Test interfaces, not implementations. • Don’t test Active Record (or the rest of Rails, for that matter). • You need to test some of the typical aspects of Active Record models:	◦ Complex validations	◦ Scopes	◦ Callback targets and hooks• Make assertions about the results and side effects of public instance methods. • Make (selective) assertions an object’s behavior toward collaborators. Testing Controllers There’s been a faction of the Rails community that has become vocal about skipping controller testing completely. They usually argue that simulating more realistic user interactions eliminates the need for more focused controller tests which tend to be very repetitive and dull to write anyway. Even the core team has started a gradual move away from controller testing. ◦ Controller tests should include assertions for the visible side effects that controller actions produce including:	◦ HTTP response code	◦ Redirect location	◦ System state changes (models created, updated, or destroyed)	◦ Flash variables, session variables, and cookies set or changed• You should write tests for complex or generated routes. • Controllers should specifically not make assertions about any of the following:	◦ Rendered templates	◦ Instance variables passed to the view "
    }, {
    "id": 50,
    "url": "http://localhost:4000/2021/12/24/how_to_set_right_obj.html",
    "title": "How to set the right objectives",
    "body": "2021/12/24 - Why Greatness Cannot Be Planned: The Myth of the Objective. Kenneth Stanley Knowledge Project Podcast AI Researcher Reveals How to Set the Right Objectives Objectives are good when they are modest, but things get complicated when they are more ambitious. We as society believe that setting objectives and pursuing them it’s going to help us make new discoveries comma new accomplishments, achievements. Some great ideas were never an objective until they were discovered. (Rock and roll, penicillin) Serendipity are discoveries that you were not planning to make it. The core problem with ambitious objectives is that many cases trying harder won’t help you achieve the outcome you’re seeking. You can’t be so tied to your vision of accomplishment that you’re not open to the unexpected or unplanned. You can block your own ability to reach an objective by setting it. Assessment feels like we’re moving towards our objective; the problem is that even if the metric shows that you’re moving up in the short run it doesn’t mean it will lead to the point all the way down. Example: increasing the tests scores in the US schools. (Universal global achievement. Incredible complex) The metric is the assessment and year over year can be going up but it doesn’t solve the fundamental problem. It needs accountability and assessment with a different approach (an approach that recognizes how you actually make innovative progress in a extreme complex problem) If stepping stones are counter-intuitive (they are not what you would expect) then the metrics are useless because they (metrics) won’t detect those stepping stones If stepping stones are not counter-intuitive then it’s not a hard problem, we would have solved already; that’s what makes the problem hard to solve that you don’t know the steps. So we need to proliferate stepping stones. It’s like investing portfolio, they are just ideas, you don’t know what is going to pay off but you do need that portfolio and make that kind of prediction; some of them will not work out and we need to tolerate. Traditional metrics don’t allow stepping stones that won’t lead to the objective. Accountability must thrive interesting steppingstone, even when they won’t go up. What is not a stepping stone is having everyone getting better than prior year. A solution for the education problem is dissemination of the network teachers, see what on teacher did and work and build from that; it may lead to an end road buy we can’t find out if not try. We need to find interesting things that are not objectively detectable through the usual assessment. Peer review allows to see from the global optic to the individual. (Academic publishing is an example)Innovations happen through individual connections. With ambitious goals they are far off in the future and we don’t know what the next stepping stone is so it’s better to almost take like an evolutionary approach where we are creating these mutations or copying errors or trying all these little experiments and then we see which of those experiments leads to some interesting insights or conclusions and then the idea being, we take those conclusions and then we propagate it to and we propagate it to all other nodes almost like nature sort of rewarding. Subjective judgments are interesting because objective judgments are easy. One example is when we got through this pandemic we should have chosen the best 5th grade teachers (State level or city) and gave them the opportunity to teach all 5th grade students because they were the best, and have best practices however this implies two things: subjection (this is teacher than these others) and failure (which we as a humankind are afraid of). Security blanket is provided by assessments, it makes sure nothing really bad happen. Reality is inconvenient, scary, and difficult. A visionary is someone who in contrast who has recognized when the stepping stones actually have stepped into place now that’s a person you should follow and that’s a very interesting and kind of person. Within the corp-life one of the best ways to innovate is to pursue your dream, quit your job and start a start-up this is because the whole society is trapped in this “set goals minded” instead of capturing and developing the idea, they just let it go. "
    }, {
    "id": 51,
    "url": "http://localhost:4000/2021/09/25/refactoring.html",
    "title": "Refactoring",
    "body": "2021/09/25 - This book will take you from beginner to advanced in terms of refactoring. It’s recommended to have prior knowledge of either one Object Oriented language or Ruby however the Ruby language is very idiomatic so you don’t need to have a deep understanding of it in order to identify what is the author trying to teach. Firstly let’s bring up what “Refactoring” means: Verb: To restructure software by applying a series of refactorings without changing its observable behavior. Noun: A change made to the internal structure of software to make it easier to understand and cheaper to modify without changing its observable behavior. The book has around 70 examples of how you can clean your code up and some others well known “good practices”. What are the main benefits of doing it and also it considers its downsides so that you can see the whole picture, bearing in mind that the code you write today must be easy to understand and even change tomorrow. The first chapter begins with a good example of a Movie theater system, on the left side you may find some spaghetti code and on the right the code after applying some refactoring twists. Also, he brings some step by step methodology which consists in small changes, test, another small change, test in order to make sure nothing has been broken. He gives you a brief example and then provides a small image, the motivation, the mechanics and the example. For visual learners, the book has plenty of diagrams, before the Refactoring and after so you can see how a requests is sent from the user/browser and pass through different methods and by doing that you may see how an object is modified and what methods intervene and also how clean is the new diagram. There is a section called “Tip” where the author gives you some advices in order to perform better; this is the first: When you find you have to add a feature to a program, and the programs code is not structured in a convenient way to add the feature, first refactor the program to make it easy to add the feature, then add the feature. He goes over about the ROI (return of investment), the technical debt, how to manage it in the case we have tight deadlines and how much we should invest in order to write good code in the first attempts. Notes. Instance methods should not be too long nor does too much. Even if it works, it’s until we want to change the system when we notice there’s a bad smell. Code is written by humans and humans need to understand it also care about it. A poorly design system is hard to change. If it’s hard to figure out what to change is very likely that programmer will make a mistake and introduce bugs. The only guarantee you’re going to have is that they will change it again within six months. The first to refactor is always the same. I need to build a solid set of tests for that section of code. Decomposing and Refactoring the Statement Method I am looking to decompose the method into smaller pieces. Smaller pieces of code tend to make things more manageable. They are easier to work and to move around. My first step is to find a logical clump of code and use Extract Method. When I extract, I need to know what could go wrong. If I take a larger piece, I can introduce a bug into the program. So before doing it try to figure out how to do it safely. Any non modified variable can be passed as parameter. Modified variables need more care. Never be afraid to change names of things to improve clarity. Good programmers write code that humans can understand. In most cases a method should be on the object whose data it uses. While Refactoring you should focus on clarity, and then later focus on performance as a separate activity. Replacing the Conditional Logic with Polymorphism. If you must use a case statement should be your own data, not on someone else’s. Using subclasses, we can get rid of the case statement using Polymorphism. Example: Movie (as main class) then subclasses: RegularMovie, Children’sMovie and NewMovie. An object cannot change its class during its lifetime. All these lead to better-distributed responsibilities and code that is easier to maintain. The purpose of refactoring is to make software easier to understand and modify. You can make many changes in software that make little or no change in the observable behavior. It only alters the internal structure. Any user, whether an end user or another programmer, cannot tell that things have changed. The two hats by Kent Beck. When you add a function, you should not modify existing code, you’re just adding new features (hat #1), on the other hand when you are refactoring, you should not add code, just restructure the code (hat #2). Refactoring is not the silver bullet for all software development issues. Loss of the structure of code has a cumulative effect. The harder it’s to see the design in the code, the harder it’s to preserve it. Refactoring helps you spot bugs. When I’m studying code, I find Refactoring leads me to higher levels of understanding that otherwise I would miss. You don’t decide to refactor, you refactor because you want to do something else, and refactoring helps you do that other thing. I ask myself if I can refactor the code to make that understanding more immediately apparent. Then I refactor it. The other driver of Refactoring is a design that does not help me add a feature easily Developers often to both things, to remove existing pain points and experiment with new solutions. When developers have a deeper understanding of the code base they can ne more effective at adding to it and suggesting how to improve it. Refactoring tends to break big objects and big methods into several smaller ones. When shouldn’t you refactor? A compromise route is to refactor a large piece of software into components with strong encapsulation. Then you can make a refactor-versus-rebuild decision for one component at a time. Another time you should avoid refactoring is when you are close to a deadline. At that point the productivity gain from refactoring would appear after the deadline and thus be too late. With refactoring the emphasis changes. You still do up-front design, but now you don’t try to find the perfect solution. You may find that the solution is different from the one you previously came up. Always look for flexible solutions. Refactoring can lead to simpler designs without sacrificing flexibility. The secret to fast software is to write tunable software first and then to tune it for sufficient speed. Since the early days of programming people have realized that the longer a procedure is, the more difficult it is to understand. If you have a good name for a method, you should not look at the body. Ninety-nine percent of the time, all you have to do to shorten a method is Extract method. Find the parts of the method that seem to go nicely together and make a new method. A block of code with a comment that tells you what it is doing can be replaced by a method whose name is based on the comment. When a class is trying to do too much, it often shows up as too many instance variables. When a class has too many instances variables, duplicated code cannot be far behind. As with a class with a huge wad of variables, the usual solution for a class with too much code is either to Extract class, Extract module or extract subclass. A Useful trick is to determine how clients use the class and to use the Extract module for each of these uses. That may give you ideas of how you can break up the class. A class smell is a method that seems more interested in a class other than the one it actually is in. You can shrink a lot of parameter lists and simplify method calling. Bunches of data that hang around together really ought to be made into their own object. Most times when you see a case statement it may be replaced by Polymorphism. Each class you create costs money to maintain and to understand. A class that isn’t doing enough to pay for itself should be eliminated. Inheritance often leads to over-intimacy. One of the prime features of Objects is encapsulation – hiding internal details form the rest of the world. Comments are used as deodorant to somehow mask the bad smell. If you want to refactor, the essential precondition is having solid tests. If you don’t write self-testing code, you’ll end up spending most time debugging. When you get a bug report, start by writing a unit test that exposes the bug. Write isolated tests that do not depend on each other. You should concentrate on where the risk is. Look at the code and see where it becomes more complex. I emphasize the safe way of doing the refactoring, which is to take small steps and test after every one. A large part of refactoring is composing methods to package code properly. Almost all the time the problems come from methods that are too long. Long methods are troublesome because they often contain a lot of information which gets buried by the complex logic that usually gets dragged in. The key refactoring is Extract method, which takes a clump of code and turns it into its own method. Inline method which does the opposite. I prefer short, well-named methods. It increases the chances that other methods can use a method and also allows you to read from a higher level as a series of comments. Comments often identify pieces of a method that can be extracted. In such situation temporary variables can be helpful to break down the expression into something more manageable. The difficulty in decomposing a method lies in local variables. Refactoring can break down something complex into simpler pieces, but sometimes you just reach the point at which you have to remove the whole algorithm and replace it with something simpler. Moving methods is the bread and butter of refactoring. I move methods when classes have too much behavior or when classes are collaborating too much and are highly coupled. I consider moving a field if I see more methods on another class using the information in the field than the class itself. You’ve Probably heard that a class should be a crisp abstraction, handle a few clear responsibilities, or some similar guideline. You need to consider where it can be split, and you split it. A good sign that a subset of the data and a subset of the methods seem to go together. Other good signs are subsets of data that usually change together or are particularly dependent on each other. One of the keys, if not the key; to objects is encapsulation. Encapsulation means that object need to know less about other parts of the system. A class is doing too much, remove the middleman with method delegation. Each object stands for one object in the real world. Having many two-way links also makes it easy for mistakes to lead to zombies: objects that should be dead but still hang around because of a reference that was not cleared. Replacing case-like or conditional statements with Polymorphism involves blowing away the original class and replacing it with a new class for each type code. If the original class has a large chunk of code that doesn’t use the type code, I choose either Replace Type code with Module Extension or Replace Type code with State/Strategy. Replace Type code with Module Extension aims to remove conditional logic. Both the original class and the module that is being extended can access the same instance variables. Modules cannot be unmixed easily. When the code is changed at the runtime and the type changes are complex enough that I cant get away with Module Extension I use State/Strategy. I often find conditionals expressions come in two forms. The first form is a check where either course is part of the normal behavior. The second is a form situation in which one answer from the conditional indicates normal behavior and the other indicates an unusual condition. You have a conditional that chooses different behavior depending on the type of an object. One of the grandest sounding words in object jargon is polymorphism. The essence of polymorphism is that it allows you to avoid writing an explicit conditional when you have objects whose behavior varies depending on their types. You can achieve polymorphism in two ways in Ruby, one by implementing the same method signature on multiples objects and call these methods polymorphically and the second by introducing inheritance hierarchy and have the method that is to be called polymorphically on the subclasses. The essence of polymorphism is that instead of asking an object what type it is and the invoking some behavior based on the answer you just invoke the behavior. An assertion technique is a conditional statement that is assumed to be always true. Goal of interface is to show only what they have to and no more. Remember your code is for a human first and a computer second. Methods should be named in a way that communicates their intention. A good way to do this is to think about the comment you would use to describe the method and turn that comment into the name of the method. A good rule to follow is to say that any method that returns a value should not have observable side effects. If you come across a method that returns a value that is used by the caller and also has side effects, you should try to separate the query from the modifier. There are two motivations here for using Replace Constructor with Factory Method. The first comes about if we need to perform this construction login in more than one place. And the second motivation is encapsulation. Exceptions are better because they clearly separate normal processing form error processing. A module should have one single responsibility, just like a class. A module that is difficult to name with the words “helper” or “assistant” is probably doing too much. The main trigger for use of Extract Subclass is the realization that a class has behavior used for some instances of the class and not for others. A Ruby Class can only inherit from one superclass directly. If you want the class to vary in several different ways, you have to use delegation or module extension for all but one of them. Notice that the implementation using extension of modules is similar to the inheritance example. So why use extend instead of inheritance? The answer is that you would use extend if the modules you were creating could be used to extend various classes. By using delegation instead, you make it clear that you are making only partial use of the delegated class. Book examples: https://github. com/DominicLizarraga/refactoring_ruby_edition "
    }, {
    "id": 52,
    "url": "http://localhost:4000/2021/06/15/well_grounded_rubyist.html",
    "title": "The Well-Grounded Rubyist",
    "body": "2021/06/15 - The book is on its 3rd edition and it’s comprised of 3 parts and 16 chapters:  Ruby foundations: (chapters 1-6)The syntax is introduced, key concepts and semantics that Ruby uses, also the construction of objects, classes, modules and identifiers, code conventions, also, how to execute files from the console, how to use Gem files and finally using the Ruby interpreter (irb).  Built-in Classes and methods: (chapters 7-12)The most used built-in classes, including: String, Array, Hash, Numeric, Range, Date, Time and Regular Expressions are presented with many examples, what should you expect out of it? How to use it? How the Boolean logic works. The book has a very digested way of reading how the code is flowing, it has a numerical series where you can read from 1 to 12, step by step, line by line so that you can see how the program reads variables, re-assign them and lastly how the output reached that level, instead of jumping from one line to another.  Ruby dynamics (chapters 12-16)Here you will find the metaprogramming basics, as well as handlers for non-existing methods, how to catch up those exceptions, callbacks, hook messages and finally a functional programming example. Notes. false and cause I conditional expression to evaluate as false; all other objects including true, of course, but also including 0 an “empty strings” caused it to evaluate to true . Variables types: locals, instance, class, global. Every object is capable of understanding a certain set of messages. Each message that an object understands corresponds directly to a- method, a name, executable routine whose execution the object has the ability to trigger. A class defines an object functionality, and every object is an instance of exactly one class period every time you create a string object, you have created an instance of the class string. Although every object is an instance of a class, the concept of class is less important than the concept of object. That’s because objects can change acquiring methods and behaviors that were not defined in their class period the class is responsible for launching object into existence, a process known as instantiation, but they’re after the object has a life of its own. The ability of objects to adopt behaviors that their class did not give them is one of the most central defining principles of design of Ruby as a language. Rather than asking in the abstract weather a = b, you ask whether it considers itself equal to B. If you want to know whether a given student is taking a class from a given teacher, you ask the student, are you student of this teacher ? There is room for debate as to whether this or that programming language, or even these or that kind of programming language, corresponds more closely than others to shape of the real world. A lot depends on how you perceive the world. Do you perceive it as people with things, each of which has task to do and waits for someone to request the task? If so, you may conclude that object oriented languages model the world best. Do you see life as a series of to-do items on a checklist, to be gone through in order? If so, you may see a strictly procedural programming language as having closer ties to the characteristics of the real world. In short there is no answer to the question of what the real world is. Designing object oriented software is largely a matter of figuring out what you want your objects to be: what they should do, how they will interact with each other, how many of each there should be . For example, many students, one register. And other such questions. To get an object to talk, you have to ask it to talk. But before you ask it to talk, you have to teach it how to talk. It’s all about asking objects to do things and tell you things. respond_to? is an example of introspection or reflection. Keywords are special reserved words that you cannot use as variable names. For example def is a keyword ; The only thing you can use it for is to start a method definition. Defining a class lets you group behaviors (methods) into convenient bundles, so that you can quickly create many objects that behave essentially the same way . You can also add methods to individual objects, if that’s appropriate for what you are trying to do in your program. But you don’t have to do that with every object if you model your domain into classes. A typical class consists of a collection of methods definition. Classes usually exist for the purpose of being instantiated that is, of having objects created instances of that class periodMovies about objects, and objects are instances of classes. The instance variable enables individual objects to remember state. Instance variables work much like other variables: you assign values to them, and you read those values back; You can add them together, print them out, and so on pivot but instance variables have a few differences: • Always start with a single @ • Are only visible to the object to which they belong • Instance variable initialized in one method inside a class can be used by any instance method defined within that class. An attribute is a property of an object whose value can be read and or written through the object. Every Ruby class can have only one superclass, in keeping with the principle of single inheritance. Ruby provides modules, which art bundles of programming functionality similar to classes (except that they don’t have instances), that you can easily graft onto your class family tree to provide as many methods for your objects as you need. Your line the idea of a class method is that you send a message to the object that’s the class rather than the one of the class instances. Like classes, modules are bundles of methods and constants. Unlike classes, models don’t have instances; Instead, you specify that you want to add the functionality of a particular module to that of a class or a specific object. No class can inherit from more than one class. In cases where you want numerous extra behaviors for a class instances and you don’t want to stash them all in the class superclass and its ancestral classes, you can use modules to organize your code in a more granular weight. When you are designing a program and you identify a behavior or set of behaviors that may be exhibited by more than one kind of entity or object, you have found a good candidate for a module. The practice of arranging objects that talk to one another in a complete program is called object-oriented design. You learn in chapter 3 that you define a method twice inside the same class, the second definition takes precedence over the first. If the object’s method lookup path includes two or more same name methods, the first one encounter is the winner and is executed. Include will make a module’s methods available as instance method. extend on the other hand, will make a modules method available as class methods. The kernel module provides an instance method called _missing. This method is executed whenever an object receives a method that it does not know how to respond to that is, a message that does not match a method anywhere in the object’s method look-up path. • Modules don’t have instances. It follows that entities or things are generally best modeled in classes, while characteristics, shared behaviors, and properties of entities or things are best encapsulated in modules. • A class can have only one superclass, but it means in as many modules as it wants. If you are using inheritance, give priority to create a sensible superclass/subclass relationship. To know which object itself, you need to know what context you are in. In practice, there are not many contexts to worry about. There is the top level ( before you have entered or after you have left any other context, such as a class definition). There are class definition blocks, model definition blocks, and method definition blocks. It’s all about self switching from one object to another, which it does when you enter a class or module definition, an instance method definition, or a Singleton method (including class method) definition. As soon as you cross a class or module keyword boundary , the class or module whose definition block you’ve entered – the Class or Module object becomes self. A simple rule governs instance variables and their resolution: every instance variable you will ever see in a Ruby program belongs to whatever object is the current object (self) at that point in the program. Using global variables tends to end up being a substitute for solid, flexible program design , rather than contributing to it. One of the main points of object oriented programming is that data and actions are encapsulated in objects. You are supposed to have to query objects for information and to request that they perform actions. And objects are supposed to have a certain privacy. When you ask an object to do something, you are not supposed to care what the object does internally to get the job done. Even if you yourself wrote the code for the objects method, when you send the object a message, you treat the object as a black box that works behind the scenes and provides a response. Global variables these sort the landscape by providing a layer information shared by every object in every context. Globally scoped data is fundamentally in conflict with the object oriented philosophy of endowing objects with abilities and then getting things done by sending request to those objects. Every definition block whether for a class, a model, a method, starts a new local scope, a new local variable, scratch pad, and get its own variable. At its simplest, idea behind a class variable is that it provides a storage mechanism that’s shared between a class and instance of that class, and that’s not visible to any other objects. No other entity can fill this role. Local variables don’t survive the scope change between class definition and their inner method definition. Globals do but they are also visible and mutual everywhere else in the program someone not just in one class. So class variables have a niche to feel: visibility to a class and its instances, and to no one else. The main business of Ruby program is to send messages to objects. And the main business of an object is to respond to messages. Sometimes, and object wants to be able to send itself messages that it does not want anyone else to be able to send it. For this scenario, Ruby provides the ability to make a method private. If you don’t use an explicit receiver for a method call, Ruby assumes that you want to send the message to the current object , self. Ruby control flow techniques include the following: Conditional execution. Execution depends on the truth of an expression. Looping. A single segment of code is executed repeatedly Iteration. a call to a method is supplemented with a segment of code that the method can call one or more times during its own execution. Exceptions. Error conditions are handled by special control for rules. After all, when you call a method on an object, control is passed to the body of the method ( 8 different scope); And when the method has finished executing, control returns to the point right after the point where the method call took place. The difference between a method call with a block and a method call without a block comes down to whether or not the method can deal. If there is a block, then it can; If not it cannot, because there is nothing to deal to. An Exception is a special kind of object, an instance of the class exception or a descendant of that class period raising an exception means stopping normal execution of the program and either dealing with the problem that’s being encountered or existing the program completely. It’s generally considered good practice to catch a specific exceptions rather than simply using rescue to catch all exceptions. ensure clause is executed whether an exception is raised or not. In short it is packed to begin/end structure of which it is a part, and its execution is unconditional. The fact that you can define an even redefine elements like the + -, and square brackets means that Ruby has a great deal of flexibility. But there are limits of what you can redefining will be. You can’t where they find any of the literal object constructors: {} it’s always a hash literal (or a code block, if it appears in that context), “” we’ll always delimit a string, and so forth. One consideration, weighing in on the side of modifying objects instead of creating new ones, is efficiency, creating new objects is expensive in terms of memory and processing. All that matters is what the object can do, what methods it can execute. Nil does exist. Single values, such as integer and strings, as opposed to collection or container objects that hold multiple values are considered as a scalar. Symbols aren’t unique. Whenever you see xyz, you are seeing a representation of the same object. Again, symbols are more like integers than strings in this respect. When you see the notation “xyz” in two places, you are looking at representations of two different string objects; The literal string constructor “” creates a new string. But :xyz is always the same Symbol object, just as 100 is always the same object. Symbols are immutable. There is no such thing as appending characters to a symbol; Once the symbol exists, that’s it. You will never see :abc « :d or anything of that kind. Symbols have a number of users, but most appearance fall into one of two categories, method arguments and hash keys. Well we can process symbol faster. Whereas the strings have a malleability that’s a good fit for their presentation of arbitrary values. Strings being mutual, symbols not. Symbols share with integers not only immutability and uniqueness but also immediacy: a variable to which a symbol is bound provides the actual symbol value, not a reference tweet. Any class that aspires to be innumerable must have an each method whose job is to yield items to a supply code block , one at a time periodNumerators are closely related to eaters, but they are not the same thing period and iterate are is a method that yields one or more values to a code block. And enumerator is an object, not a method, therefore maintain state. An Enumerator can add innumerably to objects that don’t have it. It’s a matter of wiring: if you hook up and enumerators each method to any iterate are, then you can use the numerator to perform innumerable operations on the object that owns the iterator, whether that object considers itself innumerable or not. Here is the source code https://github. com/jleo3/twgr "
    }, {
    "id": 53,
    "url": "http://localhost:4000/2021/05/30/practical_oriented.html",
    "title": "Practical Object-Oriented Design (POODR)",
    "body": "2021/05/30 - This book is the second edition that Sandi Metz publishes and it’s even considered as a must-read by the RoR community, give it a shot you won’t regret at all no matter what language you’re coming from. The introduction gives you why we want to work at a place where we feel as if we had some real impact, without being painful and why not make it funny as well, also explores the idea of increasing the productivity and reducing costs associated with poor design software. It goes over some agile methodology; it brings up the “Agile Manifesto” and explores its points of intersection between project management and software development. The core example of the book is a Bicycle store and it starts with the most simple but thorough class and it gradually increases its complexity always by giving you the reason why would you for instance need to add spare parts method to the main class or create a new one from scratch, what are the benefits and downsides? Is the customer really requesting this? What if we go beyond the scope of the app and make it flexible since the beginning? And finally, you end up with a Bicycle store and an app to book trips. 🚲 🏔 It offers many examples of all the good practices or rules you may find below and gives you the before and after of each scenario, and you can find the most important examples in my repository. https://github. com/DominicLizarraga/refactoring_ruby_edition Chapter 1. “Object-Oriented Design” Encourages you to shift your thinking from a world of collection of predefined procedures to modeling the world as a series of messages that pass between objects. It depicts that statement with an example of a woman waking up at the same hour, preparing her coffee and suddenly steps on the cat, causing a reaction that was not on the normal routine. 🐈 It also elaborates on the idea that the only sure thing that will happen is that your app will need some changes, it’s impossible to never change. It includes some customer perspective and how the client doesn’t not even know what they want so you must be ready for progressive modifications. “You must combine an overall understanding of your application’s requirements with knowledge of the costs and benefits of design alternatives and then devise an arrangement of code that is cost effective in the present and will continue to be so I the future. ” “The purpose of design is to allow you to design later, and its primary goal is to reduce the cost of change. ” The chapter 2. “Designing Classes with a single responsibility” The foundation of an object-oriented system is the message, but the most visible organizational structure is the class. Your goal is to model your application, using classes, such that it does what it is supposed to do right now and is also easy to change later. Creating an easy-to-change application, however, is a different matter. Your application needs to work right now just once; it must be easy to change forever. The problem is not one of technical knowledge but of organization; you know how to write the code but not where to put it. When it says easy to change it means the following: • changes have no unexpected side effects, • small changes in requirements require correspondingly small changes in code, • existing code is easy to reuse, and • the easiest way to make a change is to add code that in itself is easy to change. A class should do the smallest possible useful thing; that is, it should have a single responsibility. Chapter 3. “Managing Dependencies” Because well-designed objects have a single responsibility, their very nature requires that they collaborate to accomplish complex tasks. This collaboration is powerful and perilous. To collaborate, an object must know something know about others. Knowing creates a dependency. Ig not managed carefully; these dependencies will strangle your application. Your design challenge is to manage dependencies so that each class has the fewest possible; a class should know just enough to do its job and not one thing more. To some degree of dependency between these two classes is inevitable; after all, they must collaborate. When two (or more) objects are so tightly coupled that they behave as a unit, it’s impossible to reuse just one. Every dependency is like a little dot of glue that causes your class to stick to the things it touches. A few dots are necessary. If prevented from achieving perfection, your goals should switch to improving the overall situation by leaving the code better than you found it. If you get this right, your application will be pleasant to work on and easy to maintain. If you get it wrong, the dependencies will gradually take over and the application will become harder to change. Depend on things that change less often than you do. Injecting dependencies creates loosely coupled objects that can be reused in novel ways. Isolating dependencies allows objects to quickly adapt to unexpected changes. The key to managing dependencies is to control their direction. Chapter 4. “Creating Flexible Interfaces” It’s easy to think about object-oriented applications as being the sum of their classes, they are so very visible; and they spin around responsibilities and dependencies. There is design detail that must be captured at that level, but an object-oriented application is more than just classes. It is made up of classes but defined by messages. Classes control what’s in your source code repository; messages reflect the living, animated application. Design therefore, must be concerned with the messages that pass between objects. It deals not only with what objects know (their responsibilities) but also with how they talk to one another. The conversation between objects takes place using their interfaces; this chapter explores creating flexible interfaces that allow applications to grow and to change. Imagine two running applications. Each consists of objects and the messages that pass between them. In the first application, the messages have no apparent pattern. Every object may send any message to any other object. If the message left visible trails, there trails would eventually draw a woven mat, with each object connected to every other. In the second application, the messages have a clearly defined pattern. Here the object communicates in specific and well-defined ways. If these messages left a trail, the trails would accumulate to create a set of islands with occasional bridges between them. The second application is composed of a pluggable, component-like objects. Each reveals as little about itself, and knows as little about others, as possible. The design goal, as always, is to retain maximum future flexibility while writing only enough code to meet today’s requirements. Drawing this sequence diagram exposes the message passing between the objects. The best possible situation is for an object to be completely independent of its context. An object that could collaborate with others without knowing who they are or what they do could be reused in novel and unanticipated ways. Your goal is to write code that works today, that can easily be reused, and that can be adapted for unexpected use in the future. Object-oriented applications are defined by the messages that pass between objects. This message passing takes place along “public” interfaces; well-defined public interfaces consists of stable method that expose the responsibilities of their underlying classes and provide maximal benefit at minimal cost. Chapter 5. “Reducing Costs with Duck Typing” The purpose of object-oriented design is to reduce the cost of change. Duck typed objects are chameleons that are defined more by their behavior than by their class. Avoid getting sidetracked by your knowledge of what each argument class already does; think instead about what the object needs. Concrete code is easy to understand but costly to extend. Abstract code may initially seem more obscure, but once understood is far easier to change. Recognizing hidden ducks. Case statements that switch on class Uses of method: kind_of? and is_a? responds_to? Polymorphism in OOP refers to the ability of many different objects to respond to the same message. Duck typing reveals virtual underlying abstractions that might otherwise be invisible. Depending on these abstractions reduces risks and increases flexibility, making your application cheaper to maintain and easier to change. Chapter 6. “Acquiring Behavior through Inheritance” This chapters offers a detailed example of how to write code that properly uses inheritance. The idea of inheritance may seem complicated, but as with all complexity, there’s a simplifying abstraction. Inheritance is, at its core, a mechanism for automatic message delegation, if and object cannot respond to a received message, it delegates that message to another. A superclass can have many subclasses, but each subclass is permitted have one superclass. Creating hierarchy has costs; the best way to minimize these costs is to maximize your chance of getting the abstraction right before allowing subclasses to depend on it. The best way to create an abstract superclass Is by pushing code up from concrete subclasses. Chapter 7. “sharing Role Behavior with Modules” To reap benefits from using inheritance you must understand not only how to write inheritable code but also when it makes sense to do so. Use of inheritance is always optional; every problem that it solves can be solved another way. Because no design technique is free, creating the most cost-effective application requires making informed tradeoffs between the relative costs and likely benefits alternatives. When formerly unrelated objects begin to play a common role, they enter into a relationship with the objects for whom they play the role. Many object-oriented languages provide a way to define a named group of methods that are independent of class and can be mixed in to any object. In ruby these mix-ins are called modules. When objects that play a common role need to share behavior, they do so via a Ruby module. When a class includes a module, the methods in that module get put into the same look path as methods acquired via inheritance. Chapter 8. “Combining Objects with Composition” Composition is the act of combining distinct parts into a complex whole such that the whole becomes more than the sum of its parts. Music for example, is composed. You can create software this same way, by using object-oriented composition to combine simple, independent objects into larger, more complex wholes. A bicycle has parts. Bicycle is the containing object, the parts are contained within a bicycle. The Bicycle class is responsible for responding to the spares message. This spares message should return a list of spare parts. The more parts an object has, the more likely it is that it should be modeled with composition. Composition, classical inheritance and behavior sharing via modules are competing techniques for arranging code. Each has different costs and benefits; these differences predispose them to be better at solving slightly different problems. Chapter 9. “Designing Cost-Effective Tests” Without tests, these applications can be neither understood nor safely changed. They add value without increasing costs. These are notes I took from the book, nothing is mine. "
    }, {
    "id": 54,
    "url": "http://localhost:4000/2021/05/29/example.html",
    "title": "Example",
    "body": "2021/05/29 - Test photo! "
    }, {
    "id": 55,
    "url": "http://localhost:4000/2021/05/23/eloquent-ruby.html",
    "title": "Eloquent Ruby",
    "body": "2021/05/23 - This is book is not for learning the very basics of Ruby, it’s more for people who have played with the language, the console and maybe built simple web app, I say this because it assumes you know what is an array, how you can manipulate or work with it therefore the book only shows shortcuts for instance methods on arrays, the correct usage of bang (!). I contains 3 sections after each chapter, staying out of trouble, in the wild and to wrap up, which has the most important takeaway after the lesson, i. e. “Choose the right control structure”, a real example from a codebase and finally a summary of what it went over. The book navigates each lesson through a kind of library system where a Document is created with its author, it plays with the first name and last name of the author, then it adds it to an array, then to a hash in order to have it more well organized. It will refresh you some basics methods like inject, map, sort, reverse, push, pop, delete, shift with the bang and without it always keeping in mind that Ruby is an idiomatic language. The book dedicates one chapter to learn how to work and mutilate this String class which is something Ruby is pretty smart and after that String brush up it goes to the Regular Expression, It shows you only the basics of how to validate an e-mail, address how to format a date, and it helps you find it easy to use instead of the intimidating appearance it seems to be. It has a deep chapter on the usage of symbols, it shows you the difference between a symbol and just string, it brings the symbol characteristics, it’s immutability, its better performance and it’s memory space utilization. The core of Ruby on Rails, everything is an object, shows you the keywords, how to treat the self, some instance methods in order to know what class is the object you are evaluating, it also presents why treating everything as an object is a good way because it provides consistency to your application, the difference between public, private, protected methods. how to require external libraries like date for instance and it closes remembering us that virtually everything in Ruby is an object, and virtually all of those objects inherit the basic set of methods from the Object class. Engineering is all about tradeoffs. just about every engineering decision involves getting something, but at a price, and there is a price to be paid for dynamic typing. In the chapter 8 lays out the difference between dynamic and static programming languages and encourages you to write tests which is the best way 2 make sure your code works as it should, do you need to test it early, you need to test it often, and you certainly need to test it whenever you change it. The tests framework used on this book are Unit::Test and RSpec it shows you how to start those tests and make them work with their document class. The author Hardly stresses how important is to write test in order to know how your code is working there is no shortcut, there is no easy way it would save you tons of hours if you do it often. The part II of the books goes over the back bone of the language, in this case Classes, Modules and Blocks. Despite shelves full of books on software architecture, and UML diagrams to fill an Art Museum and design meeting that seem to last longer than the pyramids, building software mostly comes down to writing one method after another, methods that stick to doing one thing and doing it well. Composing methods for humans, this technique advocates dividing your class up into methods that have three characteristics. first, each message should do a single thing , focus on solving a single aspect of the problem. by concentrating on one thing, your methods are not only easier to write, they are also easier to understand. second, each method needs to operate at a single conceptual level: Simply put, don’t mix high level logic with the nitty-gritty details. a method that implements their business logic around say, currency conversions, should not suddenly veer off into the details of how the various accounts are sorted in the database. Finally, each method needs to have a name that reflects its purpose. nothing new here, we have all heard endless lectures about picking good method names. the time to listen to all of them haranguing is when you are creating lots of little methods that you are trying to put together into a functional whole. Why is building small, well named methods that do one thing such a good idea? it’s not about writing better code for the computer, because the computer does not care. you can code the same algorithm in a handful of large methods or in a myriad of little message and , as long as you’ve gotten the details right, the computer will give you exactly the same answer. the reason you should lean towards smaller methods is that all those compact, easy-to-comprehend methods will help you get the details right. Short, easily comprehending methods also have some secondary advantages as well. take the old bit of coding advice that every message should have exactly one way out, so that all of the logic converges at the bottom for a single return. the key to preventing your compose methods from turning on you is to remember that every method should have two things going for it. First, it should be short. and second, it should be coherent. In plain English, your method should be compact, but it should also do something. Unfortunately, since short is so much easier to remember than coherent, programmers will sometimes go too far in breaking up their methods. There is also a chapter that teaches you how to modify normal operators (&lt;, &gt;, +, -, =, %, *) and change their behavior totally, it demonstrates the ups and downs of defining your own operators, and what are they consequences for others users if they don’t know what outcome will they get. Chapter 12 and 13 explore the idea behind equality classes, how you can leverage the custom operator by giving them another behavior, how equal? is different from ==, or even ===; all of them have different meaning and the author breaks them all down, next it touches the Singleton and class methods what are their uses, when should you use them, how are they built and again they differences. The usage of Class instance variables, instance variables and modules, what are the benefits , the caveats, what happen if a name collision takes place, what can they hold, what are the risks of over using a module and one of the keys of programming which is naming these instances, those classes, these modules. How to include that module into a Class, how to extend the usage of that module, and also how is the look-up procedure when you call a method (Inheritance tree). An easy rule of thumb for naming modules is that if you find yourself creating a lot of names that all start with the same word, perhaps ‘TonsOTonerPrintQueue’ and ‘TonsOTonerPrintAdministration’, then you just may need a ‘TonsOToner’ module. The book also covers iterators with 3 chapters, they’re different ways of calling, the usage of yield (Execute around), the naming convention, how to enable a class to use more than 40 methods coming from the enumerable module, the usage of rescue, begin, raise; Come on errors when using execute around which can be for instance forget about exceptions; because execute around is all about warranties. The whole idea of execute around is that the color is warranty that this will happen before the code fires and that will happen after. The technique “execute later “ is when you add a parameter prefix with an ampersand, some practical examples of lambdas and procs as well and lastly it touches some of the metaprogramming topics to modify subclasses, to use the method_missing method In order to rescue one execution and provide an exception. Updating existing classes, fixing broken classes, what is the monkey patching? Dealing with DSL and XML, what are the Gems package, how to consume them, nuts and bolts of gems, where are they located and also how to build a gem publish them and make it public. "
    }, {
    "id": 56,
    "url": "http://localhost:4000/2021/04/01/beginning.html",
    "title": "Beginning Rails 6 🚇",
    "body": "2021/04/01 - This book takes you from the straightforward “rails new blog –d=postgrsql” to adding active jobs and sending automated emails; it goes step by step so that you can see gradually the app development, it has more than 500 pages with 18 chapters; it touches the very basics of Ruby in the 4th just in case the reader has no experience with this language however Rails is very intuitive and easy to follow along. As you may read the main web app that is built along with this book is a blog where an user can sign-in/ log-in with email and password, can post with “Rich Text” (attach images, modify font, color, size), can edit its own posts, can comment on other’s posts and finally can delete only posts that user has created. Articles are the epicenter of the application. It uses the most common Gems in order to get the app up and running, it helps you add the gem to translate the app into different languages (Spanish, Portuguese, etc. ), it helps you enable the active storage gem which is used like a cloud storage (comes by default with Rails), explains you the differences between CSS and SCSS, also how to connect JavaScript, what is it for?, action text, Ajax, Action Cable and finally it uploads the app to Heroku (Cloud platform to host your app) in order to grant access anyone in the world. It was also the first book I’ve read that contains the whole Action Pack broken down, routes, controllers, views, which means Action Controller, Action View and Action Dispatch respectively in addition the whole request cycle, who are the actors, what is DNS for? And lands all of this with a CD player in a car example, pretty clear for me. Notes. ✍🏻 A framework is a collection of libraries and tools intended to facilitate development. Design with productivity in mind a good framework provides a basic but complete infrastructure on top of which to build an application. Why choose Rails? 🛤 It provides a powerful database abstraction layer called active records, which works with all popular data based systems. It chips with a sensible set of defaults and provides a well-proven, multi-layer system for organizing programs files and concerns. Its goal as a framework is to solve 80% of the problems that occur in web development, assuming that the remaining 20% are problems that are unique to the applications domain; you get to focus on just 20% which is what really matters. With rails, you can respond to the needs of customers quickly and easily, and rails works well during collaborative development. It has the famous convention over configuration, “don’t repeat yourself” (DRY), the concepts of rapid prototyping and that “you ain’t gonna need it” (YAGNI) Philosophy, closing the gap between customer and programmer. Programming is all about making decisions. If you were to write a system from scratch, without the aid of rails, you would have to make a lot of decisions: how to organize your files, what naming conventions to adopt, and how to handle databases access are only a few. Rails lets you start right away by encompassing a set of intelligent decisions about how you program should work and alleviating theamount of low-level decisions making you need to do up front. As a result, you can focus on the problems direct trying to solve and get the job done more quickly. Although you can manipulate most things in the Rails setup and environment, the more you accept the defaults, the faster you can develop applications and predict how they will work. If you put your files in the right place and name them according to the right conventions, things just work. If you are willing to agree to the defaults, you’re generally have less code to write. The more duplication exists in a system, the more room box has to hide. Ruby is known for making certain programmatic constructs look more natural by way of what’s called syntactic sugar. Rails has popularized the term synthetic vinegar coma is the exact opposite of syntactic sugar: awkward programmatic constructs are discouraged by making their syntax look sour. Rails employs a time honored and well-established architectural pattern that advocates dividing application logic and labor into three distinct categories: the model, view, and controller. In the MVC pattern, the model represents the data, the view represents the user interface, and the controller directs all the action. The real power lies in the combination of the MVC layers. Using the pain of maintenance considerably while increasing the level of ability among components. Models. in rails, the model layer represents the database. For example, a model called User convention, would map to a table called users. All the rules for data access, associations, validation, calculations and routines that should be executed before and after save, update or destroy operation and nearly encapsulated in get model. Controllers. It is the controller’s job to fill with requests coma like processing server variables and formatting data, asking the model for information, and sending information back to the model to be saved in the database. It sets up variables to be used in the view, and then proceeds to render or redirect to another action after processing is complete. Controllers typically manage a single area of an application. For example, in a recipe application, you probably have a controller just for managing recipes. Inside the recipes controller, you can define what are called actions. Actions describe what a controller can do. If you want to be able to create, read coma update and delete recipes, you create appropriately named actions in the recipe’s controller. When a request comes into a controller, it uses a URL parameter to identify the action to execute; And when it is done, it’s sensory response to the browser. Their response is what you look at next. Views. The view layer in the MVC forms the visible part of the application. In rails, views are the templates that (most of the time) contain HTML markup to be rendered in a browser. It’s important to note that views are meant to be free of all but the simplest programming logic. Any direct interaction with the model layer it should be delegated to the controller layer, to keep the view clean and decouple from the applications business logic. active_record: a library that handles database abstraction and interaction. Action view: a templating system that generates the HTML documents the visitor gets back as a result of a request to a rails application. Action controller: a library for manipulating both application flow and the data coming from the database on its way to being displayed in a view. New lane these libraries can be used independently of rails one of another. Together, they form the rails MVC development stack. Rails is modular. One of the greatest features of rails is that it was built with modularity in mind from the ground up. Although many developers appreciate the fact that they get a full stack, you may have your own preferences in libraries. In the real world, specifications above as we learn how real users interact with our web applications. Chapter 3, goes to explain how is the rails architecture distributed, what are the files inside of each folder, how to start writing our first migration, execute it, how to add validations to the model, add more fields to the model, and also, how to rollback a migration in case you make a mistake or you did not add something important, it is always reversible. Chapter 4, explains why Ruby is dynamic, how you can use the IRB prompt, what are the Ruby data types such as string, numbers, symbols, arrays and hashes. what are variables, what are they for, and they need do not specify a data type for the variable or the find it in your code before you use it. What are the best practices for naming variables, in this case long and descriptive. Blocks and iterators, comments, control structures, methods. And finally, a brief introduction to object-oriented programming, objects and classes. A key feature of active record which maps table to classes, table rows to object, and table columns to object attributes. This practice is commonly known as object relational mapping (ORM). rails db:system:change -Which makes it easy to switch databases. Active Record provides the link between these classes and your tables, allowing you to work with what look like regular objects, which, in turn, can be persisted to the database. This frees you from having to write low level SQL to talk to the database. Object oriented programming is all about objects. You create a class that encapsulates all the logic required to create an object, along with its properties and attributes, and use the class to produce new objects, each of which is in unique instance, distinct from other objects of the same class. That means sound a little abstract (and with good reason abstraction, after all, is the name of the game) but if it helps you can think of a class as being an object factory. Classes are used to create objects, and objects have attributes. Every object has a unique set of attributes different from other objects of the same class. A return of nil always represents nothing. The new constructor creates a new object, but it is your responsibility to save it. If you forget to save the object, it will never be written to the database. To summarize, when you want to create a new object and save it manually, use the new constructor; When you want to create and save in one operation, use create. update_attributes is an instance variable if you want to update attributes in just one operation. The following call works for deleting or what’s inside the array Article. delete([1, 2, 3]) The primary way in which you enhance models is by adding methods to them. This is referred to as adding domain logic. With active record, all the logic for a particular table is contained in one place that model. This is why the model is set to encapsulate all the domain logic. This logic includes access rules, validations, relationships, and well, just about anything else you feel like adding. user. build_profile(attributes={}) Returns a new profile object that has been instantiated with attributes and linked to user through a foreign key but has not yet been saved. user. create_profile(attributes={}) Returns a new profile object that has been instantiated with attributes and linked to user through a foreign key that has already been saved. Their rule of thumb is that belongs_to declaration always go in the class with the foreign key rails db:setup Command recreates the database and adds the seat data as you may expect. Whenever you want to add a validation error to the list of errors, you just type errors. add(column_name, error_message). Action Controller. Orchestrate your applications flow. Every time a user requests a page, submits a form, or clicks a link, that request is handled in one way or another by a controller. A typical controller is most often a collection of actions that relates to a specific area of concern. For example, consider the blog application you have been building in the previous chapters. The controller that manages articles has the class name articles controller and has action methods for listing, creating, updating, reading, and deleting articles. The controller looks for a view whose name matches they requested name action. Action View. this library is another important part of action pack. Given that controllers are responsible for handling the request and issuing a response, views are responsible for rendering the output of a response in a way a browser or any other user agent can understand. The primary mechanism by which they do is through shared variables. All instance variables that you may see in a view comes from the controller; look at the view is not handling any logic to fetch the list of these articles. Action Pack. routing salt this problem by decoupling the URL from the underlying program implementation. Request cycle Then type request to response process is called the action pack request cycle. They request cycle consists of the following steps:Rails receives a request from the outside world (usually a browser). routing picks apart the request to determine the controller and action to invoke. A new controller object is instantiated, and an action method is called. The controller interacts with the model (usually performing a CRUD operation in a database with an Active Record model, but not necessarily). A response is sent back to the browser, in the form of either a render or a red direct. HTTP verbs The HTTP protocol defines several request methods, the most popular of which art GET and POST. Both our method for requesting a webpage; The differences in how the request is sent. GET is the simpler of the two period it includes all the information about the request as a part of the URL. POST sends information in visibly, which is to say as a part of the request header and not part of the URL so you cannot type a post request into your browser’s locations bar. How do you know when to use each? The best way to think of this is to consider GET high as read method. It should never do anything destructive, such as modifying a database record. POST, on the other hand, can be thought of as a writer method. When you need to create data, use POST. PATCH is used when you need to update a record partially, for instance, only changing your e-mail address. PUT is used to update a record completely. Most of the time, our controllers handle interactions with a collection of things, so we reflected by using a plural name. Comments are interesting because they are a little different from our other models so far. Comments depend on a particular article; They never exist on their own because they are conceptually meaningless if they are not tight to an article. Remember that you always have the article_id in your parameters because it is always included in your nested name routes. Also notice how you find they assign comment you do so using @article. comments. HTTP is a stateless so how can the application remember you are logged in if HTTP is a stateless? The answer is that you fake state with session object. Example: session[:account_id] = @account. id. Notice that you define session as a resource and not resources, because you never deal a set of sessions at once. The rule of thumb is that whenever you have data that are provided by the user, you cannot trust them blindly . You need to escape it. This includes model attributes as well ask parameters. Fortunately, railes escapes all rendered as strings for you. html_safe method skips the HTML escaping process. simple_fromat method Convert text to HTML using simple formatting rules. The chapters of Active Storage, how to implement Ajax (was implemented for creating and deleting comments, interacted with the DOM with a . js file where all the code for doing this was placed) and sending and receiving email (Action Mailer and Action Mailbox) is difficult to describe but overall those chapters are pretty neat, I’d say more than https://guides. rubyonrails. org/. Active Job chapter covers the configuration, the creation, the exception handling, retry, discard and finally it has a benchmark exercise where the perform_later method on the mail delivery improved significantly the app performance. This is the first time I faced Active Model, before this one I didn’t know it existed, the book take that module to build an EmailAFriend without the need to create the whole model as Article for example and with all the benefits a model implies, Active Record, callbacks, validations, attributes and so on. The Action Cable chapter is short, explains how HTTP is the normal way the web works, then how web sockets were introduced as a bidirectional server communication and after that it just lays out the four main concepts as connections, channels, streams, broadcasting, subscription and so on, it configures it and apply the broadcast to Article so every time one article is published it will appear at the top without refreshing and start the cycle from the beginning. The last 3 chapters covers testing, internationalization and the upload to Heroku, the first on them emphasize the importance of always test after each small change, and why the didn’t apply test to follow along, they bring up the technical debt, refactoring. what tools are outside to automate the testing like Unit::Test, fixtures, validations and lastly the 4 types of tests, for models, for controllers, mailers and system, it doesn’t go deep into the weeds, it only explain what they are. "
    }, {
    "id": 57,
    "url": "http://localhost:4000/2021/02/21/ruby_way.html",
    "title": "The Ruby Way",
    "body": "2021/02/21 - The book is on its third edition, it has had plenty of space as the must-read for every Ruby programmer, many great personalities in the software development community have commented, praised, written about this book (including Yukihiro “Matz” Matsumoto, the creator of Ruby) because a few years after Ruby was conceived the first edition was published, and as everything evolved, the book has done as well. This time the background of the beginning of this language is presented, how Matz thought in terms of design and usage for building this language, it went from the approach machine-centered paradigm to a human-centered one. Ruby strives to be friendly to the programmer, and with that in mind, we can rely on a completely new style of software development, more strategically then tactic, easier to read, needlessly to add comments. This piece has 22 chapters, and more than 700 pages; it covers the conception of the language, introduction to object orientation, basic syntax and semantics, working with strings, symbols, ranges, numbers, times and dates and of course our arrays, hashes and other Enumerables, also, goes over more advanced data structures like trees, graphs, sets, stacks and queues. It brings the difference between static and dynamic languages, testing, how to handle different data formats, how is related Ruby and web applications, and more stuff that you can leverage in order to cement draw Ruby fundamentals. To me it was the longest book I’d ever had in my hands, quite hard to start to be honest but as soon as you pass the first pages you get caught, it refreshed me a ton of built in methods for the most important data structures, and when I say a ton, it’s about 80% of all what you need (very comfy way to read these methods on the book, and with the method description more friendlier) , so very well thought from the author perspective, not hard theory to digest, only practical examples and a few debates between 2 different points of view but nothing abstract. I think is a good start for people who want to harden their programming skills because it covers many topics of software development, it doesn’t matter what language you come from, it works for processing text files, web development, graphical interfaces, some algorithms to get familiarized with. Notes. ✍🏻 An object is an entity that serves as a container for data and also controls access to the data. Associated with the object is a set of attributes, which are essentially no more than variables belonging to the object. Also associated with an object is a set of functions that provide an interface to the functionality of the object, called methods. It is a essential that any OOP language to provide encapsulation. The class may be thought of as the blueprint or pattern; The object itself is the thing created from that blueprint or pattern. A class is often thought of as an abstract type, a more complex type than, for example, an integer or character string. Inheritance is a mechanism that allows us to extend previously existing entity by adding features to create a new entity. In short, inheritance is a way of reusing code. Easy effective code reuse has long been the Holy Grail of computer science, resulting in the invention decades ago of parameterized subroutines and code libraries. Multiple inheritance he’s probably the most controversial area in OOP; one camp will point out the potential for ambiguity that must be resolved. It is conceivable that a new class could inherit from more than one class. Diamond inheritance problem, so-called because of the shape of its inheritance diagram, with both super classes inheriting from a single common superclass. The literal meaning of polymorphism is the ability to take on multiple forms or shapes. In its broadest sense, this refers to the ability to different objects to respond in different ways to the same message (or method invocation). The first, inheritance polymorphism, is what most programmers are referring to when they talk about polymorphism. When a class inherits from its superclass we know that any method present in the superclass is also present in the subclass. The second kind of polymorphism Conway identifies is interface polymorphism. This does not require any inheritance relationship between classes; It only requires that the interface of the object have met thoughts of a certain name. A module consists of methods or constants that may be used as though they were actually part of the class or object; When a module is mixed in via the include statement this is considered to be a restrictive form of multiple inheritance. By rivals are used to hold reference to objects. A module is a collection of methods and constants that is external to the Ruby program. The private level means that the method is accessible only within the class or its subclass. Ruby is a dynamic language in the sense that objects and classes may be altered at runtime. Will be has the capability to construct and evaluate pieces of gold in the course of executing the existing statically coded program. This is perhaps the most difficult area a programmer will encounter in learning Ruby. Everything is intuitive once you understand it. Everything is true except false and nil. many languages have some kind of for loop, as does Ruby. The question sooner or later arises as to whether the index variable can be modified. Any object can be in principle converted to some kind of string representation; That is why nearly every quarter class has a to_s method. A symbol is like a string in that it corresponds to a sequence of chapters. It is unlikely string in that each symbol has only one instance (just as a fixed number works). Therefore there is a memory or performance issue to be aware of. The &amp; notation allows us to pass a proc instead of an explicit attached block if we want. Because we use the &amp; on an object that is not a problem interpreter tries to call to_call on that object. It will call it repeatedly, once for each element in the right. The collect method (part of innumerable) is a useful tool that proves to be a time and labor saver in many circumstances. If you want to delete all instances of a certain piece of data, delete would do the job. The compact method (or it’s in place version compact!) removes nil values from an array, leaving the rest untouched. The delete_if passes every element into the supply block and delete the elements for which the block evaluates to true. It behaves similarly to reject!, except that the latter can return when the array remains unchanged. They reject method takes a block and produces a new array without the elements for which the block returns true. Bear in mind that +, concat, and even +=always create a new array object. Also bear in mind that while « adds to the existing array, it happens a new array element (which may itself be an array). What makes a collection enumerable ? Largely it is just the fact of being a collection. The module enumerable has the requirements that the default iterate each should be defined. Sequence as such is not an issue because even on unordered collection can have any generator. And enumerator is basically an object that can be used for external or internal iteration. In internal iteration, we simply iterate over each item in the collection and execute the block for each item in the sequence; External iteration means that the code can grab the next item in the sequence “on demand”. There are many other methods on Enumerable, and I cover most of them here. For convenience, I have divided them a little arbitrarily in four areas: searching and selecting, counting and comparing, iterating, and finally extracting and converting . The purpose of inheritance, of course, is to add or enhance functionality. It’s not always necessary to use super in such a way, but it is often convenient. Every attribute and method of the point is reflected in the child. The child can have additional attributes and methods, as you have already seen. The child can override or redefine any of the attributes and methods of the parents. If we invoke a method on a subclass, the method for that class will be called if it exists. If it does not the method in the superclass will be called, and so on. When we create a new structure template by calling Struct . New we may pass a string with the class name as the first argument. If we do come a new class is created where in class Struct itself, with the name passed in as the first parameter and the attributes given as the rest of the parameters. Every time you invoke a method, you are sending a message to an object. "
    }, {
    "id": 58,
    "url": "http://localhost:4000/2021/01/22/agile.html",
    "title": "Agile web Development with Rails 6 🛤",
    "body": "2021/01/22 - This was the first Rails book I read and caught me with the real example it takes you through, you’ll be building an online shop and the author goes from installing Rails, ruby and other libraries to finally code some automations and uploading to Heroku, you can either follow the book or at the beginning of each chapter you can download the final version of the app so that you will never lose track of what is being presented, also, brings a summary after lesson and has a playtime section where you can push yourself to do a bit more of the exercises. In addition something I find very interesting in the book is that the foreword and some sections in each chapter DHH had the opportunity to share either his experience or advice regarding the current topic and he, being the creator of this framework and having built a company on top of it (Basecamp and Hey), I consider it as a nugget of information. Lastly, this is the book that has the best explanation about how Action Pack, Action Controller, Action View, Action Dispatch work together; it dedicates 1 chapter to just explain how routes get match to the controller and their actions and how are they converted into views. Very immaculate. Let’s begin with chapter 2 (1st is about installing all the stuff) The first example is to show the reader how to use the rails command, in this case the author creates a demo app with two views and one controller, after that it creates a couple of links in order to show how works, nothing fancy so far. Next chapter goes over the MVC architecture, the model is responsible for maintaining the state of the application. Is more than data; It enforces all the business rules that apply to the that data. For example, if a discount should not be applied to orders of less than $20, the model enforces the constraint. The model acts as both a gatekeeper and a data stored. That view is responsible for generating a user interface, normally based on data in the model. For example, an online store has a list of products to be displayed on a catalog screen. The list is accessible via the model, but it is a view that formats the list for the end user. Debut itself never handles incoming data. Controllers on the other side, orchestrate the application. They receive events from the outside world (normally, user input), interact with the model, and display an appropriate view to the user. The MVC architecture was originally intended for conventional GUI applications, where developers found that the separation of concerns led to far less coupling which in turn made the code easier to write and maintain. Each concept or action was expressed in a single, well known place. In a Rails application, an incoming request is first sent to a router, which works out where in the application the request should be sent and how the request should be parsed. Ultimately, these face identifies a particular method (called an action in rails parlance) somewhere in the controller code. The action might look at data in the request it might interact with the model, and it might cause other actions to be invoked. Eventually the action prepares information for the view, renders something to the user. The routing component receives the incoming request and immediately picks it apart. The request contains a path (/line_items?product_id=2) and a method (this button does a POST operation; Other commands methods are GET, PUT, PATCH and DELETE). In this case, Rails takes the first part of the path line_items as the name of the controller and the product_id as the id of the product . By convention, POST methods are associated with create actions. They create method handles user requests. In this case, it finds the current user shopping cart when parentheses which is an object managed by the model). It also asks the model to find the information for product 2. It then tells the shopping cart to add the product to itself. Object relational mapping (ORM) libraries map database tables to classes. If a database has a table called orders, our program will have a class name Order. Rows in this table correspond to objects of the class - a particular order is represented as an object of the Order class. Within that object, attributes are used to get and set the individual columns . Our order object has methods to get and set the amount, sales tax, and so on. So, and ORM layer maps tables to classes, rows to objects, and columns to attributes of those objects. Class methods are used to perform table level operations, and instance method perform operations on individual rows. Active record is the ORM layer supplied with rails. It closely follows the standard model: tables map 2 classes, roast two objects, and columns to object attributes. Action pack: the view and controller When you think about it, and controller parts of the MVC are pretty intimate. The controller supplies their data to the view and the controller receives events from the pages generated by the abuse. Because of these interactions, support for views and controllers in rails is bundled into a single component, Action pack. The view is responsible for creating all or part of the response to the displayed in a browser, to be processed by an application, or to be sent as an e-mail. At its simplest , is a chunk of HTML code that displays some fixed text. More typically, you will want to include dynamic content created by the action method in the controller. The controller in rails is the logical center of your applications. It coordinates the interaction among the user, the abuse, and the model . however, rails handles most of this interaction behind the scenes; The code you write concentrates on application level functionality . This makes rails controller code remarkably easy to develop and maintain. The controller is also home to a number of important ancillary services: • It is responsible for routing external requests to internal actions. It handles people friendly you are extremely well. • It manages catching, which can give application orders of magnitude performance boosts. • It manages helper modules, which extend the capabilities of the view templates without walking up their code. • It manages sessions, giving the users the impression of ongoing traction with our applications. Chapter 4 goes on to what is an object oriented language, will we names for local variables, methods parameters, and methods names, it provides the general rules of syntax, the kind of data types you will find in groovy like strings, array, hashes. The core of the Ruby language, which is blocks and iterators, control structures with the if statements, while loops, unless, until. Chapter 5: incremental development, use cases, page flow, data and priorities are covered. The first sketch of the shopping cart is shown, the user stories are broken down for instance: the buyer uses the web app to browse products we have to sell , select some of to purchase, and supply the information needed to create an order. On the other side the seller journey is as well described and something important is how the data is it going to be handled, how many controllers are we planning to code, the schemas are presented as well and finally the author emphasizes that all of these planning will become outdated because we must get customer feedback and most of these will change. The book pushes you to develop the web app in incremental changes called iterations. Chapter 6, it starts with the application “rails new depot” and creating the first model in this case the product , it shows you how to migrate, the addition of CSS for the forms, it explains the HTTP verbs and this is the first commit to GitHub. Next chapter added some model validations in order to ensure the user input, also, introduced the first unit test examples and explain how they work; the importance of naming self-explanatory variables, tests. Chapter 8, builds the 2nd controller in this case is a Store and it added some CSS to the index view, also, went over the layout, using partials files in order to create the navbar, and continued with the testing now including the front end (what should the &lt;H2&gt; tag title contain or how many items &lt;li&gt; should have). The following chapter creates the Cart model, line_item, by a scaffolding them, and connect the line_item model to product and to cart, becoming a joint table; another feature added here is the introduction to sessions , it explains how they work, how much they can carry on and what are they useful. Chapter 10 covers how to deploy a new migration because in the first one, something was forgotten and leveraging how you can juggle with migrations there are four decided to add a new one instead of creating everything from scratch. Some flash notice modifications took place, and a strong parameter adjustment as well, finally the CSS was at refined to the new changes. The next chapter introduced they AJAX and it explains it very well, the book contains why Ajax exist how can I change the flow of the views, then Ajax feature it’s just highlighting some data without refreshing the whole page and finally action cable is presented with the core concepts. Within the next iteration the add_order_to_line_item model is created, a new form for capturing the lines items for the order as well and linking Line items 2 one order, after each addition a test is deployed and passed. In order to make more dynamic our rails app we need to add React which is a JavaScript view library designed to quickly create dynamic user interfaces. We will use it to create a dynamic payment method details form coma and Webpacker will ensure that the configuration and set-up for all these is as simple as possible. That said, there is a bit of setup we need to do. Web Packer essentially is the decisions made by the rail steam and bundled up into a gem. React dynamically renders HTML. Unlike ERB, react does this in the browser, and it is optimized to do it fast. React re render each field of the form instead of having this server re render the entire thing. the core concept in react is components. A component is a view, backed by some sort of state. When the state changes, the rear Enders. The view can behave differently depending on the current state inside the component. Chapter 14 goes on the e-mail module of Rails and explain why sending e-mail normally is slow, why would you choose Action Mailer and then you put on top of it Active Job to offload the work. In a Rails app, when a bit of logic becomes more complex than a line or two of code, you want to move that out of the controller and put it into a model. The chapter 15, 16, 17, are about logging in, internationalization, and responding emails with rich text this is almost as straight out as you may find it in the rails guide so I won’t go deeper due to is configuration, set-up and little adjustments. The last part of the book (III) contains 6 chapters and they are under a title called “Rails in depth” I consider this very helpful if you want to go deep into the weeds and explore how is rails composed? why does rails app contain many default files? What are they for? When is correct to use a helper from there app file or from the model? Where does rail put the logs? Naming conventions? Where do you configure the environments? And many interesting methods that I didn’t know. Active record he’s also touched in this chapter and with more detail the CRUD actions are explained, also, using like classes, order, limit, using the word keyword, joins coma scopes, writing your own SQL, What are the 16 call backs Rails includes. Action Pack lies at the heart of rails applications. It consists of three Ruby modules: action dispatch, action controller and action view. Action dispatch routes request to controllers. Action controller converts requests into responses. Action view is used by action controller to format those responses. Components such as action controller, action view, and active record handled the processing of request, and the rails environments needs them together into a coherent and easy to use whole. At its most basic, a web application accepts an incoming request from my browser, process it, and sends a response. The first question that springs to mind is, how does the application know what to do with the incoming request? A shopping cart application will receive requests to display a catalog, add items to a part, create an order, and so on. How does it route these requests to the appropriate code?it turns out that Rails provides two ways to define how to route a request: a comprehensive way that you will use when you need to and a convenient way that you will generally use whenever you can. The comprehensive way lets you define a direct mapping of URLs to actions based on pattern matching, requirements and conditions. The convenient way lets you define routes based on resources, such as the models that you define. And because the convenient weight is built on the comprehensive way, you can freely mix and match the two approaches. A controller always responds to they use exactly one time per request. This means you should have just one call to a render(), redirect_to() or send() method in the processing of any request. Because the controller must respond exactly once, it checks to see whether a response has been generated just before it finishes handling a request. If not, the controller looks for a template named after the controller and action and automatically renders it. This is the most common way that rendering takes place. You may have noticed that in most of the actions north shopping cart tutorial we never explicitly rendered anything. Instead, or action methods set-up the context for the view and return. The controller notices that no rendering has taken place and automatically invokes the appropriate template. A real session is a hash-like structure that persists across request. Unlike raw cookies, sessions can hold any objects as long as those objects can be marshaled, which makes them ideal for holding state information in web applications. Rails encourages and agile, iterative style of development. We don’t expect to get everything right the first time period instead, we write tests and interact with our customer to refine our understanding as we go. For that to work, we need any supporting set of practices. We write tests to help us design our interfaces and to act as a safety net when we change things, and we use a version control to store our application source files, allowing us to undo mistakes and to monitor what changes day today. The database schema in a rails application constantly evolves as we progress through the development column we add a table here, rename a column there, and so on the database changes in step with the applications code. With rails, each of those steps is made possible through the use of migration. A migration is simply a Ruby source file in your applications and You can modify column types, renaming columns, changing columns, defining indices, renaming tables, the usage of primary keys, and even using native SQL and always you can rollback their migrations when they go bad. "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}
</script>
<style>
    #lunrsearchresults {padding-top: 0.2rem;}
    .lunrsearchresult {padding-bottom: 1rem;}
    .lunrsearchresult .title {color: #0f4fd9;}
    .lunrsearchresult .url {color: silver;}
    .lunrsearchresult a {display: block; color: #777;}
    .lunrsearchresult a:hover, .lunrsearchresult a:focus {text-decoration: none;}
    .lunrsearchresult a:hover .title {text-decoration: underline;}
</style>


<form onSubmit="return lunr_search(document.getElementById('lunrsearch').value);">
    <p><input type="text" class="form-control" id="lunrsearch" name="q" maxlength="255" value="" placeholder="Search via Lunr.js" /></p>
</form>
<div id="lunrsearchresults">
    <ul></ul>
</div>
  </div>
  <div class='' style='position:relative'>
    
    <div class='only-print'>
      <h2>dom lizarraga</h2>
      <div style='margin-top:0;'>dominiclizarraga@hotmail.com</div>
    </div>
    <nav class='header-wrap'>
      <div class='header nu limiter no-print'>
        <h1 style='line-height:1.6;font-size:1rem;margin:0 0 0.25em 0;'>dom lizarraga</h1>
        <ul style='list-style:none;padding:0;margin:0;'>
          <li style='margin:0.5rem 0;'><a href='/'>Notes</a></li>
          <li style='margin:0.5rem 0;'><a href='/reading/'>Reading</a>⇠</li>
          <li style='margin:0.5rem 0;'><a href='/projects/'>Projects</a></li>
          <li style='margin:0.5rem 0;'><a href='/computer_science/'>Computer <br>Science</a></li>
          <li style='margin:0.5rem 0;'><a href='/confs/'>Confs</a></li>
          <li style='margin:0.5rem 0;'><a href='/about/'>About</a></li>
        </ul>
      </div>
    </nav>
    <div class='limiter content '>
      <div itemscope itemtype="http://schema.org/Review">

<h1 style='font-size: 30px;'>
I read The Minitest Cookbook by Chris Kottom
on <span itemprop="datePublished" datetime="2022-01-05">January 5, 2022</span>
</h1>


<h3 itemprop="reviewRating" itemscope itemtype="http://schema.org/Rating">Review
  <meta itemprop="worstRating" content="1">
  <meta itemprop="ratingValue" content="5">
  <meta itemprop="bestRating" content="5">
  <div
    class='star'
    class='value-title'
    title='5'
    style='margin-left:10px;display:inline-block;background-size:15px 14px;height:14px;width: 75px'></div>
</h3>

<div itemprop="description" class='body'><p>Today though, the separation between development and testing has largely disappeared - at least in the universe that most Ruby and Rails programmers occupy.</p>

<p>In many if not most cases now, the one writing the code is also responsible for producing automated tests that cover the work
done. And while you’re probably sick of hearing it, this is a good thing for all kinds of reasons. Why?</p>

<p>• Tests demonstrate that your code actually works.
• The pattern of thinking needed to write tests for code is very close to
that needed to design it.
• Testing and developing in parallel tends to surface more bugs early in the development process when fixing them is cheap and easy.
• Well-tested code tends to be better designed with reduced coupling and greater cohesion.
• A good test suite acts as a detailed specification.
• Writing tests during development increases programmer engagement and efficiency.
• A test suite with good coverage aids in maintenance, refactoring, and upgrades with reduced risk of breakage and regression.
• It’s faster to write code with tests than without.
• Having automated tests reduces or removes the need for manual testing</p>

<p>Best tests will have a few important characteristics in common:
• Clarity: The name of each test suggests what it’s about at a glance.
• Purpose: The intent and meaning of the test is obvious and unambiguous from the testing logic.
• Eloquence: The test logic is expressed through fluent use of the language and the testing framework.
• Readability: Tests are written and formatted in a way that promotes rapid discovery and comprehension.
• Efficiency: All other things being equal, automated tests should use the minimum possible system resources</p>

<p>Unlike a lot of books on testing, this one won’t dwell on the mechanics of test-driven development. TDD has become so prevalent and popular among the Ruby and Rails development community that you’d be hard pressed to find a book on testing or development that doesn’t take it as a starting point for everything taught. But TDD is primarily about development and only incidentally about testing, and it often treats the tests that fall out of it as a by-product rather than as first-class citizens of your project. That tends to result in test suites that are neglected after they’ve served the purpose of driving out features.</p>

<p>• Fact: The entire framework weighs in at less than 1600 lines of code. RSpec is almost 8 times as large. With a code base that size, the source practically becomes its own documentation.
• Fact: Minitest has been singled out as a very readable project because it’s written in plain Ruby that developers of all experience
levels can dig into and understand.
• Fact: The project has remained small and simple because of conscious decisions to keep it that way in spite of frequent requests
for expanded features.
• Fact: The source code showcases Ruby’s power and elegance with great uses of closures, metaprogramming, concurrent programming, and others.
• Fact: Since the Minitest framework also happens to be tested with Minitest, it includes some exceptional practical examples illustrating good testing technique</p>

<p>To really get comfortable with Minitest’s internals, there are four basic abstractions that you’ll need to understand: plugins, reporters, runnables and the Minitest runner.</p>

<p>Plugins</p>

<p>In Minitest, plugins are modules that extend or modify the behavior of Minitest. They can be used to add new features, customize the test runner, or modify the output of test results. Examples of plugins in Minitest include pride (a colorful test runner), parallel (for parallel test execution), and focus (to run specific tests or test suites).</p>

<p>Minitest plugins are usually packaged as RubyGems which implement a simple framework-defined contract that allows them to be loaded an initialized by the framework. Specifically speaking, every plugin includes a loader file that follows a standard naming convention - ex: minitest/ foo_plugin.rb where foo is the name of the plugin.</p>

<p>minitest-rails is a plugin for Minitest that adds some additional features for working with Ruby on Rails applications. It provides some additional test generators that can create test files for your Rails application’s models, controllers, views, and helpers. It also includes support for testing Rails-specific features like routes and controllers.</p>

<p>In addition to the generators, minitest-rails also provides a Rails-specific test runner that sets up the Rails environment before running the tests. This can be helpful if your tests need to access Rails configuration or other Rails-specific features.</p>

<p>Overall, minitest-rails is a helpful plugin for anyone working with Ruby on Rails applications and using Minitest as their testing framework.</p>

<p>Another example: the minitest/pride plugin adds colorful output to your test results in the terminal.</p>

<p>Reporters</p>

<p>A test suite is a map for directing development effort to the parts of your project that need it. From this perspective, the results reported by your test suite act as its user interface and indicate the state of your code base.</p>

<p>Each test Minitest runs passes a result to a Reporter object which is responsible for acting on it. Depending on the Reporter, it might:
• Display information to the console.
• Store the result for later processing.
• Increment counters or compile statistics.
• Send the result to another system - ex: a CI, a database, etc.</p>

<p>As an abstraction, a Reporter is just an object that implements four methods that allow it to accept and operate on test results:
• #start - called before the first test is run
• #record - accept and process a single test result
• #report - deliver a detailed report after the test run
• #passed? - indicate passed/failed/errored/skipped tests</p>

<div><img src="/../graphics/projects/cook_book_1.png" alt="beginning_rails" style="width:500px;" /></div>

<p>In Minitest, reporters are used to generate output of the test results. They provide various types of outputs such as progress bar, detailed documentation, and colorized output.</p>

<p>Runnables</p>

<p>In Minitest, runners are classes that run a set of tests.</p>

<p>Assert-style tests and Spec-style tests are two different styles of writing tests in Minitest.</p>

<p>Assert-style tests are based on assertions that verify the expected result of a test. They are usually written using methods such as assert, assert_equal, assert_match, etc. The focus is on verifying specific outcomes and behavior of the code being tested.</p>

<p>Spec-style tests are based on specifying the expected behavior of a system or component. They are usually written using describe and it blocks that describe the behavior of the code being tested. The focus is on describing the behavior and intent of the code, rather than just verifying specific outcomes.</p>

<p>Assert-style tests are based on the idea of making assertions about the state of the system under test. These tests usually follow the “Arrange-Act-Assert” pattern, where the test sets up the system’s initial state, performs some action, and then makes one or more assertions about the system’s final state. (This uses instance methods starting with the string “test_”).</p>

<p>Spec-style tests, on the other hand, are based on the idea of describing the behavior of the system under test using a domain-specific language (DSL). In these tests, the focus is on describing what the system should do rather than how it should do it. Spec-style tests often use “describe” and “it” blocks to structure the test code.</p>

<p>Both styles of testing have their pros and cons, and the choice of which one to use often comes down to personal preference and the requirements of the project. Some developers prefer the clarity and simplicity of Assert-style tests, while others find the expressiveness and readability of Spec-style tests to be more appealing. Ultimately, the most important thing is to choose a style that works for you and your team and allows you to write effective, maintainable tests.</p>

<p>The Minitest Runner</p>

<p>The Minitest Runner is the component responsible for running Minitest test suites. It loads the test files, executes the tests, and reports the results. By default, Minitest uses the Minitest::Runnable and Minitest::Test classes to define and run tests, respectively. However, the runner can be customized to use other classes or to change the way the tests are run. The runner is a key part of Minitest’s flexibility and extensibility.</p>

<p>The runner and Runnables fit together like the layers of an onion where each layer represents a Ruby block or method. The inner layers represent the Runnables where the tests are actually executed, and the outer layers represent the runner - the code that gives the onion its shape.</p>

<p>Minitest.run
Next, Minitest sets up the environment for the test run along with all the necessary supporting objects. All the framework’s major responsibilities are handled right here as it:
• Parses the command line arguments.
• Loads and initializes all detected Minitest plugins.
• Instantiates and runs the reporters.
• Runs tests by passing control on to the next layer.
• Ensures that parallel worker threads are shut down gracefully.</p>

<hr />
<p>Basic Recipes</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Problem</span><span class="p">:</span>
<span class="k">class</span> <span class="nc">FizzBuzz</span>
	<span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="n">number</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">number</span> <span class="o">%</span> <span class="mi">15</span> <span class="o">==</span> <span class="mi">0</span>
			<span class="s2">"FizzBuzz"</span>
		<span class="k">elsif</span> <span class="n">number</span> <span class="o">%</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span>
			<span class="s2">"Buzz"</span>
		<span class="k">elsif</span> <span class="n">number</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span>
			<span class="s2">"Fizz"</span>
		<span class="k">else</span>
		<span class="n">number</span><span class="p">.</span><span class="nf">to_s</span>
		<span class="k">end</span>
	<span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Takeaways
You need four things to develop a Ruby project with Minitest:
• Install Minitest as a project dependency with Bundler.
• Create a test directory at test/ .
• Create a test helper to include all global configuration and customization at test/test_helper.rb .
• Create a new Rakefile or update the existing one with a Rake::TestTask configured to suit your needs (by convention to run tests you use the command <code class="language-plaintext highlighter-rouge">rake</code>)</p>

<hr />
<p>Writing Tests</p>

<p>All the tests that we write follow the same basic four-phase structure.
	1. Setup the inputs and data objects prior to running the test.
	2. Exercise the logic under test.
	3. Verify that the tested code produces the expected results.
	4. Teardown or reset application state before running the next test.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'test_helper'</span>
<span class="nb">require</span> <span class="s1">'fizz_buzz'</span>

<span class="k">class</span> <span class="nc">FizzBuzzTest</span> <span class="o">&lt;</span> <span class="no">Minitest</span><span class="o">::</span><span class="no">Test</span>
	<span class="k">def</span> <span class="nf">setup</span> 
		<span class="vi">@fb</span> <span class="o">=</span> <span class="no">FizzBuzz</span><span class="p">.</span><span class="nf">new</span>
	<span class="k">end</span>
	<span class="k">def</span> <span class="nf">test_converts_multiples_of_fifteen_to_fizzbuzz</span>
		<span class="c1"># fb = FizzBuzz.new</span>
		<span class="n">assert_equal</span> <span class="s1">'FizzBuzz'</span><span class="p">,</span> <span class="vi">@fb</span><span class="p">.</span><span class="nf">convert</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>
		<span class="n">assert_equal</span> <span class="s1">'FizzBuzz'</span><span class="p">,</span> <span class="vi">@fb</span><span class="p">.</span><span class="nf">convert</span><span class="p">(</span><span class="mi">45</span><span class="p">)</span>
		<span class="n">assert_equal</span> <span class="s1">'FizzBuzz'</span><span class="p">,</span> <span class="vi">@fb</span><span class="p">.</span><span class="nf">convert</span><span class="p">(</span><span class="mi">90</span><span class="p">)</span>
		<span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">90</span><span class="p">].</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span>
			<span class="n">assert_equal</span> <span class="s1">'FizzBuzz'</span><span class="p">,</span> <span class="vi">@fb</span><span class="p">.</span><span class="nf">convert</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
		<span class="k">end</span>
	<span class="k">end</span>
	<span class="k">def</span> <span class="nf">test_converts_multiples_of_five_to_buzz</span>
		<span class="c1"># fb = FizzBuzz.new</span>
		<span class="n">assert_equal</span> <span class="s1">'Buzz'</span><span class="p">,</span> <span class="vi">@fb</span><span class="p">.</span><span class="nf">convert</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
		<span class="n">assert_equal</span> <span class="s1">'Buzz'</span><span class="p">,</span> <span class="vi">@fb</span><span class="p">.</span><span class="nf">convert</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
		<span class="n">assert_equal</span> <span class="s1">'Buzz'</span><span class="p">,</span> <span class="mi">2</span><span class="n">fb</span><span class="p">.</span><span class="nf">convert</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
	<span class="k">end</span>
	<span class="k">def</span> <span class="nf">test_converts_multiples_of_three_to_fizz</span>
		<span class="c1"># fb = FizzBuzz.new</span>
		<span class="n">assert_equal</span> <span class="s1">'Fizz'</span><span class="p">,</span> <span class="vi">@fb</span><span class="p">.</span><span class="nf">convert</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
		<span class="n">assert_equal</span> <span class="s1">'Fizz'</span><span class="p">,</span> <span class="vi">@fb</span><span class="p">.</span><span class="nf">convert</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
		<span class="n">assert_equal</span> <span class="s1">'Fizz'</span><span class="p">,</span> <span class="vi">@fb</span><span class="p">.</span><span class="nf">convert</span><span class="p">(</span><span class="mi">48</span><span class="p">)</span>
		<span class="c1"># another example could have been assert 'Fizz' == fb.convert(3)</span>
	<span class="k">end</span>
	<span class="k">def</span> <span class="nf">test_returns_same_number_for_other_numbers</span>
		<span class="n">assert_equal</span> <span class="s1">'1'</span><span class="p">,</span> <span class="vi">@fb</span><span class="p">.</span><span class="nf">convert</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">assert_equal</span> <span class="s1">'101'</span><span class="p">,</span> <span class="vi">@fb</span><span class="p">.</span><span class="nf">convert</span><span class="p">(</span><span class="mi">101</span><span class="p">)</span>
		<span class="n">assert_equal</span> <span class="s1">'2014'</span><span class="p">,</span> <span class="vi">@fb</span><span class="p">.</span><span class="nf">convert</span><span class="p">(</span><span class="mi">2014</span><span class="p">)</span>
	<span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>
<div><img src="/../graphics/projects/cook_book_2.png" alt="beginning_rails" style="width:500px;" /></div>

<div><img src="/../graphics/projects/cook_book_3.png" alt="beginning_rails" style="width:500px;" /></div>

<p>Another example of syntaxis:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ArticleTest</span> <span class="o">&lt;</span> <span class="no">ActiveSupport</span><span class="o">::</span><span class="no">TestCase</span>
	<span class="nb">test</span> <span class="s2">"should not save article without title"</span> <span class="k">do</span>
		<span class="n">article</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">new</span>
		<span class="n">assert_not</span> <span class="n">article</span><span class="p">.</span><span class="nf">save</span>
	<span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>
<div><img src="/../graphics/projects/cook_book_4.png" alt="beginning_rails" style="width:500px;" /></div>

<p>That’s why many developers follow a strict one assertion per test policy - so that each assertion has exactly one chance to succeed or fail. It’s true that your tests will be better and more maintainable when each test verifies a single behavior of the system, but writing a single test for each of the assertions above seems like overkill to me since they’re all testing the same general behavior.</p>

<p>setup runs before each test.
teardown runs after each test.</p>

<p>It’s better to favor readability over DRY-ness when writing tests.</p>

<p>Usage of skip</p>

<p>Skip can be useful in situations where you want to write a test that specs out some future work that you’re not
quite ready to code just yet. For example, FizzBuzzTest doesn’t currently check to see what happens when we pass it an  unexpected input.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">test_raises_argument_error_for_bad_argument</span>
	<span class="n">skip</span> <span class="s1">'not yet implemented'</span>
	<span class="n">assert_raises</span><span class="p">(</span><span class="no">ArgumentError</span><span class="p">)</span> <span class="p">{</span> <span class="vi">@fb</span><span class="p">.</span><span class="nf">convert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">}</span>
	<span class="n">assert_raises</span><span class="p">(</span><span class="no">ArgumentError</span><span class="p">)</span> <span class="p">{</span> <span class="vi">@fb</span><span class="p">.</span><span class="nf">convert</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">}</span>
	<span class="n">assert_raises</span><span class="p">(</span><span class="no">ArgumentError</span><span class="p">)</span> <span class="p">{</span> <span class="vi">@fb</span><span class="p">.</span><span class="nf">convert</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">}</span>
	<span class="n">assert_raises</span><span class="p">(</span><span class="no">ArgumentError</span><span class="p">)</span> <span class="p">{</span> <span class="vi">@fb</span><span class="p">.</span><span class="nf">convert</span><span class="p">(</span><span class="s1">'foo'</span><span class="p">)</span> <span class="p">}</span>
	<span class="n">assert_raises</span><span class="p">(</span><span class="no">ArgumentError</span><span class="p">)</span> <span class="p">{</span> <span class="vi">@fb</span><span class="p">.</span><span class="nf">convert</span><span class="p">(</span><span class="kp">nil</span><span class="p">)</span> <span class="p">}</span>
<span class="k">end</span>

</code></pre></div></div>

<p>Takeaways
	• Assert-style test cases are classes that inherit from Minitest::Test.
	• Public instance methods of those classes whose names begin with test_ are treated as tests by the runner.
	• Minitest provides a small set of assertions out of the box, and of those, about half are used frequently.
	• Override the setup and teardown methods to include code that should be executed before or, respectively, after each test is
	executed.
	• If you have to choose between readability and DRY-ness in your tests, you should almost always choose readability.</p>

<p>Writing Specs</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FizzBuzzIterator</span>
	<span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="vi">@counter</span> <span class="o">=</span> <span class="n">start</span>
		<span class="vi">@fb</span> <span class="o">=</span> <span class="no">FizzBuzz</span><span class="p">.</span><span class="nf">new</span>
	<span class="k">end</span>
	<span class="k">def</span> <span class="nf">next</span>
		<span class="n">input</span> <span class="o">=</span> <span class="vi">@counter</span>
		<span class="vi">@counter</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="vi">@fb</span><span class="p">.</span><span class="nf">convert</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
	<span class="k">end</span>
<span class="k">end</span>

</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'test_helper'</span>
<span class="nb">require</span> <span class="s1">'fizz_buzz_iterator'</span>

<span class="n">describe</span> <span class="no">FizzBuzzIterator</span> <span class="k">do</span>
	<span class="n">it</span> <span class="s1">'outputs sequential FizzBuzz values starting from 1 when initialized without a starting value'</span> <span class="k">do</span>
		<span class="n">iterator</span> <span class="o">=</span> <span class="no">FizzBuzzIterator</span><span class="p">.</span><span class="nf">new</span>
		
		<span class="n">expect</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'1'</span>
		<span class="n">expect</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'2'</span>
		<span class="n">expect</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'Fizz'</span>
		<span class="n">expect</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'4'</span>
		<span class="n">expect</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'Buzz'</span>
		<span class="n">expect</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'Fizz'</span>
	<span class="k">end</span>
	<span class="n">it</span> <span class="s1">'outputs sequential FizzBuzz values starting from the starting value when initialized with a starting value'</span> <span class="k">do</span>
		<span class="n">iterator</span> <span class="o">=</span> <span class="no">FizzBuzzIterator</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
		
		<span class="n">expect</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'Buzz'</span>
		<span class="n">expect</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'11'</span>
		<span class="n">expect</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'Fizz'</span>
		<span class="n">expect</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'13'</span>
		<span class="n">expect</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'14'</span>
		<span class="n">expect</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'FizzBuzz'</span>
	<span class="k">end</span>
<span class="k">end</span>

<span class="c1"># Other alternatives</span>

<span class="n">expect</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'Fizz'</span>
<span class="n">value</span><span class="p">(</span><span class="n">iteratory</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'11'</span>
<span class="n">_</span><span class="p">(</span><span class="n">iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'Buzz'</span>

</code></pre></div></div>
<p>Assertion vs Expectation</p>

<div><img src="/../graphics/projects/cook_book_5.png" alt="beginning_rails" style="width:500px;" /></div>

<div><img src="/../graphics/projects/cook_book_6.png" alt="beginning_rails" style="width:500px;" /></div>

<div><img src="/../graphics/projects/cook_book_7.png" alt="beginning_rails" style="width:500px;" /></div>

<p>Like most powerful tools, this one can be abused. As a general rule, try to limit describe block nesting to at most two or three layers deep. More than that and the specs hard to follow and less readable for future developers (including future you).</p>

<p>Before and After for Spec-Style</p>

<p>before blocks for all enclosing scopes will be called before the test logic in order from outermost to innermost.</p>

<p>after blocks for all enclosing scopes will be called after the test logic in order from innermost to outermost.</p>

<p>In practical terms, this lets us define blocks with increasingly specific setup and teardown logic that cascade or override previous operations</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'test_helper'</span>
<span class="nb">require</span> <span class="s1">'fizz_buzz_iterator'</span>

<span class="n">describe</span> <span class="no">FizzBuzzIterator</span> <span class="k">do</span>
	<span class="n">before</span> <span class="k">do</span>
		<span class="vi">@iterator</span> <span class="o">=</span> <span class="no">FizzBuzzIterator</span><span class="p">.</span><span class="nf">new</span>
	<span class="k">end</span>
	
	<span class="n">it</span> <span class="s1">'outputs sequential FizzBuzz values starting from 1'</span> <span class="k">do</span>
		<span class="n">expect</span><span class="p">(</span><span class="vi">@iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'1'</span>
		<span class="n">expect</span><span class="p">(</span><span class="vi">@iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'2'</span>
		<span class="n">expect</span><span class="p">(</span><span class="vi">@iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'Fizz'</span>
		<span class="n">expect</span><span class="p">(</span><span class="vi">@iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'4'</span>
		<span class="n">expect</span><span class="p">(</span><span class="vi">@iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'Buzz'</span>
		<span class="n">expect</span><span class="p">(</span><span class="vi">@iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'Fizz'</span>
	<span class="k">end</span>
	
	<span class="n">describe</span> <span class="s1">'when initialized with a starting value'</span> <span class="k">do</span>
		<span class="n">before</span> <span class="k">do</span>
			<span class="vi">@iterator</span> <span class="o">=</span> <span class="no">FizzBuzzIterator</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
		<span class="k">end</span>
		<span class="n">it</span> <span class="s1">'outputs sequential FizzBuzz values starting from the starting value'</span> <span class="k">do</span>
			<span class="n">expect</span><span class="p">(</span><span class="vi">@iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'Buzz'</span>
			<span class="n">expect</span><span class="p">(</span><span class="vi">@iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'11'</span>
			<span class="n">expect</span><span class="p">(</span><span class="vi">@iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'Fizz'</span>
			<span class="n">expect</span><span class="p">(</span><span class="vi">@iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'13'</span>
			<span class="n">expect</span><span class="p">(</span><span class="vi">@iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'14'</span>
			<span class="n">expect</span><span class="p">(</span><span class="vi">@iterator</span><span class="p">.</span><span class="nf">next</span><span class="p">).</span><span class="nf">must_equal</span> <span class="s1">'FizzBuzz'</span>
		<span class="k">end</span>
	<span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>The let function provides an alternate and some would say more elegant way of setting up testing state with a more declarative syntax.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">describe</span> <span class="no">FizzBuzzIterator</span> <span class="k">do</span>
	<span class="n">let</span><span class="p">(</span><span class="ss">:iterator</span><span class="p">)</span> <span class="p">{</span> <span class="no">FizzBuzzIterator</span><span class="p">.</span><span class="nf">new</span> <span class="p">}</span>
	<span class="c1"># ...</span>
<span class="k">end</span>

<span class="n">describe</span> <span class="no">FizzBuzzIterator</span> <span class="k">do</span>
	<span class="n">let</span><span class="p">(</span><span class="ss">:iterator</span><span class="p">)</span> <span class="p">{</span> <span class="no">FizzBuzzIterator</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="p">}</span>
	<span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Each call to let dynamically defines a new method with the specified name that executes the block argument upon the first invocation and caches the result for later access - in other words, a lazy initializer.</p>

<p>Takeaways</p>

<p>• Create a new test case in Minitest::Spec using a top-level describe block with a String or Class argument.</p>

<p>• Define a test using an it block with a descriptive String passed as a parameter.</p>

<p>• Make assertions on the values of expressions by wrapping them in a Minitest::Expectation object using expect or one of its aliases.</p>

<p>• Use nested describe blocks to define scopes within a test case as a way of grouping related tests.</p>

<p>• Implement before and after blocks for shared setup and teardown logic specific to a block context.</p>

<h2 id="-create-named-lazy-initializers-using-let-blocks">• Create named lazy initializers using let blocks.</h2>

<p>Configure Pre-Test State</p>

<p>As explained back in Writing Tests, each test run under Minitest follows a common progression of steps: Setup, Exercise, Verify, and Teardown. Of these, Setup usually accounts for more lines of code and can be the toughest for new developers to understand. There are several options for setting the state, and knowing which one is the best fit requires familiarity with all of them.</p>

<p>Method 1: Set up the same state before each test.</p>

<div><img src="/../graphics/projects/cook_book_8.png" alt="beginning_rails" style="width:500px;" /></div>

<p>Method 2: Configure different state before each test.</p>

<div><img src="/../graphics/projects/cook_book_9.png" alt="beginning_rails" style="width:500px;" /></div>

<p>Method 3: Using a memoized helper method.</p>

<div><img src="/../graphics/projects/cook_book_10.png" alt="beginning_rails" style="width:500px;" /></div>

<p>Method 4: Create data objects within the test.</p>

<div><img src="/../graphics/projects/cook_book_11.png" alt="beginning_rails" style="width:500px;" /></div>

<p>Collections</p>

<p>Enumerable types where order doesn’t matter like Hash and Set count two instances as being equal if they contain the same elements regardless of the order in which the elements were added or passed during initialization.</p>

<div><img src="/../graphics/projects/cook_book_12.png" alt="beginning_rails" style="width:500px;" /></div>

<p>Relations (active record)</p>

<p>Just as with Arrays though, order matters, so you’ll need to ensure that both the actual and the expected values are sorted the same way when performing comparisons.</p>

<div><img src="/../graphics/projects/cook_book_13.png" alt="beginning_rails" style="width:500px;" /></div>

<p>ActiveRecord::Relation objects compare mostly like Arrays except when compared with others of the same type, and then according to the SQL representation.</p>

<div><img src="/../graphics/projects/cook_book_14.png" alt="beginning_rails" style="width:500px;" /></div>

<p>Dates and Times</p>

<div><img src="/../graphics/projects/cook_book_16.png" alt="beginning_rails" style="width:500px;" /></div>

<p>Intermediate Recipes</p>

<p>Mocks:  mocks test the behavior of an object toward the objects to which it sends messages.</p>

<p>Use mocks sparingly and only after careful consideration. The more collaborators you mock, the greater your risk of false positives.</p>

<p>• Only mock what you own. If you don’t own it, the API could change, and you’d never detect it in your tests.
• Only mock immediate collaborators and avoid deep mocking (mocks returning mocks returning mocks).
• Ideally, only use mocks to solve specific difficult problems like:
◦ Connecting to unreliable or uncontrollable external resources
◦ Real object performance is prohibitively slow
◦ Expensive setup and/or configuration
◦ Avoiding other undesirable side effects</p>

<p>Stubs
Stubs provide the context needed to fully exercise an object through a given test scenario</p>

<p>• Use stubs wherever and whenever they’re needed, but recognize that needing too many is probably a code smell.
• Don’t use stubs where they’re not needed, and apply them as narrowly as possible where you do use them. (See Mocha’s stub_everything and any_instance.stub as prime examples of mocking framework features promoting bad coding practices.)
• Never ever, ever stub the object under test. More often than not, you’ll end up testing the stub and not the object itself.</p>

<p>Fake Objects</p>

<p>A fake is an alternate version of a given class intended for testing only. It exposes an interface resembling that of the real thing it replaces but with an implementation that’s either simplified or hollowed out which allows
them to:
• Capture and verify interactions between the object under test and the fake object (like a mock).
• Maintain consistent interactions between the object under test and the fake object (like a stub).
• Avoid resource-intensive or otherwise undesirable processing (like both mocks and stubs).</p>

<p>We could have gotten the same result using mocking or stubbing, but it might have taken many more lines of setup code. A fake can be a great fit when dealing with complex APIs since it comes ready-made and pre-programmed with the behavior we want and need for running our tests.</p>

<p>Testing Mixin Behavior</p>

<p>Testing something that can’t be instantiated on its own confuses many developers.</p>

<p>two types of mixins:</p>

<p>Those that are coupled with the classes that include them, and those that aren’t (non-coupled modules)</p>

<p>Takeaways</p>

<p>• Use Object#extend to patch a mixin’s method into a simple Object for easy testing.
• Try mixing into a Ruby Struct in cases where you need the including class to have some specific attributes or behavior of its own.</p>

<p>Sharing Code Between Tests</p>

<p>One point that should be clear to you by now is this: a self-contained test is a readable test. Minitest provides a nice, narrow vocabulary for writing tests, and when we stick to that vocabulary, life becomes better for the developers that follow.</p>

<p>When it comes to organizing tests:
• Extracting code into a new helper methods
• Extracting helper methods into a new module
• Extracting tests into a new module</p>

<p>Extracting helper methods by:
• Using descriptive names for helper methods and variable arguments
• Updating the extracted code to ensure that it’s still comprehensible, even outside the previous context</p>

<p>Takeaways</p>

<p>• Code shared within a single test case can be extracted to a private helper method in the same class.
• Code shared across multiple test cases can be extracted to a module that may be included in all.
	◦ Sharing tests between test cases is a special case of this</p>

<p>Managing Test Data</p>

<p>• Whenever persistence isn’t important to your test, use Object.new to create a new instance.
• Rails fixtures have a lot going for them including great performance and a reliable set of known models for your tests.
• Use both functional and memorable names for your fixtures.
• Configure your fixtures carefully, and try to cover at least:
◦ One minimal valid configuration
◦ One or two realistic models
◦ Other well-defined object states
• Use advanced ERB and YAML features to define fixtures dynamically.</p>

<p>Testing Active Record Models</p>

<p>Active Record maps the application database to Ruby objects that manage attributes, relationships, queries, and lifecycle methods among other things.</p>

<p>• Test public methods, not private ones.
• Test interfaces, not implementations.
• Don’t test Active Record (or the rest of Rails, for that matter).
• You need to test some of the typical aspects of Active Record models:
	◦ Complex validations
	◦ Scopes
	◦ Callback targets and hooks
• Make assertions about the results and side effects of public instance methods.
• Make (selective) assertions an object’s behavior toward collaborators.</p>

<p>Testing Controllers</p>

<p>There’s been a faction of the Rails community that has become vocal about skipping controller testing completely. They usually argue that simulating more realistic user interactions eliminates the need for more focused controller tests which tend to be very repetitive and dull to write anyway. Even the core team has started a gradual move away from controller testing.</p>

<p>◦ Controller tests should include assertions for the visible side effects that controller actions produce including:
	◦ HTTP response code
	◦ Redirect location
	◦ System state changes (models created, updated, or destroyed)
	◦ Flash variables, session variables, and cookies set or changed
• You should write tests for complex or generated routes.
• Controllers should specifically not make assertions about any of the following:
	◦ Rendered templates
	◦ Instance variables passed to the view</p>
</div>


<div class='breaker'></div>

<h3>Details</h3>
<ul itemprop="itemReviewed" itemscope itemtype="http://schema.org/Book">
  <li><span itemprop=name>The Minitest Cookbook</span> by <span itemprop=author>Chris Kottom</span></li>

  
  

  <li>Published: <span itemprop=datePublished>2012</span></li>
  
</ul>

  <div itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="dominiclizarraga.github.io">
    <meta itemprop="url" content="http://localhost:4000">
  </div>
  <meta itemprop="author" content="dom lizarraga">
  <meta itemprop="url" content="http://localhost:4000/2022/01/05/minitest_cookbook.html">

</div>

<div class="mobile-only-button">
  <script type="text/javascript" src="https://cdnjs.buymeacoffee.com/1.0.0/button.prod.min.js" data-name="bmc-button" data-slug="domlizarrraga" data-color="#5F7FFF" data-emoji="🍕" data-font="Comic" data-text="Buy me a pizza" data-outline-color="#000000" data-font-color="#ffffff" data-coffee-color="#FFDD00" ></script>
</div>

<script src="https://giscus.app/client.js"
        data-repo="dominiclizarraga/dominiclizarraga.github.io"
        data-repo-id="R_kgDOJ601Dg"
        data-category="General"
        data-category-id="DIC_kwDOJ601Ds4CliRX"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
</script>

    </div>
  </div>
</body>
</html>
