<!doctype html>
<html lang=en>
<head>
  <meta charset=utf-8>
  <meta name=author content='dom lizarraga' />
  <meta name='theme-color' content='#fff' />
  <meta name='twitter:title' content="" />
  <meta name=description content="Dom Lizarraga" />
  <meta name='twitter:description' content="Dom Lizarraga" />
  <meta name='og:description' content="Dom Lizarraga" />
  
  <meta name=viewport content='width=device-width,minimum-scale=1'>
  <meta property='og:site_name' content="dominiclizarraga.github.io"/>
  <meta property='og:email' content="dominiclizarraga@hotmail.com"/>
  <meta property='og:type' content=blog content="domlizarrraga" />
  <meta property='twitter:account_id' content=domlizarraga_ />
  
  
  <script type='application/ld+json'>{"@context": "http://schema.org","@type": "CreativeWork","author": "dom lizarraga"}</script>
  
    <link rel=alternate type='application/rss+xml' title="dominiclizarraga.github.io" href="http://localhost:4000/rss.xml" />
    <link rel=alternate type='application/atom+xml' title="dominiclizarraga.github.io" href="http://localhost:4000/atom.xml" />
  
  <link rel=icon type=image/x-icon href=/css/favicon.png />
  <style>:root {
  --mono-font: San Francisco Mono, Monaco, "Consolas", "Lucida Console",
    "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace;
  --sans-font: -apple-system, BlinkMacSystemFont, "avenir next", avenir,
    helvetica, "helvetica neue", ubuntu, roboto, noto, "segoe ui", arial,
    sans-serif;
}

.star {
  width: 13px;
  height: 12px;
  display: inline-block;
  background: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTMiIGhlaWdodD0iMTIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTYuMzA5IDkuMjJMMi40MDkgMTJsMS40NC00LjU2N0wwIDQuNTgzbDQuNzg4LS4wNDJMNi4zMDggMCA3LjgzIDQuNTRsNC43ODkuMDQ0LTMuODUgMi44NDlMMTAuMjA5IDEyeiIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9zdmc+");
}

body {
  color: #111;
  margin: 0px auto;
  -webkit-font-smoothing: antialiased;
  text-rendering: optimizeLegibility;
  line-height: 1.6;
  font-size: 1rem;
  font-family: var(--sans-font);
  background-color: #f8f5d5;
}

/* Print tweaks ------------------------------------------------------------- */
.only-print {
  display: none;
}

.notitle .body p:first-child {
  margin-top: 0.25rem;
}

.body img {
  width: 100%;
  max-width: 640px;
}

/* Element styles ----------------------------------------------------------- */
sup,
sub {
  vertical-align: baseline;
  position: relative;
  top: -0.4em;
}

sub {
  top: 0.4em;
}

a {
  color: #000;
  text-decoration-skip-ink: auto;
  text-decoration: underline;
}

a:visited {
  color: #333;
}

ol,
ul {
  margin: 1rem 0;
}

ul ul {
  margin: 0;
}

ol li ul {
  margin: 5px 10px;
}

iframe {
  border: 0;
}

small,
.small {
  font-size: 14px;
}

br {
  line-height: 1em;
}

h1 a {
  color: #111;
}

em {
  font-style: italic;
}

h1 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 32px;
  letter-spacing: 0.004em;
}

h2 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 1.5rem;
  letter-spacing: 0.009em;
}

h3 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 1.25rem;
  letter-spacing: 0.009em;
}

h4 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 1rem;
}

h5 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 0.875rem;
}

p {
  margin: 1rem 0;
}

blockquote {
  font-size: 16px;
  line-height: 25px;
}

td {
  vertical-align: top;
}

hr {
  background: #000;
  height: 1px;
  border: 0;
}

summary {
  cursor: pointer;
}

.body table {
  border-collapse: collapse;
  border-spacing: 0;
  width: 100%;
}

.body th {
  text-align: left;
}

.body td,
.body th {
  padding: 0.5rem;
}

.body td {
  border: 1px solid #cfcfcf;
}

.limiter {
  max-width: 640px;
  padding-left: 20px;
  padding-right: 20px;
  margin-left: auto;
  margin-right: auto;
}

/* Padding --------------------------------------- */
.pad2y {
  padding-top: 20px;
  padding-bottom: 20px;
}

span.image-credit {
  float: right;
  margin: 0 0 10px 10px;
  font-size: 12px;
}

span.image-credit:before {
  content: "↑";
  margin-right: 5px;
}

figcaption {
  font-size: 11px;
  text-align: center;
  font-size: 0.8rem;
  margin-top: -1.2rem;
}

div.post blockquote p {
  margin: 0;
}

/** Writing ----------------------------------------------------------------- */
.writing,
.books {
  display: grid;
  grid-column-gap: 5px;
  grid-row-gap: 5px;
}

.writing {
  grid-template-columns: 1fr min-content;
}

.books {
  grid-template-columns: 1fr 0.75fr min-content 70px;
}

.writing a,
.books a {
  font-weight: 500;
  letter-spacing: -0.015em;
}

.writing > div,
.books > div {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.writing time,
.books time {
  padding-right: 0.25em;
  color: #333;
  font-variant-numeric: tabular-nums;
  letter-spacing: -0.012em;
  white-space: pre;
}

.project-box {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-gap: 30px;
}

.project-box a.project {
  text-decoration: none;
  color: #666;
}
.project-box a.project:hover {
  color: #000;
}
.project-box a.project img {
  display: block;
  margin-bottom: 10px;
  border-radius: 0.375rem;
  height: 160px;
  object-fit: cover;
}

/** Responsive -------------------------------------------------------------- */

/* Screen width:  0px -------- 480px -------- 640px -------- 1024px -------- ∞ */
/* max-width: 480px:  |←――――――| */
/* max-width: 640px:  |←―――――――――――――| */
/* min-width: 640px:                    |――――――――――――――――――――――――――――→| */
/* max-width: 1024px: |←――――――――――――――――――――――――――| */

@media screen and (max-width: 480px) {
  .project-box {
    grid-template-columns: repeat(1, 1fr);
  }
}

@media screen and (max-width: 640px) {
  .limiter {
    width: auto;
  }
  .project-box {
    grid-template-columns: repeat(2, 1fr);
  }
  .writing,
  .books {
    grid-template-columns: 1fr;
    grid-row-gap: 0px;
  }

  .writing div,
  .books div {
    white-space: normal;
  }

  .writing time,
  .books div:nth-child(4n) {
    padding-bottom: 20px;
  }
}

@media screen and (min-width: 640px) {
  .nu a {
    text-decoration: none;
  }

  .nu a:hover {
    text-decoration: underline;
  }
}

@media screen and (max-width: 1024px) {
  .header-wrap {
    border-bottom: 1px solid #000;
    padding-bottom: 10px;
  }

  .sigil {
    display: none;
  }
  /* this css if for containing search result in mobile */
  #lunrsearchresults {
    width: 350px !important;
    overflow-x: hidden;
  }

  .about-image{
    margin-top: 5px;
  }

  .project-box {
    margin-top: 5px;
    margin-bottom: 20px;
  }
}

@media screen and (min-width: 1025px) {
  .header {
    position: absolute;
    /* top: 40px; */
    right: 50%;
    margin-right: 340px !important;
    letter-spacing: -0.009em;
  }
  .content h1:first-child {
    margin-top: 0;
  }
}

@media print {
  .no-print {
    display: none;
  }
  .only-print {
    display: block;
  }
  body {
    margin: 0;
  }
  .limiter {
    max-width: 100% !important;
    margin: 0 !important;
    padding: 0 !important;
  }
}

/** Code highlighting ------------------------------------------------------- */
p code,
pre code,
li code,
g.highlight,
.code {
  font-family: var(--mono-font);
}

p code {
  font-size: 90%;
}

pre code {
  font-size: 0.8rem;
  line-height: 1.5;
}

.highlight,
blockquote {
  overflow-x: auto;
  padding: 10px 20px;
  margin: 0;
  background: #fff;
  border-radius: 10px;
}

blockquote {
  font-style: italic;
}

blockquote p:first-child {
  margin-top: 0;
}

blockquote p:last-child {
  margin-bottom: 0;
}

/* pygments theme. does not support generics. .highlight class omitted */
.highlight {
  margin: 10px 0;
}

.highlight .hll {
  background-color: #ffffcc;
}

.c, /* Comment */
.cm, /* Comment.Multiline */
.cp, /* Comment.Preproc */
.cs, /* Comment.Special */
.c1 {
  color: #999988;
} /* Comment.Single */

.o, /* Operator */
.ow, /* Operator.Word */
.ge {
  color: #000000;
} /* Generic.Emph */

.kc, /* Keyword.Constant */
.kd, /* Keyword.Declaration */
.kn, /* Keyword.Namespace */
.kp, /* Keyword.Pseudo */
.kr, /* Keyword.Reserved */
.kt {
  color: #445588;
} /* Keyword.Type */

.err {
  color: #a61717;
} /* Error */

.m {
  color: #007f7f;
} /* Literal.Number */
.s {
  color: #d01040;
} /* Literal.String */

.na, /* Name.Attribute */
.nb, /* Name.Builtin */
.nc, /* Name.Class */
.no, /* Name.Constant */
.nd, /* Name.Decorator */
.ni, /* Name.Entity */
.ne, /* Name.Exception */
.nf, /* Name.Function */
.nn, /* Name.Namespace */
.nt, /* Name.Tag */
.nl {
  color: #990000;
} /* Name.Label */

.k, /* Keyword */
.nv {
  color: #008080;
} /* Name.Variable */

.mf, /* Literal.Number.Float */
.mh, /* Literal.Number.Hex */
.mi, /* Literal.Number.Integer */
.mo {
  color: #009999;
} /* Literal.Number.Oct */

.sb, /* Literal.String.Backtick */
.sc, /* Literal.String.Char */
.sd, /* Literal.String.Doc */
.s2, /* Literal.String.Double */
.se, /* Literal.String.Escape */
.sh, /* Literal.String.Heredoc */
.s1, /* Literal.String.Single */
.si, /* Literal.String.Interpol */
.ss, /* Literal.String.Symbol */
.bp, /* Name.Builtin.Pseudo */
.sx {
  color: #d01040;
} /* Literal.String.Other */

.sr, /* Literal.String.Regex */
.vc, /* Name.Variable.Class */
.vg, /* Name.Variable.Global */
.vi, /* Name.Variable.Instance */
.il {
  color: #009999;
} /* Literal.Number.Integer.Long */

/** Code for buy me a coffe mobile version ------------------------------------------------------- */

.mobile-only-button {
  margin-top: 30px;
  display: none;
}

@media screen and (max-width: 480px) {
  .mobile-only-button {
    display: flex;
    justify-content: center;
    align-items: center;
    margin-bottom: 50px;
  }
  
  /* Style for the generated iframe */
  .mobile-only-button iframe {
    margin: 0 auto;
  }
}

/** Code for styling reading time ------------------------------------------------------- */

.reading-time {
  color: #475569;
  text-align: right;
  font-style: italic;
}

/** Code for footer + RSS svg ------------------------------------------------------- */

.personal-elements-container, a[rel="nofollow"], .rss-text {
  color:rgb(71, 95, 105);
  font-style: italic;
  display: flex;
  /* align-items: center; */
  flex-direction: column;
  gap: 10px;
}

.rss-link {
  display: flex;
  align-items: flex-end;
}

/** Code for search bar ------------------------------------------------------- */

.search-bar-desktop {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
}

.search-input-container {
  max-width: 600px;
  margin-top: 10px;
  margin-right: 40px;
}

.search-input {
  border: 1px solid rgb(133, 134, 133);
  padding: 0.75rem;
  background-color: #ffffff;
  width: 100%;
  border-radius: 0.375rem;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
  transition: border-color 0.2s, box-shadow 0.2s;
  height: 10px;
  margin-left: 10px;
  font-size: 0.875rem;
}

.search-input:focus {
  border-color: #3b82f6;
  outline: none;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
}

/** Code for search bar RESULTS ------------------------------------------------------- */

#lunrsearchresults {
  padding-top: 0.2rem;
  width: 100%;
}

.limiter > #lunrsearchresults {
  margin-top: 1rem;
  margin-left: -20px !important;
}

.limiter #lunrsearchresults ul {
  padding-left: 0;
  list-style: none;
}

.lunrsearchresult {
  /* padding-bottom: 1rem; */
  margin-bottom: 1rem;
}

.lunrsearchresult a:hover .title {
  text-underline-offset: 3px;
}

strong {
  margin-bottom:1rem;
  display:block;
}

/** CSS style for authors quotes in 99 bottles book notes ------------------------------------------------------- */

.quote-box {
  margin: 20px auto;
  padding: 8px 10px;
  max-width: 600px;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  background-color: #f9f9f9;
  text-align: center;
  font-size: 14px;
}</style>
  <title>dominiclizarraga.github.io</title>
  <link href='https://twitter.com/domlizarraga_' rel=me />
  <link href='https://github.com/dominiclizarraga' rel=me />
  <link href='mailto:dominiclizarraga@hotmail.com' rel=me />
  <link rel="canonical" href="http://localhost:4000/">
  <script data-name="BMC-Widget" data-cfasync="false" src="https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js" data-id="domlizarrraga" data-description="Support me on Buy me a coffee!" data-message="" data-color="#5F7FFF" data-position="Right" data-x_margin="18" data-y_margin="18"></script>
</head>
<body class='post'>
  <div class="limiter search-bar-desktop">
    <script src="/js/lunr.js"></script>

<script>

var documents = [{
    "id": 0,
    "url": "http://localhost:4000/404",
    "title": "",
    "body": "404!"
    }, {
    "id": 1,
    "url": "http://localhost:4000/about/index.html",
    "title": "About",
    "body": "👋 Hey there! I’m Dominic a software developer proficient in Ruby on Rails, Hotwire (including Turbo + Stimulus), JS, APIs, Minitest, Capybara, Postgres, HTML, CSS(bootstrap) &amp; Tailwind. 🚀 I’m currently looking for my next adventure, my last job was with Oblsk where we worked on some amazing projects like PLT4M where I solved user stories from developing new features, creating models, involving ORM queries Sequel, testing with Mini &amp; Capy &amp; CSS responsiveness. 🏃 Then we moved to work on H4H a non-profit org that needed a solution for its marketing team so they can create content easily, here we implemented Strapi API as a headless CMS and Tailwind design (fully-responsive). 🥊 I’m currently working on a Ruby for good project called CASA where I help them to solve stakeholders tickets, I’ve been doing this as a way of giving back to the community and keep learning since this project uses Rspec, bootstrap, JavaScript and bits of jQuery ✨. I consider myself as very resilient and resourceful also I have learnt how to manage my emotional state and communicate efficiently and on time. 🔑 Here you may find my resume, LinkedIn, GitHub or if you want to drop me a line :) Tech stack  Ruby on Rails - Hotwire (Turbo &amp; Stimulus) Tailwind / Bootstrap Minitest &amp; Rspec - Capybara API’s - Agile methodologies SQL &amp; PostgreSQL AWS S3 - JavaScript HTML, CSS - GitHub - HerokuLanguages 🇺🇸 English - Professional 🇲🇽 Spanish - Native 🇩🇪 German - Basic "
    }, {
    "id": 2,
    "url": "http://localhost:4000/confs/index.html",
    "title": "Conferences",
    "body": " Here you’ll find the confs that I have attended or will be attending in the future.  Rails Saas | Oct 2022. Description pending.  Rails Conf | Apr 2023. Description pending.  Blue Ridge Ruby | Jun 2023. Description pending.  Ruby For Good | Jul 2023. Description pending.  Rails Camp | Sep 2023. Description pending.  Rails world | Oct 2023. Description pending.  Ruby Conf | Nov 2023. Description pending.  Sin City Ruby | Mar 2024. Coming soon 🤗 Rails conf | May 2024. Coming soon 🤗 Blue Ridge Ruby | May 2024. Coming soon 🤗"
    }, {
    "id": 3,
    "url": "http://localhost:4000/",
    "title": "",
    "body": " Mental model for writing double tests 2025-08-04 Good enough testing workshop | notes 2025-06-28 Rails code guide through with Kasper Timm Hansen | notes 2025-01-31 UML inventor interview (Grady Booch) | notes 2024-12-15 Intercom Off Script series | notes 2024-10-12 Stimulus controller - life cycle 2024-03-12 Refactoring and testing a long method in Ruby on Rails 2024-02-17 What's the difference behing button_to link_to form_with 2024-02-14 Follow as Polymorphic 2024-02-07 Beginner guide to Docker 🐳 2024-01-28 Action policy gem + Cache 2024-01-26 When you see the `. count` in a Rails view 👀 2024-01-22 Avoiding N+1 Queries 🚓 2024-01-18 Key concepts for Redis and cache 💽 2024-01-16 What is cache? 💵 💰 2024-01-14 Product Focused Ruby - Kasper Timm Hansen.  2023-12-17 How to quickly deep dive into a new code base.  2023-12-14 Always have a question to solve in mind.  2023-12-12 N + 1 queries and how to fix them.  2023-12-06 Debugging libraries for Ruby and Rails 2023-12-01 The Rails and Hotwire Codex 🌀 2023-11-21 Shape up 🎢 2023-11-08 Decompose for method calls 2023-11-07 Positional vs Keyword arguments 2023-11-02 Latest tips &amp; tricks | Ruby &amp; Rails 2023-10-26 Financial Wisdom Over Forks.  2023-10-09 How to crack your next code challenge 🧮 2023-09-30 Search bar in Rails 🔍 2023-09-10 Chartkick gem vs chart. js 2023-08-20 LLM Langchain. rb 🦜 | Andrei Bondarev 2023-08-01 NYU Startup Summer program 2023-07-24 How I learned rpsec 2023-06-14 Practicing Rails | Justin Weiss 2022-03-26 Rails Testing | University of Waterloo 2022-03-04 The Beginner’s Guide to Rails Testing Jason Swett 2022-02-14 The man in the arena 2022-02-05 How to set the right objectives 2021-12-24"
    }, {
    "id": 4,
    "url": "http://localhost:4000/computer-science/computer-networks/",
    "title": "Networking Notes",
    "body": " Notes on Computer Networks  {% for post in site. categories. computer-networks %}  {{ post. title }}  {{ post. date | date:  %Y-%m-%d  }} {% endfor %}"
    }, {
    "id": 5,
    "url": "http://localhost:4000/computer-science/operating-systems/",
    "title": "Operating Systems Notes",
    "body": " Notes on Operating Systems  {% for post in site. categories. operating-systems %}  {{ post. title }}  {{ post. date | date:  %Y-%m-%d  }} {% endfor %}"
    }, {
    "id": 6,
    "url": "http://localhost:4000/computer-science/",
    "title": "Computer Science Notes",
    "body": " I’ve committed to gaining depth in computer science, and here are the notes I’m taking along with the lessons on csprimer. com. Courses:  Programming: Beyond the basics Computer Systems Algorithms and Data Structures Computer Networks Operating Systems Relational Databases Distributed Systems {% for post in site. categories. computer-science %}  {{ post. title }}  {{ post. date | date:  %Y-%m-%d  }} {% endfor %}"
    }, {
    "id": 7,
    "url": "http://localhost:4000/pood/",
    "title": "Practical Object-Oriented Design",
    "body": " Documenting my journey through Practical Object-Oriented Design course. Here are the notes from the 12-week walkthrough of Practical Object-Oriented Design Course by Sandi Metz. I’m also reading the book 99 Botles (which I think is the same content, but written. ) Good Object-Oriented Programming requires an understanding of three things:    First, testing. You have to know how to write good tests.     Second, refactoring. You need the skills to rearrange the internals of existing code without breaking/changing the output.     Finally, OOP. You have to understand the concepts underlying object-oriented programming and design.   {% for post in site. categories. pood %}  {{ post. title }}  {{ post. date | date:  %Y-%m-%d  }} {% endfor %}"
    }, {
    "id": 8,
    "url": "http://localhost:4000/computer-science/distributed-systems/",
    "title": "Distributed Systems Notes",
    "body": " Notes on Distributed Systems  {% for post in site. categories. distributed-systems %}  {{ post. title }}  {{ post. date | date:  %Y-%m-%d  }} {% endfor %}"
    }, {
    "id": 9,
    "url": "http://localhost:4000/computer-science/algorithms-and-data-structures/",
    "title": "Algorithms and Data Structures Notes",
    "body": " Notes on Programming: Algorithms and Data Structures  {% for post in site. categories. algorithms-and-data-structures %}  {{ post. title }}  {{ post. date | date:  %Y-%m-%d  }} {% endfor %}"
    }, {
    "id": 10,
    "url": "http://localhost:4000/computer-science/beyond-the-basics/",
    "title": "Computer Systems Notes",
    "body": " Notes on Programming: Beyond the Basics  {% for post in site. categories. beyond-the-basics %}  {{ post. title }}  {{ post. date | date:  %Y-%m-%d  }} {% endfor %}"
    }, {
    "id": 11,
    "url": "http://localhost:4000/computer-science/relational-databases/",
    "title": "Computer Systems Notes",
    "body": " Notes on Relational Databases  {% for post in site. categories. relational-databases %}  {{ post. title }}  {{ post. date | date:  %Y-%m-%d  }} {% endfor %}"
    }, {
    "id": 12,
    "url": "http://localhost:4000/computer-science/systems/",
    "title": "Computer Systems Notes",
    "body": " Notes on Computer Systems  {% for post in site. categories. computer-systems %}  {{ post. title }}  {{ post. date | date:  %Y-%m-%d  }} {% endfor %}"
    }, {
    "id": 13,
    "url": "http://localhost:4000/projects/index.html",
    "title": "Projects",
    "body": " {% for project in page. projects %}        {{ project. name }}   {{ project. description }}   {% endfor %} "
    }, {
    "id": 14,
    "url": "http://localhost:4000/reading/index.html",
    "title": "Reading",
    "body": "{% for book in site. categories. book %}   {{ book. title }}  {{ book. author }} {{ book. date | date:  %Y-%m-%d  }}    {% endfor %}"
    }, {
    "id": 15,
    "url": "http://localhost:4000/2025/09/20/session-07.html",
    "title": "POOD Session 7: Manufacture Role Players & Alter Base Classes (Monkeypatching)",
    "body": "2025/09/20 - Session 7: Manufacture Role PlayersDate: September 20, 2025 This blog post consists in three parts:  My notes on Manufacture Role Players My notes on Alter Base Classes (Monkeypatching) Notes on Sandi’s talk Managing Dependencies (Go Ahead, Make a Mess)Key Concepts:  Manufacture Role Players: Watch 1: Contrasting the Concrete Factory with Shameless Green In this lesson, we covered how the new Factory differs from the old conditional structure we had. Sandi encouraged us to think about why the first conditional had 0, 1, 2, and  else  branches, while in the new Factory model, we only have 0, 1, and  else  branches. We don’t have a  2  branch because in the Shameless Green exercise, becuase some words needed to be transformed from plural to singular. Now, with the new Factory model, it takes care of this as a BottleNumber class. The key point of factories is selecting the required path and creating the corresponding instance, no behavior is involved. This contrasts with the first version, where after choosing the path, and behavior was supplied. This is something that factories should avoid doing. Watch 2: Fathoming Factories Polymorphism is the word we use to refer to that quality where many different objects can respond to the same message. Message senders don’t need to know the name of the class. They just need to know the name of the message, and so, the class effectively disappears. So Shock should be ignorant of the names of all these classes. It shouldn’t know the implementation details inside these classes. And it shouldn’t know how to pick which class is the right one for any certain circumstance. It’s the responsibility of a factory to manufacture the correct instance of a role playing object. The factory knows all those things that the Shock class doesn’t know. The factory knows all the names of the types, and it knows how to pick the right type for any specific circumstance. You can think of factories as the place in your application where conditionals go to die. Isolating conditionals in factories loosens the coupling between the objects in your application, and it lowers the cost of change. If you isolate the conditional in the factory and the names of the types in the factory, it means that it doesn’t matter to the Shock class, to the object wants to interact with a player of the cost role, that class doesn’t care if you add or remove new Shock types. The changes that need to be made to add or remove an object all happen in the factory, and the factory contains a very simple bit of code. Here is a visual example of how we passed from a convoluted Bycicle/Shock objects to a factory and roles. Working on a bicycle simulation. Each bicycle could have optional shocks, and those shocks involved a complex “cost” calculation. As more shock types were added, the best approach was to extract them into their own classes. Each shock class implemented its own cost method, allowing all shocks to respond consistently to the same message. This design made it easy to add new shock types without breaking existing code. However, Sandi explained that an even better approach would be to introduce a factory, which is responsible only for knowing which shock to instantiate. The factory doesn’t need to know about the internal implementation of each shock, it just returns the correct one when requested.    Your browser does not support the video tag.  Sandi mentioned 3 types of factories:    Dimension  Options    Structure  Open or Closed    Choosing Logic Location  Factory owns the logic or Logic is dispersed in the objects being chosen    Type Knowledge  Factory knows all type names or Objects register themselves with the factory Watch 3: Opening the Factory In this lesson, we looked at how our current factory isn’t really open. The fact that we had to manually add BottleNumber6 shows that every time we need a new type, we’d have to edit the factory again. That’s fine if nothing ever changes, but it’s not very flexible. So the goal here is to make it open, to let new BottleNumber classes get created automatically just by following a naming convention. To do that, we use a bit of Ruby metaprogramming. The trick is const_get, a method that takes a string like  BottleNumber6  and turns it into the actual class. If the class exists, great — we get it back. If it doesn’t, Ruby throws a NameError, which we can rescue and fall back to a default BottleNumber class. This makes the factory much more dynamic, since it no longer needs a big case statement to decide what to build. There was also a quick side trip into how garbage collection works in Ruby, which was actually super helpful. Basically, objects get cleaned up when nothing references them anymore, but class definitions don’t, they stick around forever because Ruby keeps them in a sort of “big hash in the sky. ” That’s why you need to be careful with class variables: anything stored there will live for the entire life of the program. So yeah, a bit of metaprogramming magic, a bit of memory awareness, and now our factory is officially open for business. class BottleNumber def self. for(number)  begin   const_get( BottleNumber#{number} )  rescue NameError   BottleNumber  end. new(number)  # case number  # when 0  #  BottleNumber0  # when 1  #  BottleNumber1  # else  #  BottleNumber  # end. new(number) endendIt’s not obvious what this code does, and that might be an issue for people. It’s a very valid. These metaprogramed classes, a big downside is you can’t find them anymore and someone can wipe them out since are not referenced anymore. You know, for every question in OO, the answer is always,  It depends , and here it depends. We’re just trying to save money. We wanna write the most cost effective code. Sometimes adding a little complexity will reduce overall cost. You have to be careful because we wanna be overly complex a lot of times, but if complexity will save you money, then it’s cheaper and you should do it. Watch 4: Supporting Arbitrary Class Names In this lesson, we explored the third way to make the factory open. This time, Sandi proposed using a Hash to support arbitrary class names, meaning the factory isn’t limited to BottleNumber anymore. The implementation is pretty straightforward, but even with this hash approach, it still feels a lot like the first version with the case statement. If you want to add a new class, you still have to edit the hash and add a new key-value pair. So technically, it’s not fully open yet, but it does separate data from logic in a cleaner way. The case statement version is definitely easier to read since it’s just a simple list of conditions. But the advantage of the hash approach is that the data driving the program now lives separately, and that opens the door to storing it somewhere else, like in a YAML file or a database. One cool side note from this section was how Sandi pointed out that your syntax highlighter can give you hints about your code’s design. Fewer color changes usually mean simpler, more object-oriented code — bigger chunks of the same abstraction. In contrast, when you see lots of color changes, that’s often procedural code with many shifting ideas packed together. ```rubyclass BottleNumber def self. for(number)  Hash. new(BottleNumber). merge(   0 =&gt; BottleNumber0,   1 =&gt; BottleNumber1,   6 =&gt; BottleNumber6)[BottleNumber]. new(BottleNumber) endend Watch: Dispersing the Choosing Logic Alter Base Classes (Monkeypatching): Managing Dependencies: "
    }, {
    "id": 16,
    "url": "http://localhost:4000/2025/09/13/session-06.html",
    "title": "POOD Session 6: Polymorphism, Remedy Liskov & Make the Easy Change",
    "body": "2025/09/13 - Session 6: Get to Know Polymorphism, Remedy Liskov Violations &amp; Make the Easy ChangeDate: September 13, 2025 This blog post consists in three parts:  My notes on Polymorphism My notes on Remedy Liskov Violations My notes on Make the Easy ChangeKey Concepts:  Get to know Polymorphism: Watch 1: Making Sense of Conditionals This block contains two videos. One delves into conditionals and the other explores object-oriented polymorphism. We still have not the code to be Open. Here, we are going to pick another code smell. The most repeated pattern are the conditional, with 2 branches and all checking number == 1 or number == 0. The problem with repeating conditionals is evident. How many methods would you have to change to fulfill the six-pack requirement? You have to touch a bunch of places in here because the six-pack-ness is spread out over a number of these conditionals. These conditionals provide us with generalizations in the false branches and specializations in the true branches. If we had mixed up our styles of code, it would have been much more difficult to tell here what we needed to do next. Consistency of style enables future refactorings and enhances understanding. Examples of bad usage of inheritance: # BAD: Deep/Wide Inheritance Hierarchyclass Employee; endclass FullTimeEmployee &lt; Employee; endclass PartTimeEmployee &lt; Employee; endclass ContractEmployee &lt; Employee; endclass SeniorFullTimeEmployee &lt; FullTimeEmployee; endclass JuniorFullTimeEmployee &lt; FullTimeEmployee; end# . . . gets messy and hard to understand# BAD: Tiny Specializations Leading to Cross-Cutting Problemsclass Employee def swag_amount  100 end  def tax_rate  0. 20 endendclass LongTermEmployee &lt; Employee def swag_amount  super * 2 # specializes only swag endendclass OutOfStateEmployee &lt; Employee def tax_rate  0. 15 # specializes only taxes endend# Problem: Need LongTermOutOfStateEmployee? Can't inherit from both!# GOOD: Use Composition for Cross-Cutting Concernsclass Employee def initialize(swag_policy:, tax_policy:)  @swag_policy = swag_policy  @tax_policy = tax_policy end  def swag_amount  @swag_policy. calculate end  def tax_rate  @tax_policy. rate endendclass StandardSwagPolicy def calculate  100 endendclass LongTermSwagPolicy def calculate  200 endendclass InStateTaxPolicy def rate  0. 20 endendclass OutOfStateTaxPolicy def rate  0. 15 endend# Now you can mix and match any combination:Employee. new( swag_policy: LongTermSwagPolicy. new, tax_policy: OutOfStateTaxPolicy. new)# ACCEPTABLE: Inheritance for Leaf Nodes (Small, Focused Classes)class BottleNumber def container   bottles  endendclass BottleNumber1 &lt; BottleNumber def container   bottle  # specializes most of the small class endendclass BottleNumber0 &lt; BottleNumber def quantity   no more  # specializes most of the small class endendWatch 2: Replacing Conditionals with Polymorphism “Poly” means many, “morph” in this case means form. Many forms. We use polymorphism to describe a situation in which many different objects can respond to the same message. This means that the message sender doesn’t know or care the type of the object that it gets passed, and it means that later you can create new objects that polymorphously play some existing role and get that behavior into your app without having to change anything about those objects that are sending the messages. Let’s implement a Factory object model that evaluates and creates depending on the request, different new objects, these new objects will inherit from a general BottleNumber and will contain specializations. This will reduce the conditionals we have into several new small classes. This change is like primitive obsession but instead of obsessing upon the entire class, we actually obsess on instances of the class (0 and 1). class Bottles def song  verses(99, 0) end def verses(upper, lower)  upper. downto(lower). map { |i| verse(i) }. join( \n ) end def verse(number)  bottle_number = bottle_number_for(number)  next_bottle_number = bottle_number_for(bottle_number. successor)   #{bottle_number} of beer on the wall,  . capitalize +   #{bottle_number} of beer. \n  +   #{bottle_number. action},   +   #{next_bottle_number} of beer on the wall. \n  end # Factory def bottle_number_for(number)  case number  when 0   BottleNumber0  when 1   BottleNumber1  else   BottleNumber  end. new(number) endendclass BottleNumber attr_reader :number def initialize(number)  @number = number end def to_s   #{quantity} #{container}  end def quantity  number. to_s end def container    bottles  end def action   Take #{pronoun} down and pass it around  end def pronoun   one  end def successor  number - 1 endendclass BottleNumber0 &lt; BottleNumber def quantity   no more  end def action   Go to the store and buy some more  end def successor  99 endendclass BottleNumber1 &lt; BottleNumber def container   bottle  end def pronoun   it  endendQuiz:  This refactoring is super easy, yet it greatly increases the abstraction of the code. List some qualities of the current code that make this refactoring so easy. All of the following are true:  The tests run quickly.  The code has a consistent style.  The methods have a single responsibility.  The conditionals test for equality.  Imagine the code you would have written to solve the 99 bottles problem before you knew about Shameless Green or read the 99 Bottles of OOP book. (You may actually have made a stab at solving the problem before starting the course–that’s the code I’m asking about here. )Would it have been equally easy to refactor that code into this state? If not, what qualities of the code would have made the refactoring difficult? It’s common for that first attempt to have the following qualities:  The abstractions are incorrect or incomplete.  The code and the conditionals have an inconsistent style.  Methods have more than one responsibility. Remedy Liskov Violations: Watch 1: Transitioning Between Types Here we are tackling the Liskov violation that . succesor represents, remember it should return BottleNumber not a number. We named the factory  self. for . The name  . for  implies that it takes an argument, but in my experience factories always do. The job of a factory is to pick an object, and it needs some thing to pick on. class Bottles def song  verses(99, 0) end def verses(upper, lower)  upper. downto(lower). map { |i| verse(i) }. join( \n ) end def verse(number)  bottle_number = BottleNumber. for(number)   #{bottle_number} of beer on the wall,  . capitalize +   #{bottle_number} of beer. \n  +   #{bottle_number. action},   +   #{bottle_number. successor} of beer on the wall. \n  endendclass BottleNumber attr_reader :number def initialize(number)  @number = number end def self. for(number)  case number  when 0   BottleNumber0  when 1   BottleNumber1  else   BottleNumber  end. new(number) end def to_s   #{quantity} #{container}  end def quantity  number. to_s end def container   bottles  end def action   Take #{pronoun} down and pass it around  end def pronoun   one  end def successor  BottleNumber. for(number - 1) endendclass BottleNumber0 &lt; BottleNumber def quantity   no more  end def action   Go to the store and buy some more  end def successor  BottleNumber. for(99) endendclass BottleNumber1 &lt; BottleNumber def container   bottle  end def pronoun   it  endendQuiz  What is the official definition of the Liskov Substitution Principle?  “Functions that use pointers to base classes must be able to use objects of derived classes without knowing it. ”Or more generally…  “Objects of a superclass shall be replaceable with objects of its subclasses without breaking the application” If ‘official’ Liskov has to do with inheritance, how can whatever’s wrong with the #successor methods be a Liskov violation? Write a new Liskov Substitution Principle definition that extends it to cover both problems.    The Liskov Substitution Principle can be expanded to include not only subtypes but also any other object that is meant to be interchangeable with current one. Liskov requires that methods return the objects that they “promise” to return.     In our case the very name of the #successor method implies that it returns something that acts like a BottleNumber, that is, that it returns an object that conforms to the API of the receiver. Returning a number instead of a BottleNumber forces that caller to check the returned object’s type in order to know how to talk to it.  This is a Liskov violation.  Make the Easy Change: Watch 1: Making the Easy Change In this lesson we discovered that the code is now open to the six-pack requirement. A quick recap of what we’ve done so far:    We started out by writing the Shameless Green implementation of 99 Bottles.     then we got a new requirement to say 1 six-pack instead of 6 bottles.     We decided to make this code open to change (we didn’t really know how to do that)     Therefore we used that flow chart that suggested that we find code smells (they are 24).      We identifed code smells, and then we picked the code smell that we thought, if we corrected it (duplicate code).     We had to isolate the things we want to vary.     The first code smell that we worked on was all that duplication in the verse method; we decided it contained concealed concepts, and we used the flocking rules to identify those concepts, to give those concepts names.     Selecting the most similar pieces of code     Finding the smallest difference between them     Making the simplest change to remove that difference     After that, we decided that all the methods that we’d created using the flocking rules were obsessing upon a primitive.     We extracted the BottleNumber class in order to cure that obsession.     Finally, we noticed that we had repeating conditionals in that BottleNumber class, and we cured those conditionals by following the Replace Conditional with Polymorphism recipe and making a little inheritance hierarchy of different players of the bottle number role.  For implementing the six-pack we switched to TDD so the first thing to do is writing a failing test. We changed in bottles_test. rb the following, notice the “1 six-pack” 7 bottles of beer on the wall, 7 bottles of beer. Take one down and pass it around, 1 six-pack of beer on the wall. 1 six-pack of beer on the wall, 1 six-pack of beer. Take one down and pass it around, 5 bottles of beer on the wall. Then ran tests and failed: 7 bottles of beer on the wall, 7 bottles of beer. -Take one down and pass it around, 1 six-pack of beer on the wall. +Take one down and pass it around, 6 bottles of beer on the wall. -1 six-pack of beer on the wall, 1 six-pack of beer. +6 bottles of beer on the wall, 6 bottles of beer. Take one down and pass it around, 5 bottles of beer on the wall. Then we added a new class of specialization BottleNumber6 with two methods #quantity and #container and don’t forget about the Factory, we gotta add one case branch. class BottleNumber attr_reader :number def initialize(number)  @number = number end def self. for(number)  case number  when 0   BottleNumber0  when 1   BottleNumber1  when 6   BottleNumber6  else   BottleNumber  end. new(number) end. . . class BottleNumber6 &lt; BottleNumber def quantity   1  end def container   six-pack  endend“Make the change easy, (warning, this might be hard), then make the easy change. ”, and that’s exactly the experience that we had. We’ve spent chapters making the code open, but once it was open, the change was easy. If you learn the code smells and you get familiar with even just the names of the refactorings, you can identify code smells and look up the refactoring recipes when you want to use them. It’ll make your code better and your life easier. Watch 2: Defending the Domain It’s true that the number of bugs in code is related to the volume of code, the more code you write, the more bugs you’ll have, so it’s better to minimize the amount of code you have. However, it’s not a good idea to reduce it beyond the logical point. It’s only a good idea to reduce it if it’s correct. The original class, Bottles, can know about BottleNumber. It has to know about how to get them but once we extract those BottleNumber# classes we have to turn our back on Bottles. Bottles can know about the things that it’s gonna contain, BottleNumber can’t know about the objects that will contain it. The relationship can’t be bidirectional. It’d mean you can never use them in another context The above ideas were to stand your domain on the next proposal: class BottleNumber6 &lt; BottleNumber def quantity   1  end def container   six-pack  endend# VSclass BottleNumber6 &lt; BottleNumber def to_s   #{quantity} #{container}  endendSandi’s summary  The purpose of this block was to produce a code arrangement that was open to the six-pack requirement. Not only did it succeed in fulfilling that requirement, but along the way it also resolved a number of other issues.  This block explored the Data Clump code smell. It replaced a Switch Statement with a set of polymorphic objects, which it created using a factory. It corrected the Liskov violation in successor, and used that problem as a jumping-off point for a more general lesson about how to change the return types of polymorphic methods.  The BottleNumber for factory was straightforward and most certainly did the job. While simple factories like this work great in many situations, they’re not best for every case. There’s a whole world of different styles of factories waiting to be explored. "
    }, {
    "id": 17,
    "url": "http://localhost:4000/2025/09/06/session-05.html",
    "title": "POOD Session 5: Decipher Caching and Immutability",
    "body": "2025/09/06 - Session 5: Decipher Caching and Immutability, Cache BottleNumbers &amp; Recognize Data ClumpsDate: September 06, 2025 This blog post consists in three parts:  My notes on Decipher Caching and Immutability My notes on Cache BottleNumbers My notes on Recognize Data ClumpsKey Concepts:  Immutability vs mutation in object-oriented programming Cache invalidation and the 80/20 rule Liskov Substitution Principle violations Data Clumps code smell Modeling business logic as separate objectsDecipher Caching and Immutability: Watch 1: Appreciating Immutability To mutate is to change. State is the particular conditional of something at certain point in time. and a variable is a thing that varies. In the real world, things change state, or they vary, over time. And it makes perfect sense that in computer programming we would choose the term variable for that thing that holds state, that changes over time. This choice reflects our expectation, that all things vary.  It’s common in OO to change the state of objects; we send a message and pass a bit of data, and then you hold on to that new bit of data. But it’s possible, as the functional folks will gladly tell you, to write code where most objects would never have to change state. Instead of mutating an object, if it needed to vary state, you could just create a new object on that new piece of state. What this means is if you had a coffee cup and you drank all the coffee, instead of refilling the cup, you would just get a new cup with more coffee in it. Instead of noting that the continents had moved because of plate tectonics, you would get entirely new continents, even if they’d only moved a matter of millimeters. What might the benefits of immutable objects be? Well, they’re easy to understand. You’re never in a situation where someone else is holding a pointer to an object that you’re also holding onto, and that object somehow changes state underneath you. What you see is always what you get. Immutable objects are easy to reason about. If you have mutable objects, where state is changing, often you need collaborators in the tests that you’re creating. So you have to spin up these other objects in order to get state to change in the object that’s under test. But for immutable objects, you would just create a new object on a different piece of state. So there are many good reasons to love immutable objects. And the question is why don’t we use them more?    The first is just habit, when you learned OO, or any example that you look at using OO, very often mutates objects.     The second reason I think is an unquestioned assumption that many people make that object creation will be expensive and that it’s better to mutate an existing object rather than create a new one.  Watch 2: Assuming Fast Enough In the previous section made the case for immutability. And it’s a good thing. We often don’t do it though, and it’s mostly for two reasons. One: habit, we’re not in the habit of thinking about creating immutable objects. But two, a bigger issue, is even if we want to create immutable objects, very often, we imagine that it will be too expensive to create new objects. A person named Phil Karlton famously said:  There are only two hard problems in Computer Science:    naming and  cache invalidation.  Cache is local copy of something. A temporary variable, when you declare a variable and say equal some operation, you’ve created a cache. Also, known as memoization. Why would you cache? Sometimes we cache to give a name to the result of an intermediate operation, to add clarity to the code. The other reason we may cache is to preserve the result of a costly long running operation. And so now we have a problem. If you save the result of a long running operation, how will you know when your cache gets dirty? (different result and you’re holding on to a previous cache copy) The code to figure out that your cache is dirty is cache invalidation. There’s a thing called the 80/20 rule, which says that 80%, or 90% or 95%, of an application’s work occurs in 20% of its code. (Most of the code don’t run pretty much) Don’t add complexity based on guesses. Write the simplest possible code, and then, and only then, if you find that parts of your app are too slow, (if someone complains) then profile your code to identify the slow parts and then work on them to make them faster. A profiler is a tool that watches your code as it runs and measures how much time you spend in certain operations. Your initial solution should avoid mutation. You should treat object creation as free and you should also avoid caching, just rerun operations and use the results. If you find that parts of your app are too slow and you profile it, you might find that you’d be better off to break some of your objects into smaller parts. If you have parts that you need to mutate, or if you have parts that you need cache and invalidate, it’s nice to minimize the size of those parts. If you can create objects for the ideas of your business and have those objects hold on to the bags of state, you end up in a situation where it’s easy to test your business logic and you’re decoupled from the database. Example of objects as buisness ideas: # DON'T: Business logic coupled to database/stateclass Order def initialize(id)  @id = id end def apply_discount  record = Database. find(@id)  if record. total &gt; 100   record. discount = record. total * 0. 10   record. save  end endend# DO: Extract business logic into separate objectsclass DiscountCalculator def initialize(total)  @total = total end def calculate  @total &gt; 100 ? @total * 0. 10 : 0 endendclass Order def apply_discount  record = Database. find(@id)  discount = DiscountCalculator. new(record. total). calculate  record. discount = discount  record. save endend# Now DiscountCalculator is easy to test without database:# DiscountCalculator. new(150). calculate =&gt; 15. 0Cache BottleNumbers: Here we applied the lessons from prior block to reduce the number of new BottleNumbers and simplify the code. Watch 1: Creating BottleNumbers With current code, how many instances of BottleNumber get created over the course of the song? It happens every time verse calls one of these methods, and that happens nine times in verse, that means we’re creating 900 BottleNumbers. Too many? As we said before, only if this code is too slow. Caching these values is very complicated. The next trial will reduce the number of BottleNumber: class Bottles def song  verses(99, 0) end def verses(upper, lower)  upper. downto(lower). map { |i| verse(i) }. join( \n ) end def verse(number)  bottle_number = BottleNumber. new(number)   #{bottle_number. quantity. capitalize} #{bottle_number. container} of beer on the wall,   +   #{bottle_number. quantity} #{bottle_number. container} of beer. \n  +   #{bottle_number. action},   +   #{quantity(successor(number))} #{container(successor(number))} of beer on the wall. \n  end def quantity(number)  BottleNumber. new(number). quantity end def container(number)  BottleNumber. new(number). container end def action(number)  BottleNumber. new(number). action end def successor(number)  BottleNumber. new(number). successor endendWatch 2: Recognizing Liskov Violations In last session we created bottle_number within verse and that reduced the BottleNumber from 900 to 200 creation. We left the 4 phrase with no implementation of this new cache since it requires a different number. We need the succersor number. Adding next_bottle_number implies that you’re going to get another BottleNumber back, and yet here you don’t. I’m going to call this yet another violation of that generalized Liskov Substitution Principle. The method makes a promise that you are going to get back a BottleNumber but instead you get a number. Why? Because back in the shameless green lesson it was useful and seemed like a good idea. We didn’t even have BottleNumber. We should have changed successor so that it would return instances of BottleNumber rather than instances of a number. Notice that the refactoring recipes, even though they guided us all along the way, they don’t really help with this problem. You have to be able to look at the names of things and understand that you need to make an additional change in the successor method; because you’ve changed type, successor needs to return the new type. class Bottles def song  verses(99, 0) end def verses(upper, lower)  upper. downto(lower). map { |i| verse(i) }. join( \n ) end def verse(number)  bottle_number = BottleNumber. new(number)  next_bottle_number = BottleNumber. new(bottle_number. successor)   #{bottle_number. quantity. capitalize} #{bottle_number. container} of beer on the wall,   +   #{bottle_number. quantity} #{bottle_number. container} of beer. \n  +   #{bottle_number. action},   +   #{next_bottle_number. quantity} #{next_bottle_number. container} of beer on the wall. \n  endendclass BottleNumber attr_reader :number def initialize(number)  @number = number end def quantity  if number == 0    no more   else   number. to_s  end end def container  if number == 1    bottle   else    bottles   end end def action  if number == 0    Go to the store and buy some more   else    Take #{pronoun} down and pass it around   end end def pronoun  if number == 1    it   else    one   end end def successor  if number == 0   99  else   number - 1  end endendSandi’s recap until this lesson:  This block continued the quest to make Bottles open to the six-pack requirement. It recognized that many methods in Bottles obsessed on number, and undertook the Extract Class refactoring to cure this obsession. The refactoring created a new class named BottleNumber.  During the course of the refactoring, conditionals were examined from an experienced OO practitioners’ point of view. This block also explored the rewards of modeling abstractions, the trade-offs of caching, the advantages of immutability, and the benefits of deferring performance tuning.  Most programmers are happier with the current code than they were with Shameless Green, but this version is far from perfect. The total Flog score, for example, has gone up again. From Flog’s point of view, after turning one conditional into many back in previous lessons, you’ve now compounded your sins by introducing a new class which adds no new behavior but increases the length of the code.  Also, there are no unit tests for BottleNumber. It relies entirely on Bottle ‘s tests. The code still exudes many smells (duplication, conditionals, and temporary field, to name a few). And, finally, it commits a Liskov violation in the successor method.  Recent refactorings were undertaken in hopes of making the code open to the six-pack requirement, but this has not yet succeeded. You’ve been acting in faith that removing code smells would eventually lead to openness. It’s possible that your faith is being tested.  Despite the imperfections listed above, there are ways in which the code is better. There are now two classes, but each has focused responsibilities. While it’s true that the whole is bigger, each part is easy to understand and reason about.  The code is consistent and regular, and embodies an extremely stable landing point that splendidly enables the next refactoring. Quiz for these Liskov, primitive obsession cure session:  Why do the current #successor methods violate the Liskov Substitution Principle?They make a promise that they do not keep. They return an unexpected type, forcing the receiver to know too many things (have too many dependencies).  How many instances of the BottleNumber class are being created before this refactoring? And how many after?900 before, 200 after.  OO works out better if you write code that can treat object creation as . . . FREE Recognize Data Clumps: Watch 1: Consolidating Data Clumps What’s a Data Clump? Martin Fowler defines it as three or four things that always seem to come together, either passed as perimeters or used as a group. Examples: Imagine you had a reporting system where many methods took a starting and an ending date. start_date and end_date are always passed together and share behaviors (validation, formatting, comparison). class DateRange attr_reader :start_date, :end_date def initialize(start_date, end_date)  @start_date, @end_date = start_date, end_date  validate end def validate  raise  Invalid range  if start_date &gt; end_date end def duration  (end_date - start_date). to_i endendInstead of passing two arguments everywhere: Report. new(start_date, end_date)you pass a single cohesive object: Report. new(DateRange. new(start_date, end_date))Sandi Metz outlines an implicit 4-step reasoning process in this section:  Identify Repeating Pairs or GroupsLook for two or more values that “always travel together” passed as arguments or used side by side (quantity + container, start_date + end_date, x + y).  Recognize Shared BehaviorAsk: “Do other parts of the app perform similar checks or operations on these values?” Example: validating a date range, computing coordinates, or pluralizing bottles.  Corral the Clump into an ObjectCreate a class that encapsulates both the data and the behavior related to it. This lets scattered logic “coalesce” into one place.  Simplify the Calling CodeReplace multiple arguments with a single object. This reduces duplication and increases consistency, your app now speaks in terms of meaningful concepts (DateRange, Point, BottleNumber) instead of raw primitives. This refactor simplified the verse, reduced duplication, and made the method cleaner: class Bottles def song  verses(99, 0) end def verses(upper, lower)  upper. downto(lower). map { |i| verse(i) }. join( \n ) end def verse(number)  bottle_number = BottleNumber. new(number)  next_bottle_number = BottleNumber. new(bottle_number. successor)   #{bottle_number} of beer on the wall,  . capitalize +   #{bottle_number} of beer. \n  +   #{bottle_number. action},   +   #{next_bottle_number} of beer on the wall. \n  endendclass BottleNumber attr_reader :number def initialize(number)  @number = number end def to_s   #{quantity} #{container}  end def quantity  if number == 0    no more   else   number. to_s  end end def container  if number == 1    bottle   else    bottles   end end def action  if number == 0    Go to the store and buy some more   else    Take #{pronoun} down and pass it around   end end def pronoun  if number == 1    it   else    one   end end def successor  if number == 0   99  else   number - 1  end endend"
    }, {
    "id": 18,
    "url": "http://localhost:4000/2025/08/30/session-04.html",
    "title": "POOD Session 4: Cure Primitive Obsession with Extract Class",
    "body": "2025/08/30 - Session 4: Cure Primitive Obsession with Extract ClassDate: August 30, 2025 This blog post consists in one part:  My notes on Cure Primitive ObsessionKey Concepts:  Primitive obsession Extract Class refactoring pattern Naming classes after what they are vs. what they do Modeling abstract concepts as objectsCure Primitive Obsession with Extract Class: Watch 1: Selecting the Target Code Smell In this lesson we have more code, more abstraction which means more levels of indirection. It’s not really more complex and mini-differences are hidden in these abstractions. We’re midway through refactoring. Seeing the code become more complicated is normal. We can learn more in the next talk. All the little things talk. Refactoring recipes don’t promise to make the code simpler, they promise to help you make a very planned change and if fail revert it. The code is not open yet, and we chose the code duplication as code smell to solve and we followed flocking rules for identifying abstractions. We need to make a decision if we continue with our current code and if we revert it and pick a different code smell. We’ve got to ask ourselves, did the refactor we implement, isolate more the parts I want to vary? ( six-pack ) And the answer is yes, quatity(number) and container(number) If we were to vary container or quantity now, we’re dealing with a smaller amount of code. Sandi recommended to move on and pick another code smell. We had to pick the next code smell and Sandi helped us with the following questions:    Do any of the methods have the same shape?     Are there any arguments that have the same name?     If you were to put the private keyword in here, where would it go?     If this were 2 classes, were would you split it?     The method that have arguments, do they depend on the argument itself or the whole class?  Almost all questions are YES. Something that caught my attention was how the number argument started as a verse in song and verses(upper, lower) methods but in verse(number) it becomes a bottle number, which is confusing, same argument name for two different concepts. A worse problem is when we use the different names for the same concept. def container(number) if number == 1   bottle  else   bottles  endendLet’s evaluate the container(number): You passed it an argument, and that argument is so impaired that it does not come with its own behavior. You force it to know that it should test it for some values, and you force it to know what behavior to supply, based on the value that it tested for. You force it into the conditional. You forced it to know the different values that it might test in the conditional. And you forced it to know the behavior that applied to each of those. This is not OO. We should be able to call number. container at this point we cannot. The code needs a smarter number. Watch 2: Extracting Classes A number of methods take the same argument (number). Most of them have the same shape. They contain a conditional, they would be considered private, and they depend more on the argument that got passed than the class as a whole. These things suggest the Primitive Obsession code smell. The cure for Primitive Obsession is to extract a class. We’ll “wrap a coat of behavior around a primitive,” we’re taking something simple like a number or a string and giving it a bit of intelligence. Now, since we’re going to create a class, the first thing we do is name it. What is this thing? Example: it’s a bottle. It’s blue, 22 ounces, made of plastic, and holds water. But remember what we write in code isn’t the bottle itself. It’s a representation of all bottles. Think of a boolean, like true, you can’t pick one up or see it. It’s not physical; it’s an idea. In Ruby, true is just a variable that points to an instance of TrueClass. That’s the beauty of object-oriented programming: it lets you build worlds where ideas are as real as physical objects. When you start modeling concepts the same way you model things, you’ve crossed an important milestone as an OO programmer. Those hidden, abstract ideas, the ones that live in the relationships between real objects, are where the most powerful abstractions are found. Another example: in an Event Management System, perhaps you have buyers and tickets and there’s a bunch of interactions between them. You have purchases and refunds and discounts and you could resell your tickets. Now, all of the logic to do those actions, those operations, could exist in either ticket or buyer, but it’s better if they get modeled as their own separate things. If you do that, and put the logic in its own object, you create objects that are easier to understand, easier to change, easier to vary, and easier to test. And since tests are just a form of reuse, a test is often the first reuse of an object. If you can test it, if it’s easy to test, it means it will be also easy to reuse. Here is another example to illustrate what primitive obsession code smell is: # BEFORE: Primitive Obsessionclass Order def initialize(country_code)  @country_code = country_code end def tax_rate  if @country_code ==  US    0. 07  elsif @country_code ==  MX    0. 16  else   0. 20  end end def currency  if @country_code ==  US     USD   elsif @country_code ==  MX     MXN   else    EUR   end endend# AFTER: Extract Class to cure Primitive Obsessionclass Order def initialize(country)  @country = country end def tax_rate  @country. tax_rate end def currency  @country. currency endendclass Country attr_reader :code def initialize(code)  @code = code end def tax_rate  case code  when  US  then 0. 07  when  MX  then 0. 16  else 0. 20  end end def currency  case code  when  US  then  USD   when  MX  then  MXN   else  EUR   end endendWhen naming instance methods, we asserted that methods ought to be named one level of abstraction higher than what they do, but the rule is different for classes. Classes ought to be named after what they are, and therefore this new class is a BottleNumber. The class Bottles is now free of conditionals and BottleNumber only deals with number nothing about the Song and this is how this the code we finished with during this session. class Bottles def song  verses(99, 0) end def verses(upper, lower)  upper. downto(lower). map { |i| verse(i) }. join( \n ) end def verse(number)   #{quantity(number). capitalize} #{container(number)} of beer on the wall,   +   #{quantity(number)} #{container(number)} of beer. \n  +   #{action(number)},   +   #{quantity(successor(number))} #{container(successor(number))} of beer on the wall. \n  end def quantity(number)  BottleNumber. new(number). quantity end def container(number)  BottleNumber. new(number). container end def action(number)  BottleNumber. new(number). action end def successor(number)  BottleNumber. new(number). successor endendclass BottleNumber attr_reader :number def initialize(number)  @number = number end def quantity  if number == 0    no more   else   number. to_s  end end def container  if number == 1    bottle   else    bottles   end end def action  if number == 0    Go to the store and buy some more   else    Take #{pronoun} down and pass it around   end end def pronoun  if number == 1    it   else    one   end end def successor  if number == 0   99  else   number - 1  end endend"
    }, {
    "id": 19,
    "url": "http://localhost:4000/2025/08/23/session-03.html",
    "title": "POOD Session 3: Identify Abstractions",
    "body": "2025/08/23 - Session 3: Identify Abstractions &amp; Dry Out Shameless GreenDate: August 23, 2025 This blog post consists in two parts:  My notes on Identify Abstractions My notes on code Dry Out Shameless Green”Key Concepts:  Flocking Rules – A systematic way to discover hidden abstractions by:   Selecting the most similar pieces of code     Finding the smallest difference between them     Making the simplest change to remove that difference     Abstraction Discovery – Don’t invent abstractions upfront; uncover them by observing recurring patterns and responsibilities that emerge through refactoring.     Naming by Responsibility – When extracting methods, name them after what they do, not how they do it. (e. g. quantity, container, pronoun, action, successor)     Liskov Substitution Principle – Objects should behave as they claim to; avoid conditionals that depend on an object’s type.     Duck Typing – In Ruby, objects are defined by their behavior, not their class. If two objects respond to the same messages, they share a “role. ”e. g. PrivateContract and CommercialContract both respond to #name, so they can be used interchangeably.     Depending on Abstractions     Emergent Design – By consistently applying the Flocking Rules, abstractions emerge naturally; you don’t need to foresee the design from the start.  Identify Abstractions: Watch 1: Following the Flocking Rules ✨ Quick reminder: We need to change the code to display “six-pack” instead of “6 bottles” which means make the code open to extension, closed to modification Here are the steps to find abstractions in code, these are mini-decisions, we still don’t know the outcome:  Select the things that are most alike Find the smallest difference between them Make the simplest change to remove the differencea) parse the new codeb) parse and execute itc) parse, execute and use its resultsd) deleted unused code Remember to  change one line at the time.  run tests after each change if the test fail, undo and make a better changeSet of rules of flocking birds 🦅-🦅-🦅-🦅  alignment: tells them to steer on the average heading of their near neighbors cohesion, says steer towards the average position of their neighbors, which is sort of a long range attraction rule separation, don’t hit each otherThis will turn difference into sameness and will reveal Concealed Concepts. Watch 2: Converging on Abstractions Increase isolation of the thing we want to vary. With the hope that eventually the code will open for the change we want to make. Discover hidden abstractions instead of look at the problem and make them up. We went from this code:  def verse(number)  case number  when 0    No more bottles of beer on the wall,   +    no more bottles of beer. \n  +    Go to the store and buy some more,   +    99 bottles of beer on the wall. \n   when 1    1 bottle of beer on the wall,   +    1 bottle of beer. \n  +    Take it down and pass it around,   +    no more bottles of beer on the wall. \n   when 2    2 bottles of beer on the wall,      2 bottles of beer. \n   +    Take one down and pass it around,  +    1 bottle of beer on the wall. \n   else    #{number} bottles of beer on the wall,   +    #{number} bottles of beer. \n   +    Take one down and pass it around,   +    #{number - 1} bottles of beer on the wall. \n   end endTo this one, always following flocking rules for finding hidden abstracions, select the things that are most alike, find the smallest difference between them and make the simplest change to remove the difference:  def verse(number)  case number  when 0    No more bottles of beer on the wall,   +    no more bottles of beer. \n  +    Go to the store and buy some more,   +    99 bottles of beer on the wall. \n   when 1    1 bottle of beer on the wall,   +    1 bottle of beer. \n  +    Take it down and pass it around,  +    no more bottles of beer on the wall. \n   else    #{number} #{container(number)} of beer on the wall,   +    #{number} bottles of beer. \n  +    Take one down and pass it around,   +    #{number - 1} bottles of beer on the wall. \n   end end def container(number)  if number == 1    bottle   else    bottles   end endDry Out Shameless Green: In this block we finished DRYing out bottles Shameless Green via the Flocking Rules. We coded for 30 minutes with the aim to DRYing out the #verse. After that time we watched the solution videos, replicate the code and discussed it with the group. This is the code we started with, after chopping off the case statement for number 2 all tests run on green: def song  verses(99, 0) end def verses(upper, lower)  upper. downto(lower). map { |i| verse(i) }. join( \n ) end def verse(number)  case number  when 0    No more bottles of beer on the wall,   +    no more bottles of beer. \n  +    Go to the store and buy some more,   +    99 bottles of beer on the wall. \n   when 1    1 bottle of beer on the wall,   +    1 bottle of beer. \n  +    Take it down and pass it around,   +    no more bottles of beer on the wall. \n   else    #{number} bottles of beer on the wall,   +    #{number} bottles of beer. \n  +    Take one down and pass it around,   +    #{number-1} #{container(number-1)} of beer on the wall. \n   end end def container(number)  if number == 1    bottle   else    bottles   end endendWatch 1: Replacing Difference With Sameness It’s time to pick a pair to work on, keeping in mind go for the code that is pretty similar to each other, in other words, less differences and work towards reducing the differences. In this case is the branch 1 and the else branch. Their difference rely on  1 bottle  vs  #{number} ,  it  vs  one  and  no more  vs  #{number-1}  This change will make our code slower and more abstract, but he have to do this in order to make our code look the same. The cost of this change is execution time, but keeping both cases will cost more due to maintenance (2 very similar branches). def verse(number) case number when 0   No more bottles of beer on the wall,   +   no more bottles of beer. \n  +   Go to the store and buy some more,   +   99 bottles of beer on the wall. \n  when 1   #{number} #{container(number)} of beer on the wall,   +   #{number} #{container(number)} of beer. \n  +   Take it down and pass it around,   +   no more bottles of beer on the wall. \n  else   #{number} #{container(number)} of beer on the wall,   +   #{number} #{container(number)} of beer. \n  +   Take one down and pass it around,   +   #{number - 1} #{container(number - 1)} of beer on the wall. \n  endendWhen following the flocking rules trying to turn difference into sameness, resist the urge to volunteer changes. Limit your changes to only what the recipe calls for and see what happens Watch 2: Equivocating About Names The official definition of equivocate is to use ambiguous language so as to conceal the truth or avoid committing oneself. Sometimes we just don’t know and we have to do the best we can with the information we have at the time. We are now tackling the  it  vs  one  case, therefore we need to name the concept, create a method or function to be responsible for it, and then use it, send the message in the place of this difference. We are looking for that method name where def thing is many layers of abstraciton away. When naming, we have 3 rules:    Naming Rule  Pros  Cons    Time-boxed naming - Set a time limit and use a thesaurus to find the best name within that time  Time limited approach prevents overthinking  You'll never know less than you know right now, so a better name may emerge later; good enough names may not motivate future improvements    Intentionally bad placeholder - Pick the worst possible name (like  foo ) knowing you'll rename it later  Very fast; saves time and money  The name is terrible    Ask someone good at naming - Find a person skilled at naming and describe your problem to them  Access to expertise; the act of describing the problem may help you discover a good name yourself  Self explanatory In this case  it  and  one  are pronouns. It feels too far from the domain of the 99 Bottles song, but it also feels more correct than anything else I can think of. Let’s use pronoun by first defining the method, then making it return the else branch. After that add the pronoun method in the actual code, run tests, then add a default argument, then we add another branch to cover the 1 branch Now that else branch and 1 branch are identical and as we are getting used to this recipe the coding part becomes easier, however the naming part is the challenging.  def verse(number)  case number  when 0    No more bottles of beer on the wall,   +    no more bottles of beer. \n  +    Go to the store and buy some more,   +    99 bottles of beer on the wall. \n   when 1    #{number} #{container(number)} of beer on the wall,   +    #{number} #{container(number)} of beer. \n  +    Take #{pronoun(number)} down and pass it around,   +    no more bottles of beer on the wall. \n   else    #{number} #{container(number)} of beer on the wall,   +    #{number} #{container(number)} of beer. \n  +    Take #{pronoun(number)} down and pass it around,   +    #{number - 1} #{container(number - 1)} of beer on the wall. \n   end end def container(number) . . .  end def pronoun(number)  if number == 1    it   else    one   end endWatch 3: Deriving Names From Responsibilities We finished last lesson by picking def pronoun(number) for the  it  and  one  and it was difficult to come up with that name, it’s even more complex when we don’t know the domain. We’ll continue with the same flocking rules as previously, pick the code that are similar, remove differences, create a new method to inject in that space and remove unused code. A good trick for naming is “What is the responsibility of the method or function that I’m trying to create to replace this difference?” At least for now, the good enough name for the change on  no more  words is going to be  quantity . Watch 4: Choosing Meaningful Defaults In this section we add the  def quantity  method and play with a default argument  def quantity(number=0)  When you can, use the else branch first. def verse(number) case number when 0   No more bottles of beer on the wall,   +   no more bottles of beer. \n  +   Go to the store and buy some more,   +   99 bottles of beer on the wall. \n  else   #{number} #{container(number)} of beer on the wall,   +   #{number} #{container(number)} of beer. \n  +   Take #{pronoun(number)} down and pass it around,   +   #{quantity(number - 1)} #{container(number - 1)} of beer on the wall. \n  endenddef quantity(number=0) if number == 0   no more  else  number endenddef container(number)def pronoun(number)Watch 5: Seeking Stable Landing Points The section emphasizes the importance of consistency in code style to reduce mental load and business costs. Sandi Metz explains that consistent, similarly structured methods make code easier to read and maintain. She advises teams to adopt and follow a style guide, even if imperfect, because any consistent style is better than none. If teams can’t agree, rotate disputed styles for a month; if seniors resist, let them keep their own area but require adherence to team style elsewhere. Over time, consistency benefits everyone by highlighting real differences in code and lowering long-term costs. Watch 6: Obeying the Liskov Substitution Principle The point of Liskov is that objects have to be what they say they are. They have to behave like you expect. They can’t do anything that forces folks that interact with them to check what kind of a thing they are in order to know how to talk to them. Please notice the consistency we have in the new methods, all of them have if statements, and receive an argument number however we are doing a kind of a duck type. 🦆 Example: # Define the  duck type  role: every Contract must respond to `name`class PrivateContract def initialize(person_name)  @person_name = person_name end def name  @person_name endendclass CommercialContract def initialize(business_name)  @business_name = business_name end def name  @business_name endend# Code that works with any kind of contractdef print_contract_name(contract) puts  Contract with: #{contract. name} end# Example usageprivate_contract  = PrivateContract. new( John Doe )commercial_contract = CommercialContract. new( Acme Corporation )print_contract_name(private_contract)# =&gt; Contract with: John Doeprint_contract_name(commercial_contract)# =&gt; Contract with: Acme CorporationIn the example above, we unified the API so that both private and commercial contracts respond to the same message: . name Here is the code by fixing it from the quantity method to respond to . capitalize  def verse(number)  case number  when 0    #{quantity(number). capitalize} bottles of beer on the wall,   +    no more bottles of beer. \n  +    Go to the store and buy some more,   +    99 bottles of beer on the wall. \n   else    #{quantity(number). capitalize} #{container(number)} of beer on the wall,   +    #{number} #{container(number)} of beer. \n  +    Take #{pronoun(number)} down and pass it around,   +    #{quantity(number - 1)} #{container(number - 1)} of beer on the wall. \n   end end def quantity(number=0)  if number == 0    no more   else   number. to_s  end end def container(number) def pronoun(number)Even in a dynamically-typed language like Ruby, you should never check an object’s type just to decide what message to send. Instead, define a clear role (a duck type) and make sure every object that plays that role conforms to its API. Watch 6: Taking Bigger Steps So we’ve been through this pattern a couple of times where we turned small differences into methods, so we could send messages to make things the same. We grabbed that shape (verse method and 4 case statements) and moved it down into these new methods that we’re creating. def verse(number) case number when 0   #{quantity(number). capitalize} bottles of beer on the wall,   +   #{quantity(number)} #{container(number)} of beer. \n  +  action(number) +   99 bottles of beer on the wall. \n  else   #{quantity(number). capitalize} #{container(number)} of beer on the wall,   +   #{quantity(number)} #{container(number)} of beer. \n  +  action(number) +   #{quantity(number - 1)} #{container(number - 1)} of beer on the wall. \n  endenddef action(number) if number == 0   Go to the store and buy some more,   else   Take #{pronoun(number)} down and pass it around,   endenddef quantity(number)def container(number)def pronoun(number)Watchn 7: Discovering Deeper Abstractions We’ve almost arrived to have same code on both branches, except the last line of verse method. In our first apporach we proposed adding a new branch to if statemnt def verse(number) case number when 0   #{quantity(number). capitalize} bottles of beer on the wall,   +   #{quantity(number)} #{container(number)} of beer. \n  +  action(number) +   #{quantity(number - 1)} bottles of beer on the wall. \n  else   #{quantity(number). capitalize} #{container(number)} of beer on the wall,   +   #{quantity(number)} #{container(number)} of beer. \n  +  action(number) +   #{quantity(number - 1)} #{container(number - 1)} of beer on the wall. \n  endenddef quantity(number) if number == -1 # 👈  99 elsif number == 0    no more  else  number. to_s endendWith this change the tests are green however  -1  isn’t a valid value in the context of the song, which has to make you wonder whether things are working by accident and not really working by design. We’d better ask ourselves, what is the responsibility of the quantity method? quantity is responsible for knowing what to sing in place of a number. If there are 50, you’re going to sing “50”, if there’s 0, you’re going to sing “no more”. This is the method that represents the mapping between the value of a number and the string that you sing in its place. As the song progresses, the verse number gets decremented, except when we reach 0, it wraps back around to the top and starts over again with 99. When you’re confused, very often a good strategy is: don’t try to solve the whole problem straight away. If you can nibble away at it, solving the simple parts of the problem might make the hard ones easier. And here we already have a rule for what to do when we’re confused; it’s to try to make things more alike, even if not yet identical, using code that we’ve already written. You can think of this next verse as the successive verse. If I ask you for the successor of the letter B, you would tell me C, you wouldn’t tell me A. We think of A as the predecessor and B as a successor. I kind of like the word successor here, but we have to agree that successor means next and not necessarily next higher.  def verse(number)  case number  when 0    #{quantity(number). capitalize} bottles of beer on the wall,   +    #{quantity(number)} #{container(number)} of beer. \n  +   action(number) +    #{quantity(succesor(number))} #{container(number)} of beer on the wall. \n   else    #{quantity(number). capitalize} #{container(number)} of beer on the wall,   +    #{quantity(number)} #{container(number)} of beer. \n  +   action(number) +    #{quantity(number - 1)} #{container(number - 1)} of beer on the wall. \n   end end def succesor(number)  if number == 0    99   else   number - 1  end end def action(number) def quantity(number) def container(number) def pronoun(number)Watch 8: Depending on Abstractions Abstractions are beautiful things. They allow you to consolidate the implementation details for an idea in your code in a single place so that everybody can use it if they know its name. They give a name to those things so that you can have a conversation with people using this shortcut language, instead of having to describe the whole thing. class Bottles def song  verses(99, 0) end def verses(upper, lower)  upper. downto(lower). map { |i| verse(i) }. join( \n ) end def verse(number)   #{quantity(number). capitalize} #{container(number)} of beer on the wall,   +   #{quantity(number)} #{container(number)} of beer. \n  +  action(number) +   #{quantity(succesor(number))} #{container(succesor(number))} of beer on the wall. \n  end def succesor(number)  if number == 0    99   else   number - 1  end end def action(number)  if number == 0    Go to the store and buy some more,    else    Take #{pronoun(number)} down and pass it around,    end end def quantity(number=0)  if number == 0    no more   else   number. to_s  end end def container(number)  if number == 1    bottle   else    bottles   end end def pronoun(number)  if number == 1    it   else    one   end endendWe use the Flocking Rules to convert four concrete verse_templates into a single more abstract verse method. And along the way, we found a bunch of smaller, internal abstractions and we’ve created methods for them and named them. It’s important to ask whether this new code actually improves upon the Shameless Green variant from which we started. Most programmers do think it’s better, but you may be sad to find out that static analysis tools will score it worse. We turned one conditional into many and add 55% more code. The counterbalance of that is that there’s a lot of value in this code. What we have now, that we didn’t use to have, is a bunch of identified, named concepts. We know that 99 bottles contains a container and a pronoun and a quantity and an action, and even a successor.  This block finished the refactoring that began in previous blocks. It iteratively followed the Flocking Rules to remove differences in the verse method, and as a result unearthed abstractions that were deeply hidden within the 99 Bottles song.  It illustrated the power of the Flocking Rules to uncover sophisticated concepts, even those which cast only dim shadows in the existing code. You don’t have to understand the entire problem in order to find and express the correct abstractions—you merely apply these rules, repeatedly, and abstractions will naturally appear.  One final thought before moving on. Consider this question: If several different programmers started from Shameless Green and refactored the verse method according to the Flocking Rules, what would the resulting code look like? If you’ve guessed that everyone’s code would be identical, excepting the names used for the concepts, you’d be right. This has enormous value.  Now we’ll return to the “six-pack” problem. "
    }, {
    "id": 20,
    "url": "http://localhost:4000/2025/08/16/session-02.html",
    "title": "POOD Session 2: Test Driving Shameless Green",
    "body": "2025/08/16 - Session 2: Considering Existing Tests and Meet the Open/Closed PrincipleDate: August 16, 2025 This blog post consists in four parts:  My notes on Test Driving Shameless Green My notes on code Open/Closed principle” My notes on code Code smells talk” A Google NotebookLM link that contains 2 exercises based on the code smells video (quiz and flashcards). Key Concepts:  Aim for code that is easier to understand, then refactor.  Single responsabillity principle (SRP) How adding conditionals increases code paths exponentially.  Tolerate duplication as a temporary tradeoff for clarity.  Recognizing code smells The 24 code smells (and 2 more!) Open/Closed principle Refactor systematically by discarding and solving one at a time Test Driving Shameless Green: In this lesson, our main task was to watch Sandi Metz’s talk, study her code, and then answer six questions about it. Afterward, we turned to the book 99 Bottles to compare our answers with Sandi’s own. The real challenge, however, wasn’t just about finding the “right” answer, it was about learning how to justify our decisions. Could we explain our reasoning clearly enough to convince other programmers that our solution (or Sandi’s) was the better one? Working in a team of three, we debated each approach and practiced the art of defending design choices.  What decisions must be made before you can write this first test?I think what behavior should we test. Is it a number that adds another number? Is it a boolean? In this case is a concatenated string. Also, what methods should be publicly available? What is the API look like? (Bearing in mind that we should name methods after the concept they represent rather than how they currently behave. ) What parameters are we going to allow? And what method for? Maybe, which test to write first: entire song, multiple verses, or single verse? (Think in simplicity) Arrange, Act, Assert We shouldn’t overthink these decisions initially  Is it better to interpolate ‘number’ or to add a conditional?I think we should aim for understability first, therefore the conditional may be a good start. Once we deepen our domain understanding we can provide more flexibility with the interpolation. Sandi’s suggestion was to interpolate over conditional. As the test gets more specific the code will become more general.  Why not just interpolate a conditional?The code we are writing is the following: class Bottles def verse(number)   #{number} bottles of beer on the wall,   +   #{number} bottles of beer. \n  +   Take one down and pass it around,   +   #{number - 1} botle#{ s  if number - != 1} of beer on the wall. \n  endendI think this version is hard to understand at a glance, you gotta read it more than once and remembering that the code you write is many times read than written, I point to understability first. Sandi proposed a case statement where the verses are almost identical but vary by the “number” variable. Again, it’s much simpler and easier to follow.  Why is duplication in #verse acceptable, but not in #verses?I think because of the Single Responsibility principle, if we add duplication in #verses we are mixing tasks between those methods. One if for returning one verse at once and the other is for passing the “number” variable as iteration.  What should the expectation in the song test be?The song method is the main subject of this exercise, and i think of it as the final result of the code so even when it seems tedious, writing down all the 99 verses is the way to test that code is working properly. class Bottles def song  verses(99, 0) end def verses(upper, lower)  upper. downto(lower). map { |i| verse(i) }. join( \n ) end def verse(number)  case number  when 0    No more bottles of beer on the wall, no more bottles of beer. \nGo to the store and buy some more, 99 bottles of beer on the wall. \n   when 1    1 bottle of beer on the wall, 1 bottle of beer. \nTake it down and pass it around, no more bottles of beer on the wall. \n   when 2    2 bottles of beer on the wall, 2 bottles of beer. \nTake one down and pass it around, 1 bottle of beer on the wall. \n   else    #{number} bottles of beer on the wall, #{number} bottles of beer. \nTake one down and pass it around, #{number-1} bottles of beer on the wall. \n   end endend What design flaw forces you to write this last annoying test?The flaw is that song does not accept any arguments, it always produces the full song from 99 to 0. The song method is closed to extension. — Quiz answers —  &gt; What decisions must be made before you can write this first test? (Video 1:55)  &gt; You have to make lots of decisions! For example, you must design your API, decide on the classes you plan to create and the messages to which they respond, and determine the required inputs and expected outputs for each method.  &gt; (99 Bottles book section 2. 2)  &gt; Is it better to interpolate 'number' or to add a conditional? (Video 2:50)  &gt; It is better to interpolate the value of the number into the verse string rather than to add a new conditional.  &gt; (99 Bottles book section 2. 2)  &gt; We tend to discount the complexity of adding a conditional where none existed before, but beware!  &gt; A method containing a single two-branch conditional has two execution paths, that is, there are two separate paths through the code.  &gt; If you add a second two-branch conditional, you create four possible execution paths.  &gt; Adding yet another two-branch conditional (now you have three two-branch conditionals) results in eight execution paths, not six.  &gt; The number of execution paths increases exponentially, calculated as the number of branches raised to the power of the number of conditionals.  &gt; For example, 2 branches × 10 conditionals = 1,023 possible paths!  &gt; There's no way a method like this has a complete test suite.  &gt; Why not just interpolate a conditional?!? (Video 4:08)  &gt; Interpolating a conditional to decide whether or not to add an 's' to  bottle  adds complexity without creating a useful abstraction. It's better to duplicate for now and wait for more information from future tests.  &gt; Refactor only when you are confident about your abstractions. Until then, tolerate duplication as a temporary tradeoff for clarity.  &gt; (99 Bottles book section 2. 2)  &gt; Why is duplication in #verse acceptable, but not in #verses? (Video 6:24)  &gt; The Single Responsibility Principle says each method should do one thing well. The #verse method’s job is to produce correct lyrics. The #verses method’s job is to call #verse for each verse and join the results.  &gt; Duplication inside #verse is fine because it’s encapsulated — it’s invisible to other parts of the app. But duplicating that logic elsewhere (like in #verses) would violate SRP.  &gt; (99 Bottles book section 2. 6)  &gt; What should the expectation in the song test be? (Video 7:44)  &gt; The whole song.  &gt; (99 Bottles book section 2. 10)  &gt; The song test is annoying! You're forced to write that long expectation because of a design flaw in the code. Speculate about what that flaw might be. (Video 9:45)  &gt; This was just to make you think! The answer will become clear as the course progresses. :-) Meet the Open/Closed Principle: Block 3 covers two new ideas: the Open/Closed Principle and Code Smells. Here, we were tasked to watch short videos (~4 mins) that showed us design principles for the next code exercise. Watch #1: Listening to Change What we do most of us do for a living is, we change code. And what that means is the cost of code is in the reading. Writing code happens only once, but reading happens over and over and over. Have you ever done that thing where you’re working on some code and you add code for a feature that’s not yet been asked for but that you guess will arrive in the future? How’d that turn out? Dead code, whether it’s obsolete or anticipatory, adds costs, if the cost of code is in the reading. That last note remineded me of this Jeremy Smith tweet  Things I’ve learned the hard way about web development:    automated testing is always worth it in the long-run  limit your dependencies where possible, and keep up with dependency upgrades  don’t write code in anticipation of future needs  integrate code changes often, no long feature branches  deploy schema, data, and code changes separately whenever possible  limit your work in progress  make sure you have monitoring in place so that, when things go wrong, you know about it first  don’t save the toughest, most unclear part of a project for last  if you think you might miss a deadline, communicate that as early as possible  address common production exceptions so you don’t lose important rare ones in the noise  anticipate product usage changes and seasonality and account for it in infrastructure changes and feature releases The rule is: the sum of the costs incurred by guessing far outweighs the money you save by very occasionally being right. So what should you do? The rule is every bit of code you write should be for a feature that is currently being used. Here is the challenge: Every place, the song currently says six bottles, it should instead say 1 six-pack. We could fulfill this new requirement by adding two more branches to the existing case statement but that would lead to 4 branches and eventually to unmaintainable code. Things that change, do. And what I mean by that is that the stuff that changes, the things that change at the highest rate in your application often are concepts or ideas that are core to your domain. And so the most changeable things are the most valuable to your business.  We need to make it more amenable to change, which means we need OO. Watch #2: Starting With the Open/Closed Principle Requirement is: change the word from “six bottles” to “1 six-pack”. We gotta make the code open. Open is the “O” in SOLID. This principle says that when you’re adding code to fulfill a new requirement, you should not simultaneously change existing code. Think of it, what it would mean for your code, if every time you went to write the code to fulfill a new requirement, the existing code was open to the new code you wanted to write. This will imply:  Tests continue to run green Almost impossible to break and existing feature You can write brand new tests Implement new feature by just adding code. Not adjusting current code. Diagram for checking if code is open:  A very strict definition of openness for this problem. The current code is open to new requirement if you can implement that requirement without changing anything in any existing class. Do you know how to make it open? if you can’t instantly describe the transformation that will bend this code into a shape that’s open to the new requirement, you don’t really know how to do it. (This is very common) We need a technique to find code smells that we’ll see in the next section. Watch #3: Recognizing Code Smells Have you ever been defeated by refactoring? You try and make a change, and you dive in and change a bunch of code, and you break a bunch of tests, and you thrash around with a machete, you finally throw up your hands and do a git reset --hard? Why? Because code has a lots of different wrong parts. If you try to fix everything at once is easy to get really in over you head. It would be much easier to improve code if you could reach in and grab a single thread and tug and fix that one piece until it was correct, leaving everything else unchanged. Code smells are things that might be wrong with your code. They’re the names of code arrangements that could be a problem. They are 24, listed in the book (chapter 3), Martin Fowler’s refactoring.  Code smelss categories (5):    Bloaters - Things that increase code volume unnecessarily    Long Function  Self explanatory    Large Class  Self explanatory    Data Clumps  Two or more pieces of data that always come together should be wrapped in an object    Long Parameter List  Self explanatory    Primitive Obsession  Passing primitives (String, Integer) around with behavior instead of wrapping them in objects    Abusers - Things you could do in OO but should be careful with    Repeated Switches  Same conditional pattern appearing multiple times `case statements`; branches should be objects    Refused Bequest  Subclasses that don't implement all superclass methods and throw exceptions (related to inheritance)    Alternative Classes with Different Interfaces  Different classes doing the same thing with different method names    Temporary Field  Using temporary variables to cache results or name operations; consider using methods    Global Data  Data you don't own that others can change    Mutable Data  Prefer immutable objects when possible    Preventers - Code that prevents easy changes    Divergent Change  One object changes for different reasons; should be split into multiple objects    Shotgun Surgery  One single change requires modifications in many places; should be consolidated    Mysterious Name  Self explanatory    Dispensables - Arbitrary additions that increase length without adding value    Lazy Element (lazy class)  Object not doing enough to justify its existence    Speculative Generality  Writing code for imagined requirements; when you write code for future features    Data Class  Class with only data; behavior should be combined with data    Duplicated Code  Self explanatory    Comments  Explaining code instead of writing self-explanatory code    Loops  Use Map/Filter instead of writing loops    Couplers - Objects bound together by messages    Feature Envy  Object interacting too much with another object; may belong together    Insider Trading  Objects passing private implementation details    Message Chains  Sending messages through multiple objects in sequence (Message. where(sender:  Joe ). count( OK ))    Middle Man  Object only forwarding messages without adding value Code smells map to curative refactorings. Each of those refactorings comes with a recipe, a step-by-step guide about how to do it. you can identify code smells, then go look up the refactoring recipes that are curative for it, select one, and then follow the step-by-step directions to get rid of that smell. Refactoring is to alter the arrangement of code without changing its behavior. (refactoring should happen all under green because tests ought your back) Watch #4: Identifying the Best Point of Attack Requirement is: change the word from “six bottles” to “1 six-pack”. class Bottles def song  verses(99, 0) end def verses(upper, lower)  upper. downto(lower). map { |i| verse(i) }. join( \n ) end def verse(number)  case number  when 0    No more bottles of beer on the wall, no more bottles of beer. \nGo to the store and buy some more, 99 bottles of beer on the wall. \n   when 1    1 bottle of beer on the wall, 1 bottle of beer. \nTake it down and pass it around, no more bottles of beer on the wall. \n   when 2    2 bottles of beer on the wall, 2 bottles of beer. \nTake one down and pass it around, 1 bottle of beer on the wall. \n   else    #{number} bottles of beer on the wall, #{number} bottles of beer. \nTake one down and pass it around, #{number-1} bottles of beer on the wall. \n   end endendWe have repeated switches, duplicated code, long function, maginc number (have meaning but lack fo name), and concealed concept (duplication of concepts that are represented by different implementations of code). We have at least 5 code smells and we gotta choose just one. And probably discard some of the code smells as candidates, since it’s common that some code smells create other code smells. We throw out long function and repeated switches. that leaves magic number, concealed concept and duplicated code. We’ll tackle concealed concept. The core idea here is that, if we isolate the thing we want to vary, it’s then possible to make new variants without editing existing code. And that’s what it means to be open. Watch #5: Refactoring Systematically You can think of refactoring versus adding new features as two different programming modes.    In refactoring mode, you move code around, but you don’t touch a test. The test run merrily along unchanged, and you should never see red.     In adding new features mode, the first thing you do is write a failing test; you should see red right away. Then you can write the code to make that test pass.     And if the code base you’re working on is open to your new feature, then you can implement that feature without altering any existing code.  When refactoring tests break:    You’re not really refactoring. You’re not rearranging code without changing behavior. You’re actually rearranging code while changing behavior.     The tests are flawed. Tests are tightly coupled to current implementation of the code.  Notes on Sandi Metz’s talk (Get a Whiff of This (code smells talk)”)::    Kent Beck created the term “code smells” and with Martin Fowler, both wrote the chapter 3 of the book Refactoring.     They have been in this since 1990.     Try to mention 5 code smells? Most people can’t.     Once you give a complex idea a name, we can talk to each other in an unambiguous way without having miscommunications.     A code smells might indicate a problem, not that it is a problem.     Sandi lists the 5 categories of code smells, bloaters, abusers, code change preventers, dispensables and couplers— they can be found above in a table.     If ugly code doesn’t change then it cost no money.     In OO we have data + behaviour in objects, not only data.     Don’t write code that you think will be needed later. Don’t guess! The times you are right have to outweight the time you’re wrong.     The code is written once and read thousands therefore we cost money reading code. Make it clear     If you add the code smell speculative generality you increase levels of abstraction, which is indirection in turn difficult to understand.     Every code smell maps to its own curative refactoring recipe     The next PDF includes a cross reference of Martin Fowler refactoring to each code smell  Code smells Talk exercises Google NotebookLM: In the following link you’ll find 50 flashcards and a 10 questions-quiz based on Sandi’s video “Get a Whiff of This (code smells)” It’s a Google NotebookLM link to exercise Hope you can learn something new ! Here is an sample how the flashcards look like and my result of the exercises: Flashcards on Get a Whiff of This by Sandi Metz (code smells) talk:   Get a Whiff of This by Sandi Metz (code smells) talk quiz result:   "
    }, {
    "id": 21,
    "url": "http://localhost:4000/2025/08/16/99-bottles-of-oop.html",
    "title": "99 bottles of OOP",
    "body": "2025/08/16 -  Rediscovering Simplicity Test Driving Shameless Green Unearthing Concepts Practicing Horizontal Refactoring Separating Responsibilities Achieving Openness Manufacturing Intelligence Developing a Programming Aesthetic Reaping the Benefits of DesignIntroduction. : Writing code is the process of working your way to the next stable end point, not the end point itself. You don’t know the answer in advance, but instead, you are seeking it. This book documents every step down every path of code, and so provides a guided-tour of the decisions made along the way. It not only shows how good code looks when it’s done, it reveals the thoughts that produced it. Rediscovering Simplicity: Experience has taught you that most code will someday change, and you’ve begun to craft it in anticipation of that day. Complexity seems both natural and inevitable. Where you once optimized code for understandability, you now focus on its changeability. Your code is less concrete but more abstract -you’ve made it initially harder to understand in hopes that it will ultimately be easier to maintain. OOD doesn’t claim to be free; it merely asserts that its benefits outweigh its costs. Design decisions inevitably involve trade-offs. There’s always a cost. For example, if you’ve duplicated a bit of code in many places, the Don’t Repeat Yourself (DRY) principle tells you to extract the duplication into a single common method and then invoke this new method in place of the old code. DRY is a great idea, but that doesn’t mean it’s free. The price you pay for DRYing out code is that the invoker of the new method no longer knows the result, only the message it should send. If you’re willing to pay this price, that is, you are willing to be ignorant of the actual behavior, the reward you reap is that when the behavior changes, you need alter your code in only one place. Example: # before DRYclass Invoice def total_in_cents  (line_items. sum(&amp;:price) * 100). to_i end def discount_in_cents  (discount. amount * 100). to_i endend# after DRYclass Invoice def total_in_cents  convert_to_cents(line_items. sum(&amp;:price)) end def discount_in_cents  convert_to_cents(discount. amount) end private def convert_to_cents(amount)  (amount * 100). to_i endend   total_in_cents no longer shows how the conversion happens.     Whoever calls total_in_cents only knows: “I send a message convert_to_cents” they don’t directly know that it multiplies by 100 and converts to integer.     So if later someone asks: “Wait, does this return a float or an integer?” — you can’t see that directly in the total_in_cents method anymore. You must chase down into convert_to_cents to know.  Did you divide one large class into many small ones? You can now reuse the new classes independently of one another, but it’s no longer obvious how they fit together for the original case. Have you injected a dependency instead of hard-coding the class name of a collaborator? The receiver can now freely depend on new and previously unforeseen objects, but it must remain ignorant of their actual class. The examples above change code by increasing its level of abstraction. DRYing out code inserts a level of indirection between the place that uses behavior and the place that defines it. Breaking one large class into many forces the creation of something new to embody the relationship between the pieces. Injecting a dependency transforms the receiver into something that depends on an abstract role rather than a concrete class. Design is thus about picking the right abstractions. If you choose well, your code will be expressive, understandable and flexible.      Benefits   Cons       DRY (Don't Repeat Yourself)         • Eliminates code duplication    • Single source of truth for behavior    • Easier maintenance - change in one place    • Reduces bugs from inconsistent implementations         • Adds level of indirection between usage and definition    • Can make code harder to understand    • May create premature abstractions    • Debugging requires jumping between files/methods        Dependency Injection         • Enables flexible composition with unforeseen objects    • Improves testability with mock objects    • Reduces coupling between classes    • Supports polymorphism and duck typing         • Receiver must remain ignorant of actual class types    • Increases complexity of object construction    • Can make dependencies less obvious    • Requires abstract thinking about roles vs. classes        Single Responsibility Principle (Divide Large Classes)         • Classes can be reused independently    • Easier to test individual components    • More focused, cohesive responsibilities    • Simpler to understand each piece in isolation         • No longer obvious how pieces fit together    • Requires new abstractions to coordinate parts    • Can lead to over-engineering    • May scatter related logic across multiple files     However, if you get the abstractions wrong, your code will be convoluted, confusing, and costly. Unfortunately, abstractions are hard, and even with the best of intentions, it’s easy to get them wrong. Early abstractions are often not quite right, and therefore they create a catch-22. You can’t create the right abstraction until you fully understand the code, but the existence of the wrong abstraction may prevent you from ever doing so. This suggests that you should not reach for abstractions, but instead, you should resist them until they absolutely insist upon being created. This book is about finding the right abstraction. 1. 1. Simplifying Code: The code you write should meet two often-contradictory goals. It must remain concrete enough to be understood while simultaneously being abstract enough to allow for change. Code can range on a spectrum from very concrete (one long, detailed procedure) to very abstract (many tiny classes and methods). The best solutions usually aren’t at the extremes but somewhere in the middle, where the code is both understandable and easy to change. The programmer’s job is to find that balance. This section discusses four different solutions to the “99 Bottles of Beer” problem. 1. 1. 1. Incomprehensibly Concise: class Bottles def song  verses(99, 0) end def verses(hi, lo)  hi. downto(lo). map {|n| verse(n) }. join( \n ) end def verse(n)   #{n == 0 ? 'No more' : n} bottle#{'s' if n != 1}  +    of beer on the wall,   +   #{n == 0 ? 'no more' : n} bottle#{'s' if n != 1} of beer. \n  +   #{n &gt; 0 ?  Take #{n &gt; 1 ? 'one' : 'it'} down and pass it around    :  Go to the store and buy some more },   +   #{n-1 &lt; 0 ? 99 : n-1 == 0 ? 'no more' : n-1} bottle#{'s' if n-1 != 1} +    of beer on the wall. \n  endendThis first solution embeds a great deal of logic into the verse string. The code above performs a neat trick. It manages to be concise to the point of incomprehensibility while simultaneously retaining loads of duplication. Consistency (in conditionals) The style of the conditionals is inconsistent. Most use the ternary form, other statements are made conditional by adding a trailing if. Every time the style of the conditionals changes, the reader has to press a mental reset button and start thinking anew. Duplication The code duplicates both data and logic. Having multiple copies of the strings “of beer” and “on the wall” isn’t great, but at least string duplication is easy to see and understand. Logic, however, is harder to comprehend than data, and duplicated logic is doubly so. Names The most obvious point to be made about the names in the verse method is that there aren’t any. The verse string contains embedded logic. Each bit of logic serves some purpose, and it is up to you to construct a mental map of what thesepurposes might be. This code would be easier to understand if it did not place that burden upon you. Creating a method requires identifying the code you’d like to extract and deciding on a method name. This, in turn, requires naming the concept, and naming things is just plain hard. In the case above, it’s especially hard. This code not only contains many hidden concepts, but those concepts are mixed together. Combining many ideas into a small section of code makes it difficult to isolate and name any single concept. When you first write a piece of code, you obviously know what it does. Therefore, during initial development, the price you pay for poor names is relatively low. However, code is read many more times than it is written, and its ultimate cost is often very high and paid by someone else. Code is also charged with doing what it’s supposed to do now as well as being easy to alter so that it can do more later.  How difficult was it to write? How hard is it to understand? How expensive will it be to change?Code is easy to understand when it clearly reflects the problem it’s solving, and thus openly exposes that problem’s domain If this solution would be openly exposed the “99 Bottles” domain, a brief glance at the code would answer these questions:  How many verse variants are there? Which verses are most alike? In what way? Which verses are most different, and in what way? What is the rule to determine which verse comes next?These questions reflect core concepts of the problem, yet none of their answers are apparent in this solution. The number of variants, the difference between the variants, and the algorithm for looping are distressingly obscure. This code does not reflect its domain, and therefore you can infer that it was difficult to write and will be a challenge to change. 1. 1. 2. Speculatively General: This next solution errs in a different direction. It does many things well but can’t resist indulging in unnecessary complexity. class Bottles NoMore = lambda do |verse|   No more bottles of beer on the wall,   +   no more bottles of beer. \n  +   Go to the store and buy some more,   +   99 bottles of beer on the wall. \n  end LastOne = lambda do |verse|   1 bottle of beer on the wall,   +   1 bottle of beer. \n  +   Take it down and pass it around,   +   no more bottles of beer on the wall. \n  end Penultimate = lambda do |verse|   2 bottles of beer on the wall,   +   2 bottles of beer. \n  +   Take one down and pass it around,   +   1 bottle of beer on the wall. \n  end Default = lambda do |verse|   #{verse. number} bottles of beer on the wall,   +   #{verse. number} bottles of beer. \n  +   Take one down and pass it around,   +   #{verse. number - 1} bottles of beer on the wall. \n  end def song  verses(99, 0) end def verses(finish, start)  (finish). downto(start). map {|verse_number|   verse(verse_number) }. join( \n ) end def verse(number)  verse_for(number). text end def verse_for(number)  case number  when 0 then Verse. new(number, &amp;NoMore)  when 1 then Verse. new(number, &amp;LastOne)  when 2 then Verse. new(number, &amp;Penultimate)  else Verse. new(number, &amp;Default)  end endendclass Verse attr_reader :number def initialize(number, &amp;lyrics)  @number = number  @lyrics = lyrics end def text  @lyrics. call self endendTo summarize, sending verse(number) to an instance of Bottles invokes verse_for(number), which uses the value of number to select the correct lambda on which to create and return an instance of Verse. The verse method then sends text to the returned Verse, which in turn sends call to the lambda, passing self as an argument. This invokes the lambda, which may or may not actually use the argument that was passed. This example answers better the next questions in comparison to first example:    How many verse variants are there?There are four verse variants (look at the constants).     Which verses are most alike? In what way?Verses 3-99 are most alike (as evidenced by the fact that all are produced by the Default variant).     Which verses are most different? In what way?Verses 0, 1 and 2 are clearly different from 3-99, although it’s not obvious in what way.     What is the rule to determine which verse should be sung next?Buried deep within the NoMore lambda is a hard-coded “99,” which might cause one to infer that verse 99 follows verse 0.  Now, the value/cost questions:    How difficult was it to write?There’s far more code here than is needed to pass the tests. This unnecessary code took time to write.     How hard is it to understand?The many levels of indirection are confusing. Their existence implies necessity, but you could study this code for a long time without discerning why they are needed.     How expensive will it be to change?The mere fact that indirection exists suggests that it’s important. You may feel compelled to understand its purpose before making changes.  As you can see from these answers, this solution does a good job of exposing core concepts, but does a bad job of being worth its cost. The code does two basic things. First, it defines templates for each kind of verse (lines 2-28), and second, it chooses the appropriate template for a specific verse number and renders that verse’s lyrics (lines 39-63). Notice that the verse templates contain all of the information needed to answer the domain questions. But it’s not the templates that are costly; it’s the code that chooses a template and renders the lyrics for a verse. This choosing/rendering code is overly complicated 1. 1. 3. Concretely Abstract: This solution valiantly attempts to name the concepts in the domain: class Bottles def song  verses(99, 0) end def verses(bottles_at_start, bottles_at_end)  bottles_at_start. downto(bottles_at_end). map do |bottles|   verse(bottles)  end. join( \n ) end def verse(bottles)  Round. new(bottles). to_s endendclass Round attr_reader :bottles def initialize(bottles)  @bottles = bottles end def to_s  challenge + response end def challenge  bottles_of_beer. capitalize +     + on_wall +  ,   +  bottles_of_beer +  . \n  end def response  go_to_the_store_or_take_one_down +  ,   +  bottles_of_beer +     + on_wall +  . \n  end def bottles_of_beer   #{anglicized_bottle_count} #{pluralized_bottle_form} of #{beer}  end def beer   beer  end def on_wall   on the wall  end def pluralized_bottle_form  last_beer? ?  bottle  :  bottles  end def anglicized_bottle_count  all_out? ?  no more  : bottles. to_s end def go_to_the_store_or_take_one_down  if all_out?   @bottles = 99   buy_new_beer  else   lyrics = drink_beer   @bottles -= 1   lyrics  end end def buy_new_beer   Go to the store and buy some more  end def drink_beer   Take #{it_or_one} down and pass it around  end def it_or_one  last_beer? ?  it  :  one  end def all_out?  bottles. zero? end def last_beer?  bottles == 1 endendThis solution is characterized by having many small methods. This is normally a good thing, but somehow in this case it’s gone badly wrong. Have a look at how this solution does on the domain questions:    How many verse variants are there?It’s almost impossible to tell.     Which verses are most alike? In what way?Ditto.     Which verses are most different? In what way?Ditto.     What is the rule to determine which verse should be sung next?Ditto.  Value/cost questions.    How difficult was it to write?Difficult. This clearly took a fair amount of thought and time.     How hard is it to understand?The individual methods are easy to understand, but despite this, it’s tough to get a sense of the entire song. The parts don’t seem to add up to the whole.     How expensive will it be to change?While changing the code inside any individual method is cheap, in many cases, one simple change will cascade and force many other changes.  It’s obvious that the author of this code was committed to doing the right thing, and that they carefully followed the Red, Green, Refactor style of writing code. It looks as though these strings were refactored into separate methods at the first sign of duplication. DRY reduces change costs by eliminating duplication, but increases understanding costs through indirection. Use DRY when the savings from easier maintenance outweigh the complexity of following abstract layers. The beer method centralizes the drink name in one location. To change from “beer” to “Kool-Aid,” you only modify line 42, avoiding scattered string updates throughout the codebase. But then look at these other method names, and how many time they’re used: def bottles_of_beerdef buy_new_beerdef drink_beerdef last_beer?This small change in requirements forces a change in many places, which is exactly the problem DRY promises to avoid. When you name a method beer that returns “beer,” you tie the method name to its current implementation. This breaks when you change the implementation to return “Kool-Aid. ” You should name methods not after what they do, but after what they mean, what they represent in the context of your domain. The method should be called beverage because that’s what it represents in the song’s context - one level of abstraction higher than the specific implementation. # fromdef beverage  beer end# to:def beverage  Kool-Aid endTherefore, one lesson to be gleaned from this solution is that you should name methods after the concept they represent rather than how they currently behave. However, notice that even if you edited the code to improve every method name, this code still isn’t quite right. Changing the name of the beer method to beverage makes it easy to replace the string “beer” with the string “Kool-Aid” but does nothing to improve this code’s score on the domain questions. 1. 1. 4. Shameless Green: None of the solutions shown thus far do very well on the value/cost questions. First example (Incomprehensibly Concise), cares only for terseness (brevity). Second example (Speculatively General) tries for extensibility but achieves unwarranted complexity (too much lambdas usage). The heart of the third example (Concretely Abstract) is in the right place, but it can’t get its feet out of the mud (too many methods, difficult to follow). Speculatively General and Concretely Abstract were both written with an eye toward reducing future costs. The failure here is not bad intention—it’s insufficient patience.  This next example is patient and so provides an antidote for all that has come before. class Bottles def song  verses(99, 0) end def verses(upper, lower)  upper. downto(lower). map {|i| verse(i)}. join( \n ) end def verse(number)  case number  when 0    No more bottles of beer on the wall,   +    no more bottles of beer. \n  +    Go to the store and buy some more,   +    99 bottles of beer on the wall. \n   when 1    1 bottle of beer on the wall,   +    1 bottle of beer. \n  +    Take it down and pass it around,   +    no more bottles of beer on the wall. \n   when 2    2 bottles of beer on the wall,   +    2 bottles of beer. \n  +    Take one down and pass it around,   +    1 bottle of beer on the wall. \n   else    #{number} bottles of beer on the wall,   +    #{number} bottles of beer. \n  +    Take one down and pass it around,   +    #{number-1} bottles of beer on the wall. \n   end endendThe most immediately apparent quality of this code is how very simple it is. The code is gratifyingly easy to comprehend. Domain questions.    How many verse variants are there?Clearly, four.     Which verses are most alike? In what way?3-99, where only the verse number varies.     Which verses are most different? In what way?0, 1 and 2 are different from 3-99, though figuring out how requires parsing strings with your eyes.     What is the rule to determine which verse should be sung next?This is still not explicit. The 0 verse contains a deeply buried, hard-coded 99.  Value/cost questions:    How difficult was this to write?It was easy to write.     How hard is it to understand?It is easy to understand.     How expensive will it be to change?It will be cheap to change. Even though the verse strings are duplicated, if one verse changes it’s easy to keep the others in sync.  By the criteria that have been established, Shameless Green is clearly the best solution, yet almost no one writes it. Most programmers have a powerful urge to do more, but sometimes it’s best to stop right here. When you DRY out duplication or create a method to name a bit of code, you add levels of indirection that make it more abstract. In theory these abstractions make code easier to understand and change, but in practice they often achieve the opposite. One of the biggest challenges of design is knowing when to stop, and deciding well requires making judgments about code. 1. 2. Judging Code: You judge code constantly. Writing code requires making choices; the choices you make reflect personal, internalized criteria. 1. 2. 1. Evaluating Code Based on Opinion: Just as “Everybody complains about the weather but nobody does anything about it”, everyone has an opinion about what good code looks like, but those opinions usually don’t tell us what action to take to create it. Here are a few definitions of clean code.  I like my code to be elegant and efficient.  — Bjarne Stroustrupinventor of C++  Clean code is … full of crisp abstractions …  — Grady Boochauthor of Object Oriented Analysis and Design with Applications  Clean code was written by someone who cares.  — Michael Feathersauthor of Working Effectively with Legacy Code Your own definition probably follows along these same lines. Any pile of code can be made to work; good code not only works, but is also simple, understandable, expressive and changeable. The problem with these definitions is that although they accurately describe how good code looks once it’s written, they give no help with achieving this state, and provide little guidance for choosing between competing solutions. Since form follows function, good code can also be defined simply, and somewhat circularly, as that which provides the highest value for the lowest cost. Our sense of elegance, expressiveness and simplicity is an outgrowth of our experiences when reading and modifying code. Code that is easy to understand and a pleasure to extend naturally feels simple and elegant. 1. 2. 2. Evaluating Code Based on Facts: Measures that rise to become metrics are backed by research that has stood the test of time. They’ve been scrutinized by many people over many years. You can think of metrics as crowd-sourced opinions about the quality of code. This section examines three different metrics: Source Lines of Code, Cyclomatic Complexity, and ABC Source Lines of Code This one number has been used to predict the total effort needed to develop software, to measure the productivity of those who write it, and to predict the cost of maintaining it. The metric has the advantage of being easily garnered and reproduced, but suffers from many flaws. Using SLOC to predict the development effort needed for a new project is done by counting the SLOC of existing projects for which total effort is known, deciding which of those existing projects the new project most resembles, and then running a cost estimation model to make the prediction. Measuring programmer productivity by counting lines of code assumes that all programmers write equally efficient code. While the cost of maintenance is related to the size of an application, the way in which code is organized also matters. It is cheaper to maintain a well-designed application than it is to maintain a pile of spaghetti-code. Cyclomatic Complexity In 1976, Thomas J. McCabe, Sr. published “A Complexity Measure”:  What is needed is a mathematical technique that will provide a quantitative basis for modularization and allow us to identify software modules that will be difficult to test or maintain. Think of this algorithm as a little machine that ponders your code and then maps out all the possible routes through every combination of every branch of every conditional. A method with many deeply nested conditionals would score very high, while a method with no conditionals at all would score 0. Cyclomatic complexity neither predicts application development time nor measures programmer productivity. Cyclomatic complexity sounds great, and it’s easy to see that it could be useful, but it views the world of code through a narrow lens. Assignments, Branches and Conditions (ABC) Metric The problem with cyclomatic complexity is that it doesn’t take everything into account. Code does more than just evaluate conditions; it also assigns values to variables and sends messages. These things add up, and as you do more and more of each, your code becomes increasingly difficult to understand. In 1997, twenty-one years after the unveiling of cyclomatic complexity, Jerry Fitzpatrick published “Applying the ABC Metric to C, C++, and Java”. His ABC stands for assignments, branches and conditions, where:  Assignments is a count of variable assignments.  Branches counts not branches of an if statement (as one could forgivably infer) but branches of control, meaning function calls or message sends.  Conditions counts conditional logic. ABC is a measure of complexity. Highly complex code is difficult to understand and change, therefore ABC scores are a proxy for code quality. High scores suggest that code will be hard to test and expensive to maintain. Summary     Step   Principle   Description       1   Start Shameless Green   Write the simplest code that works, even if it has duplication. Don't try to be clever or anticipate future needs.      2   Tolerate Duplication   Let duplicate code exist until you fully understand the problem domain. Duplication is often better than the wrong abstraction.      3   Resist Premature Abstraction   Don't create abstractions until they  absolutely insist upon being created.   Wait until the pattern becomes obvious and painful.      4   Name for the Domain, Not Implementation   When you do abstract, name methods/classes after what they represent in your problem space (beverage not beer), not their current behavior.      5   Optimize for Change, Not Cleverness   Make code easy to understand and modify by future you. Simple, clear code beats concise, clever code every time.      6   Ask the Domain Questions   Before changing anything, evaluate if your code clearly reveals: How many variants exist? Which parts are most alike/different? What are the core rules and patterns?      7   Ask the Value/Cost Questions   For any solution, honestly assess: How difficult was it to write? How hard is it to understand? How expensive will it be to change?      The Golden Rule: If your code doesn't clearly answer the domain questions or fails the value/cost test, step back toward simplicity. The right abstractions will emerge naturally when you understand the problem deeply enough.   Test Driving Shameless Green: The Shameless Green solution consists of intention-revealing, working software, and is the result of writing simple code to pass a series of presupplied tests. The provenance of the code that was written in Chapter 1 is obvious, but the tests appeared without explanation. It is now time to take a step back, and investigate how to create tests that lead to Shameless Green. 2. 1. Understanding Testing: The practice of writing tests before writing code became known as test-driven development(TDD). In its simplest form, TDD works like this:    Write a test. Because the code does not yet exist, this test fails. Test runners usually display failing tests in red.     Make it run. Write the code to make the test pass. Test runners commonly display passing tests in green.     Make it right. Each time you return to green, you can refactor any code into a better shape, confident that it remains correct if the tests continue to pass.  The ideas of testing, and of testing first, have won the hearts and minds of programmers. However, a commitment to writing tests doesn’t make this easy. TDD presents a never-ending challenge. You must repeatedly decide which test to write next, how to arrange code so that the test passes, and how much refactoring to do once it does. Each decision requires judgment and has consequences. If your TDD judgment is not yet fully developed, it’s reasonable to temporarily adopt that of a master. Here’s an excellent guiding principle:  Quick green excuses all sins. — Kent Beck Green means safety. Green indicates that, at least as evidenced by the tests at hand, you understand the problem. Green is the wall at your back that lets you move forward with confidence. Getting to green quickly simplifies all that follows. Because the initial goal is more about reaching green than writing perfect code, the refactoring step sometimes removes duplication and other times retains it. The plan is to create tests that thoroughly describe the “99 Bottles” problem, and then to solve the problem with the implementation known as Shameless Green. The Shameless Green solution strives for maximum understandability but is generally unconcerned with changeability This chapter concentrates on creating the tests and writing simple code to pass them. Future chapters refactor the resulting code to improve the design. 2. 2. Writing the First Test: The first test is often the most difficult to write. At this point, you know the least about whatever it is you intend to do. Your problem is a big, fuzzy, amorphous blob, and it’s challenging to reach in and carve off a single piece. It feels important to choose well, because where you start informs how you’ll proceed, and ultimately determines where you’ll end. In the beginning, you have ideas about the problem but actually know very little. Your ideas may turn out to be correct, but it’s just as possible that time will prove them wrong. You can’t figure out what’s right until you write some tests, at which time you may realize that the best course of action is to throw everything away and start over. Therefore, the purpose of some of your tests might very well be to prove that they represent bad ideas. Learning which ideas won’t work is forward progress, however disappointing it may be in the moment. So while it is important to consider the problem and to sketch out an overall plan before writing the first test, don’t overthink it. If you were to sketch out a public Application Programming Interface (API) for “99 Bottles,” it might look like this:  verse(n) Return the lyrics for the verse number n verses(a, b) Return the lyrics for verses numbered a through b song Return the lyrics for the entire songThis API allows others to request a single verse, a range of verses, or the entire song. Now that you have a plan for the API, there are a number of possibilities for the first test. You could write a test for the entire song, for a series of contiguous verses, or for any single verse. Let’s begin by testing a single verse: class BottlesTest &lt; Minitest::Test def test_the_first_verse  expected =    99 bottles of beer on the wall,   +    99 bottles of beer. \n  +    Take one down and pass it around,   +    98 bottles of beer on the wall. \n   assert_equal expected, Bottles. new. verse(99) endendThe simple test above assumes a Bottles class with a verse(n) method that returns the 99th verse when called with 99. This test, like all tests, contains three parts:  Setup Create the specific environment required for the test. (Arrange) Do Perform the action to be tested. (Act) Verify Confirm the result is as expected. (Assert)Running that test produces this error: 1) Error: BottlesTest#test_the_first_verse: NameError: uninitialized constant BottlesTest::Bottles test/bottles_test. rb:16:in `test_the_first_verse'TDD tells you to write the simplest code that will pass this test. The above error states that the Bottles class does not yet exist. class BottleendBecause you wrote the test, you can confidently predict that running it a second time will now produce the following error: 1) Error: BottlesTest#test_the_first_verse: NoMethodError: undefined method `verse' for #&lt;Bottles:0x007fde360741f0&gt; test/bottles_test. rb:16:in `test_the_first_verse'Then, add verse method: class Bottle def verse endendRun tests again: 1) Error: BottlesTest#test_the_first_verse: ArgumentError: wrong number of arguments (1 for 0) /Users/skm/Projects/books/99bottles/lib/bottles. rb:6:in `verse' test/bottles_test. rb:16:in `test_the_first_verThen, add the argument that we missed: class Bottle def verse(_) endendRun tests again: 1) Failure: BottlesTest#test_the_first_verse [test/bottles_test. rb:16]: --- expected +++ actual @@ -1,3 +1 @@ - 99 bottles of beer on the wall, 99 bottles of beer.  -Take one down and pass it around, 98 bottles of beer on the wall.  -  +nilMinitest shows the difference between expected and actual output by prefixing the expectedwith ‘-‘ and the actual with ‘+’. Therefore, you can interpret: Minitest expected…  “99 bottles of beer on the wall, 99 bottles of beer. ” followed by a newline, followed by “Take one down and pass it around, 98 bottles of beer on the wall. ” followed by another newline”but instead got nil. Copy the expected output into the verse method: class Bottle def verse(_)   99 bottles of beer on the wall,   +   99 bottles of beer. \n  +   Take one down and pass it around,   +   98 bottles of beer on the wall. \n  endendThe API says that verse takes an argument, but you can make this first test pass without actually using it. Therefore, the argument continues to be named “_” in line 2 above. Although this code passes the test, it clearly doesn’t solve the entire problem. As a matter of fact, writing a second test will break it. You as the writer of tests know that the verse method must eventually take the value of its argument into account, but you as the writer of code must act in ignorance of this fact. When doing TDD, you toggle between wearing two hats.    While in the “writing tests” hat, you keep your eye on the big picture and work your way forward with the overall plan in mind.     When in the “writing code” hat, you pretend to know nothing other than the requirements specified by the tests at hand. Thus, although each individual test is correct, until all are written, the code is incomplete.  2. 3. Removing Duplication: Now that the first test passes, you must decide what to test next. Unearthing Concepts: [Your notes for chapter 3] Practicing Horizontal Refactoring: [Your notes for chapter 4] Separating Responsibilities: [Your notes for chapter 5] Achieving Openness: [Your notes for chapter 6] Manufacturing Intelligence: [Your notes for chapter 7] Developing a Programming Aesthetic: [Your notes for chapter 8] Reaping the Benefits of Design: [Your notes for chapter 9]T "
    }, {
    "id": 22,
    "url": "http://localhost:4000/2025/08/09/session-01.html",
    "title": "POOD Session 1: Write Shameless Green",
    "body": "2025/08/09 - Session 1: Write Shameless GreenDate: August 09, 2025 This blog post consists in four parts:  My notes of the first group session My notes from the video “All little things” I had ChatGPT to explain me some concepts A Google NotebookLM link that contains 2 exercises based on the video (quiz and flashcards). Key concepts:  DRY is not always good.  Duplication is far cheaper than the wrong abstraction Make smaller things and let them know about each other as little as possible.  To do good OOP, you need to refactor. To do refactoring, you must have tests.  Open/Closed. Open for extension, closed for modification.  Inheritance Middleman Factory item Small touch on Single Responsibility PrincipleNotes from 1st session: I’ve started a 12-week walkthrough of Practical Object-Oriented Design Course by Sandi Metz, and we’re reading the first two chapters of 99 botles. Here are the highlights from the first session: We were tasked to watch Sandi Metz’s talk All the little things (here my notes) and then to complete as much of the coding challenge as possible and make all tests pass within 15 mins. The test was about singing the 99 bottles of beer song which is a song counting down bottles of beer.  SIDE NOTE: I asked chatGPT about this song after I solved the exercise which is wrong. My mentor has always told me to figure out as much as I can on the domain model (the rules and boundaries of the problem). And since it was the first time I knew about this song I missed very important details, for instance: knowing the highest number possible is 99 and the lowest is 0. It may have changed my approach. The tests asserted/expected a concatenated string and at a first glance I identified that numbers and a few words were changing as we were counting down. I tried to follow conventions like short classes, short methods and so on. First, I made sure I was outputting the correct string and then pinpointed the numbers that needed the counting-down, then came up with the method name bottle_count_phrase because it was meant for toggling from the words bottle, bottles and no more bottles (0, 1 or &gt; 1 (greater than 1) respectively) and the integer change by subtracting 1. I tried the first version and it worked, so I advanced to the next test, until I faced the word variation (“one” or “it”). After identifying the possible variables, in this case only 2, I first wrote down an if statement, which later became a ternary operator. With these possible paths and having the 4 tests passing (green) this was my solution: class Bottles def verse(characters)  song(characters) end def song(number_of_bottles)   #{bottle_count_phrase(number_of_bottles)} of beer on the wall,   +   #{bottle_count_phrase(number_of_bottles)} of beer. \n  +   Take #{removal_pronoun(number_of_bottles -= 1)} down and pass it around,   +   #{bottle_count_phrase(number_of_bottles)} of beer on the wall. \n  end def bottle_count_phrase(number_of_bottles_remaining)  if number_of_bottles_remaining == 0    no more bottles   elsif number_of_bottles_remaining == 1    #{number_of_bottles_remaining} bottle   else    #{number_of_bottles_remaining} bottles   end end def removal_pronoun(number_of_bottles)  number_of_bottles &gt;= 1 ?  one  :  it  endendAfter this exercise we were encouraged to see Sandi’s solution which is the following: def song verses(99, 0)enddef verses(upper, lower) upper. downto(lower). map { |i| verse(i) }. join( \n )endcase numberwhen 0  No more bottles of beer on the wall, no more bottles of beer. \nGo to the store and buy some more, 99 bottles of beer on the wall. \n when 1  1 bottle of beer on the wall, 1 bottle of beer. \nTake it down and pass it around, no more bottles of beer on the wall. \n when 2  2 bottles of beer on the wall, 2 bottles of beer. \nTake one down and pass it around, 1 bottle of beer on the wall. \n else  #{number} bottles of beer on the wall, #{number} bottles of beer. \nTake one down and pass it around, #{number-1} bottles of beer on the wall. \n endAs soon as I saw it, felt like my mentor was talking to me again:  Make sure you understand the domain.  Stare at the input, see what changes in the output.  Devise how to achieve those modifications (do I need an array, hash or counter variable to store any type of result?).  If outcome is the expected, then improve. Where I’m getting with this is, that if I knew that we were only to receive integers as inputs and that the song based on that input, was always going to be the same except the words (‘one’ vs. ‘it’) and numbers, I could have hardcoded the solution (not saying it’s an easy approach to come up with) but my approach was thought with more flexible design with interpolation and conditionals but definitely, I overcomplicated the solution. Something that I noticed in this course as in the Effective testing with RSpec by Myron Marston and Ian Dees is that the authors encourage to tackle test one by one even though it sounds obvious to avoid cluttering your terminal with errors, sometimes we want to see the full picture but their approach is very effective. Lesson learned, read thoroughly the problem, understand the inputs, outputs, if possible make a hand-written drawing, understand what changes, what type of data structure? and lastly if the result is the expected, refine it. It also reminds me of the PEDAC method. And we must aim as quick as possible to ‘Shameless Green’ which is a solution that’s optimized for readability without consideration for future change. We can think of it as the simplest version possible. At the end of this lesson we have the next question? What is the definition of Shameless Green? Possible answers: a) Even thinking about it is embarrassing. b) A solution that’s optimized for changeability without regard for understandability. c) A solution that’s optimized for understandability without regard for changeability. ✅ Notes on Sandi Metz’s talk (video): “All the Little Things”:    All the problems we have caused by writting ugly code has the same simple solution.     One piece of advice: make smaller things. Make more classes, more methods and let them know about each other as little as possible.     Metric Flog is a crowd source idea about the complexity of code (Assignments, Branches, Calls). The higher the worse (harder to understand and reason about).     Sandi used to think that she had to understand everything in order to help with anything.     Squint test, is identifying code that can benefit of changing.     Changes in shape (nested conditionals == harder to reason about)     Changes in color, meaning code has different levels of abstractions, therefore it’s difficult to follow.     When we write code and follow a pattern, if it’s a good pattern, code gets better. But if it’s a bad one, we exacerbate the problem. (Example: No one adds 500 lines of code to an ActiveRecord model, they just kept adding more. )     Refactoring is: change its arrangement without altering its behaviour.     To do refactoring, you must have tests.     OOP build seams between objects, they send messages each other. Messages create seams. In prodecual code, it’s just one flow.     The first refactoring is not going to be neither smart nor clever. But that’s the whole point. The point is to get to green as quickly as possible.     Write code for one test at the time.     Finish the refactoring before going off on a tangent so keep the duplication.     Duplication is far cheaper than the wrong abstraction.     If you have code that you don’t understand you have two choices: you can keep it forever or you can write test around it and refactor.     All intermediate refactoring make the code more complex. intermediate complexity leads to ultimate simplicity.     Open/Closed. Open for extension, closed for modification.     Object oriented design is a style guide for arranging code.     With Open/Closed in place we’d be able to add new behavior without editing existing code.     When you have different prefixes and common suffixes, they’re candidate to have the prefix as a Class and the suffix as a instance_method. Example:        Before (prefixes and suffixes)   After refactoring                  class GildedRose      def normal_tick       . . .       end     end                   class Normal      def initialize()       . . .       end      def tick       . . .       end     end                      class GildedRose     def brie_tick      . . .      end    end                   class Brie      def initialize()       . . .       end      def tick       . . .       end     end                      class GildedRose     def sulfuras_tick      . . .      end    end                   class Sulfuras      def initialize()       . . .       end      def tick       . . .       end     end             If a purpose of an object is just forwarding messages to someone else, you must ask if it justifies its existance (codesmell is called middleman).     Item factory, it finds the rights object and sends a message to it. (it produces the right kind of item object and then forwards messages)     Inheritance is not evil. You want subclasses to be at the leafnode (at the end) of the object graph (shallow, narrow) and subclasses use all the behaviour of the super class.     Business logic != code configuration  Notes on Middleman and ItemFacory principle with ChatGPT: Ah, I see exactly the part you’re struggling with. Let me break it down for you clearly, because Sandi Metz is talking about two related ideas here: message forwarding and the “middleman” problem. 1️⃣ The Gilded Rose problem Originally, the GildedRose class has one big method (tick) with 43 lines of conditional logic. It checks the type of item (Normal, Brie, Backstage, Sulfuras) and applies the rules for that item. From GildedRose’s perspective:  It’s treating items as roles—“I have something that behaves like a Normal item, or like a Brie, etc. ” But the code treats them as concrete classes—it looks inside and checks strings, runs conditionals, and manipulates quality and days_remaining directly. Sandi’s point: we should flip this around—instead of Gilded Rose knowing how each item works, each item should know how to “tick” itself. GildedRose just asks “item, do your tick. ” 2️⃣ The “middleman” concept A middleman is a class whose only purpose is to forward a message to someone else. For example: class GildedRose def tick_item(item_name)  item = get_item_class(item_name). new  item. tick endendHere:  GildedRose isn’t doing any real work itself; it just finds the right item class and tells it to do its tick.  That’s message forwarding. Sandi says: “When an object’s only purpose is to forward messages somewhere else, you have to wonder if it justifies its existence. ”  If GildedRose only forwards messages and does nothing else, maybe it’s not necessary.  But in this case, it still has one real responsibility: it figures out which item class to instantiate based on a string. That’s enough justification for its existence. So GildedRose becomes effectively an item factory: it produces the right kind of item object and then forwards messages. 3️⃣ Why this matters for design By doing this:  Each item class is responsible for its own behavior → follows the Single Responsibility Principle.  GildedRose no longer has huge conditionals → easier to maintain.  Forwarding messages creates a seam → you can easily swap in new item types without touching GildedRose. Before: GildedRose -&gt; lots of if statements -&gt; manipulates every item type directlyAfter: GildedRose -&gt; finds item object -&gt; sends :tickitem object -&gt; handles its own rules From GildedRose’s point of view, it doesn’t care what kind of item it is, only that it responds to tick. That’s duck typing in action. 4️⃣ Why “middleman” isn’t always bad here Yes, a middleman is sometimes unnecessary. But here, GildedRose:  Maps strings to classes (Normal, Brie, Backstage…) Instantiates the correct class Sends tickThat one responsibility makes it justified. Without it, you’d have to do the mapping everywhere else in your code, which would violate DRY and clarity. ✅ TL;DR  Original GildedRose: knows too much about every item type → big, messy conditionals.  Refactored: GildedRose just figures out which object to talk to → forwards tick → small object design.  Middleman = class that only forwards messages. Sometimes it’s unnecessary, sometimes it’s a justified abstraction (here, a factory). — End of ChatGPT notes — All the little things video exercises Google NotebookLM: In the following link you’ll find 50 flashcards and a 10 questions-quiz based on Sandi’s video “All the little things” It’s a Google NotebookLM link to exercise Hope you can learn something new ! Here is an sample how the flashcards look like and my result of the exercises: Flashcards on object oriented design talk:   Object oriented design quiz result:   "
    }, {
    "id": 23,
    "url": "http://localhost:4000/2025/08/04/double-testing-mental-model.html",
    "title": "Mental model for writing double tests",
    "body": "2025/08/04 - With my recent journey of gaining more testing experience and with chatGPT on my side, I started looking at some sort of pattern when writing the double testing exercises from the book Efective testing with RSpec by Myron Marston and Ian Dees I shared the idea with the LLM, and it helped me build the following. First thing that poped my mind was the Arrange, Act, Assert so I did used that one to guide the LLM to what type of output I wanted. LLM response: You’re thinking in exactly the right direction! What you described is essentially the AAA pattern in testing: Arrange, Act, Assert. To help you memorize and internalize it — especially when working with test doubles and APIs — here’s a simple mental checklist or mantra you can use, along with a mnemonic: 🔁 The 6-Step “Double-Driven Test” Flow🧠 Mnemonic: “DUPRAP” (like “Do a PRAP” — rhymes with “wrap”) Double — Use test data — Program the mock — Request — Analyze (parse) — Prove (assert) ✅ 1. DoubleSet up your test double (mock the collaborator) let(:ledger) { instance_double('ExpenseTracker::Ledger') } 💡 Think: “Who am I faking?” — usually the object under the API, like ledger. ✅ 2. Use Test DataDefine the test data your mock should return expenses = [ { 'payee' =&gt; 'Zoo', 'amount' =&gt; 15. 25, 'date' =&gt; '2017-06-10' }, { 'payee' =&gt; 'Starbucks', 'amount' =&gt; 5. 75, 'date' =&gt; '2017-06-10' }] 💡 Think: “What result do I want my mock to send back?” ✅ 3. Program the MockTell your double how to behave allow(ledger). to receive(:expenses_on) . with('2017-06-10') . and_return(expenses) 💡 Think: “When the test calls this method, return my test data. ” ✅ 4. RequestTrigger the route via Rack/Test get '/expenses/2017-06-10' 💡 Think: “Now I run the actual API code with the test in place. ” ✅ 5. AnalyzeParse the response so you can assert on it parsed = JSON. parse(last_response. body) 💡 Think: “What did the API give me back?” ✅ 6. ProveAssert the expected response expect(parsed). to eq(expenses) 💡 Think: “Does the response match what I expected?” 🧠 Bonus: Visual Reminder # 1. Doublelet(:ledger) { instance_double('ExpenseTracker::Ledger') }# 2. Use Test Dataexpenses = [ { 'payee' =&gt; 'Zoo', 'amount' =&gt; 15. 25, 'date' =&gt; '2017-06-10' } ]# 3. Program the Mockallow(ledger). to receive(:expenses_on) . with('2017-06-10') . and_return(expenses)# 4. Requestget '/expenses/2017-06-10'# 5. Analyzeparsed = JSON. parse(last_response. body)# 6. Proveexpect(parsed). to eq(expenses)📌 Final Tip: Turn It into Muscle MemoryEvery time you write a controller- or API-level test, mentally repeat: “Double, Data, Allow → Request, Parse, Expect” Write 3–5 of these for different routes, and it’ll stick — just like git add, git commit, git push stuck after a week or two. Let me know if you want to turn this into a printable or flashcard! Even though tools like LLM can help us write more code (and tests!) faster than ever, understanding the basics is still on us. At the end of the day, we’re the ones responsible for making sure the code works and be maintainable. So the better we get at thinking through these steps, the more useful the LLM becomes. Don’t skip the thinking. "
    }, {
    "id": 24,
    "url": "http://localhost:4000/2025/07/08/breath-first.html",
    "title": "This is a test for Breath first algo",
    "body": "2025/07/08 - Breath first algo "
    }, {
    "id": 25,
    "url": "http://localhost:4000/2025/07/01/algorithm.html",
    "title": "This is a test for Algorithms and Data Structures",
    "body": "2025/07/01 - Algorithm "
    }, {
    "id": 26,
    "url": "http://localhost:4000/2025/06/28/good-enough-testing.html",
    "title": "Good enough testing workshop | notes",
    "body": "2025/06/28 - Recently, I attended a workshop by Lucian Ghinda called Good Enough Testing. The workshop was a great experience, and I learned a lot about testing in Ruby on Rails. Here are my notes from the workshop:  How do you know how many tests are enough? How do you know if your tests are covering enough business logic? When do you stop testing based on risk and time? What kind of bugs are you trying to catch? what does mean to test a feature?We tend to write test on habit or gut feeling. This can be systematic. Taking into consideration the context, we choose coverage criteria (what we pay attention to), and this will drive the test design and test cases we write so we can cover what’s important with minimum effort. In other words: considering the level of risk, we define test coverage that will drive the test design so that we can achieve 100% coverage with the minimum number of test cases. Objectives of workshop:  Model the universe of all possible test cases.  Define the test coverage that is the most important in the context Identify the minimum number of test cases to achieve 100% of coverage. Do this in a systematic way. 4 test design techniques. Equivalence partitioningBounday value analysisDecision tableState transition workship recording https://goodenoughtesting. com/workshops/5 "
    }, {
    "id": 27,
    "url": "http://localhost:4000/2025/06/10/beyond-recursiveness.html",
    "title": "This is a recursive post",
    "body": "2025/06/10 - Beyond the recursive 🔄 "
    }, {
    "id": 28,
    "url": "http://localhost:4000/2025/05/17/thoughtbot-ebook-testing.html",
    "title": "Testing Rails - Thoughtbot",
    "body": "2025/05/17 - In my journey to improve my testing skills I found this Thoughtbot ebook  Pending.  Pending. Pending. : Pending. : https://thoughtbot. com/upcase/rails-testing-exercises https://thoughtbot. com/upcase/fundamentals-of-tdd https://thoughtbot. com/upcase/test-driven-rails "
    }, {
    "id": 29,
    "url": "http://localhost:4000/2025/05/02/beyond-programming.html",
    "title": "This is a test for beyond programming",
    "body": "2025/05/02 - Beyond the basics I "
    }, {
    "id": 30,
    "url": "http://localhost:4000/2025/04/16/websockets.html",
    "title": "Websockets post",
    "body": "2025/04/16 - Websockets "
    }, {
    "id": 31,
    "url": "http://localhost:4000/2025/04/11/effective-testing-with-rspec.html",
    "title": "Effective testing with RSpec",
    "body": "2025/04/11 - Recently, I participated in a very competitive interview. When I submitted the code challenge, I felt my weakest area was the testing suite. Even though feedback was not available, being honest with myself and seeing some posts from the reviewers, I decided to dive deeper into testing. I picked up books like Professional Rails Testing by Jason Swett, Hands-On Test Driven Development by Greg Donald, Effective Testing with RSpec by Myron Marston and Ian Dees and even attended a testing workshop by Lucian Ghinda. I had practiced testing before, but I felt it was time to level up and get it closer to the same standard as the rest of my code. Here are the notes, examples, and quotes that stood out to me while reading.  Getting started with RSpec.  From writing specs to running them.  The RSpec way.  Starting On the Outside: Acceptance Specs.  Testing in isolation: Unit specs.  Getting real: Integration specs.  Structuring code examples.  Slicing and dicing specs with metadata.  Configuring RSpec.  Exploring RSpec expectations.  Matchers included in RSpec expectations.  Creating custom matchers.  Understanding test doubles. Part I — Chapter 1. Getting Started. : Picture of the book! Where should i put this testing heuristics Given-When-Then scenarios The forward is written by Tom Stewart author of Understanding Computation And he expresses something that picked my curiosity:  After all, the big challenge of test-driven development is not knowing how to write tests, but knowing how to listen to them. For your tests to be worth the bites they are written in, they must be able to speak to you about how well the underlying program is designed and implemented and, crucially, you must be able to hear them. The words and ideas baked into RSpec are carefully chosen to heighten your sensitivity to this kind of feedback. As you play with its expressive little pieces you will develop a test for what a good test looks like, and the occasional stumble over a test that now seems harder or uglier or way more annoying than necessary will start you on a journey of discovery that leads to a better design for that part of your code base. ” In the introduction we see different quotes like our tests are broken again! Why does the suite take so long to run? What value are we getting from this test anyway?No matter whether you are new to automated tests or helping using them for years, this book will help you write more effective tests. by effective, we mean tests that give you more value than the time spent writing them. This book you will learn RSpec in three phases: Part I: Introductory exercises to get you acquainted with respectPart II: A work example spanning several chapters, so that you can see RSpecin action on a meaningful sized projectPart III-V: A series of deep dives into specific aspects of RSpec, which will have you get the most out of RSpec RSpec and behavior driven development: RSpec bills itself as a Behavior Driven Development (BDD) test framework. I would like to take a moment to talk about our use of that term, along with the related term, Test Driven Development (TDD). With TDD, you write each test case just before implementing the next bit of behavior. When you have a well written test, you wind up with more maintainable code. you can make changes with the confidence that your test suite will let you know if you have broken something. It is about the way they enable fearless improvements to your design. BDD brings the emphasis to where it is supposed to be: your code’s behavior.  RSpec is a productive Ruby test framework. we say productive because everything about it, its style, api, libraries, and settings are designed to support you as you write great software. We have a specific definition of effective here, does this test pay for the cost of writing and running it? A good test will provide at least one of these benefits:    design guidance: helping you distill all those fantastic ideas in your head into running, maintainable code     safety net: finding errors in your code before your customers do     documentation:capturing the behavior of a working system to help it’s maintainers  As you follow along through the examples in this book, you will practice several habits that will help you test effectively: When you describe precisely what you want your program to do, you avoid being too strict ( and failing when an irrelevant detail changes) or too lax (and getting false Confidence from incomplete tests). By writing your specs to report failure at the right level of detail, you give just enough information to find the cause of the problem, without drawing in excessive output. By clearly separating essential test code from noisy setup code, you communicate what’s exactly expected of the application, and you avoid repeating unnecessary detail. When you reorder, profile, and filter your specs, you unearth order dependencies, slow tests and incomplete work. Installing RSpec. It is made of three independent ruby gems: rspec-core: is the overall test harness that runs your specs. rspec-expectations: provides a readable, powerful Syntax for checking properties of your code. rspec-mocks: makes it easy to isolate the code you are testing from the rest of the system. ➜ rspec-book rbenv local 3. 4. 2➜ rspec-book rbenv rehash➜ rspec-book ruby -vruby 3. 4. 2 (2025-02-15 revision d2930f8e7a) +PRISM [arm64-darwin24]➜ rspec-book bundle initWriting new Gemfile to /Users/dominiclizarraga/code/dominiclizarraga/rspec-book/Gemfile➜ rspec-book bundle add rspecFetching gem metadata from https://rubygems. org/. . . Resolving dependencies. . . Fetching gem metadata from https://rubygems. org/. Fetching diff-lcs 1. 6. 2Fetching rspec-support 3. 13. 4Installing rspec-support 3. 13. 4Installing diff-lcs 1. 6. 2Fetching rspec-core 3. 13. 4Fetching rspec-expectations 3. 13. 5Fetching rspec-mocks 3. 13. 5Installing rspec-core 3. 13. 4Installing rspec-expectations 3. 13. 5Installing rspec-mocks 3. 13. 5Fetching rspec 3. 13. 1Installing rspec 3. 13. 1Note: The book suggests to use gem install rspec however I think it’s important to remember that, that command will install the library globally to that Ruby version so if you want to avoid that and narrow the impact that this installation may have, I suggest to create its own directory and use bundle init which will create a Gemfile and then you can add rspec gem to the Gemfile or use bundle add rspec. This will set this rspec version only to this project. Let’s write our first spec 😁 The book starts with the very simple example of building a sandwich. What’s the most important property of a sandwich? the bread? the condiments? No, the most important thing about a sandwich is that it should taste good. RSpec uses the words describe a it to express concepts in a conversational format:  “Describe an ideal sandwich” “First, it is delicious”01-getting-started/01/spec/sandwich_spec. rbRSpec. describe “An ideal sandwich” do it “is delicious” do  # developers work this way with RSpec all the time; they start with an outline and fill it in as they go.  endendThen let’s add the classes and methods 01-getting-started/01/spec/sandwich_spec. rbRSpec. describe “An ideal sandwich” do it “is delicious” do  sandwich = sandwich. new(“it’s delicious”, [])  taste = sandwich. taste  expect(sandwich). to eq(“it’s delicious”) endendThis file defines your test, known in RSpec as your specs, short for a specification (because they specify the desired behavior of your code). The outer describe block creates an example group – an example group defines what you are testing, in this case, a sandwich, and keeps related specs together. The nested block, the one beginning with it, is an example of the sandwich’s use. As you write specs, you will tend to keep each example focused on one particular size of behavior you are testing.  This first paragraphs reminds me of Jason Swett’s book on how many times he stresses to the readers that tests are a specifications not validations! I was able to count at least 8 times that he mentions that for example:A specification is a statement of how some aspect of a software product should behave. Remember that testing is about a specification, not verification.  A test suite is a structured collection of behavior specifications. Differences between tests, specs and examples: • A test validates that a bit of code is working properly. • A spec describes the desired behavior of a bit of code. • An example shows how a particular API is intended to be used. In the bits of code that we wrote we can clearly see the pattern arrange/act/assert. The last line with the expect keyword is the assertion in other test frameworks. Let’s look at the RSpec methods we’ve used: • RSpec. describe creates an example group (set of related tests). • it creates an example (individual test). • expect verifies an expected outcome (assertion). Up to this point this spec serves two purposes: documenting what your sandwich should do and checking that the sandwich does what it is supposed to. (Lovely, isn’t it? 🤌) Let’s run the test and see what happens. (We’ll start reading common error tests) $ ➜ rspec-book git:(master) ✗ bundle exec rspec 01-getting-started/01/spec/sandwich_spec. rbFFailures: 1) An ideal sandwich is delicious   Failure/Error: sandwich = Sandwich. new( delicious , [])     NameError:    uninitialized constant Sandwich   # . /01-getting-started/01/spec/sandwich_spec. rb:8:in 'block (2 levels) in &lt;top (required)&gt;'Finished in 0. 00539 seconds (files took 0. 09368 seconds to load)1 example, 1 failureFailed examples:rspec . /01-getting-started/01/spec/sandwich_spec. rb:6 # An ideal sandwich is deliciousHere we can see that RSpec gives us a detailed report showing us the line of code where the error occurred, and the description of the problem, in this case sandwich has not been initialized. With this we are following Red/Green/Refactor development practice essential to TDD and BDD. With this workflow, you’ll make sure each example catches failing or missing code before you implement the behavior you’re testing. The next step after writing a failing spec is to make it pass. # add to the top of the file `Sandwich = Struct. new(:taste, :toppings)` # more about [Structs official docs](https://rubyapi. org/3. 4/o/struct) and [Stackoverflow](https://stackoverflow. com/questions/25873672/ruby-class-vs-struct)# re-run the testsYou should see now a green dot “. ” and 0 failures ➜ rspec-book git:(master) ✗ bundle exec rspec 01-getting-started/01/spec/sandwich_spec. rb. Finished in 0. 00578 seconds (files took 0. 07271 seconds to load)1 example, 0 failuresLet’s add a second spec! Sandwich = Struct. new(:taste, :toppings)RSpec. describe  An ideal sandwich  do it  is delicious  do  # Developers work this way with RSpec all the time; they start with an outline and fill it in as they go  sandwich = Sandwich. new( delicious , [])  taste = sandwich. taste  expect(taste). to eq( delicious ) end it  lets me add toppings  do  # Developers work this way with RSpec all the time; they start with an outline and fill it in as they go  sandwich = Sandwich. new( delicious , [])  sandwich. toppings &lt;&lt;  cheese   toppings = sandwich. toppings  expect(toppings). not_to be_empty endendThis example shows 2 new features, check for falsehood (using . not_to instead of . to) and check for data structure attributes But also they are repetitive, let’s introduce 3 new RSpec features: • RSpec hooks run automatically at specific times during testing. • Helper methods are regular Ruby methods; you control when these run. • RSpec’s let construct initializes data on demand. To avoid the repetitiveness that the prior code shows, let’s start using what we described previously hooks, helper methods, let. Hooks The first thing that we will try in our test Suite is a before hook, which will run automatically before each example. (it reminds me to ActiveRecord callbacks) RSpec. describe  An ideal sandwich  do before { @sandwich = Sandwich. new( delicious , []) }  it  is delicious  do  taste = @sandwich. taste  expect(taste). to eq( delicious ) end it  lets me add toppings  do  @sandwich. toppings &lt;&lt;  cheese   toppings = @sandwich. toppings  expect(toppings). not_to be_empty endendThe setup code is shared across specs, but the individual Sandwich instance is not. Every example gets its own sandwich. That means that you can add toppings as you do in the second spec, with the confidence that the changes won’t affect other examples. RSpec keeps track of all the hooks you have registered. Each time RSpec is about to start running one of your examples, it will run any `before` hooks that apply.  `hooks` are great for running, setup code that has real-world side effects. If you need to clear out a test database before each example, a hook is a great place to do so. Here are some drawbacks from `hooks`: First, If you misspelled `@sandwich`, Ruby will silently return `nil` instead of aborting with a failure right away. The result is typically a confusing error message. Second, to refactor your specs to use instance variables, you have had to go through the entire file and replace `sandwich` with `@sandwich`. Finally, when you initialize an instance variable maybe `before hook`, you pay the cost of that setup time for all the examples in the group even if some of them never use the instance variable. That is inefficient and can be quite noticeable. Let’s try a different approach. (a more traditional Ruby approach) RSpec does a lot for us; it is easy to forget that it is just playing Ruby underneath. Each example group is a ruby class, which means that we can define methods on it. RSpec. describe  An ideal sandwich  do def sandwich  @sandwich ||= Sandwich. new( delicious , []) end it  is delicious  do  taste = sandwich. taste  expect(taste). to eq( delicious ) end it  lets me add toppings  do  sandwich. toppings &lt;&lt;  cheese   toppings = sandwich. toppings  expect(toppings). not_to be_empty endendA typical Ruby implementation might look something like the one we just wrote which uses memoization. This pattern is pretty easy to find in Ruby but it is not without its pitfalls. the ||= operator works by seeing if @sandwich is falsey, that is, false or nil, before creating a new @sandwich. That means that it won’t work if we are actually trying to store something falsey. Sharing objects with let RSpec gives us an alternative construct, let. Which handles the edge case that we previously discussed with memoization. You can think of let as assigning a name — in this case, :sandwich — to the result of a block. This block is lazily evaluated, meaning RSpec will only run it the first time :sandwich is accessed within an example. The result is then memoized (cached) for the remainder of that example. Our recommendation is to use these code-sharing techniques where they improve maintainability, lesson noise, and increase clarity. RSpec. describe  An ideal sandwich  do let (:sandwich) { Sandwich. new( delicious , []) } # [let official docs](https://rspec. info/features/3-13/rspec-core/helper-methods/let/) it  is delicious  do  taste = sandwich. taste  expect(taste). to eq( delicious ) end it  lets me add toppings  do  sandwich. toppings &lt;&lt;  cheese   toppings = sandwich. toppings  expect(toppings). not_to be_empty endendClaude convo about let At the end of the chapter there is a “Your turn” section where the author encouraged you to respond a couple of questions and for the first chapter they asked the following: Which of the three ways to reduce duplication that we have shown to you do you like the best for this example? Why? Can you think of situations where the others might be a better option? As all good engineering questions it depends as we have seen the first one which was the before hook, it is very clean, it reads good however we saw that it has some drawbacks, like it would return nil if the instance variable is misspelled and all the refactor gymnastics that it implies for refactoring just one file even when the instance variable is not used in a group example. Then the helper method has the memoization problem and finally they let alternative covers those issues. Some extra coding for solidifying let knowledge: RSpec. describe  An ideal sandwich  do let(:sandwich) { Sandwich. new( delicious , []) }  it  is delicious  do  puts  Example 1 - Sandwich object_id: #{sandwich. object_id}   # Example 1 - Sandwich object_id: 1232  taste = sandwich. taste  expect(taste). to eq( delicious ) end it  lets me add toppings  do  puts  Example 2 - Sandwich object_id: #{sandwich. object_id}   # Example 2 - Sandwich object_id: 1240  sandwich. toppings &lt;&lt;  cheese   toppings = sandwich. toppings  expect(toppings). not_to be_empty endend# within same group exampleit  uses the same object within one example  do puts  First call: #{sandwich. object_id}  # First call: 1248 sandwich. toppings &lt;&lt;  cheese   puts  Second call: #{sandwich. object_id}  # Same object! # Second call: 1248 expect(sandwich. toppings). to include( cheese ) # Cheese is still thereendA recap of Chapter 1: We explored the describe block, which is called on a group of examples, and the it block, which is called an example (or a test case in some other testing frameworks). We covered the expect keyword. We also looked at the Arrange-Act-Assert pattern. We thoroughly read through test failures and what they mean. We understood that testing serves two purposes: documenting what the code should do, and checking that the code does what it’s supposed to do. We explored how to negate an expectation, and how to test collections such as arrays and hashes. Finally, we saw three different ways of reducing code in tests: hooks, Ruby helper methods, and the let construct. Part I — Chapter 2. From writing specs to running them. : # Add the next file 01-getting-started/01/spec/coffee_spec. rbclass Coffee def ingridients  @ingridients ||= [] end def add(ingridient)  ingridients &lt;&lt; ingridient end def price  1. 00 endendRSpec. describe  A cup of coffee  do let(:coffee) { Coffee. new } it  costs $1  do  expect(coffee. price). to eq(1) end context  with milk  do  before { coffee. add :milk }  it  costs $1. 25  do   expect(coffee. price). to eq(1. 25)  end endendAnd in this chapter we explore the --format documentation ➜ rspec-book git:(master) bundle exec rspec 01-getting-started/01 --format documentationA cup of coffee costs $1 with milk  costs $1. 25 (FAILED - 1)An ideal sandwich is delicious lets me add toppingsFailures: 1) A cup of coffee with milk costs $1. 25   Failure/Error: expect(coffee. price). to eq(1. 25)      expected: 1. 25      got: 1. 0      (compared using ==)   # . /01-getting-started/01/spec/coffee_spec. rb:25:in 'block (3 levels) in &lt;top (required)&gt;'Finished in 0. 01762 seconds (files took 0. 08827 seconds to load)4 examples, 1 failureFailed examples:rspec . /01-getting-started/01/spec/coffee_spec. rb:24 # A cup of coffee with milk costs $1. 25Another suggestion from the book is adding the gem coderay which highlights with different colors the line that is failing. This is particularly useful when dealing with complex tests suites. bundle exec rspec 01-getting-started/01 -fd (see the expect and 1. 25) Another tool that is shown in this chapter is how to identify a slow test by adding --profile n (n is the number of offenders we’d like to see) # 01-getting-started/01/spec/slow_spec. rbRSpec. describe  The sleep() method  do it( can sleep for 0. 1 seconds ) { sleep 0. 1 } it( can sleep for 0. 2 seconds ) { sleep 0. 2 } it( can sleep for 0. 3 seconds ) { sleep 0. 3 } it( can sleep for 0. 4 seconds ) { sleep 0. 4 } it( can sleep for 0. 5 seconds ) { sleep 0. 5 }end# $ bundle exec rspec 01-getting-started/01 -fd --profile 2The sleep() method can sleep for 0. 1 seconds can sleep for 0. 2 seconds can sleep for 0. 3 seconds can sleep for 0. 4 seconds can sleep for 0. 5 secondsTop 2 slowest examples (0. 90852 seconds, 58. 8% of total time): The sleep() method can sleep for 0. 5 seconds  0. 50321 seconds . /01-getting-started/01/spec/slow_spec. rb:6 The sleep() method can sleep for 0. 4 seconds  0. 40531 seconds . /01-getting-started/01/spec/slow_spec. rb:5Finished in 1. 54 seconds (files took 0. 0894 seconds to load)5 examples, 0 failuresAlso this chapter covers how to run specific tests when you don’t need to run the whole test suite (from directories, to files to even just examples). $ rspec spec/unit/specific_spec. rb # Load just one spec file$ rspec spec/unit spec/foo_spec. rb # Or mix and match files and directoriesExample for running examples that contains word “milk” (searches arecase-sensitive) $ bundle exec rspec 01-getting-started/01 -e milk -fd Run options: include {full_description: /milk/}A cup of coffee with milk  costs $1. 25 (FAILED - 1)Failures: 1) A cup of coffee with milk costs $1. 25   Failure/Error: expect(coffee. price). to eq(1. 25)      expected: 1. 25      got: 1. 0      (compared using ==)   # . /01-getting-started/01/spec/coffee_spec. rb:25:in 'block (3 levels) in &lt;top (required)&gt;'Finished in 0. 0128 seconds (files took 0. 06799 seconds to load)1 example, 1 failureAnd if you need to run only one example or test case, you can pass rspec 01-getting-started/01/spec/coffee_spec. rb:25 and RSpec will run the example that starts on that line. Rerunning Everything That Failed There is one RSpec command that allows you to run just exactly the failing specs, this is pretty useful as the last command because you avoid running the whole test suite and you can fix one spec, rerun it, fix the next one and so on let’s dive in # here we can see that same error is being brought up, example: `with milk costs $1. 25`➜ rspec-book git:(master) ✗ bundle exec rspec 01-getting-started/01/. F. . . . . . . Failures: 1) A cup of coffee with milk costs $1. 25   Failure/Error: expect(coffee. price). to eq(1. 25)      expected: 1. 25      got: 1. 0      (compared using ==)   # . /01-getting-started/01/spec/coffee_spec. rb:29:in 'block (3 levels) in &lt;top (required)&gt;'Finished in 1. 55 seconds (files took 0. 08332 seconds to load)9 examples, 1 failureFailed examples:rspec . /01-getting-started/01/spec/coffee_spec. rb:28 # A cup of coffee with milk costs $1. 25Then we add the command --only-failures at the end and this will ask us for a path to write the last run diagnosis, in this case we added: ➜ rspec-book git:(master) ✗ bundle exec rspec 01-getting-started/01/ --only-failuresTo use `--only-failures`, you must first set `config. example_status_persistence_file_path`. # add this config lineRSpec. configure do |config| config. example_status_persistence_file_path = 'spec/examples. txt'endWhich will add a spec/examples. txt file with details as the following:       example_id   status   run_time         . /01-getting-started/01/spec/coffee_spec. rb[1:1]   passed   0. 00064 seconds       . /01-getting-started/01/spec/coffee_spec. rb[1:2:1]   failed   0. 01486 seconds       . /01-getting-started/01/spec/sandwich_spec. rb[1:1]   passed   0. 00007 seconds       . /01-getting-started/01/spec/sandwich_spec. rb[1:2]   passed   0. 00163 seconds       . /01-getting-started/01/spec/slow_spec. rb[1:1]   passed   0. 10517 seconds       . /01-getting-started/01/spec/slow_spec. rb[1:2]   passed   0. 20549 seconds       . /01-getting-started/01/spec/slow_spec. rb[1:3]   passed   0. 30431 seconds       . /01-getting-started/01/spec/slow_spec. rb[1:4]   passed   0. 40278 seconds       . /01-getting-started/01/spec/slow_spec. rb[1:5]   passed   0. 50561 seconds   Finally, when we re-run the --only-failures it will search for that “failed status” and run only that one! You can see it below: ➜ rspec-book git:(master) ✗ bundle exec rspec 01-getting-started/01/ --only-failuresRun options: include {last_run_status:  failed } 👈FFailures: 1) A cup of coffee with milk costs $1. 25   Failure/Error: expect(coffee. price). to eq(1. 25)      expected: 1. 25      got: 1. 0      (compared using ==)   # . /01-getting-started/01/spec/coffee_spec. rb:29:in 'block (3 levels) in &lt;top (required)&gt;'Finished in 0. 01276 seconds (files took 0. 08701 seconds to load)1 example, 1 failureFailed examples:rspec . /01-getting-started/01/spec/coffee_spec. rb:28 # A cup of coffee with milk costs $1. 25The usage of command rspec –next-failure rspec-book git:(master) ✗ bundle exec rspec 02-running-specs# above command created spec/tea_examples. txtexample_id             | status | run_time    |----------------------------------- | ------ | --------------- |. /02-running-specs/tea_spec. rb[1:1] | failed | 0. 0001 seconds |. /02-running-specs/tea_spec. rb[1:2] | failed | 0. 00005 seconds |02-running-specs/tea_spec. rbclass TeaendRSpec. configure do |config| config. example_status_persistence_file_path = 'spec/tea_examples. txt'endRSpec. describe  Tea  do let(:tea) { Tea. new } it  tastes like Earl Grey  do  expect(tea. flavor). to be :earl_grey end it  is hot  do  expect(tea. temperature). to be &gt; 200. 0 endend➜ rspec-book git:(master) ✗ bundle exec rspec 02-running-specs      FFFailures: 1) Tea tastes like Earl Grey   Failure/Error: expect(tea. flavor). to be :earl_grey     NoMethodError:    undefined method 'flavor' for an instance of Tea   # . /02-running-specs/tea_spec. rb:11:in 'block (2 levels) in &lt;top (required)&gt;' 2) Tea is hot   Failure/Error: expect(tea. temperature). to be &gt; 200. 0     NoMethodError:    undefined method 'temperature' for an instance of Tea   # . /02-running-specs/tea_spec. rb:15:in 'block (2 levels) in &lt;top (required)&gt;'Finished in 0. 00362 seconds (files took 0. 08398 seconds to load)2 examples, 2 failuresFailed examples:rspec . /02-running-specs/tea_spec. rb:10 # Tea tastes like Earl Greyrspec . /02-running-specs/tea_spec. rb:14 # Tea is hotThen we add the option –next-failure and it will only run the very next failure, not the whole test suite. $ bundle exec rspec 02-running-specs --next-failureRun options: include {last_run_status:  failed }FFailures: 1) Tea tastes like Earl Grey   Failure/Error: expect(tea. flavor). to be :earl_grey     NoMethodError:    undefined method 'flavor' for an instance of Tea   # . /02-running-specs/tea_spec. rb:11:in 'block (2 levels) in &lt;top (required)&gt;'Finished in 0. 00049 seconds (files took 0. 08649 seconds to load)1 example, 1 failureFailed examples:rspec . /02-running-specs/tea_spec. rb:10 # Tea tastes like Earl GreyThis chapter focused on how specs should look and how they can be run. It began with the introduction of the context block, which is an alias for describe. However, it has a more specific and useful purpose: it’s often used for phrases that describe a particular state or condition of the object being tested. We learned about the command rspec --format documentation or --f d, which separates group examples from individual examples and adds indentation to visually show nesting—such as one or two levels deep. We also explored the gem called coderay, which adds color to test output, making it easier to scan for failures. Additionally, we covered the command rspec --profile 2, which helps identify the slowest-running tests. Next, we learned about the rspec --example word command, which allows us to run only the group examples or examples that match the given word. Then, we explored how to run a specific test by including the line number in the command, like so:rspec . /spec/coffee_spec. rb:25. We also discovered a very useful command: rspec --only-failures. This runs only the tests that failed in the previous run by using a file that stores the status of each example. We then looked into running tests in focused mode—allowing us to run only specific context, it, or describe blocks by tagging them. We can assign custom tags and then pass those tags when running rspec to filter the examples accordingly. Another feature we explored was how to sketch out the test suite when you have more ideas in mind than time to implement them. You can use an it block with just a description (without a body), which RSpec treats as pending. You can also mark tests as incomplete using pending, skip, or xit. Finally, we covered the --next-failure command, which runs only the next failing test from the previous run.       Command   Description         rspec –format documentation   Displays test output with indentation to show nesting of examples.        rspec –profile 2   Shows the 2 slowest-running tests to help identify performance bottlenecks.        rspec –example word   Runs only the examples that match the given word.        rspec . /spec/filename_spec. rb:25   Runs only the test located on line 25 of the specified file.        rspec –only-failures   Runs only the tests that failed in the previous run.        rspec –next-failure   Runs the next failing test from the last run.    Part I — Chapter 3. The RSpec Way. : All these prior features of RSpec are designed to make certain habits easy:• Writing examples that clearly spell out the expected behavior of the code• Separating common setup code from the actual test logic• Focusing on just what you need to do to make the next spec pass Writing specs isn’t the goal of using RSpec—it’s the benefits those specs provide. Let’s talk about those benefits now; they’re not all as obvious as “specs catch bugs. ”  Specs increase confidence in your project • The “happy path” through a particular bit of code behaves the way you want it to. • A method detects and reacts to an error condition you’re anticipating. • That last feature you added didn’t break the existing ones. • You’re making measurable progress through the project.  Eliminating fear     With broad test coverage, developers find out early if new code is breaking existing features.     Enabling refactoring Without a good set of specs, refactoring is a daunting task.  Our challenge as developers is to structure our projects so that big changes are easy and predictable. As Kent Beck says, “for each desired change, make the change easy (warning: this may be hard), then make the easy change. ” Guiding design If you write your specs before your implementation, you’ll be your own first client.  As counterintuitive as it may sound, one of the purposes of writing specs is to cause pain—or rather, to make poorly designed code painful.  Sustainability RSpec may slow initial development but ensures faster, safer future changes—unless the project is small, static, or disposable.  Documenting behavior.  Transforming your workflow     Each run of your suite is an experiment you’ve designed in order to validate (or refute) a hypothesis about how the code behaves.     You get fast, frequent feedback when something doesn’t work, and you can change course immediatelyRunning the entire suiteConsider the difference between a test suite taking 12 seconds and one taking 10 minutes. After 1,000 runs, the former has taken 3 hours and 20 minutes. The latter has cumulatively taken nearly 7 days. Deciding what not to testEvery behavior you specify in a test is another point of coupling between your tests and your project code. That means you’ll have one more thing you’ll have to fix if you ever need to change your implementation’s behavior. If you do need to drive a UI from automated tests, try to test in terms of your problem domain (“log in as an administrator”) rather than implementation details (“type admin@example. com into the third text field”). Another key place to show restraint is the level of detail in your test assertions. Rather than asserting that an error message exactly matches a particular string (“Could not find user with ID 123”), consider using substrings to match just the key parts (“Could not find user”). Likewise, don’t specify the exact order of a collection unless the order is important. Part II — Building an app with RSpec. : Part II — Chapter 4. Building an App With RSpec. : In this chapter authors decide to build an expense tracker app where users can add/search expenses. It will use Sinatra as router and not rails since we don’t need background workers, mailers, views, asset pipelie and so on. We need a small JSON APIs and Sinatra will do the job. Acceptance specs =&gt; which checks the behavior of the application as a whole. By the end of the chapter, we’ll have the skeleton of a live app and a spec to test it (It makes me think like a smoke check for the core flow. ) Also, we used a “outside-in development” which means start working at outermost layer (the HTTP request/response cycle) and work your way inward to the classes and methods that contain the logic. Create a directory and add bundler # 04-acceptance-specs/# add ENV['RACK_ENV'] = 'test' to spec_helper. rb# add bundler as package manager`bundle init`# then in the Gemfile file add the next gemsgem  rspec ,  ~&gt; 3. 13 gem  coderay  # easy-to-read, syntax-highlightedgem 'rack-test' # provide an API for testsgem 'sinatra' # implement the web application# then run `bundle install` and `bundle exec rspec --init`, which will create:`. rspec` # contains rspec command line flags`spec/spec_helper. rb` # contains configuration optionsIt’s easy to feel overwhelmed as we’re deciding what to test first. Where do we start? What’s thecore of the project? What’s the one thing we agree our API should do? It should faithfully save the expenses we record. We’re only going to use two of the most basic features of HTTP in these examples:• A GET request reads data from the app. • A POST request modifies data. First testing run 🏃 require 'rack/test'require 'json'module ExpenseTracker RSpec. describe 'Expense Tracker API' do  include Rack::Test::Methods  it 'records submitted expenses' do   coffee = {   'payee' =&gt; 'Starbucks',   'amount' =&gt; 5. 75,   'date' =&gt; '2025-06-10'   }   post '/expenses', JSON. generate(coffee) # This will simulate an HTTP POST request (it's a Rack::Test helper)  end endendIn the console we run bundle exec rspec 04-acceptance-specs/01/expense_tracker/spec/expense_tracker_api_spec. rb and we get the next error: FFailures: 1) Expense Tracker API records submitted expenses   Failure/Error: post '/expenses', JSON. generate(coffee)     NameError:    undefined local variable or method 'app' for #&lt;RSpec::ExampleGroups::ExpenseTrackerAPI:0x000000011e93b538&gt;   # . /04-acceptance-specs/01/expense_tracker/spec/expense_tracker_api_spec. rb:14:in 'block (2 levels) in &lt;module:ExpenseTracker&gt;'Finished in 0. 00161 seconds (files took 0. 15436 seconds to load)1 example, 1 failureFailed examples:rspec . /04-acceptance-specs/01/expense_tracker/spec/expense_tracker_api_spec. rb:8 # Expense Tracker API records submitted expensesGiven error tells us that we cannot use app because we have not defined it yet, so let’s add it (temporaly with a ruby helper method. ) # 04-acceptance-specs/01/expense_tracker/spec/expense_tracker_api_spec. rb  def app   ExpenseTracker::API. new  end  it 'records submitted expenses' do   . . .   end# 04-acceptance-specs/01/expense_tracker/app/api. rbrequire 'sinatra/base'require 'json'module ExpenseTracker class API &lt; Sinatra::Base # This class defines the barest skeleton of a Sinatra app.  endendNow, by adding ExpenseTracker::API and the app method we’re verifying only that the POST request completes without crashing the app. Let’s check the response FFailures: 1) Expense Tracker API records submitted expenses   Failure/Error: expect(last_response. status). to eq(200)      expected: 200      got: 404      (compared using ==)   # . /04-acceptance-specs/01/expense_tracker/spec/expense_tracker_api_spec. rb:21:in 'block (2 levels) in &lt;module:ExpenseTracker&gt;'Finished in 0. 02102 seconds (files took 0. 20637 seconds to load)1 example, 1 failureWe need to add the route for this: # 04-acceptance-specs/01/expense_tracker/app/api. rb post '/expenses' do endLet’s fill the body of the response, we start from the testing, in this case parsing the response # 04-acceptance-specs/01/expense_tracker/spec/expense_tracker_api_spec. rb it 'records submitted expenses' do  coffee = {   'payee' =&gt; 'Starbucks',   'amount' =&gt; 5. 75,   'date' =&gt; '2017-06-10'  }  post '/expenses', JSON. generate(coffee)  p last_response  expect(last_response. status). to eq(200)  parsed = JSON. parse(last_response. body) 👈  expect(parsed). to include('expense_id' =&gt; a_kind_of(Integer)) 👈 endThen in our API we are going to fool the response with the following:  # 04-acceptance-specs/01/expense_tracker/app/api. rb post '/expenses' do  JSON. generate('expense_id' =&gt; 42) endAnd as we’re inspecting the last_response we can see the @body contains the hash with key as expense_id and value as 42. -specs/01/expense_tracker/spec/expense_tracker_api_spec. rb#&lt;Rack::MockResponse:0x000000011db1ba48 @original_headers={ content-type  =&gt;  text/html;charset=utf-8 ,  content-length  =&gt;  17 ,  x-xss-protection  =&gt;  1; mode=block ,  x-content-type-options  =&gt;  nosniff ,  x-frame-options  =&gt;  SAMEORIGIN }, @errors=  , @status=200, @headers={ content-type  =&gt;  text/html;charset=utf-8 ,  content-length  =&gt;  17 ,  x-xss-protection  =&gt;  1; mode=block ,  x-content-type-options  =&gt;  nosniff ,  x-frame-options  =&gt;  SAMEORIGIN }, @writer=#&lt;Method: Rack::MockResponse(Rack::Response::Helpers)#append(chunk) /Users/dominiclizarraga/. rbenv/versions/3. 4. 2/lib/ruby/gems/3. 4. 0/gems/rack-3. 1. 16/lib/rack/response. rb:359&gt;, @block=nil, @body=[ {\ expense_id\ :42} ], @buffered=true, @length=17, @cookies={}&gt;Saving expenses is all fine and good, but it’d be nice to retrieve them. Let’s fetch expenses by date. Let’s start by adding more expenses: # within the example 'records submitted expenses' add these 2 hashes  it 'records submitted expenses' do   zoo = post_expense(    'payee' =&gt; 'Zoo',    'amount' =&gt; 15. 25,    'date' =&gt; '2017-06-10'   )    groceries = post_expense(    'payee' =&gt; 'Whole Foods',    'amount' =&gt; 95. 20,    'date' =&gt; '2017-06-11'   )    coffee = post_expense(    'payee' =&gt; 'Starbucks',    'amount' =&gt; 5. 75,    'date' =&gt; '2017-06-10'   )   get '/expenses/2017-06-10'   expect(last_response. status). to eq(200)   expenses = JSON. parse(last_response. body)   expect(expenses). to contain_exactly(coffee, zoo)  endAnd as you may see we added the post_expense(expense) method, so add it within describe block:  def post_expense(expense)  post '/expenses', JSON. generate(expense)  expect(last_response. status). to eq(200)  parsed = JSON. parse(last_response. body)  expect(parsed). to include('expense_id' =&gt; a_kind_of(Integer))  expense. merge('id' =&gt; parsed['expense_id']) endWhen you run the test suite bundle exec rspec 04-acceptance-specs/01/expense_tracker/spec/expense_tracker_api_spec. rb you should see an error like this: Failures: 1) Expense Tracker API records submitted expenses   Failure/Error: expect(expenses). to contain_exactly(coffee, zoo)      expected collection contained: [{ amount  =&gt; 5. 75,  date  =&gt;  2017-06-10 ,  id  =&gt; 42,  payee  =&gt;  Starbucks }, { amount  =&gt; 15. 25,  date  =&gt;  2017-06-10 ,  id  =&gt; 42,  payee  =&gt;  Zoo }]    actual collection contained:  []    the missing elements were:   [{ amount  =&gt; 5. 75,  date  =&gt;  2017-06-10 ,  id  =&gt; 42,  payee  =&gt;  Starbucks }, { amount  =&gt; 15. 25,  date  =&gt;  2017-06-10 ,  id  =&gt; 42,  payee  =&gt;  Zoo }]   # . /04-acceptance-specs/01/expense_tracker/spec/expense_tracker_api_spec. rb:47:in 'block (2 levels) in &lt;module:ExpenseTracker&gt;'Finished in 0. 0305 seconds (files took 0. 2402 seconds to load)1 example, 1 failureAnd the API endpoint we should enable is the following (GET '/expenses/:date') # 04-acceptance-specs/01/expense_tracker/app/api. rbmodule ExpenseTracker class API &lt; Sinatra::Base  post '/expenses' do   JSON. generate('expense_id' =&gt; 42)  end  get '/expenses/:date' do    JSON. generate([])  end endendNow, we can mark the test_case as pending by adding right after the it block pending 'Need to persist expenses' this will change the red color from our terminal to a more friendly yellow. And with this warning we can add a webserver gem, in this case add gem 'rackup', gem 'webrick' to Gemfile and create a file: # 04-acceptance-specs/01/expense_tracker/config. ru # new file 🚨 require_relative 'app/api' run ExpenseTracker::API. new# run `cd 04-acceptance-specs/01/expense_tracker` and from that directory [NOT rspec-book] run `bundle exec rackup`# this will boot up a webserver ➜ expense_tracker git:(master) ✗ bundle exec rackup[2025-07-23 14:29:17] INFO WEBrick 1. 9. 1[2025-07-23 14:29:17] INFO ruby 3. 4. 2 (2025-02-15) [arm64-darwin24][2025-07-23 14:29:17] INFO WEBrick::HTTPServer#start: pid=6213 port=9292::1 - - [23/Jul/2025:14:29:59 -0400]  GET /expenses/2017-06-10 HTTP/1. 1  200 2 0. 0063In another terminal you can try out your server with the following command: ➜ rspec-book git:(master) ✗ curl localhost:9292/expenses/2017-06-10 -w  \n [] # this is due to our 04-acceptance-specs/01/expense_tracker/app/api. rb GET route ✅To recap of this chapter we began a project about tracking expenses that will register and search them, with only 2 actions. We set up bundler since we need more libraries than RSpec, such as Sinatra, SQlite, Rack, WEBrick, etc. We started with an outside-in approach where we defined the outer layer of the app in this case the POST endpoint. We were encouraged to think deeply about the public API and what type of data we wanted back as a response. Then we started building the classes, and we made progress by clearing one error at a time. We used two new matchers include, a_kind_of and contain_exactly which we didn’t use but was mentioned and lastly we refactored an method for persisting a Hash of expenses and booted up the web server with bundle exec rackup. It’s important to mention that all these requests are simulated. Part II — Chapter 5. Testing in isolation: Unit specs. : In this chapter we’re going to be picking up where we left off: the HTTP routing layer. Unit tests typically involve isolating a class or method from the rest of the code. The result is faster tests and easier-to-find errors. We’ll use unit spec to refer to the fastest, most isolated set of tests for a particular project. With the unit tests in this chapter, you won’t be calling methods on the API class directly. Instead, you’ll still be simulating HTTP requests through the Rack::Test interface. Xavier Shay article about how he tests rails apps Your tests for any particular layer—from customer-facing code down to low-level model classes—should drive that layer’s public API. You’ll find yourself making more careful decisions about what does or doesn’t go into the API. The behavior we want to see is - what happens when an API call succeeds and when it fails. Unit tests are great for test all the conditional branches and edge cases very fast on the other hand if we do it with acceptance/integration would be too inefficient. # create a file spec/unit/app/api_spec. rbrequire_relative '. . /app/api'module ExpenseTracker RSpec. describe API do  describe 'POST /expenses' do   context 'when the expense is successfully recorded' do    it 'returns the expense id'    it 'responds with a 200 (OK)'   end   context 'when the expense fails validation' do    it 'returns an error message'    it 'responds with a 422 (Unprocessable entity)'   end  end endendHit the console with bundle exec rspec 04-acceptance-specs/01/expense_tracker/app/api_spec. rb all tests should appear as “pending”. We are still modeling the API so we want something like this: result = @ledger. record({ 'some' =&gt; 'data' })result. success? # =&gt; a Booleanresult. expense_id # =&gt; a numberresult. error_message # =&gt; a string or nilRemember, we’re testing the API class, not the behavior. This is the perfect spot for test doubles. A test double is an object that stands in for another one during a test. To create a stand-in for an instance of a particular class, you’ll use RSpec’s instance_double method, and pass it the name of the class you’re imitating. Martin Fowler’s article about test double Add the follwoing code to file 04-acceptance-specs/01/expense_tracker/spec/unit/api_spec. rb require_relative '. . /app/api'require 'rack/test'module ExpenseTracker RecordResult = Struct. new(:success?, :expense_id, :error_message) RSpec. describe API do  include Rack::Test::Methods  def app   API. new(ledger: ledger)  end  let(:ledger) { instance_double('ExpenseTracker::Ledger') }  describe 'POST /expenses' do   context 'when the expense is successfully recorded' do    it 'returns the expense id'    it 'responds with a 200 (OK)'   end   context 'when the expense fails validation' do    it 'returns an error message'    it 'responds with a 422 (Unprocessable entity)'   end  end endendAs with the acceptance specs, you’ll be using Rack::Test to route HTTP requests to the API class. Eventually, we’ll move the RecordResult class into the codebase. The seam between layers is where integration bugs hide. Using a simple value object like a RecordResult or Struct between layers makes it easier to isolate code and trust your tests. Article related to catching bugs between layers. 🔦 If you feel a bit lost here is a summary of the 3 files we have written in chapter 5. 🔎 api. rb: Defines a thin HTTP API (Sinatra app). It’s the boundary/interface between the outside world and your app logic.    Parse incoming HTTP requests     Forward them to your application logic (Ledger object)     Return an HTTP response (JSON with status codes)  It’s like a router/controller in Rails. api_spec. rb: Tests the API in isolation using test doubles, to control its behavior and avoid hitting the database or real logic. This is a unit test for your API layer. You’re using an instance_double of Ledger to isolate the API layer and check:    Does the API route call ledger. record?     Does it return the expected response if ledger. record is successful?     What happens if ledger. record fails?  expense_tracker_spec. rb: Acceptance-level (end-to-end) spec. It tests the whole system, using real logic (no doubles), to ensure the full behavior works.    It sends POST requests with expense data.     It sends a GET request to retrieve expenses for a given day.     It checks whether the correct data is returned.     It tests the full stack: HTTP → Sinatra → Ledger → persistence.  initialize(ledger:): Adds “dependency injection” so the API can be wired up with either real objects (in end-to-end tests) or test doubles (in unit tests). # 04-acceptance-specs/01/expense_tracker/spec/unit/api_spec. rbrequire_relative '. . /. . /app/api'require 'rack/test'module ExpenseTracker RecordResult = Struct. new(:success?, :expense_id, :error_message) RSpec. describe API do  include Rack::Test::Methods  def app   API. new(ledger: ledger)  end  let(:ledger) { instance_double('ExpenseTracker::Ledger') }  describe 'POST /expenses' do   context 'when the expense is successfully recorded' do    it 'returns the expense id' do     expense = { 'some' =&gt; 'data' }     allow(ledger). to receive(:record)            . with(expense)            . and_return(RecordResult. new(true, 417, nil))     post '/expenses', JSON. generate(expense)     parsed = JSON. parse(last_response. body)     expect(parsed). to include('expense_id' =&gt; 417)    end    it 'responds with a 200 (OK)'   end   context 'when the expense fails validation' do    it 'returns an error message'    it 'responds with a 422 (Unprocessable entity)'   end  end endendThe allow method configures the test double’s behavior: when the call in this case the API class invokes . record the double will return a new RecordResult instance. Also, please notice that the expense hash doesn’t contain real data, this is ok since the whole point of the Ledger test double is that it will return a canned success or failure response. If we run the test at this point we get the following: Failures: 1) ExpenseTracker::API POST /expenses when the expense is successfully recorded returns the expense id   Failure/Error: expect(parsed). to include('expense_id' =&gt; 417)      expected { expense_id  =&gt; 42} to include { expense_id  =&gt; 417}    Diff:    @@ -1 +1 @@    - expense_id  =&gt; 417,    + expense_id  =&gt; 42,      # . /04-acceptance-specs/01/expense_tracker/spec/unit/api_spec. rb:27:in 'block (4 levels) in &lt;module:ExpenseTracker&gt;'Top 4 slowest examples (0. 03167 seconds, 91. 4% of total time):. . . Let’s handle success and failure of the request in the api. rb # 04-acceptance-specs/01/expense_tracker/app/api. rbrequire 'sinatra/base'require 'json'require_relative 'ledger'module ExpenseTracker class API &lt; Sinatra::Base  def initialize(ledger: Ledger. new)   @ledger = ledger   super()  end   post '/expenses' do   request. body. rewind   expense = JSON. parse(request. body. read)   result = @ledger. record(expense)   if result. success?    JSON. generate('expense_id' =&gt; result. expense_id)   else    status 422    JSON. generate('error' =&gt; result. error_message)   end  end endend# 04-acceptance-specs/01/expense_tracker/spec/unit/api_spec. rbrequire_relative '. . /. . /app/api'require 'rack/test'module ExpenseTracker RSpec. describe API do  include Rack::Test::Methods  def app   API. new(ledger: ledger)  end  let(:ledger) { instance_double('ExpenseTracker::Ledger') }  describe 'POST /expenses' do   context 'when the expense is successfully recorded' do    let(:expense) { { 'some' =&gt; 'data' } }        before do     allow(ledger). to receive(:record)            . with(expense)            . and_return(RecordResult. new(true, 417, nil))    end    it 'returns the expense id' do     post '/expenses', JSON. generate(expense)     parsed = JSON. parse(last_response. body)     expect(parsed). to include('expense_id' =&gt; 417)    end    it 'responds with a 200 (OK)' do     post '/expenses', JSON. generate(expense)     expect(last_response. status). to eq(200)    end   end   context 'when the expense fails validation' do    let(:expense) { { 'some' =&gt; 'data' } }        before do     allow(ledger). to receive(:record)            . with(expense)            . and_return(RecordResult. new(false, 417,  Expense incomplete ))    end    it 'returns an error message' do     post '/expenses', JSON. generate(expense)     parsed = JSON. parse(last_response. body)     expect(parsed). to include('error' =&gt; 'Expense incomplete')    end    it 'responds with a 422 (Unprocessable entity)' do     post '/expenses', JSON. generate(expense)     expect(last_response. status). to eq(422)    end   end  end endendThe last excersice is to add GET /expenses/:date starting from writing down tests:  Write the describe block, then the context, the it blocks.  The API::Sinatra is already working (we have not defined the storage engine yet) Add instance_double of ledger(RecordResult is no longer needed) Add the method expenses_on(date) on the Ledgerclass.  Generate a sample data of the JSON we want as return. (The hash should contain amount, date and payee) Modify the api. rb since the GET route always return empty array. It shoudl handle success and failure too. Here is the api. rb and the api_spec. rb. These refactored specs report “just the facts” of the expected behavior. # 04-acceptance-specs/01/expense_tracker/app/api. rb get '/expenses/:date' do  date = params[:date]  unless /\A\d{4}-\d{2}-\d{2}\z/. match?(date)   status 400   return JSON. generate({ error:  Invalid date format  })  end  expenses = @ledger. expenses_on(date)  if expenses. any?   JSON. generate(expenses)  else   JSON. generate([])  end end# 04-acceptance-specs/01/expense_tracker/spec/unit/api_spec. rbmodule ExpenseTracker RSpec. describe API do  include Rack::Test::Methods  def app   API. new(ledger: ledger)  end  let(:ledger) { instance_double('ExpenseTracker::Ledger') }  describe  GET /expenses/:date  do   context  when expenses exist on given date  do    let(:expense_canned_response) { [ { amount  =&gt; 5. 50,  date  =&gt; '2017-06-10',  payee  =&gt;  Starbucks } ] }    before do     allow(ledger). to receive(:expenses_on)            . with('2017-06-10')            . and_return(expense_canned_response)    end    it  returns the expense records as JSON  do     get '/expenses/2017-06-10'     parsed = JSON. parse(last_response. body)     expect(parsed). to eq(expense_canned_response)    end    it  responds with a 200 (OK)  do     get '/expenses/2017-06-10'     expect(last_response. status). to eq(200)    end   end   context  when expenses don't exist on given date  do    let(:expense_not_found) { [] }    before do     allow(ledger). to receive(:expenses_on)             . with('2017-05-12')             . and_return(expense_not_found)    end    it  returns an empty array as JSON  do     get '/expenses/2017-05-12'     parsed = JSON. parse(last_response. body)     expect(parsed). to eq(expense_not_found)    end    it  responds with a 200 (OK)  do     get '/expenses/2017-05-12'     expect(last_response. status). to eq(200)    end   end   context  when the date format is not valid  do    it  returns a 400 Bad Request  do     get '/expenses/2012,12,12'     expect(last_response. status). to eq(400)    end    it  returns an error message  do     get '/expenses/2012,12,12'     expect(JSON. parse(last_response. body)). to eq({  error  =&gt;  Invalid date format  })    end   end  end endendI’ll add more routes and test cases so that I can practice more  GET /expenses – List all expenses (not just by date) GET /expense/:id————- These should added once we setup SQlite ————- DELETE /expenses/:id – Delete a specific expense PUT /expenses/:id – Update an existing expense GET /expenses/stats/:month – Show monthly summary POST /budgets – Set a budget limit for a category or month GET /categories GET /expenses?category=Food&amp;date=2025-07-10 (this one needs query params, we’re currently using route params)In this chapter, we explored how to move from acceptance tests — which ensure that the entire application works as a whole — to unit tests, which isolate specific parts of the code, such as routing logic. Unit tests typically run without a live server or real database, and instead focus on one class or method at a time. The benefits of this approach are faster test execution and clearer identification of where errors occur. Rather than calling methods directly on the API class, we simulated HTTP requests using the Rack::Test interface. This aligns with the common testing principle of exercising a class through its public interface, which leads to better design decisions and a more user-focused API. We also examined the Ledger class and introduced dependency injection (DI). In Ruby, this is as simple as passing an object as an argument to the constructor, like so: initialize(ledger: Ledger. new)This technique makes it easier to swap in test doubles when testing, allowing us to isolate the API class from the actual persistence layer. A test double is a generic term for objects that stand in for real ones during testing. Depending on the testing framework, they might be called mocks, stubs, fakes, or spies. In RSpec, we use the term double. Our goal was to create a fake Ledger object to test only the API logic — without involving real data storage — making the tests faster and more focused. instance_double(class_to_fake) We also encountered verifying doubles, a powerful RSpec feature that ensures your test doubles reflect the real object’s interface. This helps avoid fragile tests. In our case, forgetting to instantiate the Ledger correctly caused RSpec to raise an error — a valuable signal that our double wasn’t matching the actual interface. If you ever need to inspect a full error stack trace during testing, you can run RSpec with the --backtrace or -b flag: bundle exec rspec -bPart II — Chapter 6. Getting real. Integration specs. : Now we have a solid HTTP routing layer designed with the help of unit specs. These specs assummed that the underlying dependencies would eventually be implemented. Now, it’s time to write those dependecies for real. Add the sequel and sqlite gems: bundle add sequel sqlite3Remember we need to have 3 differents databases for testing, development and production so that we dont clobber with real data. Then add the 3 files (2 for configurations and 1 for the expenses migration) # 04-acceptance-specs/01/expense_tracker/config/sequel. rbrequire 'sequel'DB = Sequel. sqlite( . /db/#{ENV. fetch('RACK_ENV', 'development')}. db )# 04-acceptance-specs/01/expense_tracker/spec/support/db. rb# suite-level hook. # The following code will make sure the database structure is set up and empty,# ready for your specs to add data to itRSpec. configure do |c| c. before(:suite) do   Sequel. extension :migration  Sequel::Migrator. run(DB, 'db/migrations')  DB[:expenses]. truncate endend# 04-acceptance-specs/01/expense_tracker/db/migrations/0001_create_expenses. rbSequel. migration do change do  create_table :expenses do   primary_key :id   String :payee   Float :amount   Date :date  end endendRegarding the before(:suite) hook A typical hook will run before each example. This one will run just once: after all the specs have been loaded, but before the first one actually runs. That’s what before(:suite) hooks are for. Then run the migration with bundle exec sequel -m . /db/migrations sqlite://db/development. db --echo Outout you may see: 2025-08-05 13:32:31 INFO: (0. 001937s) PRAGMA foreign_keys = 12025-08-05 13:32:31 INFO: (0. 000010s) PRAGMA case_sensitive_like = 12025-08-05 13:32:31 INFO: (0. 001011s) SELECT sqlite_version()2025-08-05 13:32:31 INFO: (0. 000890s) CREATE TABLE IF NOT EXISTS `schema_info` (`version` integer DEFAULT (0) NOT NULL)2025-08-05 13:32:31 INFO: (0. 000039s) SELECT * FROM `schema_info` LIMIT 02025-08-05 13:32:31 INFO: (0. 000029s) SELECT 1 AS 'one' FROM `schema_info` LIMIT 12025-08-05 13:32:31 INFO: (0. 000415s) INSERT INTO `schema_info` (`version`) VALUES (0)2025-08-05 13:32:31 INFO: (0. 000050s) SELECT count(*) AS 'count' FROM `schema_info` LIMIT 12025-08-05 13:32:31 INFO: (0. 000028s) SELECT `version` FROM `schema_info` LIMIT 12025-08-05 13:32:31 INFO: Begin applying migration version 1, direction: up2025-08-05 13:32:31 INFO: (0. 000512s) CREATE TABLE `expenses` (`id` integer NOT NULL PRIMARY KEY AUTOINCREMENT, `payee` varchar(255), `amount` double precision, `date` date)2025-08-05 13:32:31 INFO: (0. 000423s) UPDATE `schema_info` SET `version` = 12025-08-05 13:32:31 INFO: Finished applying migration version 1, direction: up, took 0. 001072 secondsThen we had to create a spec/ledger_spec. rb which will test out the Ledger class behavior. require_relative '. . /. . /. . /app/ledger'require_relative '. . /. . /. . /config/sequel'require_relative '. . /. . /support/db'module ExpenseTracker RSpec. describe Ledger, :aggregate_failures do  let(:ledger) { Ledger. new }  let(:expense) do   {    'payee' =&gt; 'Starbucks',    'amount' =&gt; 5. 75,    'date' =&gt; '2017-06-10'   }  end  describe '#record' do   context  with a valid expense  do    it  succesfully saves the expense in the DB  do     result = ledger. record(expense)     expect(result). to be_success     expect(DB[:expenses]. all). to match [a_hash_including(      id: result. expense_id,      payee: 'Starbucks',      amount: 5. 75,      date: Date. iso8601('2017-06-10')     )]    end   end  end endendAnd don’t forget to add the logic into the Ledger class  def record(expense)  DB[:expenses]. insert(expense)  id = DB[:expenses]. max(:id)  RecordResult. new(true, id, nil) endHere we just leveraged 2 new matchers be_success and match [a_hash_including] This particular example we detoured a bit from TDD since we declared 2 expects under the same it block but we did it judiciously since every test that touches the DB is slower so if we follow rigorously one expect per test case we’re going to be repeating that setup and teardown many times. Also, we did added the metada :aggregate_failures so that RSpec doesn’t abort execution at the first error but to run all tests even with failures! With this out of the way, let’s add a test for invalid records  it  rejects the expense as invalid  do  expense. delete('payee')  result = ledger. record(expense)  expect(result). not_to be_success  expect(result. expense_id). to eq(nil)  expect(result. error_message). to include('`payee` is required')  expect(DB[:expenses]. count). to eq(0) endThis will break our test, but that’s all the purpose of the red-green-refactor cycle. Now let’s add the valdiation for Ledger class class Ledger def record(expense)  unless expense['payee']   return RecordResult. new(false, nil, '`payee` is required')  end  DB[:expenses]. insert(expense)  id = DB[:expenses]. max(:id)  RecordResult. new(true, id, nil) endendSomething important that authors mention is that everytime we run the test suite we are adding records to our db which is not good practice, therefore they suggest to add the next RSpec configuration for leeting RSpec that everytime it finds :db tag, it should perform a DB transaction which will entails seting up the DB before running the tests and wiping out after the test suite is ran. # suppor/db. rbc. around(:example, :db) do |example| DB. transaction(rollback: :always) { example. run }endHere is a detailed list of steps that this script will do:  RSpec calls our around hook, passing it the example we’re running.  Inside the hook, we tell Sequel to start a new database transaction.  Sequel calls the inner block, in which we tell RSpec to run the example.  The body of the example finishes running.  Sequel rolls back the transaction, wiping out any changes we made to the database.  The around hook finishes, and RSpec moves on to the next example. Now let’s jump to implement the GET /expenses_on(:date) endpoint. First start with the test describe  #expenses_on  do it  returns all expenses for the date provided  do  result_1 = ledger. record(expense. merge('date' =&gt; '2017-06-10'))  result_2 = ledger. record(expense. merge('date' =&gt; '2017-06-10'))  result_3 = ledger. record(expense. merge('date' =&gt; '2017-06-11'))  expect(ledger. expenses_on('2017-06-10')). to contain_exactly(   a_hash_including(id: result_1. expense_id),   a_hash_including(id: result_2. expense_id)  ) end it  returns an empty array when there are no matching expenses  do  expect(ledger. expenses_on('2017-06-10')). to eq([]) endend# then the ruby logicdef expenses_on(date) DB[:expenses]. where(date: date). allendThis should pass all good! Conclusion: while searching some other RSpec keywords i found this useful RSpec cheat sheet from Thoughtbot also we used the :aggregate_failures feature twice. This option allows the RSpec to continue running the entire test suite even when a test fails. We first applied it at the individual test case level, and then moved it up to an example group, which signaled RSpec to apply that behavior to the entire group. We also introduced two new matchers: be_success and match a_hash_including. Another key point we learned is that every spec interacting with the database will run more slowly. Because of this, we need to be judicious when applying the TDD methodology, which encourages writing one expect per test case. In some situations, we combined multiple expect statements within the same test case to speed up execution. Finally, we explored the --bisect command, which is useful for identifying order-dependent tests. An order dependency occurs when a test fails only if another specific test runs before it. The --bisect command automatically isolates the minimal set of examples that cause the failure by repeatedly running subsets of your tests. Example: # First, run with a specific seed to reproduce the failurerspec --seed 12345# If you see a failure, run:rspec --seed 12345 --bisectSample output: Bisect started using options:  --seed 12345 Reducing test suite by half. . . . . . The minimal reproduction command is:rspec . /spec/foo_spec. rb[1:3] . /spec/bar_spec. rb[1:5] --seed 12345This tells you exactly which tests together trigger the failure, so you can debug the cause. It’s essentially automated detective work for the classic “this test only fails when that other one runs first” problem. Part III — RSpec Core. : Part III — Chapter 7. Structuring code examples. : we’ve gained the mental model of “where things go” (either files or groups or examples or setup!) we’ve have written short, clear examples that explain exactly what the expected behavior of the code islaid examples into logical groups, not oly to share setup but foor keep related specs together you’ll learn how to organize specs into groups, you’ll know where to put shared setup code and the trade-offs. This will make the tests easier to read and maintain. well-structures specs are about more than tidiness, sometimes you attach special behavior to certain examples or groups, like setting up a database or adding a custom error handling. the mechanism of metada (:tags) relies on good grouping. Getting the words right. Every RSpec is the example group in other testing Frameworks it is called test case class and it has multiple purposes:  gives a logical structure for understanding how individual examples relate to one another describes the context such as a particular class, method or situation of what you are testing, provides a ruby class to act as a scope for your shared logic, such as hooks let definition and helper methods, runs, set up and tear down code shared by several examples. The basic includes group examples, examples and expectations. describe creates an example group. This is the place where you put what you say you are testing, the description can be either a string a ruby class, a module or an object. when you use a class it has some advantages because it requires the class to exist and to be spelled correctly, Also you place here the tag filtering with extra information and that tag will be applied to the nested examples it creates a single example, you pass a description of the behavior you are specifying as with describe you can also pass custom metadata to make it more specific remember that for bdd the crucial part is to “getting the words right”. Now, so much alternatives for describe that makes more sense when the examples within that group all relate to a single class method or module that alternative is context which will make it more readable and considering that this is for the long term maintainability, and it will show the intent behind the code. another alternative is example instead of the it and it may be used when you are providing several data examples rather than several sentence about the subject or describing a behavior it will read much more clearly and lastly we have the specified instead of the it RSpec also provides the flexibility for adding the names you want in the book shows how you can combine this gem with binding. pry and how you can add an alias to the spec_helper. rb file and use that in your Cascade or example and that will add the pry: trueto metadata to its respective example group or single example and with this you can quickly toggle the pry behavior on and off just by adding or removing the name you define in the spec_helper. rb. Sharing logic. the main three organization tools are let definitions, hooks, and helper methods below is a code snippet that contains all of the three RSpec. describe 'POST a successful expense' do # let definitions let(:ledger) { instance_double('ExpenseTracker::Ledger') } let(:expense) { { 'some' =&gt; 'data' } } # hook before do  allow(ledger). to receive(:record)  . with(expense)  . and_return(RecordResult. new(true, 417, nil)) end # helper method def parsed_last_response  JSON. parse(last_response. body) endendWe have used the let definition several times in this book they are great for setting up anything that can be initialized in a line or two of code, and they give you the lazy evaluation for free which means that they are not going to be run until you actually invoke them. then we have the hooks that are for situations where they let definition block just won’t cut it. the important thing about hooks is the one and how often you want the hook to run. Hooks. “writing a hook involves two concepts. the type of hook controls when it runs relative to your examples. the scope controls how often your hook runs. ” For the when the hook should run we have three different types before, after, and around. as the name implies, you’re before hook will run before your examples. after hooks guarantee to run after your examples, even if the example fails or did before hook races an example. this hooks are intended to clean up after your setup logic and specs. this style of hook is easy to read, but it does split the setup and tear down logic into two halves that we have to keep track of. When your database cleanup logic doesn’t fit neatly into a transactional around HOOK, we recommend using a before hook for the following reasons: if you forget to add the before hook to a particular spec the failure will happen in that example rather than a later one. when you run a single example to diagnose a failure the records will stick around in the database so that you can investigate them. the around hook it’s a bit more complex because they sandwich your spec code inside your hook, so part of the hook runs before the example and part runs after. the behavior of these two Snippets is the same; it is just a question of which reads better for your application. RSpec. describe MyApp::Configuration do around(:example) do |ex|  original_env = ENV. to_hash  ex. run  ENV. replace(original_env) endendThen we have the config hooks and this is if you need to run your hooks for multiple groups. you can define the hooks once for your entire Suite in the configuration typically spec _ helper. rband they’ll run for every example in your test suite RSpec. configure do |config| config. around(:example) do |ex|  original_env = ENV. to_hash  ex. run  ENV. replace(original_env) endendand with this they will run for every example in your test suite note the trade-off here:  Global hooks reduced duplication but can lead to surprising action at a distance effect in your aspects.  hooks inside example groups are easier to follow but it is easy to leave out an important Hook by mistake when you are creating a new spec file. we do recommend only use config hooks for things that are not essential for understanding how your specs work. the Beats of logic that isolate each example, such as a database transaction or environment sandboxing, or prime candidates. we prefer to keep things simple and run our hooks unconditionally. if, however, our config hooks are only needed by a subset of examples on particularly if they are as low, we will use metadata to make sure they run only for the subset that need them. now that we have seen when to run the hooks either before or after or around let’s see the scope. this is meant when I hook needs to do a really timing tensive operation like creating a bunch of database tables or launching a live web server running the hook once per second will be cost provided. for this cases you can run the hook just once for the entire Suite of specs or once per example group. hooks take a symbol like :suite or :context argument to modify this code. RSpec. describe 'Web interface to my thermostat' do before(:context) do  WebBrowser. launch end after(:context) do  WebBrowser. shutdown endendwe only consider using context hook scope for side effects such as launching a web browser, that’s satisfy both of the following two conditions: does not interact with things that have a per example life cycle is noticeable slow to run when you use a context hook scope your responsible for cleaning up any resulting state otherwise, it can cause other specs to pass or fail incorrectly this is particularly common problem with database code. any records created in a before context hook scope will not run in your per example database transactions. the records will stick around after the example groups If you need to run a piece of setup call just once, before the first example begins that’s what :suite There may be some old syntax that you may find in code bases which is Old newbefore(:each) became before(:example)before(:all) became before(:suite) Something important when a example group is nested the before hooks run from the outside in and the after hooks run from the inside out. when to use hooks we have seen that hooks serve two different purposes: removing duplicate it or incidental details that will distract readers from the point of your example. expressing the English descriptions of your example groups as executable code Abusing RSpec hooks will make you skip all over your spec directory to trace program flow. Helper methods. Sometimes, we can get too clever for our own good and misuse these constructs in an effort to remove every last bit of repetition from our specs. Let’s see an example RSpec. describe BerlinTransitTicket do let(:ticket) { BerlinTransitTicket. new } before do  # These values depend on `let` definitions  # defined in the nested contexts below!  #  ticket. starting_station = starting_station  ticket. ending_station = ending_station end let(:fare) { ticket. fare } context 'when starting in zone A' do  let(:starting_station) { 'Bundestag' }  context 'and ending in zone B' do  let(:ending_station) { 'Leopoldplatz' }  it 'costs €2. 70' do   expect(fare). to eq 2. 7  end end context 'and ending in zone C' do  let(:ending_station) { 'Birkenwerder' }  it 'costs €3. 30' do   expect(fare). to eq 3. 3  end endendWith all these jumps around we have welcomed a behavior defined by the TDD community calls this separation of cause and effect a mystery guest link, now let’s see how would be with a smart usage of helper methods RSpec. describe BerlinTransitTicket do def fare_for(starting_station, ending_station)  ticket = BerlinTransitTicket. new  ticket. starting_station = starting_station  ticket. ending_station = ending_station  ticket. fare end context 'when starting in zone A and ending in zone B' do  it 'costs €2. 70' do  expect(fare_for('Bundestag', 'Leopoldplatz')). to eq 2. 7  end end context 'when starting in zone A and ending in zone C' do  it 'costs €3. 30' do  expect(fare_for('Bundestag', 'Birkenwerder')). to eq 3. 3  end endendNow, it’s explicit exactly what behavior we’re testing, without our needing to repeat the details of the ticketing API. (these helper methods can be extracted into modules and be glued together by calling include into the group example) Sharing examples groups As we have seen, plain old Ruby modules work really nicely for sharing helper methods across example Scripts. but that’s all they can share. if you want to reuse an example, a let construct or a hook, you will need to reach for another two; shared example groups. RSpec provides multiple ways to create and use shared sample grips. This come in pairs, with one method for defining a share group and another for using it:  shared_context and include_context are for reusing common setup and helper logic. .  shared_example and include_exampleAre for reusing examples. . there is one more way to share behavior that is different, though. it_behaves_like creates a new, nested example to hold the shared code. the difference lies in how as isolated the shared behavior is from the rest of your examples. Sharing context Sooner or later, dough, you will find that you want to share some let declarations or hooks instead. before dobasic_authorize 'test_user', 'test_password'endThis hook cannot go into your modules. plane will be modules are not aware of our aspect constructs such as hooks. instead, you can convert your module to a shared context: RSpec. shared_context 'API helpers' doinclude Rack::Test::Methodsdef appExpenseTracker::API. newendbefore dobasic_authorize 'test_user', 'test_password'endEndHere is how we use it: RSpec. describe 'Expense Tracker API', :db doinclude_context 'API helpers'# . Remember that sharing context is for reusing common setup and helper logic. Sharing examples. One of the most powerful ideas in software is defining a single interface with multiple implementation for example your web app might need to cash data in a key Value Store there are many implementation of this idea each which its own advantages over the others let’s see one example of these RS pack Behavior “shared_example” require 'hash_kv_store'RSpec. describe HashKVStore dolet(:kv_store) { HashKVStore. new }it 'allows you to fetch previously stored values' dokv_store. store(:language, 'Ruby')kv_store. store(:os, 'linux')expect(kv_store. fetch(:language)). to eq 'Ruby'expect(kv_store. fetch(:os)). to eq 'linux'endit 'raises a KeyError when you fetch an unknown key' doexpect { kv_store. fetch(:foo) }. to raise_error(KeyError)endendTo test a second implementation of this interface such as a disk-backed FileKVStore – you could copy and paste the entire spec and replace all occurrences of HashKVStore store with FileKVStore. but then you will have to add any new common Behavior to both specs files. we will have to manually keep it two specs files in sync. This is exactly the kind of duplication that shared example groups can help you fix.  To make the switch, move your describe block into its own file and change it to a shared_example block taking an argument and use that argument in the let(:kv_store) declaration RSpec. shared_examples 'KV store' do |kv_store_class|➤ let(:kv_store) { kv_store_class. new }it 'allows you to fetch previously stored values' dokv_store. store(:language, 'Ruby')kv_store. store(:os, 'linux')expect(kv_store. fetch(:language)). to eq 'Ruby'expect(kv_store. fetch(:os)). to eq 'linux'endit 'raises a KeyError when you fetch an unknown key' doexpect { kv_store. fetch(:foo) }. to raise_error(KeyError)endEndAnd we use it with the following code snippet: require 'hash_kv_store'require 'support/kv_store_shared_examples'RSpec. describe HashKVStore doit_behaves_like 'KV store', HashKVStoreendNesting In the introduction to this section, we mentioned that you can include sharedexamples with either include_examples or it_behaves_like call. So far, we’ve just usedIt_behaves_like. Calling include_examplesyou’d get two let declarations for :kv_store: one for HashKVStore and one for FileKVStore. $ rspec spec/include_examples_twice_spec. rb --format documentationKey-value storesallows you to fetch previously stored valuesraises a KeyError when you fetch an unknown keyallows you to fetch previously stored valuesraises a KeyError when you fetch an unknown keyFinished in 0. 00355 seconds (files took 0. 10257 seconds to load)4 examples, 0 failuresUsing it_behaves_like avoids this issue: RSpec. describe 'Key-value stores' doit_behaves_like 'KV store', HashKVStoreit_behaves_like 'KV store', FileKVStoreEndThis would output: $ rspec spec/it_behaves_like_twice_spec. rb --format documentationKey-value storesbehaves like KV storeallows you to fetch previously stored valuesraises a KeyError when you fetch an unknown keybehaves like KV storeallows you to fetch previously stored valuesraises a KeyError when you fetch an unknown keyFinished in 0. 00337 seconds (files took 0. 09726 seconds to load)4 examples, 0 failuresWhen in doubt, choose it behaves like it behaves like it’s almost always the one you want. it ensures that the contents of the Share Group don’t leak into the surrounding context and interact with your other examples. we recommend using include examples only when you are sure that shared example context on conflict with anything in the surrounding group. This is a table that wraps up all the key Concepts that we saw:       Concept   Usage   Gotcha         describe   Creates an example group for a class, module, object, or string; can combine with string; supports metadata.    Passing a class enforces existence and correct spelling; vague descriptions reduce clarity.        context   Alias for describe when grouping by situation or condition.    Misuse can make specs awkward (“describe when boiling”).        it   Defines a single example with behavior description; supports metadata.    Reads awkwardly if not describing a subject.        example   Alias for it; better for listing data cases.    None — just improves readability.        specify   Alias for it; use when neither it nor example reads well.    None — clarity preference only.        hooks   Shared setup/teardown logic with before, after, or around.    Overuse can cause “mystery guest” indirection; keep near usage.        before(:example)   Runs before each example (default scope).    Forgetting in a spec causes failure there; can hide setup details.        after(:example)   Runs after each example, even on failure.    Setup/teardown split can be harder to follow; prefer before for DB cleanup.        around(:example)   Wraps code before and after an example in one block.    Only supports :example scope; can be harder to read.        config hooks   Hooks in RSpec. configure for the whole suite.    Risk of “action at a distance”; use for incidental details.        scopes   :example (default), :context (once/group), :suite (once/suite).    :context can leak state; :suite only in config; avoid old :each/:all.        global hooks   Config hooks affecting all examples.    Can cause unintended side effects; harder to trace.        hooks inside example groups   Hooks scoped to one group.    Easier to follow, but may be missed in new files.        before(:context)   Runs once before all examples in a group.    Avoid for DB records or per-example lifecycle items; must clean up state.        after(:example)   Runs after each example; used for cleanup, even if the example fails.    Splits setup and teardown logic across hooks, making flow harder to follow; prefer before for database cleanup.        let definition   Lazily defines a memoized helper variable.    Overuse can hide cause/effect; nested overrides may confuse.        helper method   Ruby method in example group for setup or reuse.    Avoid hiding essential details far away; inline when important.        shared_context + include_context   Share let, hooks, and helpers across groups.    Plain Ruby modules can’t hold RSpec constructs; merging may override definitions.        shared_examples + include_examples   Share examples; include_examples pastes into current group.    Multiple includes can cause collisions (e. g. , let overwrites).        it_behaves_like   Runs shared examples in a nested group, avoiding collisions.    Adds extra nesting in output; almost always preferred to include_examples.    Part III — Chapter 8. Slicing and dicing specs with metadata. : Slicing and Dicing specs with Metadata In this chapter we are going to learn what type of information are spec stores for each example that it is run how to add more information to that previous stack coma and how to read it, how to perform expensive setup only when we need it and how to run just a subset of tests. over the course of this book, we have far away cute principle that has made our specs faster, more reliable, and easier to use: “ run just the code you need. ” when you are isolating a failure, run just the feeling example. when you are modifying a class, run just it’s unit tests. when you’ve got expensive setup code, only run it for the specs where you need it. a key piece of RS pack that’s made many of these practices possible is its powerful metadata system. metadata undergirds many of our aspects features, and rs back exposes the same system for your use. Defining metadata where do I keep information about the context my specs are running in? by contact, we mean things like: example configuration open parentheses for example, Mark as escaped or pending close parentheses source code locations status of the previous run how one example runs differently than others for example needing a web browser or a DB without some way of attaching data to examples, you and the are aspect maintainers will be stock juggling Global variables and writing a bunch of bookkeeping code. . RSpec solution to this problem couldn’t beSimpler: a plain Ruby hash. every example an example group gets its own such hash, known as the metadata hash. RSpec populates this hash with any metadata you have explicitly chat the example with, plus some useful entries of its own. If you create the following file and you run the test you will see the next information on your terminal: require 'pp'RSpec. describe Hash doit 'is used by RSpec for metadata' do |example|pp example. metadataendend# this w ould be the output$ rspec spec/metadata_spec. rb{:block=&gt;#&lt;Proc:0x007fa6fc07e6a8@~/code/metadata/spec/metadata_spec. rb:4&gt;,:description_args=&gt;[ is used by RSpec for metadata ],:description=&gt; is used by RSpec for metadata ,:full_description=&gt; Hash is used by RSpec for metadata ,:described_class=&gt;Hash,:file_path=&gt; . /spec/metadata_spec. rb ,:line_number=&gt;4,:location=&gt; . /spec/metadata_spec. rb:4 ,:absolute_file_path=&gt; ~/code/metadata/spec/metadata_spec. rb ,:rerun_file_path=&gt; . /spec/metadata_spec. rb ,:scoped_id=&gt; 1:1 ,:execution_result=&gt;#&lt;RSpec::Core::Example::ExecutionResult:0x007ffda2846a78@started_at=2017-06-13 13:34:00 -0700&gt;,:example_group=&gt;{:block=&gt;#&lt;Proc:0x007fa6fb914bb0@~/code/metadata/spec/metadata_spec. rb:3&gt;,« truncated »:shared_group_inclusion_backtrace=&gt;[],:last_run_status=&gt; unknown }. Finished in 0. 00279 seconds (files took 0. 09431 seconds to load)1 example, 0 failuresListen if it shows something that we haven’t talked about before: getting access to your examples properties at the wrong time. you can so by having your eight block take an argument. it will pass an object representing the currently running example. the call to example that metadata returns a hash containing all the metadata.  kiss like description just the string we passed to it, full description includes the checks passed to the describe, describe class, fire path, example groups and last round status with four different values as past, pending, failed or unknown Custom metadata if we want to add extra metadata to our examples in order to identify it better or to one our colleagues we can do it with the next procedure: require 'pp'RSpec. describe Hash do➤ it 'is used by RSpec for metadata', :fast do |example|pp example. metadataendend# this will save`:fast=&gt;true`, we can also add more than one, for example :fast, :focus Then we can call those example that contain the :fast meta tag with $ rspec --tag fast We can also do it for all examples by adding it to spec_helper. rb RSpec. configure do |config|config. define_derived_metadata(file_path: /spec\/unit/) do |meta|meta[:fast] = trueendendDefault metadata As we saw previously with the tag :aggreagate_failuresWhich will run all the test even when they fail, we can add these two all of the examples again adding it to the RSpec. configure RSpec. configure do |config|config. define_derived_metadata do |meta|# Sets the flag unconditionally;# doesn't allow examples to opt outmeta[:aggregate_failures] = trueendendHere is something important that if we don’t want to use that metal type the next code will be overwritten by the global setting: RSpec. describe 'Billing', aggregate_failures: false docontext 'using the fake payment service' dobefore doexpect(MyApp. config. payment_gateway). to include('sandbox')end# . . . endendTherefore we need to tweak it a little bit in order to allow the example group to follow its own rules we need to add a conditional to the spec helper RSpec. configure do |config|config. define_derived_metadata do |meta|meta[:aggregate_failures] = true unless meta. key?(:aggregate_failures)endendI say recap of this chapter we can conclude that it will be hash is created every time we run our test Suite and wouldn’t that hash we can find configurations, where the code is located, status of the example, we can even add our own tags And we can print that hash at the wrong time with . metadata Selecting which specs to run When you are running your specs, you often want to change which ones you include. in this section we are going to show you a few different situations where this kind of slicing and dicing comes in handy. most of the time when we start writing our tests, we don’t run then Tire so. we are either running unit spec for a specific class we are designing or we are kicking off some integration specs to catch regressions. one example to exclude some examples is the following tag: RSpec. configure do |config|config. filter_run_excluding :jruby_only unless RUBY_PLATFORM == 'java'endThe filter_run_excluding call indicates which examples we’re leaving out. The flip side to that method is filter_run_including, or just filter_run for short. This style of filtering is pretty brute-force. If no examples match the filter, RSpec will run nothing at all. A more generally useful approach is to use filter_run_when_matching. With this method, if nothing matches the filter, RSpec just ignores it. Remember that RSpec. configure block are permanent settings, baked into your setup code. They’ll be in effect every time you run RSpec. If you want to run your specific subset of tests from command line you can do it with the following $ rspec --tag fast # this will run just the examples tagged with :fast # this will do exactly the opposite, run all except the tests tagged with :fast$ rspec --tag ~fastSharing code conditionally we discussed three ways to share code across many examples groups: top level config hooks modules containing helper methods shared context containingRSpec constructs such as Hooks and let blocks Metadata is what enables this flexibility, and you can use it with all the culture and techniques we listed earlier: Config hooks. pass a filter expression as a second argument to config. before, config. after or config. aroundTo run that hook only for example matching the filter. # spec/spec_helper. rbRSpec. configure do |config| config. before(:example, :db) do  puts  Setting up database for this example. . .   end config. after(:example, slow: true) do  puts  Cleaning up after a slow example. . .   end config. around(:example, api: true) do |example|  puts  Before API example   example. run  puts  After API example  endend# Usage in a spec:RSpec. describe  Some feature  do it  needs database setup , :db do  # . . .  end it  is a slow example , slow: true do  # . . .  end it  calls the API , api: true do  # . . .  endendmodules. at the filter expression to the end of your config that include call in order to include a module and it’s helper methods conditionally. this also works for similar config. extend and config. prepend # spec/support/api_helpers. rbmodule APIHelpers def api_call(path)  # pretend API call here endend# spec/spec_helper. rbRSpec. configure do |config| config. include APIHelpers, api: trueend# Usage:RSpec. describe  API requests , :api do it  can call the API  do  api_call( /status ) endendshared context. just ask with modules, at a filter expression when calling config. include_contest.  this will bring in your shirt let constructs among other things into just example groups you want.  # spec/support/api_context. rbRSpec. shared_context  API context  do let(:auth_token) {  secret  }end# spec/spec_helper. rbRSpec. configure do |config| config. include_context  API context , api: trueend# Usage:RSpec. describe  Authenticated API request , :api do it  uses the auth token  do  expect(auth_token). to eq  secret  endendHere are some other examples of metadata that we have seen before       Tag   Usage   Gotcha         :aggregate_failures   Allows multiple expectations in an example to run before failing, showing all failures together.    Without it, the first failing expectation stops the example; can hide which expectation failed first.        :pending   Marks an example as pending (not yet implemented or expected to fail).    If the example passes, RSpec flags it as a failure to remind you to remove :pending.        :order   Sets run order for examples (e. g. , :random, :defined).    Random order may expose order dependencies; :defined can hide them.        :skip   Skips the example or group entirely without running it.    Easy to forget skipped tests; may hide failing scenarios if left in place.    Part III — Chapter 9. Configuring RSpec. : As you have work through there exercises in this book, you have often change RS specs Behavior to make it a better tool for your needs here are just a few of the things that you have customized: set up until you’re down a test database, but only for the examples that require one report every failing expectation in an example not just the first one run just examples that you are focusing on at the moment you can configure rspec into basic ways: on rspec. configure block: provides access to all configuration options: since the block lives in your code, you will typically use it to make permanent changes command line options: provides access to some configurations options, typically one off settings Command line configurations to see all available command line options, run rspec –help and you’ll see in you terminal options for:  calling, loading files or directories tweak the output (formatting, write output in a file, backtrace, color, no color) filtering/tags, (match a word, only run a specific example, all failures, next failure) Utility (Initialize your project with RSpec, run RSpec version)R s p e c already asked the two most important directories to load path your projects leave and expect folders. we have filtering options like the following we have output options like the following and if you want to save this options to customize the behavior for everyone we have three different options       File   Usage   Gotcha         ~/. rspec   Stores global personal RSpec preferences for all projects on your machine.    Affects every project; avoid settings that could break others’ test runs if shared.        . /. rspec   Project-level defaults; should contain only essential settings agreed upon by the team.    Overusing for personal prefs can cause conflicts; always commit only team-approved settings.        . /. rspec-local   Per-project personal preferences; lives alongside the project’s . rspec file.    Exclude from version control; every developer may have their own version.    something to keep in mind is that the order that we have listed above is how options take precedence, local options will override more global ones. For instance, if your project has --profile 5 set in its . rspec file, you could override this setting by putting --no-profile in the project’s . rspec-local file. Using a custom formatter a question for matter is a regular Ruby class that registers itself with rspec to receive notification.  as your suite runs, rspec notifies the formatter of the events it is subscribed to, such as starting an example group, running an example, or encountering a failure. R s p e c s built in formatters display failure details, messages and back traces, at the very end of the run. however, as you suite grows and start thinking longer to complete, it can be nice to see failure details as soon as they are cure. How far matters work. a formatter goes through three main steps: register itself with rspec to receive a specific notifications initialize itself at the beginning of the rsvc Run react to events as they occur RSpec. configure We have seen how easily we can set configuration options for a particular spec run via the command line. as convenient as they are this modifications are not available for all the test suit. for the rest will need to call RS p e c. configure inside one or more Ruby files. you can have multiple configure blocks in your code base; if you do rspec will combine the options from all of them. Cuz we have seen before a hook can run for each example, once for each context, or globally for the entire suit . We also have other special purpose configuration hook that doesn’t fit the typical before, after, around pattern. and example would be RSpec. configure do |config|config. when_first_matching_example_defined(:db) dorequire 'support/db'endendThis hook uses metadata :db to perform extra configuration just for the specs that needed. while config hooks are great way to reduce duplication and keep your example focused, there are significant downsides if you overuse them: it’s low test suit due to extra logic running for every example spec star hotter to understand because their logic is hidden in hooks to avoid this pitfalls you can use a simpler, more explicit technique: using Ruby modules inside your configure blocks. Sharing code with Ruby modules # spec_configure. rbclass Performerinclude Singing # won't override Performer methodsprepend Dancing # may override Performer methodsendYou can even bring methods into an individual object: # spec_configure. rbaverage_person = AveragePerson. new average_person. extend SingingRSpec provides the same kind of interface inside RSpec. configure blocks. By calling include, prepend, or extend on the config object RSpec. configure do |config|# Brings methods into each exampleconfig. include ExtraExampleMethods# Brings methods into each example,# overriding methods with the same name# (rarely used)config. prepend ImportantExampleMethods# Brings methods into each group (alongside let/describe/etc. )# Useful for adding to RSpec's domain-specific languageconfig. extend ExtraGroupMethodsendThese three config methods are great for sharing Ruby methods across the respects. if you need to share more, though such as hooks or let definitions, you will need to define a shirt example group. # spec_configure. rbRSpec. configure do |config|config. include_context 'My Shared Group'endFiltering we have found the need to run just some of the examples in your suit therefore we have used rsps filtering to run the following subsets of specs: a single example or group by name only the specs matching a certain piece of metadata such as :fast Some of the rspec configuration system that we have used inside of our configure block are the following RSpec. configure do |config| config. filter_run_when_matching :focus # Runs only examples/groups tagged with :focus config. example_status_persistence_file_path = 'spec/examples. txt' # Stores example run status for --only-failures/--next-failure config. filter_gems_from_backtrace 'rack', 'rack-test', 'sequel', 'sinatra' # Removes listed gems from failure backtraces config. filter_run_when_matching :focus # Duplicate line; same as first setting aboveendAnd if I was reviewing the directory of the exercises from Facebook are realized that the configure block is almost everywhere either from the root directory to a specific model specs files where we need it a more granually effect on the test running As a conclusion for this chapter we have explored that we have two ways to configure the rspec testing framework one is from the command line and the other is with the configure method. command line options are easy to discover and they are one off to modify the next output the next format or to run a subset of tests on the other hand with configure method covers the whole test suit and also we can have more control as we declare those configure blocks inside of the files Part IV — RSpec expectations. : With rspec-expectations, you can easily express expected outcomes about your code. It uses simple matcher objects that can be composed in useful, powerful ways. We’ll dig into how rspec-expectations works, how to compose matchers, and why doing so is useful. Part IV — Chapter 10. Exploring RSpec expectations. : In RSpec Core, we saw how rspec-core helps you structure your test code into example groups and examples. but having a sound structure is not enough for writing good tests. If our specs run code without looking at the output, we are not really testing anything, except the code doesn’t crash outright. That’s where RSpec-expectations comes in. it provides an API for a specifying expected outcomes. RSpec example should contain one or more expectations. This express what you expect to be true at a specific point in your code. In this chapter, we’ll see how one crucial part of expectations – the matcher can be combined in useful new ways. ratio = 22 / 7. 0expect(ratio). to be_within(0. 1). of(Math::PI)numbers = [13, 3, 99]expect(numbers). to all be_oddalphabet = ('a'. . 'z'). to_aexpect(alphabet). to start_with('a'). and end_with('z')The primary goal of rspec-expectations is clarity, both in the examples you write and in the output when something goes wrong. Parts of an expectation: expect(deck. cards. count). to eq(52), 'not playing with a full deck'While there is some variety here, the syntax consistently uses just a few example parts:  A subject - the thing you are testing, that is, an instance of a Ruby class.  A matcher - an object that specifies what you expect to be true about the subject, and provides the past or fail logic (Optionally) a custom failure message irb session irb(main):001&gt; require 'rspec/expectations'=&gt; trueirb(main):002&gt; include RSpec::Matchers=&gt; Objectirb(main):003&gt; expect(1). to eq(1)=&gt; trueirb(main):004&gt; expect(1). to eq(2)/Users/dominiclizarraga/. rbenv/versions/3. 4. 2/lib/ruby/gems/3. 4. 0/gems/rspec-support-3. 13. 4/lib/rspec/support. rb:110:in 'block in &lt;module:Support&gt;': (RSpec::Expectations::ExpectationNotMetError)expected: 2   got: 1(compared using ==)Wrapping your subject with expect Ruby begins evaluating your expectation at the expect method. Let’s go to irb session again: irb(main):005&gt; expect_one = expect(1)=&gt; #&lt;RSpec::Expectations::ValueExpectationTarget:0x000000013ad9. . . irb(main):006&gt; expect_one=&gt; #&lt;RSpec::Expectations::ValueExpectationTarget:0x000000013ad99708 @target=1&gt;Here, our subject is the number 1. We have wrapped in the expect method to give ourself a place to attach methods like to or not_to. in other words the expect methods wraps are object in a test friendly adapter. Side note: prior versions of RSpec expect method what should and should_not respectively. Using a matcher If expect wraps your object for testing, then the matcher actually performs the test. The matcher checks that the subject satisfies its criteria. matcher can compare numbers, find patterns in text, examine deeply nested data structures or perform any custom Behavior you need. The RSpec::Matchers module ships with built-in methods to create matchers: irb(main):007&gt; be_one = eq(1)=&gt; #&lt;RSpec::Matchers::BuiltIn::Eq:0x000000013abf9808. . . irb(main):008&gt; be_one=&gt; #&lt;RSpec::Matchers::BuiltIn::Eq:0x000000013abf9808 @expected=1&gt;This matcher can’t do anything on its own; we still need to combine it with the subject we saw in the previous section. Please, notice how expect(1) built an ExpectationTarget object internally returns: @target → is the actual value you passed in (1 in our example). This object is just a holder for that value, plus some helper methods like . to and . not_to Then, with eq(1) built a matcher object (in this case RSpec::Matchers::BuiltIn::Eq). And internally @expected → is the value you want to match against (1 here). irb(main):011&gt; expect_one. to(be_one)=&gt; trueirb(main):012&gt; expect_one. not_to(be_one)/Users/dominiclizarraga/. rbenv/versions/3. 4. 2/lib/ruby/gems/3. 4. 0/gems/rspec-support-3. 13. 4/lib/rspec/support. rb:110:in 'block in &lt;module:Support&gt;': (RSpec::Expectations::ExpectationNotMetError)expected: value != 1   got: 1(compared using ==)The to method tries to match the subject (in this case, the integer 1) against the provided matcher. If there’s a match, the method returns true; if not, it bails with a detailed failure message. The not_to method does the opposite: irb(main):017&gt; expect_one. not_to eq(be_one)=&gt; trueirb(main):014&gt; expect(1). not_to eq(2)=&gt; trueWhen you think of RSpec expectations as being just a couple of simple Ruby objects glued together, the syntax becomes clear. You’ll use parentheses with the expect method call, a dot to attach the to or not_to method, and a space leading up to the matcher (maybe eq). Custom failure messages. Let’s see an example of a very brief Ruby code that will show us a technically correct error however we can make it more explicit by adding an alternate failure message along to the matcher to or not_to irb(main):018&gt; resp = Struct. new(:status, :body). new(400, 'unknown query param `sort`')=&gt; #&lt;struct status=400, body= unknown query param `sort` &gt;irb(main):019&gt; expect(resp. status). to eq(200)/Users/dominiclizarraga/. rbenv/versions/3. 4. 2/lib/ruby/gems/3. 4. 0/gems/rspec-support-3. 13. 4/lib/rspec/support. rb:110:in 'block in &lt;module:Support&gt;': (RSpec::Expectations::ExpectationNotMetError)expected: 200   got: 400(compared using ==)irb(main):020&gt; expect(resp. status). to eq(200),  Got a #{resp. status}: #{resp. body} /Users/dominiclizarraga/. rbenv/versions/3. 4. 2/lib/ruby/gems/3. 4. 0/gems/rspec-support-3. 13. 4/lib/rspec/support. rb:110:in 'block in &lt;module:Support&gt;': Got a 400: unknown query param `sort` (RSpec::Expectations::ExpectationNotMetError)When the matchers default failure message doesn’t provide enough detail, a custom message maybe just what you need. You can save time by writing your own matches instead if you find yourself using the same message repeatedly. RSpec expectations vs traditional assertsAssertions are simpler to explain than RSpec’s expectations—and simplicity is a good thing—but that doesn’t necessarily make one better than the other.       Concept   Why   Code example         Composability   Matchers are first-class objects that can be combined and used flexibly.    expect(score). to be &gt; 5 &amp; be &lt; 10       Negation   Any matcher can be negated with not_to without writing a separate refute method.    expect(user. active?). not_to be true       Readability   Syntax reads like an English sentence describing the expected outcome.    expect(order. total). to eq 100       More useful errors   Failure messages clearly show which part failed, unlike generic assertions.    expect([13, 2, 3, 99]). to all be_odd   How matchers work Any Ruby object can be used as a matcher as long as it implements a minimal set of methods (. matches? and . failure_message), let’s build one in irb irb(main):021&gt; matcher = Object. new=&gt; #&lt;Object:0x0000000138954280&gt;irb(main):022&gt; expect(1). to matcher/Users/dominiclizarraga/. rbenv/versions/3. 4. 2/lib/ruby/gems/3. 4. 0/gems/rspec-expectations-3. 13. 5/lib/rspec/matchers. rb:968:in 'RSpec::Matchers#method_missing': undefined method 'matches?' for #&lt;Object:0x0000000138954280&gt; (NoMethodError)Did you mean? matchThis expectation has triggered a NoMethodError exception. RSpec expects every matcher to implement a matches? method, which takes an object and returns true if the object matches (and false otherwise). irb(main):027* def matcher. matches?(actual)irb(main):028*  actual == 1irb(main):029&gt; end=&gt; :matches?irb(main):030&gt; expect(1). to matcher=&gt; trueWhen the match fails, RSpec expectations calls the matcher’s failure_message method irb(main):031&gt; expect(2). to matcher/Users/dominiclizarraga/. rbenv/versions/3. 4. 2/lib/ruby/gems/3. 4. 0/gems/rspec-expectations-3. 13. 5/lib/rspec/matchers. rb:968:in 'RSpec::Matchers#method_missing': undefined method 'failure_message' for #&lt;Object:0x0000000138954280&gt; (NoMethodError)# here we implemented the . failure_messageirb(main):035* def matcher. failure_messageirb(main):036*  'expected object to equal 1'irb(main):037&gt; end=&gt; :failure_messageirb(main):038&gt; expect(2). to matcher/Users/dominiclizarraga/. rbenv/versions/3. 4. 2/lib/ruby/gems/3. 4. 0/gems/rspec-support-3. 13. 4/lib/rspec/support. rb:110:in 'block in &lt;module:Support&gt;': expected object to equal 1 (RSpec::Expectations::ExpectationNotMetError)These two methods matches? and failure_message are all you need to define a simple matcher. Composing matchersWhere the matchers really shine is when you compose them with other matchers to specify exactly what you expect and nothing more. the result is more robust tests and fewer false failures. Here are a few different ways to compose matchers:       Technique   Usage   Code example         Pass matcher into another   Use a matcher as an argument to another matcher.    expect(result). to start_with a_string_matching(/Hello/)       Embed in Array/Hash   Place matchers inside arrays or hashes to match structure and values.    expect(user). to match(name: a_string_starting_with( A ))       Logical operators   Combine matchers with &amp; (and) or | (or).    expect(score). to be &gt; 5 &amp; be &lt; 10   How matchers match objects Matchers build on top of Ruby’s standard protocols in order to provide composability: the humble === method. This method, often called “three equals” or “case equality” defines a category to which other objects may or may not be long. most of the time you wont call it directly from production code. Instead, Ruby will call it for you inside each one class of a case expression irb(main):039* def describe_value(value)irb(main):040*  case valueirb(main):041*  when be_within(0. 1). of(Math::PI) then 'Pi'irb(main):042*  when be_within(0. 1). of(2 * Math::PI) then 'Double Pi'irb(main):043*  endirb(main):044&gt; end=&gt; :describe_valueirb(main):045&gt; describe_value(3. 14159)=&gt;  Pi irb(main):046&gt; describe_value(6. 28319)=&gt;  Double Pi RSpec expectations perform the same check internally that Ruby’s case statement does: they call === on the object you pass in. that object can be anything, including another matcher. Passing one matcher into another It may not be obvious why you would need to pass a matcher to another matcher. that say you expect a particular array to start with a value that’s near pi. with rspec, you can pass the be_within(0. 1). of(Math::PI) matcher matcher into the start_with irb(main):047&gt; numbers = [3. 14159, 1. 734, 4. 273]=&gt; [3. 14159, 1. 734, 4. 273]irb(main):048&gt; expect(numbers). to start_with( be_within(0. 1). of(Math::PI) )=&gt; trueirb(main):049&gt; expect([]). to start_with( a_value_within(0. 1). of(Math::PI) )/Users/dominiclizarraga/. rbenv/versions/3. 4. 2/lib/ruby/gems/3. 4. 0/gems/rspec-support-3. 13. 4/lib/rspec/support. rb:110:in 'block in &lt;module:Support&gt;': expected [] to start with a value within 0. 1 of 3. 141592653589793Embedding matches in Array and hash data structures This ability to compose matchers—by passing them into one another, or by embedding them in data structures—lets you be as precise or as vague as you need to be. In other matchers like match_array or contain_exactly, RSpec does recursively apply matchers inside arrays and hashes, but start_with (and end_with) do not. irb(main):069* presidents = [irb(main):070* { name: 'George Washington', birth_year: 1732 },irb(main):071* { name: 'John Adams', birth_year: 1735 },irb(main):072* { name: 'Thomas Jefferson', birth_year: 1743 },irb(main):073* # . . . irb(main):074&gt; ]=&gt; [{name:  George Washington , birth_year: 1732},. . . irb(main):075* expect(presidents). to start_with(irb(main):076*  match(name: 'George Washington', birth_year: a_value_between(1730, 1740)),irb(main):077*  match(name: 'John Adams', birth_year: a_value_between(1730, 1740))irb(main):078&gt; )=&gt; trueCombining matters with logical and or operators There’s another way to combine matchers: compound matcher expressions. Every built-in matcher has two methods (and and or). irb(main):079&gt; alphabet = ('a'. . 'z'). to_airb(main):080&gt; =&gt; [ a ,. . . irb(main):081&gt; expect(alphabet). to start_with('a'). and end_with('z')irb(main):082&gt; =&gt; trueirb(main):083&gt; stoplight_color = %w[ green red yellow ]. sampleirb(main):084&gt; =&gt;  yellow irb(main):085&gt; expect(stoplight_color). to eq('green'). or eq('red'). or eq('yellow')irb(main):086&gt; =&gt; trueYou can use the words and/or, or you can use the &amp; and | operators Generated example descriptions Matchers have another useful ability over simpler assert methods: they’re selfdescribing. irb(main):087&gt; start_with(1). description=&gt;  start with 1 irb(main):088&gt; (start_with(1) &amp; end_with(9)). description=&gt;  start with 1 and end with 9 irb(main):089&gt; contain_exactly( a_string_starting_with(1) &amp; ending_with(9) ). description=&gt;  contain exactly (a string starting with 1 and ending with 9) As you can see, the descriptions of composed and compound matchers include the description of each part. Part IV — Chapter 11. Matchers included in RSpec expectations. : In the previous chapter, we learned how to write expectations to check your codes behavior. We got to know the various parts of an expectation like a subject and the matcher. Now, it’s time to take a closer look at matchers. You have called them in your specs and combine them with other matchers.  RSpec ships with a ton of useful matchers to help you specify exactly how you want the code to behave. The matchers in RSpec expectations fall into three growth categories:  Primitive: matchers for basic data types like strings, numbers and so on High order matchers: that can take other matchers as inputs, then apply them across collections Block matchers: for checking properties of code including blocks, exceptions, and side effects. Primitive matches The word primitive in a programming language refers to a breath and butter data type that cannot be broken down into a smaller pieces. booleans, integers, and floating point numbers are all primitives. Primitive matchers are similar. They have simple, precise definitions that cannot be broken down any further. They are not meant to accept other matchers as input (but you can go the other direction, passing them into other matchers). Typically, they just pass the operation you are performing - and equality check, for example a straight through the subject of the expectation. Equality and identity Most fundamentals matchers are all concerned with variations of the question: “are these two things the same?”, depending on the context. “The same” might refer to one of the several things:    Identity: for example, two references to one object     Hash key equality: two objects of the same type and value, such as two copies of the string “hello”.     Value equality: two objects of compatible types with the same meaning, such as the integer 42 on the floating Point number 42. 0  Value equality Most of the time, Ruby programmers are concerned with the last of these: value equality, embodied in Ruby’s === operator. This matcher is the one you want. However, sometimes you have a more specific me. expect(Math. sqrt(9)). to eq(3)# equivalent to:Math. sqrt(9) == 3Identity perms = Permutations. newfirst_try = perms. of(long_word_list)second_try = perms. of(long_word_list)expect(second_try). to eq(first_try)This test will likely give you a false assurances. If the underlying cache is misbehaving or was never implemented, the calculation will just run again and produce a new word list in the same order. Because both arrays have the same contents, your test will incorrectly pass. Instead, you would like to know whether or not first_try and second_try are actually referring to the same underlaying object, not just two copies with identical contents. For this stricter comparison, you will use equal matcher, which hands off to Ruby’s equal? method behind the scenes: expect(second_try). to equal(first_try)If you prefer you can also use be(x) as an alias for equal(x) to emphasize that this matcher is about identity rather than value equality expect(RSpec. configuration). to be(RSpec. configuration)Hash key equality Programmers rarely check hash key equality directly. As the name implies, it’s used to check that two values should be considered the same Hash key. RSpec eql matcher, based on Ruby’s built-in eql? method, checks for hash key equality. Generally, it behaves the same as the eq matcher since eql? always considers integers and floating point numbers to be different. # 3 == 3. 0:expect(3). to eq(3. 0)# . . . but 3. eql?(3. 0) is false:expect(3). not_to eql(3. 0)This behavior allows 3 and 3. 0 to be used as different keys in the same hash.  When in doubt, try `eq` first. (In most situations, value equality is the one you need. )Variations All three of these matchers have aliases that read better in composed matcher expressions:  an_object_eq_to aliases eq (identity) an_object_equal_to aliases equal (value equality) an_object_eql_to aliases eql (hash key equality)For instance, consider the following expectation that checks a list of Ruby classes: expect([String, Regexp]). to include(String)The intent was to require the actual Ruby String class to be present. Higher-order matchers like include checktheir arguments with the three-quals operator, ===. In this case, RSpec ends up checking String === ‘a string’, which returns true. The fix is to pass the an_object_eq_to expect([String, Regexp]). to include(an_object_eq_to String)Truthiness While Ruby has literal true and false values, it allows any object to be used in a conditional. The rules are very simple false and nil are both treated as false, and everything else is treated as true even the numbers 0. expect(true). to be_truthyexpect(0). to be_truthyexpect(false). not_to be_truthyexpect(nil). not_to be_truthy# . . . and on the flip side:expect(false). to be_falseyexpect(nil). to be_falseyexpect(true). not_to be_falseyexpect(0). not_to be_falseyIf you want to specify that the value is precisely equal to true or false, simply use one of the equality matchers we described in the last section: expect(1. odd?). to be trueexpect(2. odd?). to eq falseAlises: • be_truthy is aliased as a_truthy_value. • be_falsey is aliased as be_falsy, a_falsey_value and a_falsy_value. Operator comparisons We have used thebe method with arguments before, as in expect(answer). to be(42). This method has another form, one without arguments. with it you can perform greater-than and less-than comparisons: expect(1). to be == 1expect(1). to be &lt; 2expect(1). to be &lt;= 2expect(2). to be &gt; 1expect(2). to be &gt;= 1expect(String). to be === 'a string'expect(/foo/). to be =~ 'food'In each case, RSpec uses your operator such as == or &lt; to compare the actual and the matcher on the first line, be == 1, is equivalent to eq(1). Delta and range comparisons Checking two floats for exact equality will frequently cause failures expect(0. 1 + 0. 2). to eq(0. 3)…then you get a failure:expected: 0. 3got: 0. 30000000000000004(compared using ==)Absolute difference Instead of looking for exact equality with floats, you should use be_within matcher: expect(0. 1 + 0. 2). to be_within(0. 0001). of(0. 3)Relative difference Equally useful is the percent_of method, where you give a relative difference instead: town_population = 1237expect(town_population). to be_within(25). percent_of(1000)A single be_within matcher supports both absolute and relative values, based on which method you chain off of it Ranges Sometimes, it’s a better fit to express your expected values in terms of a range, rather than a target value and delta. expect(town_population). to be_between(750, 1250)` be_within is aliased to a_value_within and be_between is aliased to a_value_between` Dynamic predicates A predicate is a method that answers a question with a Boolean answer. For example, Ruby’s Array class provides an empty? method rather than is_empty. expect([]). to be_emptyYou can alternately use a be_a_ or be_an_ prefix for predicates that are nouns. expect(user). to be_adminexpect(user). to be_an_adminhash = { name: 'Harry Potter', age: 17, house: 'Gryffindor' }expect(hash). to have_key(:age)How Dynamic Predicate Matchers Work  You write: expect(user). to be_admin RSpec sees: “Hmm, I don’t recognize be_admin, but it follows the pattern be_*” RSpec transforms it: Strips off be_, adds ?, and calls that method on the subject RSpec actually calls: user. admin?# What you write     → What RSpec callsexpect(user). to be_admin  → user. admin?expect([]). to be_empty   → []. empty?expect(str). to be_blank   → str. blank?expect(obj). to be_valid   → obj. valid?Trade-offs As readable and useful as Dynamic predicate math chairs can be, they do have some trade-offs. For example if you want to test for exact true or false results and another bigger problem is documentation, because Dynamic matters are generated on the fly, they have no documentation. Higher-order matchers All the matchers seen so far are primitives. Now, we are going to look at higher order matchers that is, matchers that you can pass other matchers into. With this technique, you can build up composed matchers that specify exactly the behavior you need. Collections and strings RSpec ships with six different matches for dealing with data structures:       Matcher   Usage   Example         include   Checks that certain items are present (any order).    expect([1, 2, 3]). to include(2, 3)       start_with   Checks that items appear at the beginning.    expect([1, 2, 3]). to start_with(1, 2)       end_with   Checks that items appear at the end.    expect( foobar ). to end_with( bar )       all   Checks that all elements satisfy a matcher.    expect([1, 3, 5]). to all be_odd       match   Matches a data structure exactly (order matters for arrays).    expect([1, 2]). to match([be_odd, be_even])       contain_exactly   Checks that a collection has exactly these items (order doesn't matter).    expect([1, 2, 3]). to contain_exactly(3, 2, 1)   All of these matchers also work with strings, with a few minor differences. Include The include matcher is one of the most flexible.  By using include rather than a structure matcher like eq or match, you can specify just the elements you care about. The collection can contain unrelated items, and your test will still pass. At its simplest, the include matcher works on any object with an include? method. Strings and arrays both support this method. expect('a string'). to include('str')expect([1, 2, 3]). to include(3)hash = { name: 'Harry Potter', age: 17, house: 'Gryffindor' }expect(hash). to include(:name)expect(hash). to include(age: 17)It also accepts a variable number of arguments so that you can specify multiple substrings, array items, hash keys or key-value pairs: expect('a string'). to include('str', 'ing')expect([1, 2, 3]). to include(3, 2)expect(hash). to include(:name, :age)expect(hash). to include(name: 'Harry Potter', age: 17)This works well, but there is a gotcha related to variable numbers of items. Consider this example: expecteds = [3, 2]expect([1, 2, 3]). to include(expecteds)# failure messageexpected [1, 2, 3] to include [3, 2]# possible solutions:expect([1, [3, 2]]). to include([3, 2])expect([1, 2, 3]). to include(*expecteds)start_with and end_with These two matchers are useful when you care about the content of a string or a collection at the start or end but don’t care about the rest. expect('a string'). to start_with('a str'). and end_with('ng')expect([1, 2, 3]). to start_with(1). and end_with(3)# use separately expect([1, 2, 3]). to start_with(1, 2)expect([1, 2, 3]). to end_with(2, 3)# aliases and compounding expect(['list', 'of', 'words']). to start_with( a_string_ending_with('st') ). and end_with( a_string_starting_with('wo'))all The all matcher is somewhat of an oddity: it is the only built-in matter that is not a verb, and it is the only one that always takes another matcher as an argument: numbers = [1, 2, 3]expect(numbers). to all be_evenThis expression does exactly what it says: it expects all the numbers in the array to be even. One gotcha to be aware of is that, like Enumerable#all?, this matcher passes against an empty array. This can lead to surprises. Example: def self. evens_up_to(n = 0)0. upto(n). select(&amp;:odd?)endexpect(evens_up_to). to all be_evenOur expectation didn’t fail and we forgot to pass an argument to evens_up_to RSpec::Matchers. define_negated_matcher :be_non_empty, :be_emptyexpect(evens_up_to). to be_non_empty. and all be_evenWe’re using another RSpec feature, define_negated_matcher, to create a new be_non_empty matcher that’s the opposite of be_empty. Now, the expectation correctly flags the broken method as failing: expected `[]. empty?` to return false, got trueMatch If you call JSON or XML APIs, you often end up with deeply nested arrays and hashes. As you did with eq, you provide a data structure that’s laid out like the result you’re expecting. match is more flexible children = [{ name: 'Coen', age: 6 },{ name: 'Daphne', age: 4 },{ name: 'Crosby', age: 2 }]expect(children). to match [{ name: 'Coen', age: a_value &gt; 5 },{ name: 'Daphne', age: a_value_between(3, 5) },{ name: 'Crosby', age: a_value &lt; 3 }]#it works with strings tooexpect('a string'). to match(/str/)expect('a string'). to match('str')Contain_exactly We’ve seen that match checks data structures more loosely than eq; contain_exactly is even looser. The difference is that match requires a specific order, whereas contain_exactly ignores ordering. expect(children). to contain_exactly({ name: 'Daphne', age: a_value_between(3, 5) },{ name: 'Crosby', age: a_value &lt; 3 },{ name: 'Coen', age: a_value &gt; 5 })expect(children). to contain_exactly({ name: 'Crosby', age: a_value &lt; 3 },{ name: 'Coen', age: a_value &gt; 5 },{ name: 'Daphne', age: a_value_between(3, 5) })Which collection matcher should I use? With a half dozen collection matches to pick from, you may wonder which one is the best for your situation. In general, we recommend you use the loosest matter that still specifies the behavior you care about. Using a loose matcher makes your specs less brittle: it prevents incidental details from causing an unexpected failure. Quick reference for the different uses:  Block matchers With all the expectations we have seen so far, we have past regular Ruby objects into expect: expect(3). to eq(3) this is fine for checking properties of your data. but sometimes you need to check properties of a piece of code. for example, perhaps a certain piece of code is supposed to raise an exception. ```rubyexpect { raise 'boom' }. to raise_error('boom')Rsbec will run the block and watch for the specific side effects you specify: exceptions, mutating variables, I/O and so on. Raising and throwing R s p e c provides matters for both of the situations: that are properly named race error and throw SYM race error first, let’s look at race error also known as race exception. this matter is very flexible, supporting multiple forms: race error with no arguments match if any error is raised race error( some error class) matches if some error class or soup class is raised race error(‘message error’) matches if an error is raised with a message exactly equal to a giving a string raise error(/some Rejects/) matches if an error is raised with a message matching a given pattern you can also combine these criteria if the class and the message are important raise_error(SomeErrorClass, “some message”)• raise_error(SomeErrorClass, /some regex/)• raise_error(SomeErrorClass). with_message(“some message”)• raise_error(SomeErrorClass). with_message(/some regex/) expect {'hello'. world}. to raise_error(an_object_having_attributes(name: :world))There are a couple of caches with race error that can lead can lead to false positives. furious, race error with no arguments will match any error and it cannot tell the difference between exceptions you did or did not mean to throw. for example if you rename a method but forget to update your spec on my Ruby will throw a effort ever. and over serious race Arrow will swallow this exception and respect will pass. always include some kind of detail – either I specific custom ever class or a snippet from the message – that is unique to the specific race statement you are testing throw symbol exceptions are designed for, well, exceptional situation such as an error in a program logic. they are not suited for everyday control flow, so just jumping out of a deeply nasty nasty look or a methyl. for situation like this, Ruby provides the Federal construct. expect { throw :found }. to throw_symbol(:found)expect { throw :found, 10 }. to throw_symbol(:found, a_value &gt; 9)Yielding blocks are one of rubies most distinctive features. they allow you to pass around little chunks of code using an easy to read syntax def self. just_yield puts  [just_yield] about to yield  yield puts  [just_yield] after yield endRSpec. describe  yield_control demo  do it  shows the flow  do  expect { |block_checker|   puts  [expect block] calling just_yield with block_checker    just_yield(&amp;block_checker)   puts  [expect block] returned from just_yield   }. to yield_control endend#output[expect block] calling just_yield with block_checker[just_yield] about to yield[just_yield] after yield[expect block] returned from just_yieldYou can also add with these Guild arguments, no arguments and successive arguments Mutation here we use the change matcher that will help you specify the sort of mutation you are expecting array = [1, 2, 3]expect { array &lt;&lt; 4 }. to change { array. size }The matcher performs the following actions in turn:  Run your change block and store the result, array. size, as the before value Run the code under test, array « 4 Run your change block a second time and store the result, array. size, as theafter value Pass the expectation if the before and after values are differentThis expectation checks whether or not the expectation changed If you need to be more specific and highlight the amount of the change you can use: Specifically, you can use by, by_at_least, or by_at_most to specify the amount of the change: expect { array. concat([1, 2, 3]) }. to change { array. size }. by(3)expect { array. concat([1, 2, 3]) }. to change { array. size }. by_at_least(2)expect { array. concat([1, 2, 3]) }. to change { array. size }. by_at_most(4)and also we have the front and two if you want to know the exact before and after values expect { array &lt;&lt; 4 }. to change { array. size }. from(3)expect { array &lt;&lt; 5 }. to change { array. size }. to(5)expect { array &lt;&lt; 6 }. to change { array. size }. from(5). to(6)expect { array &lt;&lt; 7 }. to change { array. size }. to(7). from(6)Summary of this chapter: Primitive matchers       Concept   Usage   Example         Equality (eq)   Value equality: two objects that mean the same.    expect(42). to eq 42. 0       Identity (equal)   Object identity: same object reference.    expect(a). to equal(a)       Hash key equality (eql)   Equality as defined by Hash key rules.    expect(:a). to eql(:a)       Aliases   an_object_eq_to → eqan_object_equal_to → equalan_object_eql_to → eql   expect(x). to an_object_eq_to(y)       Truthiness   Checks truthy/falsey values.    expect(true). to be_truthy       Operator comparison   Delegates to Ruby’s operators.    expect(5). to be &gt; 3       Delta &amp; Range   Approximate numeric comparisons.    expect(3. 14). to be_within(0. 01). of(3. 15)       Dynamic predicates   Calls Ruby predicate methods.    expect([]). to be_empty       Recommendation: When in doubt, use eq. Value equality is the one you need most often.    Higher order matchers       Matcher   Usage   Example         include   Requires certain items to be present (any order).    expect([1,2,3]). to include(2,3)       start_with   Checks items at the beginning.    expect([1,2,3]). to start_with(1)       end_with   Checks items at the end.    expect( hello ). to end_with( lo )       all   Applies a matcher to all elements.    expect([1,3,5]). to all be_odd       match   Matches against a pattern (array/hash/string/regex). Requires order.    expect({a:1,b:2}). to match(a: be &gt; 0, b: be &lt; 3)       contain_exactly   Checks that only the given items are present, ignoring order.    expect([1,2,3]). to contain_exactly(3,1,2)       Recommendation: Prefer the loosest matcher that still specifies the behavior you care about. For example, use contain_exactly when order doesn’t matter to avoid brittle specs. Match when order matter   Block matchers       Matcher   Usage   Example         raise_error   Asserts exceptions raised in a block.        expect { 1/0 }. to raise_error(ZeroDivisionError)    expect { foo }. to raise_error( bad )    expect { bar }. to raise_error(/pattern/)          yield_control   Checks that a block yields.    expect { |b| obj. call(&amp;b) }. to yield_control       change   Asserts that a block mutates state.        expect { arr &lt;&lt; 1 }. to change { arr. size }. by(1)    expect { arr &lt;&lt; 2 }. to change { arr. size }. from(1). to(2)          Recommendation: Use change when you care about mutations, yield when testing block semantics, and always make raise_error specific to avoid false positives.    Part IV — Chapter 12. Creating custom matchers. : Creating custom matchers In the previous chapter, we took a tour of the matchers that ship with RSpec. We can be productive with them on simpler projects, they may be or what you need. Eventually, though, you are going to hit the limits of the built-in matchers. Because they are meant for testing general purpose Ruby code, they require you to speak in Ruby terms rather than your projects terms. For example please take a look at the next expectations: Without custom matchers: expect(art_show. tickets_sold. count). to eq(0)expect(u2_concert. tickets_sold. count). to eq(u2_concert. capacity)With custom matchers expect(art_show). to have_no_tickets_soldexpect(u2_concert). to be_sold_outWe have added to custom matchers have_no_tickets_sold and be_sold_out, so that we can describe the behavior in terms of events and tickets. These are the terms that the rest of the project team would use.  This reminds me of this Martin Fowler talk: https://www. youtube. com/watch?v=pGB5g-Do3qI  He cites an exercise by Kent Beck, where he asked team members: “Describe how the system works using only four objects. ”If they all chose the same objects, he could deduce that the team had good coherence. Otherwise, if they picked different objects, it showed that the team lacked cohesion. When we write clear, easy to use custom matchers, you gain several benefits:  you stand a greater chance of building what your stakeholders want you reduce the cost of API changes (because you need only update your match) you can provide better failure messages when something and you improve the test output, example:Without custom matchers: expected: 0got: 2(compared using ==)expected: 10000got: 9900(compared using ==)With custom matchers expected #&lt;Event  Art Show  (capacity: 100)&gt; to have no tickets sold, but had 2expected #&lt;Event  U2 Concert  (capacity: 10000)&gt; to be sold out, but had 100 unsold ticketsNot only does this report to speak out the main language, it also provides additional details such as what specific events we are testing here. Delegating to existing matchers using helper methods. We are going to start with a technique we have already used to keep your code organized: helper methods This is a test that we used when we built the expense tracker app expect(ledger. expenses_on('2017-06-10')). to contain_exactly( a_hash_including(id: result_1. expense_id), a_hash_including(id: result_2. expense_id))This matcher got the job done. Notice, though, how it expresses the expectation in terms of Ruby objects: hashes and IDs. Let’s use the main language of the project: expect(ledger. expenses_on('2017-06-10')). to contain_exactly( an_expense_identified_by(result_1. expense_id), an_expense_identified_by(result_2. expense_id))# spec/spec_helper. rbmodule ExpenseTrackerMatchers def an_expense_identified_by(id)  a_hash_including(id: id) endendRSpec. configure do |config| config. include ExpenseTrackerMatchersWe are delegating to another matcher but there is a gotcha that may bring about a false positive so let’s make this match more robust. This data structure would make the test pass { id: 1, email: 'john. doe@example. com', role: 'admin'}# let’s add the payee, amount and date by using compounding “. and”def an_expense_identified_by(id) a_hash_including(id: id). and including(:payee, :amount, :date)endRSpec allows you to create aliases for different matchers, this is how you can define them: Example of RSpec built-in: # a_value_within as an alias of the be_within matcherexpect(results). to start_with a_value_within(0. 1). of(Math::PI)Inside of the file 12-creating-custom-matchers/05/custom_matchers. rb RSpec::Matchers. alias_matcher :an_admin, :be_an_admin# will produce&gt;&gt; be_an_admin. description=&gt;  be an admin &gt;&gt; an_admin. description=&gt;  an admin The alias_matcher method can also take a block: RSpec::Matchers. alias_matcher :an_admin, :be_an_admin do |old_description|old_description. sub('be an admin', 'a superuser')end# will produce&gt;&gt; an_admin. description=&gt;  a superuser Also you can create negating matchers From this: expect(correct_grammar). to_not split_infinitivesTo this expect(correct_grammar). to avoid_splitting_infinitivesRSpec::Matchers. define_negated_matcher :avoid_splitting_infinitives, :split_infinitivesAs with alias_matcher, you pass the name of the new matcher, followed by the old one. The avoid_splitting_infinitives matcher will now behave as the negation of split_infinitives. Using the matcher DSL. Let’s go back to the expense tracker app with built and let’s say that we are going to build a custom have_a_balance_of matcher that helps with expectations expect(account). to have_a_balance_of(30)There are two ways to build a matcher like the one we just show  Using a master DSL Creating a ruby class (any Ruby class can define a matcher, if it implements the matter protocol)Let’s start with the matcher DSL To define a matcher using the DSL, we call RSpec::Matchers. define, passing the matcher name and a block containing the matcher definition: RSpec::Matchers. define :have_a_balance_of do |amount| match { |account| account. current_balance == amount }endThe outer block receives any arguments passed to the matcher. When a spec calls have_a_balance_of(amount), RSpec will pass the amount into this block. The match method defines the actual match/no-match logic. The inner block receives the subject of the expectation (the account), and returns a truthy value if the account balance matches the expected amount. Here’s the output that it produces when a spec fails: 1) `have_a_balance_of(amount)` fails when the balance does not matchFailure/Error: expect(account). to have_a_balance_of(35)expected #&lt;Account name= Checking &gt; to have a balance of 35# . /spec/initial_account_spec. rb:17:in `block (2 levels) in &lt;topThe failure message tells us that the account should have had a balance of 35. But it doesn’t say what the actual balance was.  it reminds me to the phrase “These two methods matches? and failure_message are all you need to define a simple matcher. ” in chapter 10. Let’s add the failure_message RSpec::Matchers. define :have_a_balance_of do |amount| match { |account| account. current_balance == amount }➤ failure_message { |account| super() + failure_reason(account) }➤ failure_message_when_negated { |account| super() + failure_reason(account) }private def failure_reason(account)   , but had a balance of #{account. current_balance}  endendNow this new matcher will work with expect(. . . ). to(. . . ) and for expect(. . . ). not_to(. . . )See the next failure message once we added these 2 new methods: 1) `have_a_balance_of(amount)` fails when the balance does not matchFailure/Error: expect(account). to have_a_balance_of(35)expected #&lt;Account name= Checking &gt; to have a balance of 35, but had a balance of 30# . /spec/initial_account_spec. rb:17:in `block (2 levels) in &lt;topIf we need to add a fluent interface like: • be_within(0. 1). of(50)• change { … }. from(x). to(y)• output(/warning/). to_stderr We can do it by defining again starting with the matcher: expect(account). to have_a_balance_of(10). as_of(Date. new(2017, 6, 12))And within out matcher file we add the as_of() RSpec::Matchers. define :have_a_balance_of do |amount|➤ chain(:as_of) { |date| @as_of_date = date } match { |account| account_balance(account) == amount } failure_message { |account| super() + failure_reason(account) } failure_message_when_negated { |account| super() + failure_reason(account) } private def failure_reason(account)   , but had a balance of #{account_balance(account)}  end def account_balance(account)  if @as_of_date   account. balance_as_of(@as_of_date)  else   account. current_balance  end endendDefining a matcher class If we need a little more control or my prefer to define the matter in the most explicit way possible we need to create a ruby class matcher. class HaveABalanceOf include RSpec::Matchers::Composable def initialize(amount)  @amount = amount end def as_of(date)  @as_of_date = date  self end def matches?(account)  @account = account  values_match?(@amount, account_balance) end def description  if @as_of_date    have a balance of #{description_of(@amount)} as of #{@as_of_date}   else    have a balance of #{description_of(@amount)}   end end def failure_message   expected #{@account. inspect} to #{description}  + failure_reason end def failure_message_when_negated   expected #{@account. inspect} not to #{description}  + failure_reason end private def failure_reason   , but had a balance of #{account_balance}  end def account_balance  if @as_of_date   @account. balance_as_of(@as_of_date)  else   @account. current_balance  end endendLet’s walk through: RSpec integration, within matcher. rb module AccountMatchers def have_a_balance_of(amount)  HaveABalanceOf. new(amount) endendRSpec. configure do |config| config. include AccountMatchersendHowever, in certain situations the custom matcher class is a better fit: • If your matcher is going to be used hundreds or thousands of times, writing your own class avoids a bit of extra overhead inherent in how the DSL is evaluated. • Some teams prefer more explicit code. • If you leave out the RSpec::Matchers::Composable mixin, your matcher won’t have any dependencies on RSpec and will work in non-RSpec contexts. Part V — RSpec mocks. : A robust test suite will run fast, be deterministic, and cover all essential code paths. Unfortunately, dependencies often get in the way of these goals. We can’t reliably test code while it is integrated with other libraries or systems. Test doubles, including mock objects allow you to tightly control the environment in which your test run. Part V — Chapter 13. Understanding test doubles. : In this chapter we will see:  How doubles can isolate your code from your dependencies, the difference between mocks, stubs, spies and null objects.  How to add test double behavior to an existing Ruby object.  and how to keep your doubles and your real objects in sync. In movies, a stunt double stands in for an actor, absorbing a punch or a fall when the actor cannot or should not do so. In test frameworks like RSpec, test double fulfills the same role. It stands in for another object doing testing. When we wrote the API unit specs for our expense tracker app, we treated the storage engine layer as if it were behaving exactly how we needed it, even though that the layer had not been written yet. This ability to isolate parts of your system while you are testing it is super powerful. With test doubles, we can:  Exercise hard to reach code paths, such as ever handling and reliable third-party service.  Write specs for a layer of your system before you have built it its dependencies.  Use an API while you are still designing it so that you can fix problems with the design before the implementation.  Demonstrate how a component Works relative to its neighbors. Types of test doubles: Test doubles have two characteristics one is the usage mode (what you are using it for and what you are expecting to) and the other is how the double is created, the origin. Here are the usage modes:  Stub: returns canned responses, avoiding any meaningful computation or I/O.  Mock: expects a specific messages: will raise an error if it doesn’t receive them by the end of the example.  Null Object: a benign test double that can stand in for any object: returns itself in response to any message.  Spy: records the message it receives so that you can check that later. Now here are the origins:    Pure double: a double whose behavior comes entirely from the test framework; this is what people normally think of when they talk about mock objects.     Partial double: an existing Ruby object that takes on some tests that will behavior, it’s an interface is a mixture of real and fake implementations.     Verifying double totally fake like a pure double, but constraints it’s interface based on a real object like a partial double; provides a safer test double by verifying that it matches the API.     Stubbed constant: a ruby constant such as a class or module name, which you create, remove or replace for a single test.  Any given test of what we have both on our origin and a usage mode and you can mix them for instance have a pure double acting as a stub, or a verifying double acting as a spy. Usage mode: mocks, stubs and spies. Generic test double In an irb session call mock RSpec library. RSpec’s double method creates a generic test double that you can use in any mode. irb(main):001&gt; require 'rspec/mocks/standalone'=&gt; trueirb(main):002&gt; ledger = double=&gt; #&lt;Double (anonymous)&gt;This double acts like an ordinary Ruby object. As you send messages to it (in other words, call methods on it), it will accept some messages and reject others. The difference is that a generic double gives you more debugging information than a regular Ruby object. irb(main):003&gt; ledger. record(an: :expense)/Users/dominiclizarraga/. rbenv/versions/3. 4. 2/lib/ruby/gems/3. 4. 0/gems/rspec-support-3. 13. 4/lib/rspec/support. rb:110:in 'block in &lt;module:Support&gt;': #&lt;Double (anonymous)&gt; received unexpected message :record with ({an: :expense}) (RSpec::Mocks::MockExpectationError)When we sent this message (. record), the double raised an exception. Doubles are strict by default: they will reject all messages except the ones you’ve specifically allowed. RSpec shows both the message name and arguments we sent to our double; this is already more information than a typical Ruby NoMethodError. We can get a little more details in the error message by naming the role the double plays: irb(main):004&gt; ledger = double('Ledger')=&gt; #&lt;Double  Ledger &gt;irb(main):005&gt; ledger. record(an: :expense)/Users/dominiclizarraga/. rbenv/versions/3. 4. 2/lib/ruby/gems/3. 4. 0/gems/rspec-support-3. 13. 4/lib/rspec/support. rb:110:in 'block in &lt;module:Support&gt;': #&lt;Double  Ledger &gt; received unexpected message :record with ({an: :expense}) (RSpec::Mocks::MockExpectationError)This extra information comes in handy when you’re using multiple doubles in the same example. This same double method can create any of the other kinds of test doubles you’ll use in your specs: stubs, mocks, spies, and null objects. Stubs Stubs are simple. They return preprogrammed, canned responses. Stubs are best for when you’re simulating query methods that is, methods that return a value but don’t perform side effects. The simplest way to define a stub is to pass a hash of method names and return values to the double method: irb(main):006&gt; http_response = double('HTTPResponse', status: 200, body: 'OK')=&gt; #&lt;Double  HTTPResponse &gt;irb(main):007&gt; http_response. status=&gt; 200irb(main):008&gt; http_response. body=&gt;  OK An alternative, you can perform these two steps for creating the stub and setting up the canned messages: irb(main):009&gt; http_response = double('HTTPResponse')=&gt; #&lt;Double  HTTPResponse &gt;irb(main):010&gt; allow(http_response). to receive_messages(status: 200, body: 'OK')=&gt; {status: 200, body:  OK }irb(main):011&gt; http_response. status=&gt; 200irb(main):012&gt; http_response. body=&gt;  OK Stubs watch for specific messages and return the same value each time they receive a given message. They don’t act differently based on their arguments. irb(main):013&gt; http_response. status(:args, :are, :ignored)=&gt; 200irb(main):014&gt; http_response. body(:blocks, :are, :also) { :ignored }=&gt;  OK Stubs help with a specific kind of behavior—the kind that can be verified just by looking at return values.  Query data from a dependency Perform a computation on that data Return a resultYour specifications can verify the object’s behavior simply by examining the return value in step 3. The only responsibility of the stub is to provide a suitable response to the query in step 1. Mocks With these, it’s not a return value that you care about, but rather a side effect. Here’s a typical sequence:  Receive an event from the system Make a decision based on that event Perform an action that has a side effectFor instance, a chat bot’s Reply feature may receive a text message, decide how to reply, and then post a message in the chat room. To test this behavior, it’s not enough for your test double to provide a fixed return value at step 3. It needs to make sure the object triggered the side effect of posting a message correctly. To use a mock object, you’ll pre-program it with a set of messages it’s supposed to receive. These are called message expectations. By combining the expect method with a matcher: irb(main):015&gt;ledger = double('Ledger')irb(main):016&gt; expect(ledger). to receive(:record)=&gt; #&lt;RSpec::Mocks::MessageExpectation #&lt;Double  Ledger &gt;. record(any arguments)&gt;Once you’ve created a mock object, you’ll typically pass it into the code you’re testing. At the end of each RSpec example, RSpec verifies that all mocks received their expected messages. irb(main):016&gt; RSpec::Mocks. verify(irb):15:in '&lt;main&gt;': (Double  Ledger ). record(*(any args)) (RSpec::Mocks::MockExpectationError)  expected: 1 time with any arguments  received: 0 times with any argumentsBecause the mock Ledger didn’t receive the messages it was expecting, it raises a MockExpectationError message. You can also specify the opposite behavior: irb(main):017&gt; expect(ledger). not_to receive(:reset)=&gt; #&lt;RSpec::Mocks::MessageExpectation #&lt;Double  Ledger &gt;. reset(any arguments)&gt;irb(main):018&gt; ledger. reset/Users/dominiclizarraga/. rbenv/versions/3. 4. 2/lib/ruby/gems/3. 4. 0/gems/rspec-support-3. 13. 4/lib/rspec/support. rb:110:in 'block in &lt;module:Support&gt;': (Double  Ledger ). reset(no args) (RSpec::Mocks::MockExpectationError)  expected: 0 times with any arguments  received: 1 timeWe see a failure because the mock object received a message it was specifically expecting not to receive. Null objects The test doubles you’ve defined so far are strict: they require you to declare in advance what messages are allowed. But when your test double needs to receive several messages, having to spell each one out can make your tests brittle, you may want a test double that’s a little more forgiving. You can convert any test double to a null object by calling as_null_object on it: irb(main):019&gt; yoshi = double('Yoshi'). as_null_object=&gt; #&lt;Double  Yoshi &gt;irb(main):020&gt; yoshi. eat(:apple)=&gt; #&lt;Double  Yoshi &gt;This type of null object is known as a black hole; it responds to any message sent to it, and always returns itself. irb(main):021&gt; yoshi. eat(:apple). then_shoot(:shell). then_stomp=&gt; #&lt;Double  Yoshi &gt;If you have a ChatBot class that interacts with a room and a user, you may want to test these collaborations separately. While you’re focusing on the user related specs, you can use a null object for the room. Spies One downside of traditional mocks is that they disrupt the normal Arrange/Act/Assert sequence you’re used to in your tests. See the next code: irb(main):022* class Gameirb(main):023*  def self. play(character)irb(main):024*   character. jumpirb(main):025*  endirb(main):026&gt; end=&gt; :playirb(main):027&gt; mario = double('Mario')=&gt; #&lt;Double  Mario &gt;irb(main):028&gt; expect(mario). to receive(:jump)=&gt; #&lt;RSpec::Mocks::MessageExpectation #&lt;Double  Mario &gt;. jump(any arguments)&gt;irb(main):029&gt; Game. play(mario)=&gt; nilIt feels a bit backwards to have to assert before acting. Spies are one way to restore the traditional flow. All you have to do is change the receive expectation to have_received. irb(main):030&gt; mario = double('Mario'). as_null_object=&gt; #&lt;Double  Mario &gt;irb(main):031&gt; Game. play(mario)=&gt; #&lt;Double  Mario &gt;irb(main):032&gt; expect(mario). to have_received(:jump)=&gt; nilWhen you spy on objects with have_received, you’ll either need to use null objects or explicitly allow the expected messages irb(main):033&gt; mario = double('Mario')=&gt; #&lt;Double  Mario &gt;irb(main):034&gt; allow(mario). to receive(:jump)=&gt; #&lt;RSpec::Mocks::MessageExpectation #&lt;Double  Mario &gt;. jump(any arguments)&gt;irb(main):035&gt; Game. play(mario)=&gt; nilirb(main):036&gt; expect(mario). to have_received(:jump)=&gt; nil# another way is using `spy` keyword which is an aliasirb(main):037&gt; mario = spy('Mario')=&gt; #&lt;Double  Mario &gt;irb(main):038&gt; Game. play(mario)=&gt; #&lt;Double  Mario &gt;irb(main):039&gt; expect(mario). to have_received(:jump)=&gt; nilHere, we used a chatGPT explanation for null obejcts and spies 🤖 Scenario: ChatBot class ChatBot def initialize(room)  @room = room end def reply_to(message)  if message ==  hi    @room. post( hello 👋 )  else   @room. post( 🤔 )  end endendNull Object Suppose you only care about testing how the bot decides what to say, not whether it really posted to the room. Instead of stubbing every possible method on Room, we just use a null object: RSpec. describe ChatBot do it  returns a response without caring about the room  do  room = double( Room ). as_null_object # accepts any message  bot = ChatBot. new(room)  bot. reply_to( hi )  # no error, even though we didn’t define room. post endendas_null_object is useful when the collaborator is irrelevant to the test — it “swallows” all messages without complaints. Spy Now let’s say we do care that room. post got called correctly. Using a spy, we can check after the action: RSpec. describe ChatBot do it  posts a greeting when user says hi  do  room = spy( Room )  bot = ChatBot. new(room)  bot. reply_to( hi )  expect(room). to have_received(:post). with( hello 👋 ) endendNotice the flow: Arrange: create spyAct: call methodAssert: verify with have_received This keeps the familiar Arrange–Act–Assert pattern, unlike mocks where you must set the expectation before acting. Combining as_null_object and Spies Sometimes, you want an object that:    Accepts any call (like a null object)     But you can still inspect later what happened (like a spy)  That’s exactly what spy (or double(…). as_null_object + have_received) gives you. room = double( Room ). as_null_objectbot = ChatBot. new(room)bot. reply_to( bye )expect(room). to have_received(:post). with( 🤔 )# or equivalently:room = spy( Room )bot = ChatBot. new(room)bot. reply_to( bye )expect(room). to have_received(:post). with( 🤔 )🔑 Key Takeaways Null Object (as_null_object): ignores everything, returns itself → great when collaborator doesn’t matter. Spy (spy or have_received): records what happened → great when you want to assert after-the-fact. spy(“Name”) is basically shorthand for double(“Name”). as_null_object. chatGPT session ended. Origins: pure, partial, and verifying doubles Now that we have seen the different usage modes of the tests doubles, let’s look at where they come from. Pure doubles All of the test doubles you have written so far in this chapter are pure doubles: they are purpose-built by RSpec mocks and consist entirely of behavior you add to them. You can pass them into your project code just as if they were the real thing. Pure doubles are flexible and easy to get started with. They are best for testing code where you can pass in dependencies. Unfortunately, real world projects are not always so test-friendly, and you will need to turn to more powerful techniques. Partial doubles Sometimes, the code you are testing does not give you an easy way to inject dependencies, a hard coded class name may be looking three layers deep in the API you are calling. For instance, a lot of Ruby projects called Time. now without providing a way to override the behavior during testing. To test these kinds of codebases, you can use a partial double. This add mocking and stubbing behavior to an existing Ruby objects. That means any object in your system can be a partial double. All you have to do is expect or allow a specific message. =&gt; trueirb(main):004&gt; random = Random. new=&gt; #&lt;Random:0x0000000122814a20&gt;irb(main):005&gt; allow(random). to receive(:rand). and_return(0. 1234)=&gt; #&lt;RSpec::Mocks::MessageExpectation #&lt;Random:0x0000000122814a20&gt;. rand(any arguments)&gt;irb(main):006&gt; random. rand=&gt; 0. 1234In this snippet, you have created an instance of a Ruby random number generator, and then replace its rand method with one that returns a can value. You can also use a partial double as a spy using the expect(). to have_received form irb(main):009&gt; allow(Dir). to receive(:mktmpdir). and_yield('/path/to/tmp')=&gt; #&lt;RSpec::Mocks::MessageExpectation #&lt;Dir (class)&gt;. mktmpdir(any arguments)&gt;irb(main):010&gt; Dir. mktmpdir { |dir| puts  Dir is: #{dir}  }Dir is: /path/to/tmp=&gt; nilirb(main):011&gt; expect(Dir). to have_received(:mktmpdir)=&gt; nilYou could permit any message using a spy or as_null_object or explicitly allow just the message you want. With partial doubles, you can only do that later. RSpec will revert it all your changes at the end of each example. there will be object will go back to its original behavior. Since we are experimenting in stand-alone mode we need to call the tear down explicitly to clean up what happened. irb(main):012&gt; RSpec::Mocks. teardown=&gt; #&lt;RSpec::Mocks::RootSpace:0x0000000121f74e10&gt;irb(main):013&gt; random. rand=&gt; 0. 13639968906104905irb(main):014&gt; random. rand=&gt; 0. 30073063313880466Test doubles have short lifetimes RSpec tears down all your test doubles at the end of each example. That means they wont to play well with RSpec features that leave outside the typical per-examples, such as before(:context) hooks. You can work around some of these limitations with a method name with_temporary_scope. Partial doubles are useful but we consider them as a code smell, a superficial sign that might lead to a deeper design issue. Verifying doubles The upside of test doubles is that they can stand in for a dependency you do not want to track into your test. The downside is that the double and the dependency can drift out of sync with each other. Verifying doubles can protect you from this kind of drift. While we wrote the expense tracker app we touch briefly on verifying doubles when we marked the Ledger class because it didn’t exist yet. Here is a simplified version ledger = double('ExpenseTracker::Ledger')allow(ledger). to receive(:record)post '/expenses' doexpense = JSON. parse(request. body. read)result = @ledger. record(expense)JSON. generate('expense_id' =&gt; result. expense_id)endThe Ledger class didn’t exist yet; the test double provided enough of an implementation for your routing specs to pass. Consider what will happen if at some point you rename the Ledger#record method to Ledger#record_expense but forgot to update their routing code. Your specs would still pass, since they are still providing fake record method. But your code will fail in real world use, because it is trying to call a method that no longer exist. These kinds of false positives can kill confidence in your unit specs. You avoided this drive in your expense tracker project by using a verifying double to do so, you call instance_double in place of double, passing the name of The Ledger class. ledger = instance_double('ExpenseTracker::Ledger')allow(ledger). to receive(:record)With this double in place, RSpec checks that the real Ledger class (if it is loaded) actually response to the record message with the same signature. If you rename this method to record_expense, or add or remove arguments, your specs will correctly fail under your update your use of the method and your test double setup. Use verifying doubles to catch problems earlier Although your unit specs will have a false positive, you’re acceptance specs will still have cut this regression. That’s because they use the real versions of the objects, rather than counting on test doubles. By using verifying doubles in your unit specs you get the best of both worlds. You will catch errora earlier and at less cost, while writing specs that behave correctly when APIs change. RSpec gives you a few different ways to create verifying doubles, based on what it will use as an interface template for the double:    instance_double(‘SomeClass’):Constrains the double’s interface using the instance methods of SomeClass     class_double(‘SomeClass’):Constrains the double’s interface using the class methods of SomeClass     object_double(some_object):Constrains the double’s interface using the methods of some_object, rather than a class; handy for dynamic objects that use method_missing  Stubbed constants Test doubles are all about controlling the environment your specs running: what classes are available, how certain methods behaves, and so on. a key piece of that environment is the set of Ruby constant available to your code. For instance, password hashing algorithms are slow by design for security reasons, but you may want to pick them up during testing please see the next code snippet class PasswordHashCOST_FACTOR = 12# . . . endstub_const('PasswordHash::COST_FACTOR', 1)You can use stub_const to do a number of things: • Define a new constant• Replace an existing constant• Replace an entire module or class (because these are also constants)• Avoid loading an expensive class, using a lightweight fake in its place Sometimes controlling your test environment means removing an existing constant instead of stopping one. For example, if you’re writing a library that works either with or without ActiveRecord, you can hide the ActiveRecord constant for a specific example: Hiding the ActiveRecord constant like this will cut off access to the entire module. Including any nested constants like ActiveRecord::Base. Your code won’t be able to accidentally use ActiveRecord. Just as with partial doubles, any constants you have changed or hidden will be restored at the end of each example. hide_const('ActiveRecord')We have discussed the differences between stubs, spies and null_objects. In particular we saw how they deal with the following situations:  Receiving expected messages Receiving unexpected messages Not receiving expected messagesWe also looked at the different ways to create test doubles. . pure doubles are entirely fake, whereas partial doubles are real Ruby objects that have fake behavior at it. Verifying doubles fall in between and have the advantages of both with a few of the downsides of either. Part V — Chapter 14. Customizing test doubles. : In this chapter we are going to see how to return, raise, yield a value from our test double. How to supply custom behavior, how to ensure that the double test is calling the right arguments and how many times it calls it and in the right order. Configuring responses Since a test double is meant to standing for a real object, it needs to act like one. You need to be able to configure how it responds to the code calling it. When you allow or expect a message on a test double without specifying how it responds, RSpec provides a simple implementations that just returns nil. Your test doubles will often need to do something more interesting: return a given value, raise an error, yield to a block, or throw a symbol. allow(double). to receive(:a_message). and_return(a_return_value)allow(double). to receive(:a_message). and_raise(AnException)allow(double). to receive(:a_message). and_yield(a_value_to_a_block)allow(double). to receive(:a_message). and_throw(:a_symbol, optional_value)allow(double). to receive(:a_message) { |arg| do_something_with(arg) }# These last two are just for partial doubles:allow(object). to receive(:a_message). and_call_originalallow(object). to receive(:a_message). and_wrap_original { |original| }People new to rspec are often surprise at the behavior of expect on a partial double expect(some_existing_object). to receive(:a_message)Doesn’t just set up an expectation. it also changes the behavior of an existing object. Calls to some_existing_object. message will return nil and do nothing else. If you want to add a message expectation while retaining the original implementation, you will need to use and_call_original Returning multiple values We previously used and_return keyword when we set up our test double to return the same canned expense item each time it received the record message. Sometimes you need to stubbed method to do something more sophisticated that return the same value every time it is called. You might want to return one value for the first call, and a different one for the second call and so on. &gt;&gt; allow(random). to receive(:rand). and_return(0. 1, 0. 2, 0. 3)=&gt; #&lt;RSpec::Mocks::MessageExpectation #&lt;Double  Random &gt;. rand(any arguments)&gt;&gt;&gt; random. rand=&gt; 0. 1&gt;&gt; random. rand=&gt; 0. 2&gt;&gt; random. rand=&gt; 0. 3&gt;&gt; random. rand=&gt; 0. 3&gt;&gt; random. rand=&gt; 0. 3Here we give three return values, and they rand method returns each one in sequence. Yielding multiple values Blocks are ubiquitous in Ruby, and sometimes your test doubles will need to stand in for it interface that uses blocks. The aptly name and_yield method will configure your double to yield values extractor = double('TwitterURLExtractor')allow(extractor). to receive(:extract_urls_from_twitter_firehose) . and_yield('https://rspec. info/', 93284234987) . and_yield('https://github. com/', 43984523459) . and_yield('https://pragprog. com/', 33745639845)We chain together extract_urls_from_twitter_firehose three and_yield calls. When the code we are testing calls with a block, the method will yield the block three times. Each time, the block we receive a URL and a numeric to it. Raising exceptions flexibly When you’re testing exception handling code, you can raise exceptions from your test doubles using the and_raise modifier. This method has a flexible API that mirrors Ruby Ray’s method. In the examples we have shown so far, we’ve been working with pure test doubles. These doubles have to be told exactly how to respond, because they don’t have an existing implementation to modify. allow(dbl). to receive(:msg). and_raise(AnExceptionClass)allow(dbl). to receive(:msg). and_raise('an error message')allow(dbl). to receive(:msg). and_raise(AnExceptionClass, 'with a message')an_exception_instance = AnExceptionClass. newallow(dbl). to receive(:msg). and_raise(an_exception_instance)Partial doubles are different. Since they begin as an real object with a real method implementation, you can base the fake version on the real one. Falling back to the original implementation When you are using a partial double to replace a method, sometimes you only want to replace it conditionally. You may want to use a fake implementation for a certain parameters values but fall back on the real method the rest of the time. In these cases, you can expect or allow twice: once like you normally would, and once we and_call_original to provide the default behavior. # fake implementation for specific arguments:allow(File). to receive(:read). with('/etc/passwd'). and_raise('HAHA NOPE')# fallback:allow(File). to receive(:read). and_call_originalHere, we’ve used with(. . . ) to constrain which parameter values this stub applies to. Modifying the return value Sometimes, you want to slightly change the behavior of the method you are stubbing, rather than replacing it outright. You may, for instance, need to modify its return value. RSpec and and_wrap_original method, passing it a block containing your custom behavior. Your block will take the original implementation as an argument, which you can call at any time. This is the technique to stub out a CustomerService API to return a subset of customers: allow(CustomerService). to receive(:all). and_wrap_original do |original| all_customers = original. call all_customers. sort_by(&amp;:id). take(10)endThis technique can be handy for acceptance specs, where you want to test against a live service. If the vendor does not provide a test API that only returns a few records, you can call the real API and narrow down the records yourself. By working on just a subset of the data, your specs will remain snappy. Tweaking arguments You can also use and_wrap_original to tweak the arguments you pass into a method. Yhis technique comes in handy when the code you are testing uses a lot of hard coded values. allow(PasswordHash). to receive(:hash_password) . and_wrap_original do |original, cost_factor|  original. call(1)endSince both and_call_original and and_wrap_original need an existing implementation to call, they only make sense for partial doubles. When you need more flexibility So far, we have seen several different ways to customize how your test doubles behave. you can return or yield a specific sequence of values, race and exception, and so on. Sometimes, though, the behavior you need is a slightly outside what this techniques provide. If you are not quite sure how to configure a double to do what you need, you can supply a block containing whatever custom Behavior you need. Simply pass the block to the latest method call in the received expression. Here we are going to simulate an intermented Network failure while we are testing the request succeeds 75% of the time: counter = 0allow(weather_api). to receive(:temperature) do |zip_code| counter = (counter + 1) % 4 counter. zero? ? raise(Timeout::Error) : 35. 0endWhen your code calls the weather API, RSpec will run this block and depending on how many calls you’ve made, either return a value or raise a timeout exception If your block gets any more complex than this example, you might be better off moving into its own Ruby class. Martin Fowler refers to this kind of standing as a fake. fakes particularly are useful when you need to preserve state across multiple method calls. Setting constraints Most of the test doubles you have created will accept any input. If you stub a method named jump with no other options, RSpec will use your scope whenever you’re code calls jump, jump(:with, :arguments), or jump { with_a_block }. In this section we are going to look at ways to set constraints on a test double so that RSpec only uses it if your code calls it in a certain. Constraining argument You will often want to check that your code is calling a method with the correct parameters. To constrain what arguments your mock object will accept, add a call to with to your message exception expect(movie). to receive(:record_review). with('Great movie!')expect(movie). to receive(:record_review). with(/Great/)expect(movie). to receive(:record_review). with('Great movie!', 5)If your code calls the method with arguments that don’t match that constraint then the exception remains unsatisfied. RSpec will treat it the same as any other unmet expectation. In this example, we are using expect, meaning that RSpec will report a failure: &gt;&gt; expect(movie). to receive(:record_review). with('Good')=&gt; #&lt;RSpec::Mocks::MessageExpectation #&lt;Double  Jaws &gt;. record_review( Good )&gt;&gt;&gt; movie. record_review('Bad')RSpec::Mocks::MockExpectationError: #&lt;Double  Jaws &gt; received ↩ :record_review with unexpected arguments  expected: ( Good )  got: ( Bad )« backtrace truncated »If we had used allow instead, RSpec would have looked for another expectation that fit the passed-in arguments: (no failure raised!) &gt;&gt; allow(imdb). to receive(:rating_for). and_return(3) # default=&gt; #&lt;RSpec::Mocks::MessageExpectation #&lt;Double  IMDB &gt;. rating_for(any arguments)&gt;&gt;&gt; allow(imdb). to receive(:rating_for). with('Jaws'). and_return(5)=&gt; #&lt;RSpec::Mocks::MessageExpectation #&lt;Double  IMDB &gt;. rating_for( Jaws )&gt;&gt;&gt; imdb. rating_for('Weekend at Bernies')=&gt; 3&gt;&gt; imdb. rating_for('Jaws')=&gt; 5Your test doubles can require something as simple as a specific value, or as sophisticated as any custom logic you can devise. Argument placeholders When a message takes several arguments, you maker more about some than others. In the next example we are stubbing a shoppingcart add_product method that takes a name, a numeric id, and then vendor specific code. If we only care about the name, you can pass they worth anything as a placeholder for the others expect(cart). to receive(:add_product). with('Hoodie', anything, anything)You can also represent a sequence of anything placeholders with any_args expect(cart). to receive(:add_product). with('Hoodie', any_args)The counterpart to any_args is no_args: expect(database). to receive(:delete_all_the_things). with(no_args)Hashes and keyword arguments Ruby APIs, especially ones written before Ruby 2. 0 came out class BoxOffice def find_showtime(options)  # . . .  endendbox_office. find_showtime(movie: 'Jaws')box_office. find_showtime(movie: 'Jaws', zip_code: 97204)box_office. find_showtime(movie: 'Jaws', city: 'Portland', state: 'OR')When you’re testing code that calls such a method, you can use RSpec’s hash_including to specify which keys must be present. All three of these find_showtime calls would match the following constraint: expect(box_office). to receive(:find_showtime) . with(hash_including(movie: 'Jaws')) Flexible constraints like hash_including make your specs less brittle. Rather than having to give all the keys of your hash, you can give just the ones you care about. If the value of an unimportant key changes, your specs needn’t fail.  Ruby 2. 0 added keyword arguments class BoxOffice def find_showtime(movie:, zip_code: nil, city: nil, state: nil)  # . . .  endendThe good news is that the hash_including constraint works just as well with keyword arguments as it does with old-style option hashes. RSpec also provides a hash_excluding constraint to specify that a hash must not include a particular key Custom logic When you have written a bunch of constraints, you will inevitably find yourself repeating the same complex constraint in several specs. occasionally, you will need logic that’s too involve to express as a simple constraint. In both of these situations, you can supply your own custom logic For example, if you have several specs that shoudl call find_showtime with cities in Oregon, you can wrap this constraint in a custom rspec matter: RSpec::Matchers. define :a_city_in_oregon do match { |options| options[:state] == 'OR' &amp;&amp; options[:city] }end# usage of . withexpect(box_office). to receive(:find_showtime). with(a_city_in_oregon)You can constrain arguments using an ordinary Ruby value, a regular expression, one of RSpec-mocks provided constraints or any built-in or custom matcher. Behind the scenes, rspec marks Compares method arguments using the === operator. Custom argument constraints can reduce repetition and make your expectations easier to understand. Constraining how many times a method gets called In addition to constraining a method arguments, you can also specify how many times it should be called. client = instance_double('NasdaqClient')expect(client). to receive(:current_price). thrice. and_raise(Timeout::Error)stock_ticker = StockTicker. new(client)100. times { stock_ticker. price('AAPL') }Even though we’re calling stock_ticker. price many times, we expect the circuit breaker to stop hitting the network after the third simulated timeout error. As you might guess from the name thrice, RSpec also provides once and twice modifiers. Since the English language doesn’t provide any multiplicative adverbs after 3, you’ll need to switch to the more verbose exactly(n). times expect(client). to receive(:current_price). exactly(4). timesOrdering Normally, RSpec doesn’t care what order you send messages to a test double: expect(greeter). to receive(:hello). orderedexpect(greeter). to receive(:goodbye). ordered# The following will fail:greeter. goodbyegreeter. helloUsing ordered is a sign that your specs may be too coupled to one particular implementation/ You can use all of the types of constraints we’ve seen here—arguments, call counts, and ordering—together in one expectation: expect(catalog). to receive(:search).  with(/term/). at_least(:twice). orderedSummary of concepts covered in this chpater:       Concept   Usage   Example         and_return   Configure test double to return specific values       allow(double). to receive(:msg). and_return(value)    allow(double). to receive(:msg). and_return(0. 1, 0. 2, 0. 3)          and_raise   Configure test double to raise exceptions       allow(double). to receive(:msg). and_raise(AnException)    allow(double). to receive(:msg). and_raise('error message')          and_yield   Configure test double to yield values to blocks       allow(extractor). to receive(:extract_urls)    &nbsp;&nbsp;. and_yield('https://rspec. info/', 123)          and_call_original   Fall back to original implementation (partial doubles)       allow(File). to receive(:read). with('/etc/passwd'). and_raise('NOPE')    allow(File). to receive(:read). and_call_original          and_wrap_original   Modify behavior of original method       allow(CustomerService). to receive(:all). and_wrap_original do |orig|    &nbsp;&nbsp;orig. call. take(10)    end          with   Constrain arguments that mock will accept       expect(movie). to receive(:record_review). with('Great!')    expect(cart). to receive(:add_product). with('Hoodie', anything)          hash_including   Match hashes containing specific keys       expect(box_office). to receive(:find_showtime)    &nbsp;&nbsp;. with(hash_including(movie: 'Jaws'))          Call count modifiers   Specify how many times method should be called       expect(client). to receive(:current_price). thrice    expect(client). to receive(:price). exactly(4). times          ordered   Enforce specific order of method calls       expect(greeter). to receive(:hello). ordered    expect(greeter). to receive(:goodbye). ordered          Key Insight: Use expect vs allow wisely - expect changes behavior AND sets expectations, while allow only changes behavior. Custom blocks provide ultimate flexibility when built-in modifiers aren't enough.    Here are some usefull articles i found about the topics we went over, and also i had chatGPT to provide me more details https://stackoverflow. com/questions/28006913/rspec-allow-expect-vs-just-expect-and-return https://martinfowler. com/articles/mocksArentStubs. html https://chatgpt. com/share/68ad328f-1478-800a-9304-90c2de18939a https://share. google/aimode/SFNEx3Z7x6YM1nYTJ Part V — Chapter 15. Using test doubles effectively. : In this chapter we will see:  the construction of an environment for each spec how to providde test doubles to the code we are testing what are the most common pitfalls and how to how to improve our code by applying this sign feedback from our testUsing test doubles effectively Over the previous two chapters, we have tried out mocks, stubs, spies and null objects. We have learned which situation each is best for. We have also seen how to configure their behavior, and how to check that a double is called correctly. Now, we would like to talk about the trade-offs. Although we frequently use doubles in our tests, I will be the first to acknowledge that doing so incurs some risk.  Code that passes the test but fails in production, because the test doubles don’t behave enough like a real.  Brittle tests that fail after a refactoring, even though the new coat is working correctly Do-nothing tests that only end up checking your doublesConstruction or test environment "
    }, {
    "id": 32,
    "url": "http://localhost:4000/2025/03/16/hands-on-tdd-rails.html",
    "title": "Hands-on TDD: Using Ruby, Rails, and RSpec",
    "body": "2025/03/16 - The book has a very practical approach (living up to its title “hands-on”) where the author explains what you’re going to build, which tools and why those tools. It’s meant for beginner-intermediate developers. The content follows a linear structure which means you should read chapters from the beginning to the end, in a straightforward manner, you’ll follow him along as he codes the web app as you see the red-green-refactor cycle. The outcome will be getting a better grasp of the benefits of applying Test-Driven Development (TDD), how to adopt this new mindset.  Introduction.  What is TDD?.  Getting started with Ruby. Introduction. : It was not so long ago that we did not even write tests for our software. at some points, some very smart people realize that writing tests for our software was actually a good idea. our tests will provide us with confidence that our software worked as expected and even more importantly keep us from getting phone calls in the middle of the night to fix things that would break in production. not long after we started writing tests, some other very smart people realize that writing our test first would give us an opportunity to think about what we were going to ride before we would write it. it will give us a Target to aim at, in effect. this was the birth of test driven development tdd is a style of software development where we write our test first, see that they are failing as expected, and only then do we pursue writing the code to make those tests passed. this is the central idea of my book. we will think about what we want to do, then we will capture that idea with a properly failing test. we will then write the code to make the test pass. we will then we Factor our code to make it better, or prettier, or less repetitive. we will use test driven development style of software design and engineering, which means we will write failing test first and only then write our implementation code to get our failing test passing. we will use our spec testing framework to write our test. our spec describes itself as a tool for performing behavioral driven development and as in fact the best tool available for testing will be code. The main goal of this book is to provide a practical common Hands-On introduction to test driven style of software design and engineering. many books on the topic of test driven development have been written before this one. most other books are written in a small problem sort of writing style. they cover single topics, one of the time, barely more than a reference guy. they do not cover the entire process of building software application from start to finish, using tdd. as a result, they are, in my opinion, let’s practical and much less useful for actually learning practical tdd. The author Estates the following colon I have never seen software written using tdd that was not better than software written without tdd What is Test Driven Development?: Getting started with Ruby. : "
    }, {
    "id": 33,
    "url": "http://localhost:4000/2025/03/09/systems_test_post.html",
    "title": "Computer systems Test Post",
    "body": "2025/03/09 - Test for computer systems "
    }, {
    "id": 34,
    "url": "http://localhost:4000/2025/03/08/networking_test_post.html",
    "title": "Networking Test Post",
    "body": "2025/03/08 - Test for networking "
    }, {
    "id": 35,
    "url": "http://localhost:4000/2025/02/05/professional-rails-testing.html",
    "title": "Professional Rails Testing",
    "body": "2025/02/05 - This book has two parts, the first one goes over principles of testing, the second is about the tools you can use to test your code base.  Chapter 1. Introduction.  Chapter 2. Tests as specifications.  Chapter 3. Test driven development.  Chapter 4. Writing meaningful tests.  Chapter 5. Writing understandable tests.  Chapter 6. Duplication in test code.  Chapter 7. Mocks and stubs.  Chapter 8. Flaky tests.  Chapter 9. Testing sins and crimes.  Chapter 10. Ruby DSL.  Chapter 11. Factory bot.  Chapter 12. RSpec syntax.  Chapter 13. Capybara’s DSL. Chapter 1. Introduction. : The first chapter is about what you can expect from the book, why the author chose Rspec over Minitest and the ways you can reach out to Jason Swett. Chapter 2. Tests as specifications. : The 2nd chapter aims to lay out what a test is, in this case the author rejects the idea that tests are verifications, rather they are specifications and with this definition the objective of testing goes from “make sure the code worked” to “enforce the code behave as specified”. He also provides an example of a manufacturing site where all of its finished products behave the same way because they meet their design specifications due to its production system therefore it produces that same throughput always. He also shares that the main challenge is to switch developer’s mindset from verification to a specification, this will entail moving from “capabilities” to “scenarios”. the next examples are going to be capabilities: the user can update their email address the user can sign in the user can reset their password on the other hand we have scenarios, for instance: when the user signs in with a valid credentials, the dashboard page will show up when the user attempts to sign in with invalid credentials and error message is shown A specification is a statement of how some aspect of a software product should behave. Again departing from the scenario point of view and we can break it down to the following: Scenario: when a user enters a valid email and password combination into the email and password fields, then clicks ‘sign in’ Expectation: the user dashboards page is shown. This is a style that the author has conceived and he denotes that it makes sense to him but it is not a golden rule, in other words “under such-and-such a scenario, we expect such-and-such behavior” The author describes with an example of a parser program the same pattern of a scenario and expectation and it goes step by step from creating the file, adding some boilerplate, starting with some comments in order to remove the writer’s block and finally he quotes the ‘arrange act and assert’ phases. Small recap:Scenario (what to test, we can remember this with words like “when” or “given”)Expectation (We can remember with the keyword “then”)Setup, exercise and assertion ( arrange act and assert)     Source: Medium  Chapter 3. Test driven development. : Chapter 3 is about TTD (test driven development) he briefly describes what it is, pointing out why it is often called the ‘red, green, refactor loop’, what do those colors mean? and finally the importance of refactoring the code you wrote. Red: Firstly we start with deciding “what to do” and then “doing it” (this reduces cognitive load) keeping in mind that a test is an executable and “specification”. We first write the test so we set out the ‘specification’ and then we write the code to fulfill given a specification. Something important here is to run the test so we can clear out any false positives on the code, by running it and getting the red color we make sure that it is failing. Importance of the green color and as the author quotes ‘Kent Beck’ you can make any ‘sins code’ in order to make the code pass, this means to write crappy code but make sure that you pass from red color to green color. Also the author describes that if the whole system is covered by testing, we can refactor the system code as much as we want without too much fear that refactoring will introduce regressions. It is not an absolute warranty but it provides high degree of well justified confidence. The author also said that he focuses on writing just enough code to make the current failure message go away, maybe not passing the whole test but just a small bit of it. And finally ‘refactor’ this is where all the mess is cleaned up, duplication is removed maybe some optimization is added and here the author again shares one of his personal exercises that once he have passed the testing he hold off and give himself sometime to forget about the problem because it is very embedded in his brain and the refactor is not going to be very effective, instead he takes some time and then comes back and address the exact pain Here is one statement about TDD that I liked “ the main reason for practicing TDD is to go faster and be more productive in simpler terms you want to decrease the radio of effort invested to Value produced” TTD also encourages modular, loosely coupled design, less mental effort, more enjoyable workflow, fewer bugs, documentation, feedback loops (most important I personally think!) Here is the feedback loop that TDD can create: specify an objective devise a test that can be performed to see if #1 is done perform the test device in step 2 do some work toward the objective ( wright a line of code) repeat steps three and four until the test passes repeat from step one with a new objective Some notes from the author that I think are worth is when you write a line of code it is going to help us the message failure to go away so we can avoid coding speculatively and this will help us lower the mental burden in each step of this feedback loop, Lastly the author closes this chapter by comparing the ‘manual testing‘ versus the TDD that as much as you practice it, you’ll get more fluent and it will become a great time saver Chapter 4. Writing meaningful tests. : The author states that having tests is better than not having tests but not always writing tests are equally good tests are more valuable when they are meaningful. A test is Meaningful if it tests not just means to ends but ends themselves. When we are testing something we can focus either on means or ends, for example if we test a staple by just examining if it has all the right parts and just trying to staple 3 sheets of paper.  By making sure that it has all the right parts it doesn’t mean we are testing the ends. On the contrary, if we staple 3, then 12, 20 and we can affirm that we can continually do this activity, that’s when we test the ends. When it comes to testing model associations it would be more meaningful to make assertions on the behaviors that these associations enable. Another great example is that airplanes engines can be tested even without attaching the engines to an airplane. How to decide what kind of test drive, here we only have cost and benefits, we want to achieve satisfactory test coverage while incurring the smallest cost possible. System tests are the only type of test that proves that all the parts of your system are successfully working together without system tests. We could theoretically have a web application with a fully passing suite of unit tests even if the application is unable to successfully serve a single request. Something that I have seen has always been trivial is % of test coverage and the author suggests the following:  What if we use a minimum number of system tests, perhaps one for the happy path and one or two more for the failure cases and then use fast unit tests for all the edge cases? This way we will get a reasonable level of confidence that our system works as a whole. Then we have: how to test models (POROs), requests, background jobs, mailer specs, helper specs, view specs and view components. Also we have a very important question “when to write a test and went to not”, remember that testing is not about right or wrong but about cost and benefits here are five questions:  Is the behavior likely to ever break? If the behavior were to fail, would it fail silently? if the behavior were to fail, would it fail frequently? if the behavior were to fail, would the consequence be severe? Is the test easy to write?If any of the answers to these questions is a yes, I write the test. If and only if all of the answers are negative I do skip the test. The aggregate benefit of tests. It is common to want to get some sort of 80/20 benefit by only covering the most important 20% of the codebase tests.  I think this way of thinking focuses on the benefit of individual tests while missing the aggregate benefit of tests. Remember cost and benefits of testing can be refactoring with no fear, gaining speed for development without even thinking Dusty’s part of the code base is tested well enough? In a model do we need to test every method, again remember that we covered every Behavior not every method. Chapter 5. Writing understandable tests. : I think this is the longest chapter but is the one that has more meat because it touches topics as code quality in tests, in this case “abstraction”, (we always hear about quality code of the app itself but not in tests), it revisits the what the ‘when’, the ‘given’, ‘then’ as a structure for the test. Also how to accommodate the different files you need in the rails app, when to use helper when those are helpful, what about concerns, when is a good practice to create a model without inheriting from ActiveRecord, how to preserve ‘cohesion’, also Rspec feature which is ‘shared examples’, what may cause obfuscation in the tests, whether you use ‘subject’ or ‘let’ in our specs, plus the author gives a very useful opinion about code duplication (he shares that duplication is okay when it comes to testing). Something that I truly liked is when the author brings up that a codebase is like a story book so each file has to be seen as a chapter, where you see essential points and it remains on those essentials topics and also incidental/distracting things that may go on the footnote or appendix. Tests are more than just a safety net to catch regressions. A test suite can serve as a guidebook to a system, showing what the system’s parts are, how the parts relate to each other, which ideas are more and less important, and of course, how are the parts of the system are supposed to behave A test suite is a structured collection of behavior specifications, and can also serve as the backbone for a systems design. It is common to think of a system’s code as its essence and the tests as something secondary.  I invite you to think of it the other way around. A system’s code shows what the system does, but the system’s application code does not have the last word.  Because an application tests are specifications, whatever the test specifies is, by definition, correct. So far we have mostly focused on writing new tests and writing them. but in a production application, in addition to being written and run, tests often need to be understood and modified. Abstraction is the art of hiding distracting details and emphasizing essential information. Test code is responsible for jobs that vary widely in the relevance to the high level meaning of the test. 1 test data has to be created. 2 dependencies have to be initialized. 3 code has to be finagled into the right state. 4 assertions have to be made, etc. Here is a testing code example: Before: RSpec. describe  Creating Comment , type: :feature, js: true do let(:user) { create(:user) } let(:raw_comment) { Faker::Lorem. paragraph }let(:article) do create(:article, user_id: user. id, show_comments: true)end  before { sign_in user }  it  User replies to a comment  do  create(:comment, commentable_id: article. id, user_id: user. id)    visit article. path. to_s    find( . toggle-reply-form ). click  find(   :xpath,     “//div[@class=’actions’]/form[@class=’new_comment’]/textarea”). set(raw_comment)  find(   :xpath,     “//div[contains(@class, ’reply-actions’)]/input[@name=’commit’]). click  expect(page). to have_text(raw_comment) endendThe “it” block should describe how it (the system) should behave. To me the way this test description is written is a sign that this test is not the result of a clearly thought out specification The next step is to think about the one or the given, in this case when user submits a reply to a comment or not article ( a scenario) the body of the reply shows up on the article’s page ( expectation) After (with better description): RSpec. describe “Creating Comment”, type: :feature, js: true do  context  user submits a reply to a comment on an article” do  it “shows the reply on the article’s page” do  end endendIf an abstraction does not give you the slightest clue of what it is doing without looking at its content, Then it is a pretty poor abstraction. When a test is full of distracting details, simply moving the details behind methods is not necessarily an improvement; careful thought must be given to what abstractions the methods represent and why they are helpful. RSpec. describe  Creating Comment , type: :feature, js: true do before { sign_in user } it  User replies to a comment  do  create_setup_data  submit_comment  expect_correct_comment end def create_setup_data  let(:user) { create(:user) }  let(:raw_comment) { Faker::Lorem. paragraph }  let(:article) do   create(:article, user_id: user. id, show_comments: true)  end end def submit_comment  create(:comment, commentable_id: article. id, user_id: user. id)  visit article_path. to_s  find( . toggle-reply-form ). click    find(   :xpath,    //div[@class='actions']/form[@class='new_comment']/textarea   ). set(raw_comment)    find(   :xpath,    //div[contains(@class, 'reply-actions')]/input[@name='commit']   ). click end def expect_correct_comment  expect(page). to have_text(raw_comment) endendThe author also speaks about scoping (arranging app’s files) and gives a relevant example of an appointment model ls -1 spec/modelsappointment_spec. rbinvoice_spec. rbpatient_spec. rbuser_spec. rbls -1 app/modelsappointment. rbinvoice. rbpatient. rbuser. rbThe rails g scaffold appointment command gave the developers to containers to put stuff in, one called app/models/appointment. rband another called spec/models/appointment. rb. Slowly over time, each of these containers group, a few lines of code at a time, into a monster. How do we fix this? by slicing up the model code into a smaller, more cohesive pieces for instance: The recurrence logic moved into an object called RecurrenceRule which lives in app/models/recurrence_rule. rb or even better with namespace Schedule::RecurrenceRule and lives at app/models/schedule/recurrence_rule. rb Cohesion If a code base is like a story, a file in a code base is perhaps like a chapter in a book. A well-written chapter will clearly let the reader know what the most important points are and will feature those important points most prominently. A chapter is most understandable when it principally sticks to just one topic. If a detail would pose too much of a distraction or an interruption, it gets moved to a footnote or appendix or parenthetical clause. A piece of code is cohesive if a) everything in it shares one single idea and b) it doesn’t mix into incidental details with essential points. How cohesion gets lost  Fresh new projects are usually pretty easy to work with because when you don’t have very much code, it is easier to keep your code organized and when the total amount of code is small, things have to be pretty disorganized in order for it to hurt. Things get tougher as the project grows. Entropy is the tendency for all things to decline to disorder unavoidably sets in. A common manifestation of entropy is when I developer is tasked with adding a new behavior. he or she goes looking for the object that seems like the most fitting home for that new behavior. he or she adds the new behavior, which does not perfectly fit the object where it was placed, but the code only makes the object say 5% less cohesive, the result of all these changes in aggregate is a surprisingly bad mass. How cohesion can be preserved?  The first key to maintaining cohesion in any particular piece of code is to make a clear distinction between what’s essential and what’s incidental. Let’s say that I have for example a class called Appointment. The concerns of Appointment include among other things, start time, a client and some matters related to caching. I would say that the start time and client are essential concerns of an appointment and that the caching is probably incidental. Now where to put these newly sprouted files. The rationale here is that cashing logic will only ever be relevant to a scheduling whereas an appointment might be viewed in multiple contexts, for example sometimes scheduling and sometimes billing. app/models/appointment. rbapp/models/scheduling/appointment_caching. rbHere is another example of a Customer object with certain method including one called balance.  Over time the balance calculation becomes increasingly complicated to the point that it causes Customer to lose cohesion. I can just move the guts of the balance method into a new object (a PORO) called CustomerBalance and delegate all the gory details of balance calculation to that object. Now the Customer object once again focuses on the essential points and forget about the incidental details. app/models/customer. rbapp/models/billing/customer_balance. rbIn the case that we cannot extract the incidental details of an object we can use a ‘mixin’ instead. I view ‘mixin’ as a good way to hold a bit of code which has cohesion with itself but which does not quite qualify as an abstraction and so does not make sense as an object. For me, ‘mixins’ usually don’t have a standalone value, and they are usually only ever “mixed in” to one object as supposed to be reusable.  I could have said ‘concern’ instead of ‘mixin’, but to me it is a distinction without a meaningful difference, and concerns come along with some conceptual baggage that I don’t want to bring into the picture here. Jason believes in organizing files by meaning rather than type. Shared examples from our spec is something that at first glance seems to be a good idea however it provides obfuscation because it is difficult for the programmer to know where the values and variables come from https://rspec. info/features/3-13/rspec-core/example-groups/shared-examples/ Duplication code only for testing. Duplication is mainly bad when it passes a risk of two or more pieces of behavior getting out of sync due to a mistake, leaving one copy of the behavior correct and the other one incorrect. Since tests are not behavior, they are not always susceptible to the same kinds of duplication mistakes as application code. Test helpers on DRY That DRY principle does not apply to test code in the same way that it applies to application code, since application code is behavior whereas the test code is a specification. Helpers are not tested and they do not contain specifications. They simply help with gruntwork. online test code a helper does benefit from being DRY just like application code does. Managing setup data Most tests require some setup data, the more setup data there is, the harder it is to keep the test code understandable. It’s important for tests to be deterministic, meaning that they behave the same way every time. if a test is not deterministic, it may pass sometimes and fail sometimes, giving false negatives and causing numbness to legitimate failures. A key ingredient in making a test stick is to start with the same state every time. If a test is allowed to pollute its environment by changing for example environmental variables, configuration settings or database data, then the test that runs after it will run in a fould environment instead of a clean slate. For this reason, Rails by default runs every test inside of the database transaction, before the test finishes, the transaction gets aborted so that any data created inside the test never gets committed to the database. Every piece of data that’s in the database when test starts, we will call this data “background data”, has the potential to influence how the test behaves. the less background data there is, the fewer headaches it can cause. Naming. The author lays out a test that has three values: ‘user’, ‘token’, ‘mismatch_token’.  He states that the last one is pretty clear, however after reading the whole test he suggested changing from ‘token’ to ‘valid_token’ in order to make it clearer. A good rule of thumb for naming is to call things what they are.  This rule may sound obvious, but how many times have you encountered a variable method, class or database table that’s named according to something other than what it actually is? Because code is read many more times than it is written, the cost of a poor name is often many times more than the cost saved by skipping the effort of giving it a clear name. One topic per test. Some testers believe that each test should have just one assertion, others believe that this rule is hogwash, and that a test should have as many assertions as it needs. The significant thing about the test is not how many assertions it contains but rather how many topics it contains. A test with just one topic – a test that’s only about one thing– it’s going to be easier to understand than a test that conflates multiple topics. It is common for developers to stuff several assertions into one test out of a desire for performance efficiency, especially in system specs, which are expensive to run. That I think this is usually a false economy. Yes, a performance benefit is cheap but at expense of understandably but the savings in CPU time is paid for by engineer time and we of course know which of the two is more expensive. The phases of a test Every test has four phases: set up, exercise, assertions and tear down. in Rails the tear down usually happens automatically, so we only need to think about the ‘setup’, ‘exercise’ and ‘assertion’ steps done. They are also known as a range, act, assert. Organizing your test Suite. As we saw at the beginning of this chapter, a test suite, when thought of as a structure set of behavior specifications, can serve as the backbone of a systems design. The files and folders in a test suit should be laid out in an orderly and logically fashion so that when one needs to find something, it can be found easily. Instead of organizing tests by test type, which in a sense is an incidental detail, I find it more logical to organize my test by domain concept. Each folder in a test suite can be thought of as having two dimensions: to what domain concept it belongs and to what type of test it pertains. Traditional Rspec way to order files:      | billing     | schedule    | clinical    ----------|----------------|----------------|----------------models  | models/billing | models/schedule | models/clinicalrequests | requests/billing | requests/schedule | requests/clinicalsystem  | system/billing | system/schedule | system/clinicalJason suggests the following by meaning (domain-specific) and then type:      | models     | requests    | system    ----------|---------------|----------------|---------------billing  | billing/models | billing/requests | billing/systemschedule | schedule/models | schedule/requests | schedule/systemclinical | clinical/models | clinical/requests | clinical/systemLastly, something helpful that this new approach helps is to catch regressions, when tests are organized by the main concept, the search for regressions can be conducted much more logically and efficiently. Once you get for instance spec/schedule/appointments/system/cancel _appointment. rb passing, you can then locally run all the tests in that parent folder spec/schedule/appointment. Chapter 6. Duplication in test code. : It is commonly believed that duplication is code that appears in two or more places. But this is actually mistaken. Duplication is when there is a single behavior that’s specified into or more places. Just because two identical pieces of code are present does not necessarily mean duplication exists. And just because there are no two identical pieces of code present doesn’t mean here is no duplication. Two pieces of code could happen to be identical, but if they actually serve different purposes and lead separate lives, then they do not represent the same behavior, and they do not constitute duplication. The way to tell if two pieces of code are duplicative is not to see if their code matches. The question that determines application is; “if I changed one piece of code in order to meet any requirement, would it be logically necessary to update the other piece of code the same way?” The main reason for duplication is that it leaves a problem susceptible to developing logical inconsistencies. If a behavior is expressed in two different places in a program, and one of them accidentally does not match the other, then the deviating behavior is necessarily wrong. Another reason duplication can be bad is because it can cost an extra maintenance burden. What determines how risky duplication is 1) one how easily noticeable the duplication is2) how much extra maintenance overhead the presence of the duplication incurs,3) how much traffic that area receives( how frequently that area of code needs to be changed or understood) Noticeability If someone updates one of the code of the behavior to meet any requirement they are very likely to miss updating the other one. We might call this the proximity factor. If two pieces of duplicated behavior appear in different files in different areas of the application, then a mess is much likely to occur, and therefore the application processes a larger risk. Another quality that makes the noise ability of the application issued is similarity. If two pieces of code look very similar than the duplicity is more likely to be noticed than if the two pieces of code do not look the same (similarity factor) Maintenance overhead If a piece of duplication exists as a part of the database schema, that’s a much higher maintenance cost than a small duplication in code. Instances of duplication there are large and are not represented by identical code can also be costly to maintain because, in those cases, you cannot just type the same thing twice, you have to perform a potentially expensive translation step in your head. Traffic levelThe more frequently the code is changed, the more of a toll it is going to incur, and so the bigger problem it is. Another tollway is when a piece of code needs to be understood as a priority to understanding a different piece of code. How to decide whether to DRY up a piece of code. There are two simple options, although it is not always easy. Severity. If a piece of duplication is severe for example it has low noticeability, it posses high maintenance overhead, and has a high traffic level, then those all add weight to the argument that the duplication should be cleaned up. The quality of alternatives just because a piece of duplication costs something does not automatically mean that the duplicated version costs less. It doesn’t happen very often but sometimes ad duplication unavoidably results in code that’s so generalized that it is virtually impossible to understand. Rule of three, write everything twice. When I’m deciding whether to dry up a duplication, I asked myself: how severe is this instance of duplication? Are we able to come up with a fix that’s better than the duplicated version and not worse? Example, imagine a piece of duplication in the form of three very simple and nearly identical lines, group together in a single file, the file is a unimportant one which only gets touch a couple of times a year, and no one needs to understand that piece of code as a prerequisite to understanding anything else. Now imagine another piece of duplication. The duplication appears in only two places but the places are distant from each other and therefore the application is hard to notice. The two places where the duplicated behavior appears are expressed differently enough that the code would elude detection by a quality tool or a manual human search. The behavior is vitality central and important one and the two places the behavior appears are virtually painful to keep in sync. Duplication is cheaper than the wrong abstraction The real difference between duplication and test code and application code. Duplication, again, is when a one behavior is expressed into or more places. The difference between the test code and application code is that test code does not contain behavior. all the behaviors are in the application code. the purpose of the test code is to specify the behaviors of the application code. What is the codebase that determines whether the application code is correct? the test. If a piece of behavior is duplicated in two places in the application code and one piece of behavior gets changed, it does always logically follow that the other piece of behavior needs to get updated to match. (otherwise they will not be the instance of a duplication. ) Chapter 7. Mocks and stubs. : What is a stub? In a football scrimmage, the team doesn’t play against a real opponent because:  It’s expensive (travel, logistics, etc. ).  It could have unwanted side effects (injuries, revealing strategies, etc. ).  Instead, they simulate the opponent using their own players to control the scenario. Similarly, in testing: A stub replaces an actual method with a controlled response. It prevents expensive operations like:  Database queries.  External API calls.  Complex calculations.  It ensures the test has more controllable responses. Example: class PaymentGateway def charge(amount)  # Imagine this calls an external API (expensive!)   Charged #{amount}  endendRSpec. describe PaymentGateway do it  stubs the charge method  do  gateway = PaymentGateway. new  allow(gateway). to receive(:charge). with(100). and_return( Stubbed charge )  expect(gateway. charge(100)). to eq( Stubbed charge ) # Controlled response endendWhat is a mock? Imagine Mr. Boss pretends to be a regular customer (mock objects pretend to be real objects)He orders specific items like a hamburger, fries, and a coke (sets expected method calls). Afterward, he “interrogates” the experience - “Did you receive the hamburger you ordered?” (verifies that expected interactions occurred) If any verification fails, the test fails A mock is a fake object (like the undercover boss is a fake customer)It has predetermined responses class Waiter def take_order(order)  # Imagine this method interacts with a real kitchen system   Order placed: #{order}  endendRSpec. describe Waiter do it  verifies that the order was placed  do  waiter = Waiter. new  expect(waiter). to receive(:take_order). with( hamburger )  waiter. take_order( hamburger ) # If this isn't called, the test fails endendSummary    A stub is like using a fake team in a football scrimmage—it avoids unnecessary costs.     A mock is like an undercover boss—it checks if expected interactions happen.  “Do I just need to fake a response?” → Use a stub. “Do I need to verify that something was called?” → Use a mock.       Feature   Stub   Mock         Purpose   Controls return values   Verifies method calls       Tracks calls?   No   Yes       Fails test if method is not called?   No   Yes   Testing third party interactions using stubs In principle we could test third party interactions by actually hitting live services. the upside to this approach is that it provides a very realistic environment, however the downsides are: Loss of determinism, this means that our tests will potentially be non-deterministic. Determinism is the property of always behaving the same way given the same starting conditions. Tests that involve third-party services may behave one way on some runs and another way on other runs even though they’re starting conditions were the same. Limited ability to control test scenarios, when writing tests that involved third-party services, it is desirable to cover certain scenarios such as when the server returns a value response, when the service return a graceful error response, or a 500 error so creating this scenario is impossible. Side effects, using live services can also cause rate limiting, causing the test to eventually flake once requests start failing due to rate limits, and also preventing real production requests. Stubbing services. Stubbing third party services avoids the problems that come with using live services. When services are stubbed our test can be deterministic, we can control our test scenarios and we don’t have to worry about introducing side effects. What exactly is stubbing? is a practice of replacing one piece of behavior with another. Coming up with good tests A common mistake is to write tests that “make sure the API gets called” and to “make sure the right results get returned”.  Remember that testing is about a specification, not verification. The test is not to “make sure the code worked” but rather to specify how the code should work. Remember that the behavior we are interested in is what happens after the API (stripe, paypal) response is received. Example of code before “stubbing” require  rails_helper include APIAuthenticationHelperRSpec. describe  GitHub tokens , type: :request do Describe “POST /api/v1/github_tokens” do  it  returns a token  do   post(       api_v1_github_tokens_path,        headers: api_authorization_headers   )  expect(response. body). to be( ABC123 ) endendAfter stubbing: require  rails_helper include APIAuthenticationHelperRSpec. describe  POST /api/v1/github_tokens , type: :request do it  returns a token  do  allow(GitHubToken). to receive(:generate). and_return( ABC123 ) 👈  post(   api_v1_github_tokens_path,   headers: api_authorization_headers  )  expect(response. body). to eq( ABC123 ) endendThe behavior we are mainly interested in is not how the token gets generated but in how the GitHub tokens API endpoint response to a request for a token. The line “allow(GitHubToken)” Does not actually call the method, but instead return the hard coded value “ABC123”. Code example for mocking class TaskProcessor def self. process  puts  Processing task. . .   endendclass BackgroundJob def perform  TaskProcessor. process endenddef start_background_job(job = BackgroundJob. new) job. performendclass MockedJob def initialize  @performed = false end def perform  TaskProcessor. process  @performed = true end def performed?  @performed endendRSpec. describe  Starting the background job with RSpec mock  do it  calls . perform on the mock job  do  job = MockedJob. new 👈  expect(job). to receive(:perform) 👈  start_background_job(job) endendChapter 8. Flaky tests. : When a boat leaks, the crew has not one problem but two. One problem is the water that’s in the boat, causing it to lose buoyancy. This problem can be mitigated by bailing out water, but it won’t solve the other problem, which is that there are holes in the boat allowing more water to leak in.       Layer   Symptom   Root cause         Secondary   Water in the boat   Holes in the boat.        Primary   Holes in the boat   Poor design? Aging?   The holes in the boat are the symptom of the primary problem. The two layers of the flaky test problem       Layer   Symptom   Root cause         Secondary   Individual flaky tests   Instances of non-determinism (race conditions, environment corruption, randomness, external dependencies in tests, fragile time dependencies)       Primary   Instances of non-determinism (race conditions, environment corruption, randomness, external dependencies in tests, fragile time dependencies)   Application complexity, poor test design.    What is a flaky test? A flaky test is a test that passes sometimes and fails sometimes even when no code has changed. Flaky test cost test runs to fail illegitimately, causing annoyance, wasted time and a numbness to legitimate failures. All flaky tests are caused by some form of non-determinism. Code that’s deterministic is code that always gives the same output for a given input. Flaky tests are caused by some form of non-determinism. Race conditions Race conditions are most likely to arise when the buffer is small. Imagine, a guy arrives at the train station with only a 1-minute buffer. If a ticket machine is slow or a gate malfunctions, he misses the train. Similarly, in software, race conditions occur when timing issues cause unpredictable failures. This gets fixed by adding an expect(page). to have_content command immediately after the command that submits in this case the form. Unlike the indifferent click_on command expect_page. to have_content will wait a bit before it gives up and allows the test Runner to continue. click_on “submit”expect(page). to have_content(“Thanks”) # to prevent race conditionsclick_on “Home”You can modify the default wait time docs Capybara. default_max_wait_time = 10 And also per-test basis Capybara. using_wait_time(10) do expec(page). to have_content(“Success”)endEnvironment state corruption Imagine two tests, each of which creates a user with email_address: test@example. com the first test will pass and, if there is a unique constraint on user. email, the second test will raise an error due to unique constraint validation. Sometimes the first test will fail and sometimes the second test will fail depending on the order in which order you run them. Another way to spoil the environment is to change a configuration setting. Let’s say you have a test environment with a background job configured not to run for most tests because most background jobs are irrelevant to what’s being tested and would just slow things down. But then let’s imagine that you have one test that you do want background jobs to run, and so at the beginning of the test you set background job setting from the don’t run to run. if you don’t remember to change the setting back to don’t run at the end all background jobs will run for all later tests and potentially cause problematic behavior. External dependencies in tests. The way to prevent flaky test caused by network dependencies is to stub services rather than hitting live services Randomness By definition common non-deterministic. If you have for example a test that generates a random integer between one and two and then asserts that the number is one that is going to fail about half the time period. Fragile time dependencies in test The way around this problem is to always use absolute times in tests instead of relative ones. For instance “2025-03-10 08:00:00” Instead of “tomorrow 12:00 p. m. ”       Problem   Prerequisite         Race conditions   Concurrency       Environment state corruption   Mutable environment state       Randomness   Randomness       External dependencies   External dependencies       Fragile time dependencies   Features that involve time   To summarize all this in a few words, complicated applications tend to have more flaky tests than simple ones. How to fix flaky tests Flaky tests are hard to fix largely because they are hard to reproduce. If a flaky test cannot be consistently reproduced then it is very hard to hypothesize about the conditions to make it fail. It is also hard to hypothesize about the case of a flaky chest if we don’t have enough background knowledge to guide our hypothesis. If we are familiar with the conditions that can lead to flaky tests, then we can come up with much more intelligent guesses than if we are clueless about how flaky tests arise. The fact that flaky tests are hard to reproduce also means that our fixed attempts are hard to validate or invalidate. Adopt an effective bug fix methodology. I find it helpful to split the bug fix process into three distinct stages:  reproduction, diagnosis and fix. When fixing a bug it is very easy to let your head get filled with a jumble of thoughts and lose track of what you’re doing. Dividing the processing to steps helps us stay focused on one activity at the time. Arm yourself with background knowledge. All about diagnosis start as guesses to get more efficient in diagnosing flaky tests, commit to five causes of flaky tests to memory. Before reproducing: determine whether it is really a flaky test. Not everything that appears to be a flaky test is actually a flaky test. Sometimes a test that appears to be flaky is just a healthy test that’s legitimately failing. Reproducing a flaky test.  My go-to method for reproducing a flaky chest is simply to re-run the test suite multiple times on my CI service until I see the flaky test fail. I like to run the test so it’s a large number of times to not only reproduce the failure but also to get a feel for how frequently the flaky test fails. Diagnosing flaky tests.  Remember that if you preferably understood all the code and tests, you would also understand the cause of the flaky test that you are trying to diagnose. All that lies between you and a diagnosis is certain amount of understanding. Applying the fix for a flaky test. Sometimes the only way to see if a flaky test is fixed with our attempt is to wait. Do not delete a test without a good reason. Remember that the important thing is not the cost benefit ratio of an individual flaky test fixed, but the cost benefit ratio of all the flaky test fixes on average. This means that fixing flaky tests creates a positive feedback loop. Chapter 9. Testing sins and crimes. : Chapter 10. Ruby DSL. : Chapter 11. Factory bot. : Chapter 12. RSpec syntax. : Chapter 13. Capybara’s DSL. : "
    }, {
    "id": 36,
    "url": "http://localhost:4000/2025/01/31/rails-code-guide-through.html",
    "title": "Rails code guide through with Kasper Timm Hansen | notes",
    "body": "2025/01/31 - Next session with Kasper (luma link) Last Friday I attended a session with Kasper where he shared with us how he usually explores Rails codebase, he’s got a lot of experience doing this therefore I applied what I learned here. I’ve always been curious how callbacks and model validations work in Rails, so I decided to explore this topic.  Setting up the app Possible error with bundle First exploration with ActiveRecord lib super keyword for . valid? super keyword for . save Ruby call stack Recap with flow chart Shortcut for Ruby method lookupAlways have a question in mind that you want to answer otherwise it may be pretty easy to get lost. 💡 Setting up the app: # create a new rails apprails new callbacks &amp;&amp; cd callbacks# create a new modelrails g model Post titlerails db:migrate# add the following code to the modelclass Post &lt; ApplicationRecord validates :title, presence: true, allow_nil: false before_validation :titleize_title after_create :print_out_title private  def titleize_title   return unless title. present?   self. title = title. downcase. titleize   puts  before_validation- Title changed to #{title}   end  def print_out_title   puts  after_create- Title was saved as: #{title}   endendAfter setting up a very basic app with 2 callbacks, and one validation, we can see that both callbacks are running corrrectly. ➜ callbacks git:(main) ✗ rcLoading development environment (Rails 8. 0. 1)callbacks(dev)&gt; p = Post. new=&gt; #&lt;Post:0x00000001205322c8 id: nil, title: nil, created_at: nil, updated_at: nil&gt;callbacks(dev)&gt; p. valid?=&gt; falsecallbacks(dev)&gt; p. errors. full_messages=&gt; [ Title can't be blank ]callbacks(dev)&gt; p. title =  HOLA =&gt;  HOLA callbacks(dev)&gt; p. savebefore_validation- Title changed to Hola 👈 TRANSACTION (0. 1ms) BEGIN immediate TRANSACTION /*application='Callbacks'*/ Post Create (10. 0ms) INSERT INTO  posts  ( title ,  created_at ,  updated_at ) VALUES ('Hola', '2025-02-03 01:09:45. 881379', '2025-02-03 01:09:45. 881379') RETURNING  id  /*application='Callbacks'*/after_create- Title was saved as: Hola 👈 TRANSACTION (0. 3ms) COMMIT TRANSACTION /*application='Callbacks'*/=&gt; truePretty standard, now what does trigger ‘active_record_callbacks’? Was it after calling “. valid?” or “. save”? Possible error with bundle: Let’s go and open active_record library with ‘bundle open activerecord’, it might throw you an error, I fixed it by typing: # in your console, it will work for one sessionEDITOR=code bundle open activerecord# or permanently set it in your . zshrc fileexport BUNDLER_EDITOR=code# close the . zshrc filesource ~/. zshrcDocs for ‘bundle open’ and setting your editor for opening gems 🪄 First exploration with ActiveRecord lib: Within lib/active_record/validations. rb:69 and after reading a bit we can see the following chain of method calls: save → perform_validations → valid?. Let’s add a puts statement and test it out. def valid?(context = nil) puts  you are calling 'valid?' :)  # added for testing 👈 context ||= default_validation_context output = super(context) # &lt;--- calls ActiveModel::Validations#valid? (parent method) errors. empty? &amp;&amp; outputendClose the editor and ‘reload!’ rails console ➜ callbacks git:(main) reload!Loading development environment (Rails 8. 0. 1)callbacks(dev)&gt; p = Post. new=&gt; #&lt;Post:0x0000000120b394c8 id: nil, title: nil, created_at: nil, updated_at: nil&gt;callbacks(dev)&gt; p. valid?you are calling 'valid?' :) 👈=&gt; falsecallbacks(dev)&gt; p. title =  HOLA! =&gt;  HOLA! callbacks(dev)&gt; p. saveyou are calling 'valid?' :) 👈before_validation- Title changed to Hola! TRANSACTION (0. 1ms) BEGIN immediate TRANSACTION /*application='Callbacks'*/ Post Create (3. 0ms) INSERT INTO  posts  ( title ,  created_at ,  updated_at ) VALUES ('Hola!', '2025-02-03 01:32:16. 234929', '2025-02-03 01:32:16. 234929') RETURNING  id  /*application='Callbacks'*/after_create- Title was saved as: Hola! TRANSACTION (0. 5ms) COMMIT TRANSACTION /*application='Callbacks'*/=&gt; trueWe can conclude with this inspection that each time we call “. save” or “save!” we call in the end “. valid?”. Now, let’s explore the 2 ‘super’ keywords following the chain of methods up to its ancestor. ‘super’ keyword for . valid?: Let’s open the gem with ‘bundle open activemodel’. ‘. valid?’ will invoke ActiveModel::Validations#valid? lib/active_model/validations. rb:361 this method will call ‘run_validations!’ which is defined in lib/active_model/validations. rb:459 def valid?(context = nil) current_context = validation_context context_for_validation. context = context errors. clear run_validations! # &lt;--- calls all validation callbacks (returns true if the record is valid, false otherwise)ensure context_for_validation. context = current_contextendrun_validations! → _run_validate_callbacks The latter comes from ActiveSupport::Callbacks, it is dynamically generated via ‘define_callbacks’, inside of this ActiveSupport module you’ll find very interesting classes as Before, After, Around, CallbackSequence, CallbackChain (where the callbacks are stored in a []) ‘super’ keyword for . save: The second ‘super’ keyword is in ‘. save’ and goes up to ActiveRecord::Persistence module. Just for making this more practical I have added a puts statement to lib/active_record/persistence. rb:390 def save(**options, &amp;block) create_or_update(**options, &amp;block) puts  you saved it :)  # added for testing 👈rescue ActiveRecord::RecordInvalid falseendrails console 🎮 callbacks(dev)&gt; p = Post. new=&gt; #&lt;Post:0x000000011d5b92a8 id: nil, title: nil, created_at: nil, updated_at: nil&gt;callbacks(dev)&gt; p. title =  HOLA? =&gt;  HOLA? callbacks(dev)&gt; p. valid?you are calling 'valid?' :)before_validation- Title changed to Hola?=&gt; truecallbacks(dev)&gt; p. saveyou are calling 'valid?' :)before_validation- Title changed to Hola? TRANSACTION (0. 1ms) BEGIN immediate TRANSACTION /*application='Callbacks'*/ Post Create (8. 7ms) INSERT INTO  posts  ( title ,  created_at ,  updated_at ) VALUES ('Hola?', '2025-02-03 23:16:20. 758330', '2025-02-03 23:16:20. 758330') RETURNING  id  /*application='Callbacks'*/after_create- Title was saved as: Hola?you saved it :) 👈 TRANSACTION (0. 0ms) ROLLBACK TRANSACTION /*application='Callbacks'*/=&gt; nil‘. save’ will call ‘create_or_update’ and then depending on whether the object is new or not, it can be about an ‘insert’ or ‘update’ operation. How ruby call up its ancestor objects: Something that was difficult to wrap my head around was why ‘valid?’ and ‘save’ point to different modules and how they get overridden? After some lookups I figured that this is because in ‘lib/active_record/base. rb’ we have the following: Module ActiveRecord class Base  include Persistence  include Validations  include Callbacks  . . . endendSince Validations is included after Persistence, it overrides ‘save’, adding validation checks before calling ‘super’ to go back to ‘Persistence#save’. Recap with visual aid: When we call ‘. save’, Ruby follows this lookup order: First, it checks the model’s own class (Post in this case). The Post model does not define ‘save’, so Ruby looks in the included modules. If not found, it looks in Callbacks, which does not define ‘save’ either. Third, it checks ‘ActiveRecord::Validations#save’. Since this method exists, it runs, calling ‘perform_validations’. If validation passes, it calls ‘super’, which means “find the next save method in the lookup chain. ” Finally, super calls ‘ActiveRecord::Persistence#save’. This method handles inserting/updating the record.    Persistence   ↑   Validations   ↑   Callbacks   ↑   Transactions   ↑   First, Ruby looks in the Post class itself Here a flow chart as recap of what we explored: Shorcut - Ruby method lookup: I got some feeback from Kasper and he suggested the following commands as alternatives, they seem to be more efficient than looking up the code in the gem. The code will tell you where the method is defined, and you can keep chaining . super_method to go up the inheritance chain. ➜ callbacks git:(main) rcLoading development environment (Rails 8. 0. 1)callbacks(dev)&gt; Post. instance_method(:save). super_method=&gt; #&lt;UnboundMethod: ActiveRecord::Transactions#save(**) /Users/dominiclizarraga/. rbenv/versions/3. 4. 1/lib/ruby/gems/3. 4. 0/gems/activerecord-8. 0. 1/lib/active_record/transactions. rb:361&gt;# 2 times '. super_method'callbacks(dev)&gt; Post. instance_method(:save). super_method. super_method=&gt; #&lt;UnboundMethod: ActiveRecord::Validations#save(**options) /Users/dominiclizarraga/. rbenv/versions/3. 4. 1/lib/ruby/gems/3. 4. 0/gems/activerecord-8. 0. 1/lib/active_record/validations. rb:47&gt;# 3 times '. super_method'callbacks(dev)&gt; Post. instance_method(:save). super_method. super_method. super_method=&gt; #&lt;UnboundMethod: ActiveRecord::Persistence#save(**options, &amp;block) /Users/dominiclizarraga/. rbenv/versions/3. 4. 1/lib/ruby/gems/3. 4. 0/gems/activerecord-8. 0. 1/lib/active_record/persistence. rb:390&gt;And also for seeing the module hierarchy and suplerclasses you can use the following command: Post. ancestors=&gt; [Post (call 'Post. load_schema' to load schema informations), Post::GeneratedAssociationMethods, Post::GeneratedAttributeMethods, ApplicationRecord(abstract), ApplicationRecord::GeneratedAssociationMethods, ApplicationRecord::GeneratedAttributeMethods, ActionText::Encryption, ActiveRecord::Base, Turbo::Broadcastable, 🤯 ActionText::Attribute, ActiveStorage::Reflection::ActiveRecordExtensions, ActiveStorage::Attached::Model, GlobalID::Identification, ActiveRecord::Marshalling::Methods, . . . . . . . . . ActiveRecord::ReadonlyAttributes, ActiveRecord::Persistence, 👈 ActiveSupport::Callbacks, 👈 ActiveModel::Validations, 👈 ActiveSupport::Dependencies::RequireDependency, Object, PP::ObjectMixin, ActiveSupport::ToJsonWithActiveSupportEncoder, ActiveSupport::Tryable, JSON::Ext::Generator::GeneratorMethods::Object, Kernel, BasicObject]"
    }, {
    "id": 37,
    "url": "http://localhost:4000/2024/12/15/uml-inventor.html",
    "title": "UML inventor interview (Grady Booch) | notes",
    "body": "2024/12/15 - Full interview UML creator defines UML as reason tool, not coding! Also invented object oriented analysis and design. IBM fellow is a distinguished role where he seeks to do improvements for the next 5-10 years, as Alan Kay said: The best way to predict the future is to invent it. He was after automating discovery patterns in legacy code way before LLM’s (didn’t continue the project). The moment you write a code it becomes “legacy” until you throw it away, even when it’s very small, it has a cost, has to be maintainable, tech debt, etc. ~60s IRS population increased and paperwork was too much that was not able to be done by hand so a new process of automation with Fortran came (they used to close earlier in order to reconcile accounts) that code is still running, mostly business rules plus the government still issuing more rules YOY. Complex systems started with the defense department (SAGE 50s-80s) before satellites and radars, around this time NATO was created and they aimed to fix this problem. (Golden age of software) The premise back in the day was to build monolith systems that were sustainable over time with algorithmic languages (Cobol, Fortran). The transition from monoliths to distributed systems initially with DARPA was funded by the government and having an email was pretty difficult only a thousand people had. The issue started to be more noticeable when they wanted to scale the system with algorithmic decomposition, they needed software that work in a variety of computers, multi-lingual, distributed and real time. Late 70s Smalltalk arose and the government had an issue that all their systems were using different languages so they wanted to unify them to only one, which was Ada. Ada was far ahead of its time, it used the ideas of abstract data types, which was extremely new back in the day. This new Ada wave brought the Booch method (1979) this is the 2nd golden era of software where they dealt with system distributed problems not only algorithms. Grady came up with the Booch method by reading many sources but one that caught his attention was Plato and his quote “how one should best see the world? As processes or as atoms” the latter was more inclined to OOP (classes and objects, behavior). (among other philosophical sources) ~1950 subroutines were considered a bad practice/controversial because doing a function call added 2 or 3 more instructions, now is seen normal, this was before the Booch method and thinking in classes and objects, now we take that for granted! The goal of UML was to look at the software from multiple points of view. Before data orientation, people who write COBOL used to print every day a document called “common data” as a matter of practice not due to language so that the whole team had the abstractions on a daily basis. Grady and his partners after spending some years in defense they moved to commercial space and built ROSE which helped the teams to write UML diagrams easily, only as a design tool. The market then asked “now we have an arpanet and these personal computers, how do we keep building software?” and that was the time that the concept of “use-cases” was conceived, it was very strange to look through it back in the day. UML helped people along Microsoft VScode to drive more complex software because now they have these two that most people can use and write code depicting entities relationships responsibilities and that increase the complexity on the systems (maybe LLM will enable us to develop more complex software?) After the. com hype people realized that the companies or products that were developed we’re not economically sustainable (maybe all the microapps we currently have?) Why u m l is not longer used in modern software? Grady’s outlooks  Big companies have exposed their apis therefore there is no much architectural thinking and company keeps building on top of it Startups for instance they just built with others people money and if it fails it doesn’t matter so I don’t have formality I just want to build something Another example if I build an airplane software I want more discipline and I want more ceremony so uml is going to be part of Also if I’m building a defense software and someone may die i want formality Also if I’m going to build something that people have built in the past again and again I don’t need uml for instance the users profiles or liking a post I just prompted the LLM On the other hand if I’m going to build something that I have never seen before something really complex that’s the sweet spot for UML James Webb space telescope uses UML. Economicals on software has changed, back in the day a computer was more expensive than a human so you have to spend more time thinking about the algorithm before trying it out now that has changed and you take that for granted but the competitional resources were very scarce Regarding the role of software architect: “All architecture is designed but to all design is architecture” It represents significant design decisions that shape the form and shape of the system where significant is measured by cost of change. The above paragraph reminded me of: “Successful (working) but undesigned applications carry the seeds of their own destruction; they are easy to write, but gradually become impossible to change. ”― Sandi Metz The entire history of software engineering is rising levels of abstraction, and that’s what we are currently seeing at very high level of abstraction that does not require any more the system decision which back in the day was bread and butter Now the decisions that have to be made are what cloud service I use? What message system do I use or what platform? Which are economic decisions, should I use AWS for this? A very interesting comment from Grady was that if you are a startup you’re going to hire someone who has done this before because they know the caveats of these new “architectural decision” in this case let’s say AWS because this guy has work on it before and he already knows it’s limitations and how far it can go, the costs and so forth therefore they can accelerate your development because they have more expertise on this and now these are “systemic decisions” because they have economic impact (even on the long term) Another bite from Grady Regarding why migrations are very hard to carry out is that you aim to build economically feasible software but technology is changing out of you so you that makes you think that you need to change either a new framework or where is the background jobs for the calculations being done either on the server or the mobile for instance “The code is is the truth but the code is not the whole truth” this quote again is for design decisions and sits around that you cannot just focus on what’s the best approach to this problem where is the most optimized solution for this because it involves hardware and even society, even culture. A comparable change in history like that recent AI has brought can be when software went from being developed just to one monolith across different computers like a distributed systems systems, that forced us to rethink how we design systems because now you are able to have it either on your mobile or your PC (lates 70s) By this time many changes came for instance time-sharing, whirlwind computers then mini computers (digital) with help of semiconductors. The rise of distributed systems can be like new LLMS. The perfect storm for AI was having Andrew NG discovering that the matrix multiplication that the NVIDIA GPU us were doing for more realistic game development was the ones that they need for deep learning Grady’s take on LLM: based on his vast experience on AI and now that he has 6 years researching the brain and its parts, he concludes that LLMs are unreliable narrators based on their architecture, they allow us to build scale bullshit generators, like stochastic parrots. The result is coherent though. We are not going to hit AGI by scaling. For new folks joining the market: -You will always need people to make informed decisions, tools change, it’s another level of abstraction. Find a place yourself where no one else is there and make your name there. There are plenty of spaces in the computer field, lastly have fun! Books recommendations "
    }, {
    "id": 38,
    "url": "http://localhost:4000/2024/10/12/intercom-off-script.html",
    "title": "Intercom Off Script series | notes",
    "body": "2024/10/12 - Here I wrote down some notes after watcihng the Intercom Off-script series about how they are facing the AI age and how the see it Youtube playlist Video #1  technology comes and goes,you gotta fall in love with the problem think of the core problem of your business, not the tech stack or framework work is always the same, if you want to send something you used to send it on a horse, now you use ups or fedex, want to entertain people? first it was newspaper now it’s smartphones.  the quickest to adapt, not the strongest does AI would change something in my process?It will blow up the total address of all Market because it will and I will customers or users who know what they want to do however they don’t know how to do it for instance in Excel or monday. com, salesforce who are great product very robust products but not so many people know how to use them, AI will enable them to use them at its maximum We need to rebuild our products our societies around this new technology and it is day one Video #2 Being disturbing pollution change and reshape our society because before that everything was made by hand and after that breakthrough moment we were able to have houses cars clothing Also technology is like a one-way street that once you go and cross that door you never look back before for instance once we had the iPhone in our hands we did not think about the traditional phone call or mail post What matters the most is that customers and businesses get greater experiences, it boils down to it Video #3 Attention algorithm and then wrap up with a Transformer machine learning technique Then the Transformer was trained with the huge amount of data that never before And finally it seems like it is understanding and it is capable to do some summarizing words follow some instructions An example of what AI needs was when governments increase their budget in order to roll out new highways because they saw that as much highways and streets interconnected you have the more trade Commerce and tourist activity you will get in this case AI needs more compute infrastructure and so on (Things happen fast when the value is there and apparently AI is delivering some value) Apparently it is learning because it is paying attention to the important things It’s got some limitations but you can’t work around those limitations People say that it is just a talking prediction like predicting the next word on the sentence RAG Is given the llm more context in order to make it understand the current situation therefore it will provide a more accurate answer Take a small series of tasks That you can really over-delivery on, not too broad. We have used openAI models as building blocks, Maybe five or 10 different prompts Underneath the hood, Each of them doing a specific task like search for this customer in the db, then get their last order, then disambiguate this question From an engineering perspective take five things your product should do and isolate them And get AI to do that task separately Video #4 Mother sauce and software in general seems to be very complicated and clunky because they serve a broad amount of users, It’s like cities in general they are designed for a general audience not for cyclist or pet owners or car drivers Now with AI you can have UI design that is generated on the Fly based on the user request instead of having a form where users submits email phone number number order it will go and retrieve those data from the database and make up a new form just to confirm that the information is correct and it will be completely Custom Tailor to each requested and even to each user It raises the floor for the designers, the human touch becomes more valued If you wear a drummer in the 80s and you see that a rhythm controller has come out you would thought that you are cooked but it happened all the opposite more drummers came to play their songs (democratizacion of music) So you don’t need to become a master at your craft in order to make music however there still need of people who are a master at the craft even when AI provides shortcuts Embrace the squiggle (process of designing something, converge, diverge ideas, discussions, etc) Video #5 Better, faster cheaper on online business Customer service in businesses prior the war was more personal they made individual transactions, and then as the business expanded they needed to hire more customer service in order to make it more Global more professional and then after that the 01800 phone lines came up and that was the time that the call centers started then with computers and internet the email and then the CRM too, chatbots, etc, also how customers leave feedback from the service they got and that was a time where you needed a quality customer service. Easiest decision is to cut people in order to make profit…So in order to increase the quality of your customer service at the internet scale is very difficult Video #6 Big boys and small are no longer selling software seats to humans, but software doing the work. We don’t pay for CS, we pay what’s in the receipt, and CS is all around. Having a internet business bring the benefits of scales which is selling around the clock, around the globe Heretofore (before now, new word) Agents gen1 (conversation, text boxes) and gen 2 (more familiar, proactive and take action) Cannibalize themselves if they want to survive and Netflix did with their shipping DVD business before streaming. "
    }, {
    "id": 39,
    "url": "http://localhost:4000/2024/08/17/open-source.html",
    "title": "Operating Systems - open source",
    "body": "2024/08/17 - Test for a open source ! "
    }, {
    "id": 40,
    "url": "http://localhost:4000/2024/08/15/linux.html",
    "title": "This is a test for Operating Systems",
    "body": "2024/08/15 - Test for a Linux ! "
    }, {
    "id": 41,
    "url": "http://localhost:4000/2024/05/26/what-is-distributed-systems.html",
    "title": "This is a test for Distributed Systems",
    "body": "2024/05/26 - What is Distributed Systems "
    }, {
    "id": 42,
    "url": "http://localhost:4000/2024/05/06/why-acid.html",
    "title": "This is a test for ACID",
    "body": "2024/05/06 - Why ACID in postgres "
    }, {
    "id": 43,
    "url": "http://localhost:4000/2024/05/06/what-is-vacum.html",
    "title": "This is a test for Relational Database",
    "body": "2024/05/06 - What is VACUM "
    }, {
    "id": 44,
    "url": "http://localhost:4000/2024/05/05/utf-8-bits-bytes-binary.html",
    "title": "UTF-8, bits, bytes and binary numbers!",
    "body": "2024/05/05 - Test 1 "
    }, {
    "id": 45,
    "url": "http://localhost:4000/2024/03/12/stimulus-controller-life-cycle.html",
    "title": "Stimulus controller - life cycle",
    "body": "2024/03/12 - "
    }, {
    "id": 46,
    "url": "http://localhost:4000/2024/02/17/refactoring-and-testing.html",
    "title": "Refactoring and testing a long method in Ruby on Rails",
    "body": "2024/02/17 - Recently, we had the opportunity to refactor a lengthy method in a Ruby on Rails project. The method had multiple conditional statements (around 6) that checked various aspects of a project, such as whether it was discarded, on time, accepting entries, and more. Refactoring this method required careful planning and testing to ensure that the functionality remained intact while improving the code’s maintainability and readability. Before diving into the refactoring process, we first focused on writing tests that covered all the edge and corner cases. To do this, we wrote tests that checked the opposite of what the method was currently doing. For each conditional statement, we created a test that verified the expected behavior when the condition was met and when it was not. Here’s an example of how we tested a condition that checked if a project was able to receive entries using FactoryBot: # In the test filedescribe 'Project entries' do it 'should not accept entries when the project is not set to receive entries' do  project = FactoryBot. create(:project, receive_entries: false)  # Assert that the project does not accept entries  expect(project. accept_entries?). to be_falsey end it 'should accept entries when the project is set to receive entries' do  project = FactoryBot. create(:project, receive_entries: true)  # Assert that the project accepts entries  expect(project. accept_entries?). to be_truthy endendBy writing tests for both scenarios (project accepting entries and not accepting entries), we ensured that the refactored method would handle these cases correctly. Once we had a comprehensive test suite in place and all the tests were passing, we started the refactoring process. It’s important to remember that refactoring aims to modify the internal structure of the code without changing its external behavior. The goal is to improve performance, maintainability, and readability while adhering to the DRY (Don’t Repeat Yourself) principle. During the refactoring, we focused on breaking down the long method into smaller, more manageable chunks. we extracted common functionality into separate methods and aimed to reduce the complexity of the conditional statements. Here’s a simplified example of how the refactored method might look: def process_project(project) return if project. discarded? return unless project. on_time? return unless project. accept_entries? # Process the project # . . . endBy separating the conditions into individual guard clauses, the method becomes more readable and easier to understand. Throughout the refactoring process, we continuously ran the tests to ensure that the functionality remained intact and that we didn’t introduce any unintended changes. Refactoring a long method can be a challenging task, especially for beginners. However, by following a systematic approach of writing comprehensive tests, breaking down the method into smaller parts, and focusing on improving maintainability and readability, you can successfully refactor your code and make it more manageable for future changes. Remember 🎗️, refactoring is an iterative process, and it’s okay to take small steps and gradually improve your code over time. By consistently applying good coding practices and seeking feedback from more experienced developers, you can continuously enhance your refactoring skills and write cleaner, more maintainable code.  Breaking down the method into smaller, more manageable pieces.  Applying the DRY (Don’t Repeat Yourself) principle to eliminate redundancy.  Enhancing performance and maintainability to ensure the code could be easily modified in the future. "
    }, {
    "id": 47,
    "url": "http://localhost:4000/2024/02/14/difference-between-buttonto-linkto-formwith.html",
    "title": "What's the difference behing button_to link_to form_with",
    "body": "2024/02/14 - In this blog post I’ll share my findings when developing a Like model and how I got to find these differences very particular. remote: true "
    }, {
    "id": 48,
    "url": "http://localhost:4000/2024/02/07/follow-as-polymorphic.html",
    "title": "Follow as Polymorphic",
    "body": "2024/02/07 - In this blog post I’ll share my findings when developing a Follow model (User can follow another User, Post, Comapny) with a polymorphic property. With the next models you can create a ‘Following’ feature that can be applied to almost any model you want, just add one line of code. class User &lt; ApplicationRecord # Users that follow this user 'Followers' has_many :followers, class_name: 'Follow', as: :followable # Entities this user follows 'Following' has_many :following, class_name: 'Follow', foreign_key: 'user_id'endclass Follow &lt; ApplicationRecord belongs_to :user # who is making/pushing the button  Follow  (doing the following) belongs_to :followable, polymorphic: true # This validation doesn't allow that user_1 follow user_2 twice validates :user_id, uniqueness: { scope: [:followable_type, :followable_id] }endLet’s try out the code in rails console rails consoleu1 = User. firstu2 = User. lastfollow = u1. following. create(followable: u2)Follow Create (3. 8ms) INSERT INTO  follows  ( user_id ,  followable_type ,  followable_id ,  created_at ,  updated_at ) VALUES ($1, $2, $3, $4, $5) RETURNING  id  [[ user_id , 1], [ followable_type ,  User ], [ followable_id , 18], [ created_at ,  2024-02-29 05:25:28. 228037 ], [ updated_at ,  2024-02-29 05:25:28. 228037 ]] TRANSACTION (0. 6ms) COMMIT=&gt; #&lt;Follow:0x0000000102d226e0 id: 6, user_id: 1, followable_type:  User , followable_id: 18, created_at: Thu, 29 Feb 2024 05:25:28. 228037000 UTC +00:00, updated_at: Thu, 29 Feb 2024 05:25:28. 228037000 UTC +00:00&gt;Follow. count=&gt; 1u1. following. create(followable: u2)=&gt; TRANSACTION (0. 8ms) ROLLBACK (due to model validation)# class User# def follows?(user)#  following. exists?(followable: user)# endu1. follows? u2=&gt; trueu2. followers=&gt; [#&lt;Follow:0x000000012eb126d0 id: 6, user_id: 1, followable_type:  User , followable_id: 18, created_at: Thu, 29 Feb 2024 05:12:17. 215129000 UTC +00:00, updated_at: Thu, 29 Feb 2024 05:12:17. 215129000 UTC +00:00&gt;]u1. following[#&lt;Follow:0x0000000102b63fc0 id: 6, user_id: 1, followable_type:  User , followable_id: 18, created_at: Thu, 29 Feb 2024 05:12:17. 215129000 UTC +00:00, updated_at: Thu, 29 Feb 2024 05:12:17. 215129000 UTC +00:00&gt;, #&lt;Follow:0x0000000102d226e0 . . . ]And it worked for other models like (Post, Company, etc) class Post &lt; ApplicationRecord has_many :followers, class_name: 'Follow', as: :followableenduser = User. find(user_id)post = Post. find(post_id)user. following. create(followable: post) TRANSACTION (0. 6ms) COMMIT=&gt; #&lt;Follow:0x0000000150038080 id: 8, user_id: 1, followable_type:  Post , followable_id: 92, created_at: Thu, 29 Feb 2024 05:56:29. 921783000 UTC +00:00, updated_at: Thu, 29 Feb 2024 05:56:29. 921783000 UTC +00:00&gt;We’ve explored creating a follower system in Rails, showcasing the flexibility of polymorphic associations and the importance of validations. This guide provides a solid foundation for adding social functionalities to your Rails applications, ensuring a robust and scalable feature set. "
    }, {
    "id": 49,
    "url": "http://localhost:4000/2024/01/28/beginner-guide-docker.html",
    "title": "Beginner guide to Docker 🐳",
    "body": "2024/01/28 - This is a guide to explore what is Docker and also when it’s useful. "
    }, {
    "id": 50,
    "url": "http://localhost:4000/2024/01/26/action-policy-cache.html",
    "title": "Action policy gem + Cache",
    "body": "2024/01/26 - Recently I worked with an app that was using Action Policy, I noticed that those policies were being called almost everywhere! So I started a small research and found that there was a section for cache authorizations. Let’s dive in with Redis and how policies are saved in memory. Here are the official (docs)[https://actionpolicy. evilmartians. io/#/caching] for combinig action policy + cache. "
    }, {
    "id": 51,
    "url": "http://localhost:4000/2024/01/22/when-you-see-the-count.html",
    "title": "When you see the `.count` in a Rails view 👀",
    "body": "2024/01/22 - I’ve been working on improving the app performance and have learnt about how. count works and how it can slow down the app. As a solution we have counter_cacheprovided by default by rails and also something more advance like counter_culturegem! Let’s see how it can improve you app as well! "
    }, {
    "id": 52,
    "url": "http://localhost:4000/2024/01/18/the-where-clause.html",
    "title": "Avoiding N+1 Queries 🚓",
    "body": "2024/01/18 - When optimizing an app, I recently learned to pay attention to the . where or . find methods inside . each loops because they can be potential candidates for association preloading. The reason is that for each element we iterate over, another operation will be executed, in this case . where or . find, which can lead to an N+1 query problem. Let’s see how it works. # Controller actiondef index @posts = Post. allend# View template&lt;% @posts. each do |post| %&gt; &lt;h2&gt;&lt;%= post. title %&gt;&lt;/h2&gt; # This will trigger separate query for each post to fetch the author &lt;p&gt;Author: &lt;%= post. author. name %&gt;&lt;/p&gt; # This will trigger separate query for each post to fetch the comments &lt;p&gt;Comments: &lt;%= post. comments. count %&gt;&lt;/p&gt;&lt;% end %&gt;SQL produced: -- 1 for Post. allSELECT  posts . * FROM  posts -- 2 for each post's author and comments count, this can get really worseSELECT  authors . * FROM  authors  WHERE  authors .  id  = ? LIMIT 1 [[ id , 1]]SELECT COUNT(*) FROM  comments  WHERE  comments .  post_id  = ? [[ post_id , 1]]To avoid this we can use . includes # Controller actiondef index # we eagerly load the author and comments for all the posts in a single query @posts = Post. includes(:author, :comments). allend# View template&lt;% @posts. each do |post| %&gt; &lt;h2&gt;&lt;%= post. title %&gt;&lt;/h2&gt; &lt;p&gt;Author: &lt;%= post. author. name %&gt;&lt;/p&gt; &lt;p&gt;Comments: &lt;%= post. comments. count %&gt;&lt;/p&gt;&lt;% end %&gt;SQL produced: -- 1 for Post. includes(:author, :comments), which eagerly loads the associated author and comments-- The number of queries is reduced to 3 (1 for posts, 1 for authors, 1 for comments), regardless of the number of posts. SELECT  posts . * FROM  posts SELECT  authors . * FROM  authors  WHERE  authors .  id  IN (1, 2, 3)SELECT  comments . * FROM  comments  WHERE  comments .  post_id  IN (1, 2, 3)Another alternative is to use . eager_load instead of . includes. The difference is that . includes uses separate queries to load the associations, while . eager_load uses a single query with a LEFT_OUTER_JOIN. Here I have a deeper blog about it! Just wanted to highlight that you must be careful of those where, find and find_by inside of loops! "
    }, {
    "id": 53,
    "url": "http://localhost:4000/2024/01/16/cache-and-redis.html",
    "title": "Key concepts for Redis and cache 💽",
    "body": "2024/01/16 - Expire Bust Cache hit Cache miss user. touch Setting up redis in production since developers want a slower app in development rails dev:cache type of redies: volatile (cache data that can be retrieve at some point again) or non-volatile (sidekiq because it cannot be recreated since we loose the jobs that are queued) "
    }, {
    "id": 54,
    "url": "http://localhost:4000/2024/01/14/what-is-cache.html",
    "title": "What is cache? 💵 💰",
    "body": "2024/01/14 - Currently, I’m focusing on enhancing the performance of an application, and one of the key areas I’ve explored in-depth is caching. Although I was aware of caching before, I didn’t fully grasp its concept or have the opportunity to apply it, so I never felt compelled to delve into it. If you find yourself in a similar position, here are some initial steps to build a strong understanding of caching :) What is cache? The term ‘cache’ is an English word meaning a secure place where items are stored and hidden. Now this concept will make more sense in computing. Cache is a method of storing frequently accessed data in fast memory to keep it closer to the user. This fast memory can be found either on hard drives, processors (like CPUs and GPUs) or web browser, web server, databases, client-side, CDNs and it goes from KBs to MBs and in different layers (L1, L2, etc). In browser for example, the first time you visit a web site it will download the HTML, CSS and images then computer will save a copy of those files. The next time you visit that page, it will retrieve a local copy instead of requesting a web server, which speeds up the process. Think of a coffee shop where the barista keeps commonly used items like milk and sugar at hand, rather than going to the storage room for each order. This is like 'caching', where frequently used data is kept readily accessible. ☕️ Fun fact: The concept of caching was originally proposed in 1965 by Maurice Wilkes. Paper When is it useful? There are 2 main ways so far to implement with Ruby on Rails app.    HTTP Caching - Web browser can cache HTTP responses to enable faster retrieval data. It improves response time and reduce load on back-end. By storing copies of frequently accessed data, caching reduces the need for repeated requests to the server, thereby enhancing overall performance and user experience. (Mostly for Static assets and JSON APIs and AJAX endpoints. )     This involves caching within the application itself and can be tailored to the specific needs of your Rails application. Rails provides several caching techniques like page caching, action caching, and fragment caching.  How to use it in rails? Rails has 3 ways of caching data: page, action and fragment. Each of them has different purposes.    Page caching stores the entire HTML response, serving it directly from the web server without hitting the Rails stack.     Action caching caches the output of controller actions.     Fragment caching is more granular and caches smaller pieces of a view.  Also there are different techniques as well like Russian Doll Caching, Shared partial caching, Low-Level Caching and Key-based cache expiration. Extra tools you need. 🛠️ Rails caching is designed to be backend agnostic. This means you can implement custom caching solutions or adapters for other storage mechanisms. Redis: Advanced in-memory data store, supports complex structures, ensures data persistence, replication, and integrity. Memcached: Efficient, simple key-value store, ideal for caching static data, quick setup. Memory Store: Caches data in the Rails server’s memory. This is a good option for single-server setups and development environments. File Store: Caches data as files on the disk. This can be useful in environments where memory is limited. Is it truly beneficial for your App? Currently in the implementation phase, the improvements are evident on the pages where it has been applied. It is advisable to compare response times before and after implementing these changes. If feasible, establish a Maximum Average Response Time (MART) as a benchmark. More when we complete this process! "
    }, {
    "id": 55,
    "url": "http://localhost:4000/2023/12/17/kasper-product-focused-ruby.html",
    "title": "Product Focused Ruby - Kasper Timm Hansen.",
    "body": "2023/12/17 - Sketching and mental model of programming. I recently attended a live session with Kasper Timm Hansen, he unfolded his approach to product-focused development, blending technical prowess with real-world problem solving. 1st session notes: How to start sketching out a new feature development. 1. - Have a problem definition. 2. - In a rails context, start with a controller and start figuring out how to pass stuff to the view (it will give you a lot of constraints already). 3. - Then sketch stuff out like write methods that reflect “complete” and “uncomplete” (for a Todo app and task feature), don’t focus on assigning instance variables, inheritance of the controller (you save this for later). 4. - At this point we have how routes are going to be. What are going to be the “resources” are they going to be nested? We have figured out the organizational stuff around things. So now we know how to put into business logic and complete it. 5. - Take a break from it like an outside view of like, okay, can I name this differently because. So far, it's just more meant to have a direct communication with what I intend to code and my own mental model rather than the code that I'm ending up generating. If the problem definition has a known unknown that would be one thing to start tackling, or it can help reveal unknown unknowns. And and then figure out, if it's something involved with like TCP connections, and we haven't worked with those before. Use method you know how they work to keep sketching things out (inheritance from ApplicationController or RESTful methods). 6. - Delineate between what’s the feature, and what’s the architecture? User model would be architecture and User and its Invite (User::Invite) would be the feature. This prorcess should be really flexible, really fluid, like having a conversation and not to be attached to the code you've written. Also play around with `irb`, read the Ruby docs and seek. Making abstractions by finding concepts through ‘naming’. 1. - Now that you have a sense of the concept and know how things fit together. 2. - You can build solid blocks of knowledge that you can later use. In example, how a AssociationObject works and you find more similar cases in the rest of the app. 2nd session notes (more hands-on): 1. - At the very start of the feature cycle, what you essentially do is a deep dive. You try to keep going for about half an hour, maybe an hour and you’re just trying to fire off ideas. 2. - Try to take full advantage of the fact that Ruby reads somewhat like pseudocode. It’s a case of ‘first thought, best thought’, allowing for a more rapid-fire approach. 3. - What you actually want is to quickly formulate a hypothesis. Figure out how to disprove or prove it, at least, and then keep making rapid changes. "
    }, {
    "id": 56,
    "url": "http://localhost:4000/2023/12/14/how-to-explore-a-new-codebase.html",
    "title": "How to quickly deep dive into a new code base.",
    "body": "2023/12/14 -    Utilize the user interface (UI) to create domain model objects (Posts, Books, Reservations, etc), followed by monitoring the server-side Rails logs.     Examine the generated SQL and then directly access the database using either psql or the rails dbconsole.     Read the Models file (book. rb), search for associations, callbacks, scopes.     Lastly look up the most recent record that has been saved or added to the database rails c and play with it.  "
    }, {
    "id": 57,
    "url": "http://localhost:4000/2023/12/12/always-have-a-question-in-mind.html",
    "title": "Always have a question to solve in mind.",
    "body": "2023/12/12 - I recently explored a new code base, which was challenging, but focusing on a specific question helped me to direct my research more effectively…. . "
    }, {
    "id": 58,
    "url": "http://localhost:4000/2023/12/06/n-+-1-queries.html",
    "title": "N + 1 queries and how to fix them.",
    "body": "2023/12/06 - I recently had to deal with a n + 1 query…. Firstly let’s understand why does this happen? The N+1 query problem is like inviting friends to a party and then calling each one separately to ask if they’re coming. If you have 10 friends, you make 1 call to decide to invite them and then 10 more calls to each friend. So, for 10 friends, you make 11 calls in total. In databases, this is like fetching a list of items (like blog posts), and then for each item, making another query to fetch related data (like comments on each post). If you have 10 posts and you fetch comments for each one by one, you end up making 1 query to get all posts plus 10 more queries for comments, leading to 11 queries. But why in db happens this?? The First Query (N): When you ask for the list of posts, the ORM makes one query to fetch all posts. This is your “N” part of the problem, where “N” is the number of posts. The Plus One (+1) Part: For each post, when you try to access its comments, the ORM realizes it hasn’t fetched those yet. So, it makes a new query for each post to fetch its comments. If you have 10 posts, this approach results in 10 additional queries - one for each post to get its comments. The ORM’s default behavior is to load data on demand (lazy loading). It avoids fetching related data until you explicitly access it, which can be efficient in scenarios where the related data is not needed. However, when you do need related data for each item in a list, it leads to multiple queries, creating the N+1 problem. Example: # rails console@events = Event. all Event Load (0. 5ms) SELECT  events . *  FROM  events  /* loading for pp */ LIMIT ? [[ LIMIT , 11]]# Each call to `event. attendees` for an `event` triggers a separate query to fetch the `attendees` for just that `event`. @events. each do |event| puts  Event: #{event. name}  👉event. attendees. each do |attendee|  puts   Attendee: #{attendee. name}  endend# Logs:👉Event Load (0. 2ms) SELECT  events . * FROM  events  Event: Tech Conference 👉Attendee Load (0. 1ms) SELECT  attendees . * FROM  attendees  INNER JOIN  registrations  ON  attendees .  id  =  registrations .  attendee_id  WHERE  registrations .  event_id  = ? [[ event_id , 1]]  Attendee: Alice  Attendee: Bob  Attendee: Charlie Event: Music Festival 👉Attendee Load (0. 0ms) SELECT  attendees . * FROM  attendees  INNER JOIN  registrations  ON  attendees .  id  =  registrations .  attendee_id  WHERE  registrations .  event_id  = ? [[ event_id , 2]]  Attendee: Bob  Attendee: DanaData to recreate a small excercise: Let’s create a small app so we can see in detail what is being produced by each active record method. # Create app with name `preload_demo_app`rails new preload_demo_app# Go to `preload_demo_app` dircd preload_demo_appThen let’s create models and add the associations we need needed. # Create `Event` modelrails generate model Event name:string location:string start_time:datetime# Create `Attendee` modelrails generate model Attendee name:string# Create `Registration` modelrails generate model Registration event:references attendee:referencesActive Record Associations 👇 # app/models/event. rbclass Event &lt; ApplicationRecord has_many :registrations has_many :attendees, through: :registrationsend# app/models/attendee. rbclass Attendee &lt; ApplicationRecord has_many :registrations has_many :events, through: :registrationsend# app/models/registration. rbclass Registration &lt; ApplicationRecord belongs_to :event belongs_to :attendeeendOne last step, we need some data to play with: # eventsevent1 = Event. create(name:  Tech Conference , location:  Conference Center , start_time: DateTime. new(2024, 5, 20, 10, 0, 0))event2 = Event. create(name:  Music Festival , location:  Outdoor Park , start_time: DateTime. new(2024, 6, 15, 12, 0, 0))# attendeesattendee1 = Attendee. create(name:  Alice )attendee2 = Attendee. create(name:  Bob )attendee3 = Attendee. create(name:  Charlie )attendee4 = Attendee. create(name:  Dana )# registrations Registration. create(event: event1, attendee: attendee1)Registration. create(event: event1, attendee: attendee2)Registration. create(event: event1, attendee: attendee3)Registration. create(event: event2, attendee: attendee2)Registration. create(event: event2, attendee: attendee4)With this in place we can start playing with the model by opening ‘rails c’ 🔺 Let’s see includes behavior: # `. includes` is designed to minimize the number of queries and the overall load on the database by preloading associated dataEvent. includes(:attendees) # See the `IN` SQL keyword in the query for both `registrations` and `attendees` # A single SQL query that retrieves both in a single database roundtrip.  Event Load (0. 3ms) SELECT  events . * FROM  events  /* loading for pp */ LIMIT ? [[ LIMIT , 11]]  Registration Load (0. 4ms) SELECT  registrations . * FROM  registrations     WHERE  registrations .  event_id  IN (?, ?) [[ event_id , 1], [ event_id , 2]]  Attendee Load (0. 1ms) SELECT  attendees . * FROM  attendees     WHERE  attendees .  id  IN (?, ?, ?, ?) [[ id , 1], [ id , 2], [ id , 3], [ id , 4]]🔺 Now preload: Event. preload(:attendees) # See the `IN` SQL keyword as well, here the key difference is how you apply the `. where` Event Load (0. 1ms) SELECT  events . * FROM  events  /* loading for pp */ LIMIT ? [[ LIMIT , 11]] Registration Load (0. 3ms) SELECT  registrations . * FROM  registrations   WHERE  registrations .  event_id  IN (?, ?) [[ event_id , 1], [ event_id , 2]] Attendee Load (0. 1ms) SELECT  attendees . * FROM  attendees   WHERE  attendees .  id  IN (?, ?, ?, ?) [[ id , 1], [ id , 2], [ id , 3], [ id , 4]]🔺 eager_load: Event. eager_load(:attendees) # See the LEFT OUTER JOIN, it ensures that even `events` without any attendees are included in the result SQL (0. 1ms) SELECT DISTINCT  events .  id  FROM  events   LEFT OUTER JOIN  registrations  ON  registrations .  event_id  =  events .  id   LEFT OUTER JOIN  attendees  ON  attendees .  id  =  registrations .  attendee_id  /* loading for pp */ LIMIT ? [[ LIMIT , 11]] SQL (0. 1ms) SELECT  events .  id  AS t0_r0,  events .  name  AS t0_r1,  events .  location  AS t0_r2,   events .  start_time  AS t0_r3,  events .  created_at  AS t0_r4,  events .  updated_at  AS t0_r5,   attendees .  id  AS t1_r0,  attendees .  name  AS t1_r1,  attendees .  created_at  AS t1_r2,    attendees .  updated_at  AS t1_r3 FROM  events  LEFT OUTER JOIN  registrations    ON  registrations .  event_id  =  events .  id  LEFT OUTER JOIN  attendees    ON  attendees .  id  =  registrations .  attendee_id  WHERE  events .  id    IN (?, ?) /* loading for pp */ [[ id , 1], [ id , 2]]🔺 What happens with . joins: event = Event. find_by(name:  Tech Conference )Event Load (0. 1ms) SELECT  events . * FROM  events  WHERE  events .  name  = ? LIMIT ? [[ name ,  Tech Conference ], [ LIMIT , 1]]# Usage of `. joins`Attendee. joins(:registrations). where(registrations: {event_id: event. id}) # an `INNER JOIN` is performed between `attendees` and `registrations`.  # It uses the association named `registrations` defined in the `Attendee` model.  Attendee Load (0. 2ms) SELECT  attendees . * FROM  attendees   INNER JOIN  registrations  ON  registrations .  attendee_id  =  attendees .  id   WHERE  registrations .  event_id  = ? /* loading for pp */ LIMIT ? [[ event_id , 1], [ LIMIT , 11]]Event. joins(:registrations). distinct # See the `DISTINCT` in the `SELECT` statement (ensures that events are listed uniquely).  SELECT DISTINCT  events . * FROM  events   INNER JOIN  registrations  ON  registrations .  event_id  =  events .  id  Summary: Hope you get more understanding on this topic! More blog posts here: 👇 Bhumi’s N + 1 blog postarunyadav N + 1Benito Serna N + 1 ebookSo you need a sort at database level or just with ruby is enough? "
    }, {
    "id": 59,
    "url": "http://localhost:4000/2023/12/01/debugging-libraries.html",
    "title": "Debugging libraries for Ruby and Rails",
    "body": "2023/12/01 - Exploring Ruby Debugging Tools Section 1: Pry Pry GitHub Section 2: Pry-Rails Pry-Rails GitHub Difference between “pry” and “pry-rails” Stackoverflow response Section 3: Debug Debug GitHub Section 4: Byebug Byebug GitHub "
    }, {
    "id": 60,
    "url": "http://localhost:4000/2023/11/21/hotwire-codex.html",
    "title": "The Rails and Hotwire Codex 🌀",
    "body": "2023/11/21 - Notes: Turbo Native is the core of Hotwire’s native extensions. It orchestrates a native web view through multiple screens within native navigation. This way the app has a native feel, despite all the content being rendered using the same HTML views as the web app. Native navigation: Navigation in a Turbo Native app is completely native. When the user taps a link, a native method is called to handle the visit proposal. If a fully native screen is preferred for a given URL, this method is where that choice can be made. More commonly, we’ll want to visit the destination URL. 1) When a link is tapped, 2) Turbo Native creates a new screen, 3) injects the web view into it, 4) drives the web view to the new location using Turbo, and 5) displays the screen to the user. Authentication: Turbo Native apps use cookie based authentication for requests originating in a web view. If you have purely native screens and need to make HTTP requests from native code, you’ll need to implement a form of token based authentication on the server. Session: A session co-ordinates a single native web view. It’s responsible for triggering URL visits using Turbo, and for inserting the web view into new screens when displayed to the user, we’ll use a different session for each tab so the navigation in each tab is totally independent. Path Configuration: The path configuration is a JSON file stored in the app bundle. This file specifies a set of rules that match URLs, using regex patterns, to a set of properties. These properties define how a URL should be displayed in the app. If a particular URL has a fully native screen, this is where we tell Turbo Native about that. Feature flags and other settings can also be defined making it simple to turn features on and off remotely. All of this content was taken from book below, they’re personal notes. I encourage you buy it. Book link is here. "
    }, {
    "id": 61,
    "url": "http://localhost:4000/2023/11/13/conf-7.html",
    "title": "Ruby conf @ San Diego, CA.",
    "body": "2023/11/13 - Blog about this conf is pending. "
    }, {
    "id": 62,
    "url": "http://localhost:4000/2023/11/08/shape-up.html",
    "title": "Shape up 🎢",
    "body": "2023/11/08 - Shaping Up Methodology Notes: These are some insights I’ve gathered from the “Shaping Up” methodology, which is neither Scrum nor dependent on Kanban boards. The Challenge of Building Software: In the realm of software development, there’s a substantial element of the unknown, given that what we’re building hasn’t existed before. Waiting six months to realize we’re on the wrong path is excessively long, while a two-week span is typically too brief to produce anything substantial. The Solution: Defining Scope and Time: The solution lies in defining smaller projects that are actionable and testable. A period of six weeks is sufficient to both complete and deliver a project and short enough to allow for directional changes should they be necessary. Key Idea #1: Estimate vs. Appetite: Instead of attaching a time estimate to a technical task, we should ask ourselves how much time we actually want to spend on this project. Consider the analogy of setting a budget before choosing a restaurant for dinner; it’s a strategic approach that takes into account the value, urgency, and business context. We should strive for an agreement between product teams and technical staff to ensure the time is fixed and the scope is adaptable. Key Idea #2: Shaping: “Shaping” considers two major questions about scope: “What is included?” and “What is excluded?” It also addresses the detail required upfront versus what can be delegated to the team to resolve later. “Latitude” refers to the level of freedom or specificity given to the team. A key part of shaping is the willingness to abandon features that are either technically impractical or not critical to the user interface. Key Idea #3: Autonomy: Teams, consisting of two to three members, collaborate within a six-week cycle to deliver the complete project, not merely pieces of it. These teams maintain their focus without being burdened by unrelated tasks and are self-managed, operating at their own pace. Work is distinguished as either planned (strategic) or unplanned (reactive). Further Learning:  Shaping in a Nutshell Applying Shape Up in the Real World - Rails World 2023"
    }, {
    "id": 63,
    "url": "http://localhost:4000/2023/11/07/decompose-for-method-call.html",
    "title": "Decompose for method calls",
    "body": "2023/11/07 - In Ruby, it is possible to decompose the elements of arrays/hashes into distinct variables. Since values appear within arrays in a index order, they are unpacked into variables in the same order. # Decompose of an array&gt;&gt; fruits = [ apple ,  banana ,  cherry ]&gt;&gt; x, y, z = fruits&gt;&gt; x=&gt;  apple In this case we are going to use decompose for a method call, (with arrays only one splat needed *). def send_welcome_email(name, email, signup_date) puts  Sending welcome email to: #{name}  puts  Email: #{email}  puts  Signed up on: #{signup_date} end# Array of user informationuser_data = ['Jane Doe', 'jane. doe@example. com', '2023-04-01']# Using splat to pass an array of elementssend_welcome_email(*user_data) 👈# This code will output:Sending welcome email to: Jane DoeEmail: jane. doe@example. comSigned up on: 2023-04-01Now we are going to decompose for a hash, (two splats needed **). def configure_user(profile:, preferences:, settings:) puts  Configuring user profile:  puts  Profile: #{profile}  puts  Preferences: #{preferences}  puts  Settings: #{settings} end# Hash of user configurationuser_configuration = { profile: { username: 'johndoe', language: 'EN' }, preferences: { theme: 'dark', notifications: true }, settings: { privacy: 'high', location: 'off' }}# Using 2 splats to pass a hashconfigure_user(**user_configuration) 👈# This code will output:Configuring user profile:Profile: {:username=&gt; johndoe , :language=&gt; EN }Preferences: {:theme=&gt; dark , :notifications=&gt;true}Settings: {:privacy=&gt; high , :location=&gt; off }"
    }, {
    "id": 64,
    "url": "http://localhost:4000/2023/11/02/positional-vs-keyword-params.html",
    "title": "Positional vs Keyword arguments",
    "body": "2023/11/02 - When I began programming, I was puzzled by why some parameters were named and others not. Seeing *argument_name or **argument_name threw me for a loop. 😳 Here you’ll find the definitive guide to understand both! Positional arguments: # This method takes any number of user names as positional arguments. 🙋🙋‍♀️def greet_users(*users) users. each { |user| puts  Hello, #{user}!  }end# Passing individual user names to the method, which are packed into an array. greet_users( Alice ,  Bob ,  Carlos )# Outputs:# Hello, Alice!# Hello, Bob!# Hello, Carlos!# This method can take a variable number of fruit names. 🍎🍌def list_fruits(*fruits) fruits. join(', ')end# Passing a list of fruits to the method. puts list_fruits( Apple ,  Banana ,  Cherry )# Outputs: Apple, Banana, CherryKeyword arguments: # Usage of ** for keyword arguments: 🙋🙋‍♀️def greet_users(**users) users. each do |identifier, user_info|  puts  Hello, #{user_info[:name]}!  endend# Passing user details as keyword arguments. # The keys `:user1`, `:user2`, and `:user3` are identifiers for each user's hash. greet_users( user1: { name:  Alice , age: 30 }, user2: { name:  Bob , age: 22 }, user3: { name:  Carlos , age: 25 })# Outputs:# Hello, Alice!# Hello, Bob!# Hello, Carlos!# This method takes a variable number of fruit names with details. 🍎🍌def list_fruits(**fruits_with_details) fruits_with_details. map { |fruit, color|  #{fruit}: #{color}  }. join(', ')end# Passing a hash of fruits with details to the method. puts list_fruits(Apple:  Green , Banana:  Yellow , Cherry:  Red )# Outputs: Apple: Green, Banana: Yellow, Cherry: Red# More real example of user attributes as keyword arguments. 🙋🙋‍♀️def create_user_profile(**attributes) puts  Creating a profile for: #{attributes[:name]}  puts  Email: #{attributes[:email]}  if attributes[:email] puts  Signup Date: #{attributes[:signup_date]}  if attributes[:signup_date]end# Passing attributes as a hash, packed with a double splat. create_user_profile(name:  Jane Doe , email:  jane. doe@example. com , signup_date:  2023-04-01 )# Outputs:# Creating a profile for: Jane Doe# Email: jane. doe@example. com# Signup Date: 2023-04-01Passing objects 🙋🙋‍♀️: class User attr_reader :name def initialize(name)  @name = name endend# Create an array of User instancesusers = [ User. new( Alice ), User. new( Bob ), User. new( Carlos )]# Define the greet_users method to accept multiple user objectsdef greet_users(*users) users. each { |user| puts  Hello, #{user. name}!  }end# Call greet_users with the array of User instancesgreet_users(*users)# Outputs:# Hello, Alice!# Hello, Bob!# Hello, CarlosIf you already have a hash with the appropriate keys, you can pass it to the method using the double splat operator **, which will convert the hash into keyword arguments. Docs for reference: *positional_argument **keyword_argument "
    }, {
    "id": 65,
    "url": "http://localhost:4000/2023/10/26/lastest-tips-and-tricks.html",
    "title": "Latest tips & tricks | Ruby & Rails",
    "body": "2023/10/26 - First filter then map: When you first filter a collection, you’re reducing its size by selecting only the elements that meet a certain condition. This step inherently decreases the number of items that will subsequently be processed by the map operation. Imagine you have an array of user records, and you’re only interested in processing active users with an age above 18, where the processing involves a complex calculation. users = User. allactive_adult_users = users. filter { |user| user. active? &amp;&amp; user. age &gt; 18 }processed_users = active_adult_users. map { |user| complex_calculation(user) }In this case, filtering out inactive users or those under 18 before applying the complex calculation minimizes the number of calculations, thus improving the performance. If you were to map first and then filter, every element in the collection, this means potentially performing a lot of unnecessary work. Remember: . select, . filter and find_all are Enumerable methods that do the same thing! Similar methods are . collect and . map! filter_map vs filter + map: The filter_map method iterates over an enumerable, applying a block to each element. This approach eliminates the need to iterate over a collection twice (once for filtering and once for mapping). Performance Benefits filter_map is more efficient than using filter and map separately because:  It reduces the number of iterations over the collection to just one.  It avoids creating an intermediate array that would result from the first operation (filter or map) before passing it to the second operation. fruits = ['apple', 'pear', 'banana', 'cherry', nil, 'fig', 'grape']uppercase_fruits = fruits. filter_map { |fruit| fruit. upcase if fruit&amp;. length &gt; 4 }puts uppercase_fruits # Output: [ APPLE ,  BANANA ,  CHERRY ,  GRAPE ]With both methods separate filter + map fruits = ['apple', 'pear', 'banana', 'cherry', nil, 'fig', 'grape']# First, filter out the fruits with more than 4 letters, excluding nil valuesfiltered_fruits = fruits. filter { |fruit| fruit&amp;. length &gt; 4 }# Then, map the filtered fruits to uppercaseuppercase_fruits = filtered_fruits. map(&amp;:upcase)puts uppercase_fruits # Output: [ APPLE ,  BANANA ,  CHERRY ,  GRAPE ]find_each vs all + each: When dealing with ActiveRecord objects, understanding the difference between find_each and using all followed by each is crucial for optimizing database interactions and memory usage. Using all followed by each is a straightforward way to iterate over a collection of records from the database. all retrieves all the records and loads them into memory, and each then iterates over these records one by one. Student. all. each do |student| puts student. nameendThings to consider:  Memory Usage: If the students table contains a large number of records, loading all of them with all can consume a significant amount of memory,find_each find_each is specifically designed to manage memory consumption and efficiency when processing large numbers of records. Instead of loading all records into memory at once, find_each retrieves and loads records in batches, processing each batch before moving on to the next. By default, the batch size is 1000 records, but you can specify a different batch size if needed. # Students records are proccesed in batches of 100, significantly reducing memory usage. Student. find_each(batch_size: 100) do |student| puts student. name endfind_each has different options to apply more details. Student. find_each(batch_size: 200, start: 1000, finish: 5000, order: :desc, error_on_ignore: true) do |student| # Your processing logic hereend. count vs . length vs . size: count directly translates to a SELECT COUNT(*) SQL query against the database. It asks the database to count the number of entries that match the query and does not load the objects into memory. This makes it very efficient for large datasets. Every time you call count, it performs a database query, which could be a downside if called repeatedly without a need for real-time accuracy. It will make an SQL COUNT regardless of the state of the collection in memory. (See this article to know how to tackle count efficiently) book = Book. first# Book Load . . . book. comments. load# Comment Load (0. 3ms) SELECT  comments . * FROM  comments  WHERE  comments .  book_id  = $1 [[ book_id , 1]]book. comments. count# Comment Count (0. 5ms) SELECT COUNT(*) FROM  comments  WHERE  comments .  book_id  = $1 [[ book_id , 1]]length loads the entire collection of objects into memory and then counts the number of elements. This can be memory-intensive for large datasets because it initializes all the objects. It does not trigger an extra database query if the collection is already loaded. ActiveRecord loads the comments from the database (if they haven’t been loaded already) to count them. The count is done by Ruby in memory after loading the records. blogpost = BlogPost. first# BlogPost Load . . . blogpost. comments. to_a # Comment Load (0. 2ms) SELECT  comments . * FROM  comments  WHERE  comments .  blog_post_id  = $1 [[ blog_post_id , 1]] [[ blog_post_id , 1]]blogpost. comments. length# (no additional database query is executed, comments are already loaded into memory. )size combines the behaviors of both count and length. If the collection has already been loaded, size will calculate the number of elements in-memory, avoiding a database query. If the collection has not been loaded, it will perform a SELECT COUNT(*) query, similar to count. When a counter cache is implemented, . size uses the cached value for the count, eliminating the need for database queries to count the records. With data loaded: # `size` if loaded, calculates the length with Rubyblogpost = BlogPost. first# BlogPost Load . . . blogpost. comments. load# Comment Load (0. 5ms) SELECT  comments . * FROM  comments  WHERE  comments .  blog_post_id  = $1 [[ blog_post_id , 1]]puts blogpost. comments. size# (no db hit) - Uses Ruby to calculate the size from the loaded collectionWithout data loaded: # `size` if not loaded, performs an SQL COUNT queryblogpost = BlogPost. first# BlogPost Load . . . puts blogpost. comments. size# Comment Count (0. 4ms) SELECT COUNT(*) FROM  comments  WHERE  comments .  blog_post_id  = $1 [[ blog_post_id , 1]]With counter cache: # Scenario 6: `size` if there is a counter cache, uses the cached countblogpost = BlogPost. first# BlogPost Load . . . puts blogpost. likes. size# (no db hit) - Uses counter cacheputs blogpost. likes. size# (no db hit) - Uses counter cache again without additional queriesorder vs sort_by: order method is used with ActiveRecord relations to specify the order of records returned by a query. It translates directly into an SQL ORDER BY clause, meaning the sorting is done by the database before the records are returned to your Rails application. Since order operates at the database level, it is generally more efficient for large datasets. Databases are optimized for sorting operations, especially when working with indexes. Book. order(publication_year: :desc)When you use sort_by (Ruby Enumerable), the entire collection needs to be loaded into memory first. Only then does sort_by reorder the collection based on the specified attributes or criteria. Use sort_by for smaller datasets or when you need to sort based on computed values. Here, the trick is to work on a ActiveRecord relation otherwhise Rails loads the entire collection into memory. This is because . sort_by is an Enumerable method that operates on arrays, not on database queries. So, the first step is converting the ActiveRecord relation into an array of model instances and after loading, . sort_by then iterates over the in-memory array: posts = Post. where(published: true)# This line implicitly loads all published posts into memory and then sorts them by titlesorted_posts = posts. sort_by(&amp;:title)This is just an advice I got and wanted to keep it here.  Try to make the calculations and queries even if they become big in controllers or models and in view just sort them in memory.  Better to ship the wrong thing today than the right thing in 2 weeks! Because then you can get feedback and learn 14 things in 2 weeks instead of 1 thing. And you are as useful as the code you ship. So try to ship every day, multiple times if possible :smile: @books. shuffle (in-memory): The . shuffle method is a Ruby Array method that randomly reorders the elements of the array. It operates in memory, meaning the entire array needs to be loaded. Ideal for situations where you have a relatively small dataset already loaded. Ruby API. @books. order(‘random()’) (in db): random() operation is performed by the database engine, which means it does not require loading all the data into your application’s memory to shuffle it. More details. any? =&gt; exist? vs present? =&gt; in memory: "
    }, {
    "id": 66,
    "url": "http://localhost:4000/2023/10/09/financial-wisdom-over-forks.html",
    "title": "Financial Wisdom Over Forks.",
    "body": "2023/10/09 - A Dinner Chat with 2 experienced developers. Recently, I had the opportunity to have dinner and engage in conversation with Chris O. and Harry L. at Rails World. Eager to delve into the nitty-gritty of consulting, I was particularly interested in uncovering the secrets of how to increase chances of success in this field. Among the insights shared by DHH was “The One-Person Framework” which enables one to achieve remarkable productivity with Rails. This framework allows for a comprehensive understanding of everything from backend to frontend to deployment, all while Rails navigates through the complexities aiming for simplicity. Inspired by DHH’s insights, I’m keen on taking advantage of “The One-Person Framework” to enhance my consulting practice. The discussion unfolded as follows: Accounting:    Always set aside 30% of each income you receive from consulting to cushion yourself when it’s time to pay taxes. 30 is a good figure; it’s enough.     Hire an accountant; don’t do it yourself, as it can become difficult.  Accounts:    The money that a business generates is one thing, and it must be in an exclusive account. Separate it from everything else (LLC or whatever structure).     Create a personal account for personal expenses, and avoid mixing expenses. It might seem easy initially, but it can become difficult to handle.  Sales:    Get with your referals, friends, uncles, cousins, people you were in school with and offer your services, it’d more easy if they own a company or have a decision makier position.     When it comes to consulting, once you finish a project and haven’t worked on securing another project, it’s very likely that you’ll end up doing nothing.     Therefore, in the hypothetical case that you finish “Project A” in December, dedicate 80% of your time to the project to get it done, and 20% on sales activities (attending meetups, calls, creating content, follow-ups).     Then, as you get closer to finishing the project, switch to spending 80% of your time on selling and 20% on the project so that when you finish “Project A” in December, you have “Project B” waiting in January.  Always Work with Contracts:  Include a clause specifying that if the client tells you not to finish, he has to pay you at the point or progress where you leave the projectWork on Building Trust with Clients:    When you develop for a customer, aim to either cut their costs or increase their revenue/productivity or help them have more control over their business therefore you’ll gain their trust.      Cut their costs: “Optimize processes to save your customer money. ”   Increase their revenue or productivity: “Enhance features to boost customer revenue and efficiency. ”   Help them have more control: “Empower customers with tools for informed business decisions. ”      Earned trust will increase eventually like compound interest over the years, as they will share with others how you helped them and how efficient you are.  Where to Find Potential Customers:    One approach is to get in touch with local marketing agencies and offer to outsource their work to you, whether it’s web apps or web pages. This is beneficial as it’s easier to secure payments from organizations than individuals, and it also enhances your portfolio and reputation.     For the point above 👆, show up! Don’t just email them; meet them in person, attend meetups, even those not related to tech.     Another approach is to reconnect with previous customers and inquire if there’s another department you can assist; this should happen naturally if you’ve had a good working relationship.  Don’t Convince Customers to Have a Rails App When They Don’t Really Need It (Avoid This 🚫):    One individual secured a contract where the customer apparently needed a WordPress management system, but he kept pushing for a Rails application.     Somehow, the customer paid him in advance, and after a few months, rejected the project and asked for a refund. By then, he had already spent the money without setting aside funds for taxes, and found himself having to answer to both the customer and the tax authorities.  "
    }, {
    "id": 67,
    "url": "http://localhost:4000/2023/10/05/conf-6.html",
    "title": "Rails World @ Amsterdam, NL.",
    "body": "2023/10/05 - Blog about this conf is pending. "
    }, {
    "id": 68,
    "url": "http://localhost:4000/2023/09/30/how-to-crack-you-next-code-challenges.html",
    "title": "How to crack your next code challenge 🧮",
    "body": "2023/09/30 - Notes that will help you understand and then solve a code challenge interview. "
    }, {
    "id": 69,
    "url": "http://localhost:4000/2023/09/22/apprenticeship-patterns.html",
    "title": "Apprenticeship Patterns 🌌",
    "body": "2023/09/22 - "
    }, {
    "id": 70,
    "url": "http://localhost:4000/2023/09/15/conf-5.html",
    "title": "Rails Camp @ Honolulu, HI.",
    "body": "2023/09/15 - Blog about this conf is pending. "
    }, {
    "id": 71,
    "url": "http://localhost:4000/2023/09/10/search-bar-rails.html",
    "title": "Search bar in Rails 🔍",
    "body": "2023/09/10 - Notes from building a Search bar. Justin Weiss search bar using scopes. Search bar using turbo frames. Search bar Test double. "
    }, {
    "id": 72,
    "url": "http://localhost:4000/2023/08/20/chartkick-gem.html",
    "title": "Chartkick gem vs chart.js",
    "body": "2023/08/20 - Notes from chartkick gem implementation "
    }, {
    "id": 73,
    "url": "http://localhost:4000/2023/08/01/llm-langchain-rb.html",
    "title": "LLM Langchain.rb 🦜 | Andrei Bondarev",
    "body": "2023/08/01 - While I was in New York I had the opportunity to attend a nyc. rb webinar where the main subject to discuss was going to be LLMs and what is the Ruby community doing about, Andrei Bondarev was the speaker. I know it was a webinar you can attend it wherever you are! However I found it because I was looking for a monthly meeting in NY, also I found that NYC on rails is about to start, so folks from NY please support Avi in this journey 🙏. Tweet where Avi anounces that he is going to take up rails monthly meeting (they were held off since 2016). OK moving on from ads, here I’ll share with you the resources that I have gone over the last week so I got my feet wet with this new topic called LLMs (Large Language Models). What is LLMs? It’s a subset of Deep Learning as well as Generative AI, both belong to AI. Google video that explains it very neat What is langchain then? 🦜 How LLMs work? Why are they useful? Use cases? Andrei NYC. rb slides Main Langchain ruby repo Chatbot Proof of Concept: Multi-Agent Chatbot developed by Flexport member (Ben Zhang) Courses: LangChain for LLM Application Development from Deep Learning AI "
    }, {
    "id": 74,
    "url": "http://localhost:4000/2023/07/27/conf-4.html",
    "title": "Ruby For Good @ Washington, DC.",
    "body": "2023/07/27 - Blog about this conf is pending. "
    }, {
    "id": 75,
    "url": "http://localhost:4000/2023/07/24/NYU-startup-summer.html",
    "title": "NYU Startup Summer program",
    "body": "2023/07/24 - Notes from NYU clases "
    }, {
    "id": 76,
    "url": "http://localhost:4000/2023/06/14/how_i_learned_rspec.html",
    "title": "How I learned rpsec",
    "body": "2023/06/14 - Rspec learning resources I believe that the best way to get a grasp of testing in general and rspec is to start from scratch a project and start writing down each test, that way you’ll be able to see what happens if you forget to close either a context block or an it block or even more intricate subjects like what’s the difference between describe and context. While developing a freelance project I wanted to add testing as a way to push myself to learn more about testing and also give rspec a try and by doing it I learned how to use gems like: faker, shoulda-matchers, factory_bot and finally rspec. 🎲 You’ll additionally acquire: – how to read the output of the test suite in the console. – difference between create and build more details. ; # build doesn't persist user = build(:user, name:  John )expect(user. name). to eq( John )# create does persist user = create(:user, name:  Jane )expect(user. persisted?). to be true– How to include Devise’s test helpers class PostsControllerTest &lt; ActionController::TestCase config. include Devise::Test::ControllerHelpers, type: :requestsendblog; – difference between fixtures and factories; – and finally learn how to integrate FactoryBot with RSpec link. class Test::Unit::TestCase include FactoryBot::Syntax::MethodsendHere are also another resources that I followed in order to cement more my knowledge.    2 hours long video from Type Fast a Youtube channel that makes rails tutorials. The video is very thorough. Covers model, requests, background job testing and system tests. Fairly comprehensive starter guide to RSpec     1 hour long rspec tutorial from Type Fast was well (it’s more on the setup for an app) testing setup with rspec     How to test models CJ Avila     How to use factory_bot Deanin, short tutorial     Full marathon of rspec tutorial (reading not video) from syntax, how to test a model and installing rspec Remi rspec tutorials     The Complete Guide to Rails Testing by Jason Swett link  Learn by doing is the best way to learn rspec DSL, development stack, learn what to test and why it’s important to test and avoid technical debt. So give it a try, it wont be difficult after all. Lately, I have completed a few books on testing, inclding Professional Rails Testing by Jason Swett, Hands-On Test Driven Development by Greg Donald, Effective Testing with RSpec by Myron Marston and Ian Dees and even attended a testing workshop by Lucian Ghinda. "
    }, {
    "id": 77,
    "url": "http://localhost:4000/2023/06/05/conf-3.html",
    "title": "Blue Ridge Ruby @ Asheville, NC.",
    "body": "2023/06/05 - Blog about this conf is pending. "
    }, {
    "id": 78,
    "url": "http://localhost:4000/2023/04/24/conf-2.html",
    "title": "Rails Conf @ Atlanta, GA.",
    "body": "2023/04/24 - Blog about this conf is pending. "
    }, {
    "id": 79,
    "url": "http://localhost:4000/2022/10/04/conf-1.html",
    "title": "Rails Saas @ Los Angeles, CA.",
    "body": "2022/10/04 - Blog about this conf is pending. "
    }, {
    "id": 80,
    "url": "http://localhost:4000/2022/03/26/practicing_rails.html",
    "title": "Practicing Rails | Justin Weiss",
    "body": "2022/03/26 - Introduction It is possible to learn Rails without having the things you learn abandon you as soon as you try to grab ahold of them. That’s what this book is about. It’s a second book of Rails. A companion. It’ll show you how to learn the most in the least amount of time, using the resources and knowledge you already have. And in the process, I’ll guide you through some of the toughest lessons I’ve learned during my programming and Rails career. Embrace struggle, failure, and reward. Learning to become a great Rails developer is hard work. And, being hard work, the only way to learn is to struggle. I’ve heard programming described as “Running into a brick wall, constantly. ” So don’t worry if you feel that way – we all do. Learning isn’t just about reading. It’s also about action. And that is why you can’t learn Rails without practicing Rails. Chapter 1 Tiny Apps: The best way to study new Rails ideas The best way to learn new Rails ideas and techniques is to use them. Right away. Practice them, internalize them, and make those techniques yours. When you’re working with such small apps, you focus on the single thing you want to learn. That way, you don’t have to worry about learning that new idea inside your existing, more complicated apps. For example, if you’re trying to learn ActiveModel::Serializers, and your controller isn’t serializing the model correctly, you can never be sure if the problem’s a gap in your knowledge, a problem with Rails, or a problem with your app. If you tried this out in a tiny test app, you could be pretty sure the problem was just a simple mistake or a misunderstanding. You can catch these mistakes on a small scale before you fight the bugs that appear when you use them into a larger app. I care about getting the most knowledge in the least amount of time, and scaffolds and other Rails code generators are a great way to do just that. Using the console and Tests for learning. The console is great for messing with objects, but getting those objects set up can be hard. Tests are great for getting objects set up, but hard for messing with them. Most Rails books and videos are good at showing you what’s possible. But they can’t explain everything. Those gaps will raise questions, and you’ll naturally want to have those questions answered. “Why does it work that way?” “How could this possibly work?” “What if I tried using it with this other idea I just learned about?” So, when I say “play with and modify the things you learn”, I mean “Answer the questions you have about the things you learn, using code. ” Chapter 2 How to build your own Rails app This feeling is totally normal. Whenever I’m about to start a new Rails app, I still feel like I want to give up computers forever and run into the woods or something. But I have a process to share with you that will help you get past this, so you can turn your ideas into real, working apps. When you face a large, fuzzy, overwhelming task like this, the answer is always the same: Break it apart! Break your big idea into small tasks that lead you to where you want to be. You’ll have a path you can take that, no matter what, will get you closer to finishing your app. How do you choose the first thing to work on? When you start a new project, try this short process to help decide which thing to work on first: Take a few minutes and think what you’re trying to build. Write down every feature that comes to mind. Think of the different paths a user could take through your application, the different things they could do. Describe each one in a single sentence. Then, focus on just the paths where, if you didn’t have them, your app couldn’t exist. Core paths. Core paths are the things you’d talk about if someone asked you to describe your app in 30 seconds. Which part of the feature should you start with? Once you’re ready to build your first core path, you might feel like writing models for all the objects you have in mind. Maybe you want to create migrations, add attributes, and connect everything together. But soon, you’ll have a ton of pieces that may not all fit. It’ll take a long time before you can actually use your app. And if you didn’t design your models well, you’ll just have to do that work over again when you build your UI and actually start playing with your app. So, start with UI, and infer your data model from what you see in the UI. When you begin work on a single, small feature, start with the UI:    Take the small feature, or core path, from earlier.     Think of one simple thing someone could do with that feature.     Draw just enough screens for that user to be able to do that thing.     Describe the path through that action, as if you were telling someone what you were going to do.     As you describe that path, write out the objects, properties of those objects, and other actions you think you need to develop that path.  "
    }, {
    "id": 81,
    "url": "http://localhost:4000/2022/03/04/testing_waterloo.html",
    "title": "Rails Testing | University of Waterloo",
    "body": "2022/03/04 - This is a series of lectures about rails testing -Databases &amp; Software Engineering course. How to test? Mike Cohn in his book Succeeding with agile. You should spend most of your time in Unit. End to end is manual and it means a person goes through all the user flow to reach a user acceptance criteria, click buttons, links, add stuff to the shopping cart, make a payment. This can be Manual test, actually using the interface, this is what the customer will see/use. Template:Given: that I’m a logged in user in “home page”When: when I click on “log out”Then: I’m logged out Only the basics here, for example: I can create an account but don’t extensively, send an email, one happy path and one sad path. In Rails End to end tests are called system tests Integration, tests multiple components but exclude user interface. In Rails it tests the controller. what does it respond? what does it send? POST to this path with this params (we can see if a form is going to the right path) Unit, it isolates one single object or method from the rest of the system and test it by itself. This help us see where the problem is. Models, and classes we create, First I need to make sure my individual pieces work, then i put them together and see if that larger system works and eventually we’re going to check out and test the whole entire system. Testing Pyramid and Rails Video Lecture MSCI 245 : Testing Is my app free of bugs?Does the program work as specified? Write a specification or a test that specifies expected behavior. Test case: average_rating Arrange - what is the input?Act - run the programAssert - check the output against the expected output Then we need 2 cases:  For a Book with 1 or more rating, it should return the average of that book’s ratings     known gotchas: integers vs float division, off by one (when you skip 1st element of the loop).     For a Book with 0 rating, it should return nilThis is the arrangeBob rated 5Sue rated -2Ali rated 4total 7 Run the program total 7 / 3 = 2. 333 Asserttotal vs expected_value https://www. youtube. com/watch?v=2yYSR6ftxUo Testing fundamentals - equivalence classes You cannot test all inputs. You need to carefully pick inputs to find your mistakes. “… testing can be used very effectively to show the presence of bugs, but never to show their absence” E. W. Dijkstra if 2 inputs produce the same output, they are said to be member of the same equivalence class. if the net method is tested correctly, the behavior of the method should be the same, there are only 2 inputs that we must use: [1, 2, 3] and [0, -12] def absolute_value(x)	if x &lt;= 0		return -1 * x	else		return x	endendInterior &amp; boundary values. Values that sit on either side of a division between equivalence classes are boundary valuer -&gt; where bugs hide. Other values are the interior values. [minimum. . . -1]|[0 . . . maximum] the boundary is between -1 and 0Test cases: (try to put all below in just one test) Equivalence test case min(a, b) Test:  a == b a &lt; b a &gt; bhttps://www. youtube. com/watch?v=-1kCdERz1sMBase, Edge, and Corner Cases; Happy and Sad Paths Base case - normal expected inputsEdge case - inputs approach limits or outside limitsCorner case - crazy values, should never see in real world Example: user interface - e commerce - shopping cart Base -&gt; user adds a few itemsEdge -&gt; user surprises us with a large order 100-1000 thingsCorner -&gt; whole store in cart (we don’t want the whole site to fail, we should put a limit) We can think of a form for creating a user name, nick names, emails, domains, capitalization Success &amp; failure (code should handle both) Test both good input (success). Test bad inputs (failure) to test proper error handling. Black box, you test the software and don’t get a look at the code, you cannot call the code White box, you test the software and get a look at the code to see what is happening https://www. youtube. com/watch?v=NoP3am8ipYw Hunting for bugs Logic errors  boundaries common inputs to test     some minimum   zero   one                         empty - zero       length       list       empty                     negative numbers   first/last element of an array   Most common working with arrays or any sort of list:  skip first/last element don’t process last elementNumerical erros  accidental truncation of floating point to integer divide by zero (think of a way how a user can input a 0 as denominator and catch the error) bad floating behavior (try to add a lot of small numbers to a larger numbers) assume the sum of the computer is correct sqrt(2) != √2Integrating boundaries  one system talking to another misunderstandings about proper inputs/outputsOther  null values -nil handling of exceptions loss of networks/disk/power?https://www. youtube. com/watch?v=crFl2K1bOhI MSCI 245 : A quick intro to Minitest and automated testing  testing framework enabled by default in Rails automated testing at 3 levels     Unit (individual methods or objects, this part works correctly)   Controller (integration) (we reproduce a browser with http verbs POST, GET)   System - end to end (E2E) user interface (manual, buttons)   To do unit testing we make a class that inherits from ActiveSupport::TestCase. We make one test case for every class we want to unit test. test/models/book_test. rbArrangeActAssertrequire 'test_helper' # brings test/test_helper. rbclass BookTest &lt; ActiveSupport::TestCase	# (always start with  test_ )	# The DB within test is empty	def test_average_rating_multiple_ratings		# you have to build up the case in the database		card = Author. create!(name:  Orson Scott Card ) arrange		ender_game = Book. create!(title:  Ender's Game , year:  1985 , author: card arrange		. . . 		. . . add ratings/ users				assert_in_delta(2. 333, ender_game. average_rating, 0. 001,  should return 2. 333 for Ender's Game )	end	def test_average_rating_no_ratings		christie = Author. create!(name:  Agatha Christie )		fire_pigs = Book. create!(title:  Fire Pigs , year:  1942 , author: christie)				# first the expected, then the actual		assert_nil(fire_pigs. average_nil,  this should be nil )	endThings to note:  File that start with “test_” are run with “rails test” You can create other methods You have access to all Rails You can use debugger Each test should be independent of other tests You can define a setup method in the beginning and call it before every method, (to create data)https://www. youtube. com/watch?v=JYbHurKGzM0 Testing - Test Cases - Minitest - Capybara Arrange - setup the input codeAct - execute the code w/ inputAssert - check the result against our expected output Example: we are testing addition, the input is 1 and 2, the expected result is 3. E2E or systems tests: Arrange  - sometimes could be add items to DBAct - visit the home page, click a link to create accountAssert - did i end up in the home page? seeds. rb is not for tests, is for using the app, like: admin. FIRST properties of good tests Fast - run fastI - independent | isolated, a test should not depend on another test that has run before it; what went wrong and where (try one idea per test)R - repeatable, every time you run a test it behaves the sameS - self validating, tests reports pass or fail by automatic T - timely | thorough, write the test when your write the code; coverage Test Frameworks - Minitest (will help us write FIRST tests)  resetting the Rails app and DB after each test (repeatable, independent) run tests in randomly order (independent) provide assert statements &amp; reports of pass and fail (self validating)Fast is mainly a property of this type of test, low overhead (faster than Rspec)Timely &amp; Through this is about developer behavior and skills Basics of Minitest  You write classes that inherit from Minitest.  Each method of the class that star with “test_” is run as independent test .  You can write a “setup” method, it will run before every test within that class (for creating user for instance).  Rails and Minitest restore state after each test, includes the DB.  Everything in Minitest in plain Ruby (only new methods like assert) (not like Rspec or cucumber).  Your class can have non-test methods.  You have access to all Rails, models methods and so on.  Separate test DB to avoid contamination.  There are a lots of ways to assert. assert(test = must be a boolean, message to display) - &gt; assert(expected == results) assert_equal(expected, actual) assert_nil(nil) flunk (msg) make the test fail in purpose skip (msg)       Capybara   url = root_pathvisit url ——assert_current_path url—–click_link(‘id-of-link’) # id’s from HTMLclick_link(‘Books’)click_button(‘Submit’) # it’s better to click on idfill_in(‘Name’, with: ‘Bob’)——-assert page. has_content?(‘Sorry Invalid. ’) You can search element on the page and interact with them or inspect thempage. find(:css, ‘a[href=’sign_up_path’]’). click assert_text (‘Create an account. ’) =&gt; all about UI. If you wont access session &amp; other “lower stuff” then write an integration. Example: class LinkTest &lt; ApplicationSystemTestCase	def test_nav_root_to_create_account		visit root_path		click_link('Create Account')		assert_current_path sign_up_path	endendhttps://www. youtube. com/watch?v=DxIoWJKYxIg&amp;t=1278s Demo of TDD ArrangeActAssertclass StatFunction	def self. median(values)		if values. nil? || values. length == 0 			raise ArgumentError( it needs at least one element )		end				if values. length == 1			return values[0]		end				values = values. sort		if values. length. even?			left_of_mid = (values. length / 2) - 1			result = ( values[left_of_mid] + values[left_of_mid] + 1 ) / 2. 0			return result		else			mid = (values. length / 2 )			return values[mid]		end	endendTest def test_median_one_element	# arrange	elements = [1]	# act	result = TestingExample::StatFunction. median( elements)	# assert	assert_equal( 1, result)enddef test_median_two_elements	elements = [1, 2]	result = TestingExample::StatFunction. median( elements)	assert_in_delta( 1. 5, result)enddef test_median_three_elements	elements = [1, 2, 3]	result = TestingExample::StatFunction. median( elements)	assert_equal(2enddef test_median_zero_elements	elements = []	assert_raises(ArgumentError) do		result = TestingExample::StatFunction. median( elements)	endenddef test_median_zero_elements	elements = []	assert_raises(ArgumentError) do		result = TestingExample::StatFunction. median( elements)	endenddef test_median_nil	elements = nil	assert_raises(ArgumentError) do		result = TestingExample::StatFunction. median( elements)	endendhttps://www. youtube. com/watch?v=sOT2FgD22VI What is Minitest? https://semaphoreci. com/community/tutorials/getting-started-with-minitest How to Test Rails Models with Minitest https://semaphoreci. com/community/tutorials/how-to-test-rails-models-with-minitest Getting Started With Testing In Rails (Using Minitest and RSpec) https://medium. com/@ethanryan/getting-started-with-testing-in-rails-using-minitest-and-rspec-113fe1f866a Getting Started With System Tests in Rails With Minitest In Rails jargon, system testing refers to “testing an application as a whole system”. That is done by using a browser in the tests. Instead of testing separate parts, with system tests, we can test a whole ‘workflow’, just like what a user goes through while interacting with our app, including the JavaScript parts. In practice, it means that we don’t want a system test to check if a record is created in the database when a user clicks a button; we just test if that new record appears on their screen. These kinds of user interaction tests are also called feature tests or acceptance tests. They are different from integration tests: integration tests are for testing the behavior, especially of all the parts of the app together, but not via the user interface. https://blog. appsignal. com/2020/02/12/getting-started-with-system-tests-in-ruby-with-minitest. html Official Docs https://guides. rubyonrails. org/testing. html#rails-meets-minitest Minitest vs. RSpec in Rails https://www. honeybadger. io/blog/minitest-rspec-rails/ "
    }, {
    "id": 82,
    "url": "http://localhost:4000/2022/02/14/test_jason_swett.html",
    "title": "The Beginner’s Guide to Rails Testing Jason Swett",
    "body": "2022/02/14 - The eight types of RSpec specs • Model specs• System specs• Request specs• Helper specs• View specs• Routing specs• Mailer specs• Job specs Jason usage: • Model specs always• System specs always• Request specs rarely• Helper specs rarely• View specs never• Routing specs never• Mailer specs never• Job specs never Model spec I use model specs to test my models’ methods. When I do so, I tend to use a test-first approach and write a failing test before I add a new line of code so that I’m sure every bit of code in my model is covered by a test. System spec System specs are the only type of test that give me confidence my whole application really works. Even though system specs are indispensable, they’re not without drawbacks. System specs are somewhat “heavy” Request specI tend not to use request specs much because in most cases they would be redundant to my system specs. If I have system specs covering all my features, then of course a broken controller would fail one or more of my tests, making tests specifically for my controllers unnecessary. I also try to keep my controllers sufficiently simple as to not call for tests of their own. There are just three scenarios in which I do use request specs. First: If I’m working on a legacy project with fat controllers, sometimes I’ll use request specs to help me harness and refactor all that controller code. Second: If I’m working on an API-only Rails app, then system specs are physically impossible and I drop down to request specs instead. Lastly, if it’s just too awkward or expensive to use a system spec in a certain case then I’ll use a request spec instead. View and routing spec I find view specs and routing specs to be redundant to system specs. If something is wrong with one of my views or routes, it’s highly likely that one of my system specs will catch the problem. What are all the Rails testing tools and how do I use them? RSpec is a test framework. A test framework is what gives us a structure for writing our tests as well as the ability to run our tests. One of the challenges of Rails testing is generating test data. There are two common ways of generating test data in Rails tests: fixtures and factories. Fixtures typically take the form of one or more YAML files with some hardcoded data. The data is translated into database records one time, before any of the tests are run, and then deleted afterward. (This happens in a separate test database instance of course. ) With factories, database data is generated specifically for each test. Instead of loading all the data once at the beginning and deleting it at the end, data is inserted before each test case and then deleted before the next test case starts. One principle of testing is that tests should be deterministic, meaning they run the same way every time no matter what. Capybara: Some Rails tests only exercise Ruby code. Other tests actually open up a browser and simulate user clicks and keystrokes. VCR and WebMock: One principle of testing is that tests should be deterministic, meaning they run the same way every time no matter what. When an application’s behavior depends on external services (e. g. a thirdparty API like Stripe) it makes it harder to have deterministic tests. The tests can be made to fail by an internet connection failure or a temporary outage of the external service. VCR can let us run our tests against the real external service, but capture all the service’s responses in local files so that subsequent test runs don’t talk to the external service but rather just go off of the saved responses. That way, even if the internet connection fails or the service goes down, the tests still work. What keeps them (Rails devs) in the habit of writing tests consistently? Laziness, fear, and pride. Mental energy. If I write a feature without using tests, I’m often juggling the “deciding what to do” work and the “actually doing it” work at the same time, which has a cognitive cost more than twice as much as performing those two jobs separately in serial. When I build a feature with the aid of tests, the tests allow me to separate the “deciding what to do” work from the “actually doing it” work. it’s not possible to have clean, understandable code without having automated tests. Pains that tell you your test coverage might be insufficient? Too many bugs. Inability to refactor or make big changes When a change has a large footprint, like a Rails version upgrade or a broad refactoring, it’s basically impossible to gain sufficient confidence of the safety of the change without having a solid automated test suite. So on codebases without good test coverage, these types of improvements tend not to happen. How do I set up a new Rails project for testing? Start rails with template: https://guides. rubyonrails. org/rails_application_templates. html rails new my_project -T -d postgresql \ -m https://raw. githubusercontent. com/jasonswett/testing_application_template/master/applicatiOnceHow do I add tests to an existing Rails project? If you have little testing experience, I would suggest getting some practice on a fresh Rails app before trying to introduce testing to the existing Rails project you want to add tests to. Adding tests to an existing project is a distinct skill from writing tests for new projects "
    }, {
    "id": 83,
    "url": "http://localhost:4000/2022/02/05/the_man_in_the_arena.html",
    "title": "The man in the arena",
    "body": "2022/02/05 - The GOAT 🐐  Chastising the Spanish artist for painting unrepresentative cubistic abstractions, a layman withdrew a photograph of his wife from his pocket and held it up to Picasso with the admonition, “Why can’t you paint realistically, like that?” “Is that what your wife really looks like?” Picasso asked. “Yes,” replied the man. “Well, she’s very small, and quite flat. ” First of all i need to be clear that I’m neither a football follower nor fanatic but somehow TB (Tom Brady) caught me up with his “underdog/rejection” story. Chapter 1 On naming the series. The meaning behind the title of this series is because that quote was on the weight room at Michigan University and TB saw it for almost 5 years (it was coined by Theodore Roosevelt) and for him was that eventually you become that man where all eyes are on you and only you know what is all about. All began in 1993-1996 when Patriots were playing good football however they were not winning, they lost 1 super bowl, new coach; then Mr. Brady appeared in 1999 with a very solid foundation from Michigan state, - “the team, the team is first” was the guideline he was trained. He defines it as a combination of talent, what you can add on a daily/weekly basis; at this time he didn’t know what were his strengths, everynight he looked up what phase was the draft on in order to know his position. Something worth mentioning is that 5 rounds passed and no one chose him, his attributes were not even close to what a pro football team expects, finally he was picked at #199 (only 200 are allowed). Main QB (quarterback, D. Bledsoe) at that time describe him as “inquisitive”, asking about everything, everyone thought that he’d be just a backup, was not perceived as a threat; on the other side TB defined himself either “just being naive” or “too much confidence” but he was determined to play pro 🏈.  “Working hard is a very sustainable trait. Part of your character. If you don’t have that, at some point the talent does wear off, you’re drafted based on both therefore you must work hard . ” Tom Brady. Second season with Brady on board started, Bledsoe signed the highest contract ever for the next 10 years, TB was on the bench until Bledsoe was hit, time to take the grid. Despite of the very low expectation people had on him, he felt ready to do the job. TB continued playing good waiting Bledsoe to get back of his injury however Bill Belichick (coach) made the decision of giving that role to TB, seeking the best for the team. At the AFC finale (one game before Super Bowl) TB had an ankle injury, Bledsoe took his role back, made a couple of touchdowns and won the game, this only remarks how mentally strong was TB since the beginning, everything came down to Bledsoe would be the starting QB, coach thought different, Tom will play the SB. As always all odds against Patriots, however the Pats won being the most underdogs 🏆.  You gotta be ready when your opportunity presents itself. I don’t think I was physically prepared. Was I mentally and emotionally ready? Absolutely. It’s like anything. Its progress and its evolution. It’s a series of small steps that seem so insignificant. ” Tom Brady. Chapter 2 On team culture. TB describes how people, teammates, competitors have been such impactful in his life, on and off the field, those people must help you create the best version of you, if not you gotta move on. After winning the SB they lost the next season, it was time to regroup the team, they had to have more consistency; following season Belichick cut the defense leader (L. Malloy, best friend of TB) no one understood that decision which gave room to the media to start creating news about the feelings within the team, thing that TB refused with the next phrase “ignore the noise, focus on tactics”. “Patriots is not collecting talent, is building a team” B. Belichick. With that being said, TB worked his way to carefully listen to every advice from his coach that gave him structure and confidence, it enabled him to execute selfishness, caring about all his teammates, no one care about who takes the credit.  “Winning is probably the outcome but the process of winning was what the culture was all about. What are you willing to commit to be your the very best?” Tom Brady. TB learned to study every top player, take the good stuff, fine tune it and put it on practice. He used the next metaphor: “Be the best husband you could be, the best father, the best in your job, because you cannot control everything. If you have perspective in the end nothing bad really happens because out of the bad comes the really good things. ”  Mental toughness is how you deal with adversity. What’s the attitude of your heart? Embrace challenge? Failure?” Rodney Harrison. Chapter 3 The edge. This episode was on motivational style, TB put a statement about how their mentality was - one game at the time, this was tough to put into practice due to they had more than 20 wins in a row. The main responsibility of any leader is to know how to motivate each member of his team, some of them like hard coaching others need just a push and in this sports the QB is the chief; this time Belichick worked to create a competitive environment where all the players wanted to give more, here are some phrases he shares:    It was not the more you can do it. It was who could do the most.     You came 6:30 am? I’ve already got a half hour on you.     I’m getting the edge on you.     This is what I did. What’d you do?  -Are you leaving already? -Still not doing the extra, huh? I’m getting the edge on you today I think is worth pointing out the good outcome that Belichick achieved by building this environment, it’s only as good as the ability of the players to receive it. The team at that time had a high level cohesiveness and the feedback, communication was on point to keep the culture up.  “You don’t know what kind of culture you have until things aren’t going well. ” When you have failure, when you don’t do what you were supposed to do, you’ll define how your culture looks like. ” Mike Vrabel. TB also mentioned how people think there are going to be more opportunities and that is a mistake because it lowers the bar and keeps you away from doing your best effort, you may miss a chance and will disappoint you next time, it will create fear, you’ll want a lower level to play in order to avoid frustration. Chapter 4 The goliaths. In this episode you’ll find how the Patriots reached its highest level and passed from being the underdogs to the goliaths. Many new team members Randy Moss, Wes Welker amongst others; they knew they were the team to defeat which I think played against them this time. Pats had a first time ever record with 16 wins and 0 loses, no team had accomplished this before, they made football look easy, then the “spygate” got and again TB spoke up with his phrase “ignore the noise”. “So much of the success in the life is about that journey and it’s not about whether you win or lose always. It’s about how hard you try and what you put into it, thr relationships, the learnings you develop. ” Tom Brady. In the end Pats lost the Super Bowl against New York Giants, this time Giants were the weaker. Chapter 5 No guarantees. This episode covers 4 seasons and Tom describes how are the relationships he was able to develop throughout these years, friendships, the born of his 2 kids, how supportive and stabilizer was Gisselle for him and how you must overcome failure, learn from it and move on. Some highlights of this episode are the union of NFL players took place for the first time, they couldn’t attend training however TB convoked to train in one college field without coaches with gave the team an advantage over the others, ultimately the got the conditions they were after. And finally Patriots faced Giants in the finale and they lost, after a series of inconvenient events, Eli Manning won the SB.  “Challenges are opportunities in disguise”. Gisele Bündchen. Chapter 6 Stop the bleeding. Things were not clear for this season, the media started pressing on TB retirement, a new draft for his position had been picked. Pats did a comeback throuthroug the season to reach the SB with a record of 12 - 4 gaining confidence game after game, ignoring the noise and building momentum, they did their job and stop the bleeding; suddenly another scandal arose the “deflategate” just a few days before the SB, they faced the best defense at that time Seattle Seahawks with Richard Sherman. Notwithstanding the dire comments about them, the conquered their 4th Super Bowl 🏆  “Greatness come with taking chances”. Vince Wilfork. Chapter 7 Surrender. For this chapter Tom invited his 3 sisters in order to lay out how his childhood was, they were a typical California family, attending all 49’s games, Tom Brady being the youngest felt always protected by his 3 sisters and his parents, they did a pretty well job, until he left to attend Michigan University. The season covered here was on year 2017 when Tom had to defend himself against the “deflategate”, he was penalized, suspended and the worst; his mom was detected with cancer, the quimio and radiation started so his mind was cut on two sides. Tom depicts this Super Bowl as the greatest game ever played (I didn’t know why until I watched how it unfold); this finale had the biggest difference in points ever, 28 to be precise despite that, Pats did comeback and scored as many touchdowns as needed to defeat Atlanta Falcons (play after play). “I think he lives his life to really be the best at something. He is a hundred, a thousand % committed to being the better than he was a day before. ” Tom Brady sister. ​Chapter 8 No body’s business. Tom introduced his rehab clinic and method along his coach body Alex Guerrero; it seems to be his secret weapon after finishing each game as well as every recovery. From my perspective Alex is an alternative physician who uses natural healing and different methods to prepare the muscles, also he goes over emotional and mental subjects trying to get up to an integral readiness. After years working on theses methods and proving they really work, Tom convinced Rob Gronkowski to get to Alex and try out his alternatives methods, thing that Belichick didn’t agree with and sent Tom and the trainer to remain outside each meeting and game. These supplemental activities seemed to gained relevance when Tom suffered a dire injury in his thumb days before the AFC final, he needed punctures and the recovery appeared to be beyond Sunday however after several treatments he was able to flex and use his hand for Sunday and passed to the SB LII. The super Bowl was fought by the two teams but Pats couldn’t beat the Philadelphia Eagles, another lose for Tom Brady 👎. Chapter 9 Maybe. Last episode of this series goes over the season 2018 and 2019 where Pats had to face Kansas City and Patrick Mahomes, I think they highlight this game because KC started to show how good they were and the pro football they play, also because some key teammates were out so regular season was not great. The Super bowl was against Los Angeles Rams which was meant to be a tough game, very physical, low opportunities, in the end Tom was bearing in mind that it was going to be his last season playing with New England because he didn’t get a new contract.  “All comes down to the people and relationship what I value the most. Tom Brady. Conclusion. It definitely is a combination of different factors that take you to succeed or to the place you want to be, those factors may be hard work, readiness, persistence and of course luck or how tom said a few times “situacional football” which is when something completely out of your control plays in favor of you, kicker missed the goal, the receiver couldn’t catch the pass, you name them and here is the part of commitment you need to place in every activity, relationship you want to develop because if everything derails and nothing comes to the place you planned was the best; you must be satisfied that you gave everything you could in order to accomplish but luck this time was not on your side. Having lost so many SB’s being the most prestigious sports in America has to be tough as well, it’s said very easy, -he won 7 Super Bowls. But how manys he lost?! It’s tough to miss a flight, to be rejected by the company you would have loved to work for, imagine how hard is to lose the most important event in the year, after having practiced and played 9 months in a row without being with your family. Tom developed a resilient mentality which was key for his journey, to keep his feet on earth and to overcome those setbacks, never look back and learn the most from them. "
    }, {
    "id": 84,
    "url": "http://localhost:4000/2022/01/05/minitest_cookbook.html",
    "title": "The Minitest Cookbook",
    "body": "2022/01/05 - Today though, the separation between development and testing has largely disappeared - at least in the universe that most Ruby and Rails programmers occupy. In many if not most cases now, the one writing the code is also responsible for producing automated tests that cover the workdone. And while you’re probably sick of hearing it, this is a good thing for all kinds of reasons. Why? • Tests demonstrate that your code actually works. • The pattern of thinking needed to write tests for code is very close tothat needed to design it. • Testing and developing in parallel tends to surface more bugs early in the development process when fixing them is cheap and easy. • Well-tested code tends to be better designed with reduced coupling and greater cohesion. • A good test suite acts as a detailed specification. • Writing tests during development increases programmer engagement and efficiency. • A test suite with good coverage aids in maintenance, refactoring, and upgrades with reduced risk of breakage and regression. • It’s faster to write code with tests than without. • Having automated tests reduces or removes the need for manual testing Best tests will have a few important characteristics in common:• Clarity: The name of each test suggests what it’s about at a glance. • Purpose: The intent and meaning of the test is obvious and unambiguous from the testing logic. • Eloquence: The test logic is expressed through fluent use of the language and the testing framework. • Readability: Tests are written and formatted in a way that promotes rapid discovery and comprehension. • Efficiency: All other things being equal, automated tests should use the minimum possible system resources Unlike a lot of books on testing, this one won’t dwell on the mechanics of test-driven development. TDD has become so prevalent and popular among the Ruby and Rails development community that you’d be hard pressed to find a book on testing or development that doesn’t take it as a starting point for everything taught. But TDD is primarily about development and only incidentally about testing, and it often treats the tests that fall out of it as a by-product rather than as first-class citizens of your project. That tends to result in test suites that are neglected after they’ve served the purpose of driving out features. • Fact: The entire framework weighs in at less than 1600 lines of code. RSpec is almost 8 times as large. With a code base that size, the source practically becomes its own documentation. • Fact: Minitest has been singled out as a very readable project because it’s written in plain Ruby that developers of all experiencelevels can dig into and understand. • Fact: The project has remained small and simple because of conscious decisions to keep it that way in spite of frequent requestsfor expanded features. • Fact: The source code showcases Ruby’s power and elegance with great uses of closures, metaprogramming, concurrent programming, and others. • Fact: Since the Minitest framework also happens to be tested with Minitest, it includes some exceptional practical examples illustrating good testing technique To really get comfortable with Minitest’s internals, there are four basic abstractions that you’ll need to understand: plugins, reporters, runnables and the Minitest runner. Plugins In Minitest, plugins are modules that extend or modify the behavior of Minitest. They can be used to add new features, customize the test runner, or modify the output of test results. Examples of plugins in Minitest include pride (a colorful test runner), parallel (for parallel test execution), and focus (to run specific tests or test suites). Minitest plugins are usually packaged as RubyGems which implement a simple framework-defined contract that allows them to be loaded an initialized by the framework. Specifically speaking, every plugin includes a loader file that follows a standard naming convention - ex: minitest/ foo_plugin. rb where foo is the name of the plugin. minitest-rails is a plugin for Minitest that adds some additional features for working with Ruby on Rails applications. It provides some additional test generators that can create test files for your Rails application’s models, controllers, views, and helpers. It also includes support for testing Rails-specific features like routes and controllers. In addition to the generators, minitest-rails also provides a Rails-specific test runner that sets up the Rails environment before running the tests. This can be helpful if your tests need to access Rails configuration or other Rails-specific features. Overall, minitest-rails is a helpful plugin for anyone working with Ruby on Rails applications and using Minitest as their testing framework. Another example: the minitest/pride plugin adds colorful output to your test results in the terminal. Reporters A test suite is a map for directing development effort to the parts of your project that need it. From this perspective, the results reported by your test suite act as its user interface and indicate the state of your code base. Each test Minitest runs passes a result to a Reporter object which is responsible for acting on it. Depending on the Reporter, it might:• Display information to the console. • Store the result for later processing. • Increment counters or compile statistics. • Send the result to another system - ex: a CI, a database, etc. As an abstraction, a Reporter is just an object that implements four methods that allow it to accept and operate on test results:• #start - called before the first test is run• #record - accept and process a single test result• #report - deliver a detailed report after the test run• #passed? - indicate passed/failed/errored/skipped tests In Minitest, reporters are used to generate output of the test results. They provide various types of outputs such as progress bar, detailed documentation, and colorized output. Runnables In Minitest, runners are classes that run a set of tests. Assert-style tests and Spec-style tests are two different styles of writing tests in Minitest. Assert-style tests are based on assertions that verify the expected result of a test. They are usually written using methods such as assert, assert_equal, assert_match, etc. The focus is on verifying specific outcomes and behavior of the code being tested. Spec-style tests are based on specifying the expected behavior of a system or component. They are usually written using describe and it blocks that describe the behavior of the code being tested. The focus is on describing the behavior and intent of the code, rather than just verifying specific outcomes. Assert-style tests are based on the idea of making assertions about the state of the system under test. These tests usually follow the “Arrange-Act-Assert” pattern, where the test sets up the system’s initial state, performs some action, and then makes one or more assertions about the system’s final state. (This uses instance methods starting with the string “test_”). Spec-style tests, on the other hand, are based on the idea of describing the behavior of the system under test using a domain-specific language (DSL). In these tests, the focus is on describing what the system should do rather than how it should do it. Spec-style tests often use “describe” and “it” blocks to structure the test code. Both styles of testing have their pros and cons, and the choice of which one to use often comes down to personal preference and the requirements of the project. Some developers prefer the clarity and simplicity of Assert-style tests, while others find the expressiveness and readability of Spec-style tests to be more appealing. Ultimately, the most important thing is to choose a style that works for you and your team and allows you to write effective, maintainable tests. The Minitest Runner The Minitest Runner is the component responsible for running Minitest test suites. It loads the test files, executes the tests, and reports the results. By default, Minitest uses the Minitest::Runnable and Minitest::Test classes to define and run tests, respectively. However, the runner can be customized to use other classes or to change the way the tests are run. The runner is a key part of Minitest’s flexibility and extensibility. The runner and Runnables fit together like the layers of an onion where each layer represents a Ruby block or method. The inner layers represent the Runnables where the tests are actually executed, and the outer layers represent the runner - the code that gives the onion its shape. Minitest. runNext, Minitest sets up the environment for the test run along with all the necessary supporting objects. All the framework’s major responsibilities are handled right here as it:• Parses the command line arguments. • Loads and initializes all detected Minitest plugins. • Instantiates and runs the reporters. • Runs tests by passing control on to the next layer. • Ensures that parallel worker threads are shut down gracefully. Basic Recipes Problem:class FizzBuzz	def convert(number)		if number % 15 == 0			 FizzBuzz 		elsif number % 5 == 0			 Buzz 		elsif number % 3 == 0			 Fizz 		else		number. to_s		end	endendTakeawaysYou need four things to develop a Ruby project with Minitest:• Install Minitest as a project dependency with Bundler. • Create a test directory at test/ . • Create a test helper to include all global configuration and customization at test/test_helper. rb . • Create a new Rakefile or update the existing one with a Rake::TestTask configured to suit your needs (by convention to run tests you use the command rake) Writing Tests All the tests that we write follow the same basic four-phase structure. 	1. Setup the inputs and data objects prior to running the test. 	2. Exercise the logic under test. 	3. Verify that the tested code produces the expected results. 	4. Teardown or reset application state before running the next test. require 'test_helper'require 'fizz_buzz'class FizzBuzzTest &lt; Minitest::Test	def setup 		@fb = FizzBuzz. new	end	def test_converts_multiples_of_fifteen_to_fizzbuzz		# fb = FizzBuzz. new		assert_equal 'FizzBuzz', @fb. convert(15)		assert_equal 'FizzBuzz', @fb. convert(45)		assert_equal 'FizzBuzz', @fb. convert(90)		[15, 45, 90]. each do |i|			assert_equal 'FizzBuzz', @fb. convert(i)		end	end	def test_converts_multiples_of_five_to_buzz		# fb = FizzBuzz. new		assert_equal 'Buzz', @fb. convert(5)		assert_equal 'Buzz', @fb. convert(10)		assert_equal 'Buzz', 2fb. convert(20)	end	def test_converts_multiples_of_three_to_fizz		# fb = FizzBuzz. new		assert_equal 'Fizz', @fb. convert(3)		assert_equal 'Fizz', @fb. convert(12)		assert_equal 'Fizz', @fb. convert(48)		# another example could have been assert 'Fizz' == fb. convert(3)	end	def test_returns_same_number_for_other_numbers		assert_equal '1', @fb. convert(1)		assert_equal '101', @fb. convert(101)		assert_equal '2014', @fb. convert(2014)	endendAnother example of syntaxis: class ArticleTest &lt; ActiveSupport::TestCase	test  should not save article without title  do		article = Article. new		assert_not article. save	endendThat’s why many developers follow a strict one assertion per test policy - so that each assertion has exactly one chance to succeed or fail. It’s true that your tests will be better and more maintainable when each test verifies a single behavior of the system, but writing a single test for each of the assertions above seems like overkill to me since they’re all testing the same general behavior. setup runs before each test. teardown runs after each test. It’s better to favor readability over DRY-ness when writing tests. Usage of skip Skip can be useful in situations where you want to write a test that specs out some future work that you’re notquite ready to code just yet. For example, FizzBuzzTest doesn’t currently check to see what happens when we pass it an unexpected input. def test_raises_argument_error_for_bad_argument	skip 'not yet implemented'	assert_raises(ArgumentError) { @fb. convert(-1) }	assert_raises(ArgumentError) { @fb. convert(0) }	assert_raises(ArgumentError) { @fb. convert(1. 0) }	assert_raises(ArgumentError) { @fb. convert('foo') }	assert_raises(ArgumentError) { @fb. convert(nil) }endTakeaways	• Assert-style test cases are classes that inherit from Minitest::Test. 	• Public instance methods of those classes whose names begin with test_ are treated as tests by the runner. 	• Minitest provides a small set of assertions out of the box, and of those, about half are used frequently. 	• Override the setup and teardown methods to include code that should be executed before or, respectively, after each test is	executed. 	• If you have to choose between readability and DRY-ness in your tests, you should almost always choose readability. Writing Specs class FizzBuzzIterator	def initialize(start = 1)		@counter = start		@fb = FizzBuzz. new	end	def next		input = @counter		@counter += 1		@fb. convert(input)	endendrequire 'test_helper'require 'fizz_buzz_iterator'describe FizzBuzzIterator do	it 'outputs sequential FizzBuzz values starting from 1 when initialized without a starting value' do		iterator = FizzBuzzIterator. new				expect(iterator. next). must_equal '1'		expect(iterator. next). must_equal '2'		expect(iterator. next). must_equal 'Fizz'		expect(iterator. next). must_equal '4'		expect(iterator. next). must_equal 'Buzz'		expect(iterator. next). must_equal 'Fizz'	end	it 'outputs sequential FizzBuzz values starting from the starting value when initialized with a starting value' do		iterator = FizzBuzzIterator. new(10)				expect(iterator. next). must_equal 'Buzz'		expect(iterator. next). must_equal '11'		expect(iterator. next). must_equal 'Fizz'		expect(iterator. next). must_equal '13'		expect(iterator. next). must_equal '14'		expect(iterator. next). must_equal 'FizzBuzz'	endend# Other alternativesexpect(iterator. next). must_equal 'Fizz'value(iteratory. next). must_equal '11'_(iterator. next). must_equal 'Buzz'Assertion vs Expectation Like most powerful tools, this one can be abused. As a general rule, try to limit describe block nesting to at most two or three layers deep. More than that and the specs hard to follow and less readable for future developers (including future you). Before and After for Spec-Style before blocks for all enclosing scopes will be called before the test logic in order from outermost to innermost. after blocks for all enclosing scopes will be called after the test logic in order from innermost to outermost. In practical terms, this lets us define blocks with increasingly specific setup and teardown logic that cascade or override previous operations require 'test_helper'require 'fizz_buzz_iterator'describe FizzBuzzIterator do	before do		@iterator = FizzBuzzIterator. new	end		it 'outputs sequential FizzBuzz values starting from 1' do		expect(@iterator. next). must_equal '1'		expect(@iterator. next). must_equal '2'		expect(@iterator. next). must_equal 'Fizz'		expect(@iterator. next). must_equal '4'		expect(@iterator. next). must_equal 'Buzz'		expect(@iterator. next). must_equal 'Fizz'	end		describe 'when initialized with a starting value' do		before do			@iterator = FizzBuzzIterator. new(10)		end		it 'outputs sequential FizzBuzz values starting from the starting value' do			expect(@iterator. next). must_equal 'Buzz'			expect(@iterator. next). must_equal '11'			expect(@iterator. next). must_equal 'Fizz'			expect(@iterator. next). must_equal '13'			expect(@iterator. next). must_equal '14'			expect(@iterator. next). must_equal 'FizzBuzz'		end	endendThe let function provides an alternate and some would say more elegant way of setting up testing state with a more declarative syntax. describe FizzBuzzIterator do	let(:iterator) { FizzBuzzIterator. new }	# . . . enddescribe FizzBuzzIterator do	let(:iterator) { FizzBuzzIterator. new(10) }	# . . . endEach call to let dynamically defines a new method with the specified name that executes the block argument upon the first invocation and caches the result for later access - in other words, a lazy initializer. Takeaways • Create a new test case in Minitest::Spec using a top-level describe block with a String or Class argument. • Define a test using an it block with a descriptive String passed as a parameter. • Make assertions on the values of expressions by wrapping them in a Minitest::Expectation object using expect or one of its aliases. • Use nested describe blocks to define scopes within a test case as a way of grouping related tests. • Implement before and after blocks for shared setup and teardown logic specific to a block context. • Create named lazy initializers using let blocks. : Configure Pre-Test State As explained back in Writing Tests, each test run under Minitest follows a common progression of steps: Setup, Exercise, Verify, and Teardown. Of these, Setup usually accounts for more lines of code and can be the toughest for new developers to understand. There are several options for setting the state, and knowing which one is the best fit requires familiarity with all of them. Method 1: Set up the same state before each test. Method 2: Configure different state before each test. Method 3: Using a memoized helper method. Method 4: Create data objects within the test. Collections Enumerable types where order doesn’t matter like Hash and Set count two instances as being equal if they contain the same elements regardless of the order in which the elements were added or passed during initialization. Relations (active record) Just as with Arrays though, order matters, so you’ll need to ensure that both the actual and the expected values are sorted the same way when performing comparisons. ActiveRecord::Relation objects compare mostly like Arrays except when compared with others of the same type, and then according to the SQL representation. Dates and Times Intermediate Recipes Mocks: mocks test the behavior of an object toward the objects to which it sends messages. Use mocks sparingly and only after careful consideration. The more collaborators you mock, the greater your risk of false positives. • Only mock what you own. If you don’t own it, the API could change, and you’d never detect it in your tests. • Only mock immediate collaborators and avoid deep mocking (mocks returning mocks returning mocks). • Ideally, only use mocks to solve specific difficult problems like:◦ Connecting to unreliable or uncontrollable external resources◦ Real object performance is prohibitively slow◦ Expensive setup and/or configuration◦ Avoiding other undesirable side effects StubsStubs provide the context needed to fully exercise an object through a given test scenario • Use stubs wherever and whenever they’re needed, but recognize that needing too many is probably a code smell. • Don’t use stubs where they’re not needed, and apply them as narrowly as possible where you do use them. (See Mocha’s stub_everything and any_instance. stub as prime examples of mocking framework features promoting bad coding practices. )• Never ever, ever stub the object under test. More often than not, you’ll end up testing the stub and not the object itself. Fake Objects A fake is an alternate version of a given class intended for testing only. It exposes an interface resembling that of the real thing it replaces but with an implementation that’s either simplified or hollowed out which allowsthem to:• Capture and verify interactions between the object under test and the fake object (like a mock). • Maintain consistent interactions between the object under test and the fake object (like a stub). • Avoid resource-intensive or otherwise undesirable processing (like both mocks and stubs). We could have gotten the same result using mocking or stubbing, but it might have taken many more lines of setup code. A fake can be a great fit when dealing with complex APIs since it comes ready-made and pre-programmed with the behavior we want and need for running our tests. Testing Mixin Behavior Testing something that can’t be instantiated on its own confuses many developers. two types of mixins: Those that are coupled with the classes that include them, and those that aren’t (non-coupled modules) Takeaways • Use Object#extend to patch a mixin’s method into a simple Object for easy testing. • Try mixing into a Ruby Struct in cases where you need the including class to have some specific attributes or behavior of its own. Sharing Code Between Tests One point that should be clear to you by now is this: a self-contained test is a readable test. Minitest provides a nice, narrow vocabulary for writing tests, and when we stick to that vocabulary, life becomes better for the developers that follow. When it comes to organizing tests:• Extracting code into a new helper methods• Extracting helper methods into a new module• Extracting tests into a new module Extracting helper methods by:• Using descriptive names for helper methods and variable arguments• Updating the extracted code to ensure that it’s still comprehensible, even outside the previous context Takeaways • Code shared within a single test case can be extracted to a private helper method in the same class. • Code shared across multiple test cases can be extracted to a module that may be included in all. 	◦ Sharing tests between test cases is a special case of this Managing Test Data • Whenever persistence isn’t important to your test, use Object. new to create a new instance. • Rails fixtures have a lot going for them including great performance and a reliable set of known models for your tests. • Use both functional and memorable names for your fixtures. • Configure your fixtures carefully, and try to cover at least:◦ One minimal valid configuration◦ One or two realistic models◦ Other well-defined object states• Use advanced ERB and YAML features to define fixtures dynamically. Testing Active Record Models Active Record maps the application database to Ruby objects that manage attributes, relationships, queries, and lifecycle methods among other things. • Test public methods, not private ones. • Test interfaces, not implementations. • Don’t test Active Record (or the rest of Rails, for that matter). • You need to test some of the typical aspects of Active Record models:	◦ Complex validations	◦ Scopes	◦ Callback targets and hooks• Make assertions about the results and side effects of public instance methods. • Make (selective) assertions an object’s behavior toward collaborators. Testing Controllers There’s been a faction of the Rails community that has become vocal about skipping controller testing completely. They usually argue that simulating more realistic user interactions eliminates the need for more focused controller tests which tend to be very repetitive and dull to write anyway. Even the core team has started a gradual move away from controller testing. ◦ Controller tests should include assertions for the visible side effects that controller actions produce including:	◦ HTTP response code	◦ Redirect location	◦ System state changes (models created, updated, or destroyed)	◦ Flash variables, session variables, and cookies set or changed• You should write tests for complex or generated routes. • Controllers should specifically not make assertions about any of the following:	◦ Rendered templates	◦ Instance variables passed to the view "
    }, {
    "id": 85,
    "url": "http://localhost:4000/2021/12/24/how_to_set_right_obj.html",
    "title": "How to set the right objectives",
    "body": "2021/12/24 - Why Greatness Cannot Be Planned: The Myth of the Objective. Kenneth Stanley Knowledge Project Podcast AI Researcher Reveals How to Set the Right Objectives Objectives are good when they are modest, but things get complicated when they are more ambitious. We as society believe that setting objectives and pursuing them it’s going to help us make new discoveries comma new accomplishments, achievements. Some great ideas were never an objective until they were discovered. (Rock and roll, penicillin) Serendipity are discoveries that you were not planning to make it. The core problem with ambitious objectives is that many cases trying harder won’t help you achieve the outcome you’re seeking. You can’t be so tied to your vision of accomplishment that you’re not open to the unexpected or unplanned. You can block your own ability to reach an objective by setting it. Assessment feels like we’re moving towards our objective; the problem is that even if the metric shows that you’re moving up in the short run it doesn’t mean it will lead to the point all the way down. Example: increasing the tests scores in the US schools. (Universal global achievement. Incredible complex) The metric is the assessment and year over year can be going up but it doesn’t solve the fundamental problem. It needs accountability and assessment with a different approach (an approach that recognizes how you actually make innovative progress in a extreme complex problem) If stepping stones are counter-intuitive (they are not what you would expect) then the metrics are useless because they (metrics) won’t detect those stepping stones If stepping stones are not counter-intuitive then it’s not a hard problem, we would have solved already; that’s what makes the problem hard to solve that you don’t know the steps. So we need to proliferate stepping stones. It’s like investing portfolio, they are just ideas, you don’t know what is going to pay off but you do need that portfolio and make that kind of prediction; some of them will not work out and we need to tolerate. Traditional metrics don’t allow stepping stones that won’t lead to the objective. Accountability must thrive interesting steppingstone, even when they won’t go up. What is not a stepping stone is having everyone getting better than prior year. A solution for the education problem is dissemination of the network teachers, see what on teacher did and work and build from that; it may lead to an end road buy we can’t find out if not try. We need to find interesting things that are not objectively detectable through the usual assessment. Peer review allows to see from the global optic to the individual. (Academic publishing is an example)Innovations happen through individual connections. With ambitious goals they are far off in the future and we don’t know what the next stepping stone is so it’s better to almost take like an evolutionary approach where we are creating these mutations or copying errors or trying all these little experiments and then we see which of those experiments leads to some interesting insights or conclusions and then the idea being, we take those conclusions and then we propagate it to and we propagate it to all other nodes almost like nature sort of rewarding. Subjective judgments are interesting because objective judgments are easy. One example is when we got through this pandemic we should have chosen the best 5th grade teachers (State level or city) and gave them the opportunity to teach all 5th grade students because they were the best, and have best practices however this implies two things: subjection (this is teacher than these others) and failure (which we as a humankind are afraid of). Security blanket is provided by assessments, it makes sure nothing really bad happen. Reality is inconvenient, scary, and difficult. A visionary is someone who in contrast who has recognized when the stepping stones actually have stepped into place now that’s a person you should follow and that’s a very interesting and kind of person. Within the corp-life one of the best ways to innovate is to pursue your dream, quit your job and start a start-up this is because the whole society is trapped in this “set goals minded” instead of capturing and developing the idea, they just let it go. "
    }, {
    "id": 86,
    "url": "http://localhost:4000/2021/09/25/refactoring.html",
    "title": "Refactoring",
    "body": "2021/09/25 - This book will take you from beginner to advanced in terms of refactoring. It’s recommended to have prior knowledge of either one Object Oriented language or Ruby however the Ruby language is very idiomatic so you don’t need to have a deep understanding of it in order to identify what is the author trying to teach. Firstly let’s bring up what “Refactoring” means: Verb: To restructure software by applying a series of refactorings without changing its observable behavior. Noun: A change made to the internal structure of software to make it easier to understand and cheaper to modify without changing its observable behavior. The book has around 70 examples of how you can clean your code up and some others well known “good practices”. What are the main benefits of doing it and also it considers its downsides so that you can see the whole picture, bearing in mind that the code you write today must be easy to understand and even change tomorrow. The first chapter begins with a good example of a Movie theater system, on the left side you may find some spaghetti code and on the right the code after applying some refactoring twists. Also, he brings some step by step methodology which consists in small changes, test, another small change, test in order to make sure nothing has been broken. He gives you a brief example and then provides a small image, the motivation, the mechanics and the example. For visual learners, the book has plenty of diagrams, before the Refactoring and after so you can see how a requests is sent from the user/browser and pass through different methods and by doing that you may see how an object is modified and what methods intervene and also how clean is the new diagram. There is a section called “Tip” where the author gives you some advices in order to perform better; this is the first: When you find you have to add a feature to a program, and the programs code is not structured in a convenient way to add the feature, first refactor the program to make it easy to add the feature, then add the feature. He goes over about the ROI (return of investment), the technical debt, how to manage it in the case we have tight deadlines and how much we should invest in order to write good code in the first attempts. Notes. Instance methods should not be too long nor does too much. Even if it works, it’s until we want to change the system when we notice there’s a bad smell. Code is written by humans and humans need to understand it also care about it. A poorly design system is hard to change. If it’s hard to figure out what to change is very likely that programmer will make a mistake and introduce bugs. The only guarantee you’re going to have is that they will change it again within six months. The first to refactor is always the same. I need to build a solid set of tests for that section of code. Decomposing and Refactoring the Statement Method I am looking to decompose the method into smaller pieces. Smaller pieces of code tend to make things more manageable. They are easier to work and to move around. My first step is to find a logical clump of code and use Extract Method. When I extract, I need to know what could go wrong. If I take a larger piece, I can introduce a bug into the program. So before doing it try to figure out how to do it safely. Any non modified variable can be passed as parameter. Modified variables need more care. Never be afraid to change names of things to improve clarity. Good programmers write code that humans can understand. In most cases a method should be on the object whose data it uses. While Refactoring you should focus on clarity, and then later focus on performance as a separate activity. Replacing the Conditional Logic with Polymorphism. If you must use a case statement should be your own data, not on someone else’s. Using subclasses, we can get rid of the case statement using Polymorphism. Example: Movie (as main class) then subclasses: RegularMovie, Children’sMovie and NewMovie. An object cannot change its class during its lifetime. All these lead to better-distributed responsibilities and code that is easier to maintain. The purpose of refactoring is to make software easier to understand and modify. You can make many changes in software that make little or no change in the observable behavior. It only alters the internal structure. Any user, whether an end user or another programmer, cannot tell that things have changed. The two hats by Kent Beck. When you add a function, you should not modify existing code, you’re just adding new features (hat #1), on the other hand when you are refactoring, you should not add code, just restructure the code (hat #2). Refactoring is not the silver bullet for all software development issues. Loss of the structure of code has a cumulative effect. The harder it’s to see the design in the code, the harder it’s to preserve it. Refactoring helps you spot bugs. When I’m studying code, I find Refactoring leads me to higher levels of understanding that otherwise I would miss. You don’t decide to refactor, you refactor because you want to do something else, and refactoring helps you do that other thing. I ask myself if I can refactor the code to make that understanding more immediately apparent. Then I refactor it. The other driver of Refactoring is a design that does not help me add a feature easily Developers often to both things, to remove existing pain points and experiment with new solutions. When developers have a deeper understanding of the code base they can ne more effective at adding to it and suggesting how to improve it. Refactoring tends to break big objects and big methods into several smaller ones. When shouldn’t you refactor? A compromise route is to refactor a large piece of software into components with strong encapsulation. Then you can make a refactor-versus-rebuild decision for one component at a time. Another time you should avoid refactoring is when you are close to a deadline. At that point the productivity gain from refactoring would appear after the deadline and thus be too late. With refactoring the emphasis changes. You still do up-front design, but now you don’t try to find the perfect solution. You may find that the solution is different from the one you previously came up. Always look for flexible solutions. Refactoring can lead to simpler designs without sacrificing flexibility. The secret to fast software is to write tunable software first and then to tune it for sufficient speed. Since the early days of programming people have realized that the longer a procedure is, the more difficult it is to understand. If you have a good name for a method, you should not look at the body. Ninety-nine percent of the time, all you have to do to shorten a method is Extract method. Find the parts of the method that seem to go nicely together and make a new method. A block of code with a comment that tells you what it is doing can be replaced by a method whose name is based on the comment. When a class is trying to do too much, it often shows up as too many instance variables. When a class has too many instances variables, duplicated code cannot be far behind. As with a class with a huge wad of variables, the usual solution for a class with too much code is either to Extract class, Extract module or extract subclass. A Useful trick is to determine how clients use the class and to use the Extract module for each of these uses. That may give you ideas of how you can break up the class. A class smell is a method that seems more interested in a class other than the one it actually is in. You can shrink a lot of parameter lists and simplify method calling. Bunches of data that hang around together really ought to be made into their own object. Most times when you see a case statement it may be replaced by Polymorphism. Each class you create costs money to maintain and to understand. A class that isn’t doing enough to pay for itself should be eliminated. Inheritance often leads to over-intimacy. One of the prime features of Objects is encapsulation – hiding internal details form the rest of the world. Comments are used as deodorant to somehow mask the bad smell. If you want to refactor, the essential precondition is having solid tests. If you don’t write self-testing code, you’ll end up spending most time debugging. When you get a bug report, start by writing a unit test that exposes the bug. Write isolated tests that do not depend on each other. You should concentrate on where the risk is. Look at the code and see where it becomes more complex. I emphasize the safe way of doing the refactoring, which is to take small steps and test after every one. A large part of refactoring is composing methods to package code properly. Almost all the time the problems come from methods that are too long. Long methods are troublesome because they often contain a lot of information which gets buried by the complex logic that usually gets dragged in. The key refactoring is Extract method, which takes a clump of code and turns it into its own method. Inline method which does the opposite. I prefer short, well-named methods. It increases the chances that other methods can use a method and also allows you to read from a higher level as a series of comments. Comments often identify pieces of a method that can be extracted. In such situation temporary variables can be helpful to break down the expression into something more manageable. The difficulty in decomposing a method lies in local variables. Refactoring can break down something complex into simpler pieces, but sometimes you just reach the point at which you have to remove the whole algorithm and replace it with something simpler. Moving methods is the bread and butter of refactoring. I move methods when classes have too much behavior or when classes are collaborating too much and are highly coupled. I consider moving a field if I see more methods on another class using the information in the field than the class itself. You’ve Probably heard that a class should be a crisp abstraction, handle a few clear responsibilities, or some similar guideline. You need to consider where it can be split, and you split it. A good sign that a subset of the data and a subset of the methods seem to go together. Other good signs are subsets of data that usually change together or are particularly dependent on each other. One of the keys, if not the key; to objects is encapsulation. Encapsulation means that object need to know less about other parts of the system. A class is doing too much, remove the middleman with method delegation. Each object stands for one object in the real world. Having many two-way links also makes it easy for mistakes to lead to zombies: objects that should be dead but still hang around because of a reference that was not cleared. Replacing case-like or conditional statements with Polymorphism involves blowing away the original class and replacing it with a new class for each type code. If the original class has a large chunk of code that doesn’t use the type code, I choose either Replace Type code with Module Extension or Replace Type code with State/Strategy. Replace Type code with Module Extension aims to remove conditional logic. Both the original class and the module that is being extended can access the same instance variables. Modules cannot be unmixed easily. When the code is changed at the runtime and the type changes are complex enough that I cant get away with Module Extension I use State/Strategy. I often find conditionals expressions come in two forms. The first form is a check where either course is part of the normal behavior. The second is a form situation in which one answer from the conditional indicates normal behavior and the other indicates an unusual condition. You have a conditional that chooses different behavior depending on the type of an object. One of the grandest sounding words in object jargon is polymorphism. The essence of polymorphism is that it allows you to avoid writing an explicit conditional when you have objects whose behavior varies depending on their types. You can achieve polymorphism in two ways in Ruby, one by implementing the same method signature on multiples objects and call these methods polymorphically and the second by introducing inheritance hierarchy and have the method that is to be called polymorphically on the subclasses. The essence of polymorphism is that instead of asking an object what type it is and the invoking some behavior based on the answer you just invoke the behavior. An assertion technique is a conditional statement that is assumed to be always true. Goal of interface is to show only what they have to and no more. Remember your code is for a human first and a computer second. Methods should be named in a way that communicates their intention. A good way to do this is to think about the comment you would use to describe the method and turn that comment into the name of the method. A good rule to follow is to say that any method that returns a value should not have observable side effects. If you come across a method that returns a value that is used by the caller and also has side effects, you should try to separate the query from the modifier. There are two motivations here for using Replace Constructor with Factory Method. The first comes about if we need to perform this construction login in more than one place. And the second motivation is encapsulation. Exceptions are better because they clearly separate normal processing form error processing. A module should have one single responsibility, just like a class. A module that is difficult to name with the words “helper” or “assistant” is probably doing too much. The main trigger for use of Extract Subclass is the realization that a class has behavior used for some instances of the class and not for others. A Ruby Class can only inherit from one superclass directly. If you want the class to vary in several different ways, you have to use delegation or module extension for all but one of them. Notice that the implementation using extension of modules is similar to the inheritance example. So why use extend instead of inheritance? The answer is that you would use extend if the modules you were creating could be used to extend various classes. By using delegation instead, you make it clear that you are making only partial use of the delegated class. Book examples: https://github. com/DominicLizarraga/refactoring_ruby_edition "
    }, {
    "id": 87,
    "url": "http://localhost:4000/2021/06/15/well_grounded_rubyist.html",
    "title": "The Well-Grounded Rubyist",
    "body": "2021/06/15 - The book is on its 3rd edition and it’s comprised of 3 parts and 16 chapters:  Ruby foundations: (chapters 1-6)The syntax is introduced, key concepts and semantics that Ruby uses, also the construction of objects, classes, modules and identifiers, code conventions, also, how to execute files from the console, how to use Gem files and finally using the Ruby interpreter (irb).  Built-in Classes and methods: (chapters 7-12)The most used built-in classes, including: String, Array, Hash, Numeric, Range, Date, Time and Regular Expressions are presented with many examples, what should you expect out of it? How to use it? How the Boolean logic works. The book has a very digested way of reading how the code is flowing, it has a numerical series where you can read from 1 to 12, step by step, line by line so that you can see how the program reads variables, re-assign them and lastly how the output reached that level, instead of jumping from one line to another.  Ruby dynamics (chapters 12-16)Here you will find the metaprogramming basics, as well as handlers for non-existing methods, how to catch up those exceptions, callbacks, hook messages and finally a functional programming example. Notes. false and cause I conditional expression to evaluate as false; all other objects including true, of course, but also including 0 an “empty strings” caused it to evaluate to true . Variables types: locals, instance, class, global. Every object is capable of understanding a certain set of messages. Each message that an object understands corresponds directly to a- method, a name, executable routine whose execution the object has the ability to trigger. A class defines an object functionality, and every object is an instance of exactly one class period every time you create a string object, you have created an instance of the class string. Although every object is an instance of a class, the concept of class is less important than the concept of object. That’s because objects can change acquiring methods and behaviors that were not defined in their class period the class is responsible for launching object into existence, a process known as instantiation, but they’re after the object has a life of its own. The ability of objects to adopt behaviors that their class did not give them is one of the most central defining principles of design of Ruby as a language. Rather than asking in the abstract weather a = b, you ask whether it considers itself equal to B. If you want to know whether a given student is taking a class from a given teacher, you ask the student, are you student of this teacher ? There is room for debate as to whether this or that programming language, or even these or that kind of programming language, corresponds more closely than others to shape of the real world. A lot depends on how you perceive the world. Do you perceive it as people with things, each of which has task to do and waits for someone to request the task? If so, you may conclude that object oriented languages model the world best. Do you see life as a series of to-do items on a checklist, to be gone through in order? If so, you may see a strictly procedural programming language as having closer ties to the characteristics of the real world. In short there is no answer to the question of what the real world is. Designing object oriented software is largely a matter of figuring out what you want your objects to be: what they should do, how they will interact with each other, how many of each there should be . For example, many students, one register. And other such questions. To get an object to talk, you have to ask it to talk. But before you ask it to talk, you have to teach it how to talk. It’s all about asking objects to do things and tell you things. respond_to? is an example of introspection or reflection. Keywords are special reserved words that you cannot use as variable names. For example def is a keyword ; The only thing you can use it for is to start a method definition. Defining a class lets you group behaviors (methods) into convenient bundles, so that you can quickly create many objects that behave essentially the same way . You can also add methods to individual objects, if that’s appropriate for what you are trying to do in your program. But you don’t have to do that with every object if you model your domain into classes. A typical class consists of a collection of methods definition. Classes usually exist for the purpose of being instantiated that is, of having objects created instances of that class periodMovies about objects, and objects are instances of classes. The instance variable enables individual objects to remember state. Instance variables work much like other variables: you assign values to them, and you read those values back; You can add them together, print them out, and so on pivot but instance variables have a few differences: • Always start with a single @ • Are only visible to the object to which they belong • Instance variable initialized in one method inside a class can be used by any instance method defined within that class. An attribute is a property of an object whose value can be read and or written through the object. Every Ruby class can have only one superclass, in keeping with the principle of single inheritance. Ruby provides modules, which art bundles of programming functionality similar to classes (except that they don’t have instances), that you can easily graft onto your class family tree to provide as many methods for your objects as you need. Your line the idea of a class method is that you send a message to the object that’s the class rather than the one of the class instances. Like classes, modules are bundles of methods and constants. Unlike classes, models don’t have instances; Instead, you specify that you want to add the functionality of a particular module to that of a class or a specific object. No class can inherit from more than one class. In cases where you want numerous extra behaviors for a class instances and you don’t want to stash them all in the class superclass and its ancestral classes, you can use modules to organize your code in a more granular weight. When you are designing a program and you identify a behavior or set of behaviors that may be exhibited by more than one kind of entity or object, you have found a good candidate for a module. The practice of arranging objects that talk to one another in a complete program is called object-oriented design. You learn in chapter 3 that you define a method twice inside the same class, the second definition takes precedence over the first. If the object’s method lookup path includes two or more same name methods, the first one encounter is the winner and is executed. Include will make a module’s methods available as instance method. extend on the other hand, will make a modules method available as class methods. The kernel module provides an instance method called _missing. This method is executed whenever an object receives a method that it does not know how to respond to that is, a message that does not match a method anywhere in the object’s method look-up path. • Modules don’t have instances. It follows that entities or things are generally best modeled in classes, while characteristics, shared behaviors, and properties of entities or things are best encapsulated in modules. • A class can have only one superclass, but it means in as many modules as it wants. If you are using inheritance, give priority to create a sensible superclass/subclass relationship. To know which object itself, you need to know what context you are in. In practice, there are not many contexts to worry about. There is the top level ( before you have entered or after you have left any other context, such as a class definition). There are class definition blocks, model definition blocks, and method definition blocks. It’s all about self switching from one object to another, which it does when you enter a class or module definition, an instance method definition, or a Singleton method (including class method) definition. As soon as you cross a class or module keyword boundary , the class or module whose definition block you’ve entered – the Class or Module object becomes self. A simple rule governs instance variables and their resolution: every instance variable you will ever see in a Ruby program belongs to whatever object is the current object (self) at that point in the program. Using global variables tends to end up being a substitute for solid, flexible program design , rather than contributing to it. One of the main points of object oriented programming is that data and actions are encapsulated in objects. You are supposed to have to query objects for information and to request that they perform actions. And objects are supposed to have a certain privacy. When you ask an object to do something, you are not supposed to care what the object does internally to get the job done. Even if you yourself wrote the code for the objects method, when you send the object a message, you treat the object as a black box that works behind the scenes and provides a response. Global variables these sort the landscape by providing a layer information shared by every object in every context. Globally scoped data is fundamentally in conflict with the object oriented philosophy of endowing objects with abilities and then getting things done by sending request to those objects. Every definition block whether for a class, a model, a method, starts a new local scope, a new local variable, scratch pad, and get its own variable. At its simplest, idea behind a class variable is that it provides a storage mechanism that’s shared between a class and instance of that class, and that’s not visible to any other objects. No other entity can fill this role. Local variables don’t survive the scope change between class definition and their inner method definition. Globals do but they are also visible and mutual everywhere else in the program someone not just in one class. So class variables have a niche to feel: visibility to a class and its instances, and to no one else. The main business of Ruby program is to send messages to objects. And the main business of an object is to respond to messages. Sometimes, and object wants to be able to send itself messages that it does not want anyone else to be able to send it. For this scenario, Ruby provides the ability to make a method private. If you don’t use an explicit receiver for a method call, Ruby assumes that you want to send the message to the current object , self. Ruby control flow techniques include the following: Conditional execution. Execution depends on the truth of an expression. Looping. A single segment of code is executed repeatedly Iteration. a call to a method is supplemented with a segment of code that the method can call one or more times during its own execution. Exceptions. Error conditions are handled by special control for rules. After all, when you call a method on an object, control is passed to the body of the method ( 8 different scope); And when the method has finished executing, control returns to the point right after the point where the method call took place. The difference between a method call with a block and a method call without a block comes down to whether or not the method can deal. If there is a block, then it can; If not it cannot, because there is nothing to deal to. An Exception is a special kind of object, an instance of the class exception or a descendant of that class period raising an exception means stopping normal execution of the program and either dealing with the problem that’s being encountered or existing the program completely. It’s generally considered good practice to catch a specific exceptions rather than simply using rescue to catch all exceptions. ensure clause is executed whether an exception is raised or not. In short it is packed to begin/end structure of which it is a part, and its execution is unconditional. The fact that you can define an even redefine elements like the + -, and square brackets means that Ruby has a great deal of flexibility. But there are limits of what you can redefining will be. You can’t where they find any of the literal object constructors: {} it’s always a hash literal (or a code block, if it appears in that context), “” we’ll always delimit a string, and so forth. One consideration, weighing in on the side of modifying objects instead of creating new ones, is efficiency, creating new objects is expensive in terms of memory and processing. All that matters is what the object can do, what methods it can execute. Nil does exist. Single values, such as integer and strings, as opposed to collection or container objects that hold multiple values are considered as a scalar. Symbols aren’t unique. Whenever you see xyz, you are seeing a representation of the same object. Again, symbols are more like integers than strings in this respect. When you see the notation “xyz” in two places, you are looking at representations of two different string objects; The literal string constructor “” creates a new string. But :xyz is always the same Symbol object, just as 100 is always the same object. Symbols are immutable. There is no such thing as appending characters to a symbol; Once the symbol exists, that’s it. You will never see :abc « :d or anything of that kind. Symbols have a number of users, but most appearance fall into one of two categories, method arguments and hash keys. Well we can process symbol faster. Whereas the strings have a malleability that’s a good fit for their presentation of arbitrary values. Strings being mutual, symbols not. Symbols share with integers not only immutability and uniqueness but also immediacy: a variable to which a symbol is bound provides the actual symbol value, not a reference tweet. Any class that aspires to be innumerable must have an each method whose job is to yield items to a supply code block , one at a time periodNumerators are closely related to eaters, but they are not the same thing period and iterate are is a method that yields one or more values to a code block. And enumerator is an object, not a method, therefore maintain state. An Enumerator can add innumerably to objects that don’t have it. It’s a matter of wiring: if you hook up and enumerators each method to any iterate are, then you can use the numerator to perform innumerable operations on the object that owns the iterator, whether that object considers itself innumerable or not. Here is the source code https://github. com/jleo3/twgr "
    }, {
    "id": 88,
    "url": "http://localhost:4000/2021/05/30/practical_oriented.html",
    "title": "Practical Object-Oriented Design (POODR)",
    "body": "2021/05/30 - This book is the second edition that Sandi Metz publishes and it’s even considered as a must-read by the RoR community, give it a shot you won’t regret at all no matter what language you’re coming from. The introduction gives you why we want to work at a place where we feel as if we had some real impact, without being painful and why not make it funny as well, also explores the idea of increasing the productivity and reducing costs associated with poor design software. It goes over some agile methodology; it brings up the “Agile Manifesto” and explores its points of intersection between project management and software development. The core example of the book is a Bicycle store and it starts with the most simple but thorough class and it gradually increases its complexity always by giving you the reason why would you for instance need to add spare parts method to the main class or create a new one from scratch, what are the benefits and downsides? Is the customer really requesting this? What if we go beyond the scope of the app and make it flexible since the beginning? And finally, you end up with a Bicycle store and an app to book trips. 🚲 🏔 It offers many examples of all the good practices or rules you may find below and gives you the before and after of each scenario, and you can find the most important examples in my repository. https://github. com/DominicLizarraga/refactoring_ruby_edition Chapter 1. “Object-Oriented Design” Encourages you to shift your thinking from a world of collection of predefined procedures to modeling the world as a series of messages that pass between objects. It depicts that statement with an example of a woman waking up at the same hour, preparing her coffee and suddenly steps on the cat, causing a reaction that was not on the normal routine. 🐈 It also elaborates on the idea that the only sure thing that will happen is that your app will need some changes, it’s impossible to never change. It includes some customer perspective and how the client doesn’t not even know what they want so you must be ready for progressive modifications. “You must combine an overall understanding of your application’s requirements with knowledge of the costs and benefits of design alternatives and then devise an arrangement of code that is cost effective in the present and will continue to be so I the future. ” “The purpose of design is to allow you to design later, and its primary goal is to reduce the cost of change. ” The chapter 2. “Designing Classes with a single responsibility” The foundation of an object-oriented system is the message, but the most visible organizational structure is the class. Your goal is to model your application, using classes, such that it does what it is supposed to do right now and is also easy to change later. Creating an easy-to-change application, however, is a different matter. Your application needs to work right now just once; it must be easy to change forever. The problem is not one of technical knowledge but of organization; you know how to write the code but not where to put it. When it says easy to change it means the following: • changes have no unexpected side effects, • small changes in requirements require correspondingly small changes in code, • existing code is easy to reuse, and • the easiest way to make a change is to add code that in itself is easy to change. A class should do the smallest possible useful thing; that is, it should have a single responsibility. Chapter 3. “Managing Dependencies” Because well-designed objects have a single responsibility, their very nature requires that they collaborate to accomplish complex tasks. This collaboration is powerful and perilous. To collaborate, an object must know something know about others. Knowing creates a dependency. Ig not managed carefully; these dependencies will strangle your application. Your design challenge is to manage dependencies so that each class has the fewest possible; a class should know just enough to do its job and not one thing more. To some degree of dependency between these two classes is inevitable; after all, they must collaborate. When two (or more) objects are so tightly coupled that they behave as a unit, it’s impossible to reuse just one. Every dependency is like a little dot of glue that causes your class to stick to the things it touches. A few dots are necessary. If prevented from achieving perfection, your goals should switch to improving the overall situation by leaving the code better than you found it. If you get this right, your application will be pleasant to work on and easy to maintain. If you get it wrong, the dependencies will gradually take over and the application will become harder to change. Depend on things that change less often than you do. Injecting dependencies creates loosely coupled objects that can be reused in novel ways. Isolating dependencies allows objects to quickly adapt to unexpected changes. The key to managing dependencies is to control their direction. Chapter 4. “Creating Flexible Interfaces” It’s easy to think about object-oriented applications as being the sum of their classes, they are so very visible; and they spin around responsibilities and dependencies. There is design detail that must be captured at that level, but an object-oriented application is more than just classes. It is made up of classes but defined by messages. Classes control what’s in your source code repository; messages reflect the living, animated application. Design therefore, must be concerned with the messages that pass between objects. It deals not only with what objects know (their responsibilities) but also with how they talk to one another. The conversation between objects takes place using their interfaces; this chapter explores creating flexible interfaces that allow applications to grow and to change. Imagine two running applications. Each consists of objects and the messages that pass between them. In the first application, the messages have no apparent pattern. Every object may send any message to any other object. If the message left visible trails, there trails would eventually draw a woven mat, with each object connected to every other. In the second application, the messages have a clearly defined pattern. Here the object communicates in specific and well-defined ways. If these messages left a trail, the trails would accumulate to create a set of islands with occasional bridges between them. The second application is composed of a pluggable, component-like objects. Each reveals as little about itself, and knows as little about others, as possible. The design goal, as always, is to retain maximum future flexibility while writing only enough code to meet today’s requirements. Drawing this sequence diagram exposes the message passing between the objects. The best possible situation is for an object to be completely independent of its context. An object that could collaborate with others without knowing who they are or what they do could be reused in novel and unanticipated ways. Your goal is to write code that works today, that can easily be reused, and that can be adapted for unexpected use in the future. Object-oriented applications are defined by the messages that pass between objects. This message passing takes place along “public” interfaces; well-defined public interfaces consists of stable method that expose the responsibilities of their underlying classes and provide maximal benefit at minimal cost. Chapter 5. “Reducing Costs with Duck Typing” The purpose of object-oriented design is to reduce the cost of change. Duck typed objects are chameleons that are defined more by their behavior than by their class. Avoid getting sidetracked by your knowledge of what each argument class already does; think instead about what the object needs. Concrete code is easy to understand but costly to extend. Abstract code may initially seem more obscure, but once understood is far easier to change. Recognizing hidden ducks. Case statements that switch on class Uses of method: kind_of? and is_a? responds_to? Polymorphism in OOP refers to the ability of many different objects to respond to the same message. Duck typing reveals virtual underlying abstractions that might otherwise be invisible. Depending on these abstractions reduces risks and increases flexibility, making your application cheaper to maintain and easier to change. Chapter 6. “Acquiring Behavior through Inheritance” This chapters offers a detailed example of how to write code that properly uses inheritance. The idea of inheritance may seem complicated, but as with all complexity, there’s a simplifying abstraction. Inheritance is, at its core, a mechanism for automatic message delegation, if and object cannot respond to a received message, it delegates that message to another. A superclass can have many subclasses, but each subclass is permitted have one superclass. Creating hierarchy has costs; the best way to minimize these costs is to maximize your chance of getting the abstraction right before allowing subclasses to depend on it. The best way to create an abstract superclass Is by pushing code up from concrete subclasses. Chapter 7. “sharing Role Behavior with Modules” To reap benefits from using inheritance you must understand not only how to write inheritable code but also when it makes sense to do so. Use of inheritance is always optional; every problem that it solves can be solved another way. Because no design technique is free, creating the most cost-effective application requires making informed tradeoffs between the relative costs and likely benefits alternatives. When formerly unrelated objects begin to play a common role, they enter into a relationship with the objects for whom they play the role. Many object-oriented languages provide a way to define a named group of methods that are independent of class and can be mixed in to any object. In ruby these mix-ins are called modules. When objects that play a common role need to share behavior, they do so via a Ruby module. When a class includes a module, the methods in that module get put into the same look path as methods acquired via inheritance. Chapter 8. “Combining Objects with Composition” Composition is the act of combining distinct parts into a complex whole such that the whole becomes more than the sum of its parts. Music for example, is composed. You can create software this same way, by using object-oriented composition to combine simple, independent objects into larger, more complex wholes. A bicycle has parts. Bicycle is the containing object, the parts are contained within a bicycle. The Bicycle class is responsible for responding to the spares message. This spares message should return a list of spare parts. The more parts an object has, the more likely it is that it should be modeled with composition. Composition, classical inheritance and behavior sharing via modules are competing techniques for arranging code. Each has different costs and benefits; these differences predispose them to be better at solving slightly different problems. Chapter 9. “Designing Cost-Effective Tests” Without tests, these applications can be neither understood nor safely changed. They add value without increasing costs. These are notes I took from the book, nothing is mine. "
    }, {
    "id": 89,
    "url": "http://localhost:4000/2021/05/29/example.html",
    "title": "Example",
    "body": "2021/05/29 - Test photo! "
    }, {
    "id": 90,
    "url": "http://localhost:4000/2021/05/23/eloquent-ruby.html",
    "title": "Eloquent Ruby",
    "body": "2021/05/23 - This is book is not for learning the very basics of Ruby, it’s more for people who have played with the language, the console and maybe built simple web app, I say this because it assumes you know what is an array, how you can manipulate or work with it therefore the book only shows shortcuts for instance methods on arrays, the correct usage of bang (!). I contains 3 sections after each chapter, staying out of trouble, in the wild and to wrap up, which has the most important takeaway after the lesson, i. e. “Choose the right control structure”, a real example from a codebase and finally a summary of what it went over. The book navigates each lesson through a kind of library system where a Document is created with its author, it plays with the first name and last name of the author, then it adds it to an array, then to a hash in order to have it more well organized. It will refresh you some basics methods like inject, map, sort, reverse, push, pop, delete, shift with the bang and without it always keeping in mind that Ruby is an idiomatic language. The book dedicates one chapter to learn how to work and mutilate this String class which is something Ruby is pretty smart and after that String brush up it goes to the Regular Expression, It shows you only the basics of how to validate an e-mail, address how to format a date, and it helps you find it easy to use instead of the intimidating appearance it seems to be. It has a deep chapter on the usage of symbols, it shows you the difference between a symbol and just string, it brings the symbol characteristics, it’s immutability, its better performance and it’s memory space utilization. The core of Ruby on Rails, everything is an object, shows you the keywords, how to treat the self, some instance methods in order to know what class is the object you are evaluating, it also presents why treating everything as an object is a good way because it provides consistency to your application, the difference between public, private, protected methods. how to require external libraries like date for instance and it closes remembering us that virtually everything in Ruby is an object, and virtually all of those objects inherit the basic set of methods from the Object class. Engineering is all about tradeoffs. just about every engineering decision involves getting something, but at a price, and there is a price to be paid for dynamic typing. In the chapter 8 lays out the difference between dynamic and static programming languages and encourages you to write tests which is the best way 2 make sure your code works as it should, do you need to test it early, you need to test it often, and you certainly need to test it whenever you change it. The tests framework used on this book are Unit::Test and RSpec it shows you how to start those tests and make them work with their document class. The author Hardly stresses how important is to write test in order to know how your code is working there is no shortcut, there is no easy way it would save you tons of hours if you do it often. The part II of the books goes over the back bone of the language, in this case Classes, Modules and Blocks. Despite shelves full of books on software architecture, and UML diagrams to fill an Art Museum and design meeting that seem to last longer than the pyramids, building software mostly comes down to writing one method after another, methods that stick to doing one thing and doing it well. Composing methods for humans, this technique advocates dividing your class up into methods that have three characteristics. first, each message should do a single thing , focus on solving a single aspect of the problem. by concentrating on one thing, your methods are not only easier to write, they are also easier to understand. second, each method needs to operate at a single conceptual level: Simply put, don’t mix high level logic with the nitty-gritty details. a method that implements their business logic around say, currency conversions, should not suddenly veer off into the details of how the various accounts are sorted in the database. Finally, each method needs to have a name that reflects its purpose. nothing new here, we have all heard endless lectures about picking good method names. the time to listen to all of them haranguing is when you are creating lots of little methods that you are trying to put together into a functional whole. Why is building small, well named methods that do one thing such a good idea? it’s not about writing better code for the computer, because the computer does not care. you can code the same algorithm in a handful of large methods or in a myriad of little message and , as long as you’ve gotten the details right, the computer will give you exactly the same answer. the reason you should lean towards smaller methods is that all those compact, easy-to-comprehend methods will help you get the details right. Short, easily comprehending methods also have some secondary advantages as well. take the old bit of coding advice that every message should have exactly one way out, so that all of the logic converges at the bottom for a single return. the key to preventing your compose methods from turning on you is to remember that every method should have two things going for it. First, it should be short. and second, it should be coherent. In plain English, your method should be compact, but it should also do something. Unfortunately, since short is so much easier to remember than coherent, programmers will sometimes go too far in breaking up their methods. There is also a chapter that teaches you how to modify normal operators (&lt;, &gt;, +, -, =, %, *) and change their behavior totally, it demonstrates the ups and downs of defining your own operators, and what are they consequences for others users if they don’t know what outcome will they get. Chapter 12 and 13 explore the idea behind equality classes, how you can leverage the custom operator by giving them another behavior, how equal? is different from ==, or even ===; all of them have different meaning and the author breaks them all down, next it touches the Singleton and class methods what are their uses, when should you use them, how are they built and again they differences. The usage of Class instance variables, instance variables and modules, what are the benefits , the caveats, what happen if a name collision takes place, what can they hold, what are the risks of over using a module and one of the keys of programming which is naming these instances, those classes, these modules. How to include that module into a Class, how to extend the usage of that module, and also how is the look-up procedure when you call a method (Inheritance tree). An easy rule of thumb for naming modules is that if you find yourself creating a lot of names that all start with the same word, perhaps ‘TonsOTonerPrintQueue’ and ‘TonsOTonerPrintAdministration’, then you just may need a ‘TonsOToner’ module. The book also covers iterators with 3 chapters, they’re different ways of calling, the usage of yield (Execute around), the naming convention, how to enable a class to use more than 40 methods coming from the enumerable module, the usage of rescue, begin, raise; Come on errors when using execute around which can be for instance forget about exceptions; because execute around is all about warranties. The whole idea of execute around is that the color is warranty that this will happen before the code fires and that will happen after. The technique “execute later “ is when you add a parameter prefix with an ampersand, some practical examples of lambdas and procs as well and lastly it touches some of the metaprogramming topics to modify subclasses, to use the method_missing method In order to rescue one execution and provide an exception. Updating existing classes, fixing broken classes, what is the monkey patching? Dealing with DSL and XML, what are the Gems package, how to consume them, nuts and bolts of gems, where are they located and also how to build a gem publish them and make it public. "
    }, {
    "id": 91,
    "url": "http://localhost:4000/2021/04/01/beginning.html",
    "title": "Beginning Rails 6 🚇",
    "body": "2021/04/01 - This book takes you from the straightforward “rails new blog –d=postgrsql” to adding active jobs and sending automated emails; it goes step by step so that you can see gradually the app development, it has more than 500 pages with 18 chapters; it touches the very basics of Ruby in the 4th just in case the reader has no experience with this language however Rails is very intuitive and easy to follow along. As you may read the main web app that is built along with this book is a blog where an user can sign-in/ log-in with email and password, can post with “Rich Text” (attach images, modify font, color, size), can edit its own posts, can comment on other’s posts and finally can delete only posts that user has created. Articles are the epicenter of the application. It uses the most common Gems in order to get the app up and running, it helps you add the gem to translate the app into different languages (Spanish, Portuguese, etc. ), it helps you enable the active storage gem which is used like a cloud storage (comes by default with Rails), explains you the differences between CSS and SCSS, also how to connect JavaScript, what is it for?, action text, Ajax, Action Cable and finally it uploads the app to Heroku (Cloud platform to host your app) in order to grant access anyone in the world. It was also the first book I’ve read that contains the whole Action Pack broken down, routes, controllers, views, which means Action Controller, Action View and Action Dispatch respectively in addition the whole request cycle, who are the actors, what is DNS for? And lands all of this with a CD player in a car example, pretty clear for me. Notes. ✍🏻 A framework is a collection of libraries and tools intended to facilitate development. Design with productivity in mind a good framework provides a basic but complete infrastructure on top of which to build an application. Why choose Rails? 🛤 It provides a powerful database abstraction layer called active records, which works with all popular data based systems. It chips with a sensible set of defaults and provides a well-proven, multi-layer system for organizing programs files and concerns. Its goal as a framework is to solve 80% of the problems that occur in web development, assuming that the remaining 20% are problems that are unique to the applications domain; you get to focus on just 20% which is what really matters. With rails, you can respond to the needs of customers quickly and easily, and rails works well during collaborative development. It has the famous convention over configuration, “don’t repeat yourself” (DRY), the concepts of rapid prototyping and that “you ain’t gonna need it” (YAGNI) Philosophy, closing the gap between customer and programmer. Programming is all about making decisions. If you were to write a system from scratch, without the aid of rails, you would have to make a lot of decisions: how to organize your files, what naming conventions to adopt, and how to handle databases access are only a few. Rails lets you start right away by encompassing a set of intelligent decisions about how you program should work and alleviating theamount of low-level decisions making you need to do up front. As a result, you can focus on the problems direct trying to solve and get the job done more quickly. Although you can manipulate most things in the Rails setup and environment, the more you accept the defaults, the faster you can develop applications and predict how they will work. If you put your files in the right place and name them according to the right conventions, things just work. If you are willing to agree to the defaults, you’re generally have less code to write. The more duplication exists in a system, the more room box has to hide. Ruby is known for making certain programmatic constructs look more natural by way of what’s called syntactic sugar. Rails has popularized the term synthetic vinegar coma is the exact opposite of syntactic sugar: awkward programmatic constructs are discouraged by making their syntax look sour. Rails employs a time honored and well-established architectural pattern that advocates dividing application logic and labor into three distinct categories: the model, view, and controller. In the MVC pattern, the model represents the data, the view represents the user interface, and the controller directs all the action. The real power lies in the combination of the MVC layers. Using the pain of maintenance considerably while increasing the level of ability among components. Models. in rails, the model layer represents the database. For example, a model called User convention, would map to a table called users. All the rules for data access, associations, validation, calculations and routines that should be executed before and after save, update or destroy operation and nearly encapsulated in get model. Controllers. It is the controller’s job to fill with requests coma like processing server variables and formatting data, asking the model for information, and sending information back to the model to be saved in the database. It sets up variables to be used in the view, and then proceeds to render or redirect to another action after processing is complete. Controllers typically manage a single area of an application. For example, in a recipe application, you probably have a controller just for managing recipes. Inside the recipes controller, you can define what are called actions. Actions describe what a controller can do. If you want to be able to create, read coma update and delete recipes, you create appropriately named actions in the recipe’s controller. When a request comes into a controller, it uses a URL parameter to identify the action to execute; And when it is done, it’s sensory response to the browser. Their response is what you look at next. Views. The view layer in the MVC forms the visible part of the application. In rails, views are the templates that (most of the time) contain HTML markup to be rendered in a browser. It’s important to note that views are meant to be free of all but the simplest programming logic. Any direct interaction with the model layer it should be delegated to the controller layer, to keep the view clean and decouple from the applications business logic. active_record: a library that handles database abstraction and interaction. Action view: a templating system that generates the HTML documents the visitor gets back as a result of a request to a rails application. Action controller: a library for manipulating both application flow and the data coming from the database on its way to being displayed in a view. New lane these libraries can be used independently of rails one of another. Together, they form the rails MVC development stack. Rails is modular. One of the greatest features of rails is that it was built with modularity in mind from the ground up. Although many developers appreciate the fact that they get a full stack, you may have your own preferences in libraries. In the real world, specifications above as we learn how real users interact with our web applications. Chapter 3, goes to explain how is the rails architecture distributed, what are the files inside of each folder, how to start writing our first migration, execute it, how to add validations to the model, add more fields to the model, and also, how to rollback a migration in case you make a mistake or you did not add something important, it is always reversible. Chapter 4, explains why Ruby is dynamic, how you can use the IRB prompt, what are the Ruby data types such as string, numbers, symbols, arrays and hashes. what are variables, what are they for, and they need do not specify a data type for the variable or the find it in your code before you use it. What are the best practices for naming variables, in this case long and descriptive. Blocks and iterators, comments, control structures, methods. And finally, a brief introduction to object-oriented programming, objects and classes. A key feature of active record which maps table to classes, table rows to object, and table columns to object attributes. This practice is commonly known as object relational mapping (ORM). rails db:system:change -Which makes it easy to switch databases. Active Record provides the link between these classes and your tables, allowing you to work with what look like regular objects, which, in turn, can be persisted to the database. This frees you from having to write low level SQL to talk to the database. Object oriented programming is all about objects. You create a class that encapsulates all the logic required to create an object, along with its properties and attributes, and use the class to produce new objects, each of which is in unique instance, distinct from other objects of the same class. That means sound a little abstract (and with good reason abstraction, after all, is the name of the game) but if it helps you can think of a class as being an object factory. Classes are used to create objects, and objects have attributes. Every object has a unique set of attributes different from other objects of the same class. A return of nil always represents nothing. The new constructor creates a new object, but it is your responsibility to save it. If you forget to save the object, it will never be written to the database. To summarize, when you want to create a new object and save it manually, use the new constructor; When you want to create and save in one operation, use create. update_attributes is an instance variable if you want to update attributes in just one operation. The following call works for deleting or what’s inside the array Article. delete([1, 2, 3]) The primary way in which you enhance models is by adding methods to them. This is referred to as adding domain logic. With active record, all the logic for a particular table is contained in one place that model. This is why the model is set to encapsulate all the domain logic. This logic includes access rules, validations, relationships, and well, just about anything else you feel like adding. user. build_profile(attributes={}) Returns a new profile object that has been instantiated with attributes and linked to user through a foreign key but has not yet been saved. user. create_profile(attributes={}) Returns a new profile object that has been instantiated with attributes and linked to user through a foreign key that has already been saved. Their rule of thumb is that belongs_to declaration always go in the class with the foreign key rails db:setup Command recreates the database and adds the seat data as you may expect. Whenever you want to add a validation error to the list of errors, you just type errors. add(column_name, error_message). Action Controller. Orchestrate your applications flow. Every time a user requests a page, submits a form, or clicks a link, that request is handled in one way or another by a controller. A typical controller is most often a collection of actions that relates to a specific area of concern. For example, consider the blog application you have been building in the previous chapters. The controller that manages articles has the class name articles controller and has action methods for listing, creating, updating, reading, and deleting articles. The controller looks for a view whose name matches they requested name action. Action View. this library is another important part of action pack. Given that controllers are responsible for handling the request and issuing a response, views are responsible for rendering the output of a response in a way a browser or any other user agent can understand. The primary mechanism by which they do is through shared variables. All instance variables that you may see in a view comes from the controller; look at the view is not handling any logic to fetch the list of these articles. Action Pack. routing salt this problem by decoupling the URL from the underlying program implementation. Request cycle Then type request to response process is called the action pack request cycle. They request cycle consists of the following steps:Rails receives a request from the outside world (usually a browser). routing picks apart the request to determine the controller and action to invoke. A new controller object is instantiated, and an action method is called. The controller interacts with the model (usually performing a CRUD operation in a database with an Active Record model, but not necessarily). A response is sent back to the browser, in the form of either a render or a red direct. HTTP verbs The HTTP protocol defines several request methods, the most popular of which art GET and POST. Both our method for requesting a webpage; The differences in how the request is sent. GET is the simpler of the two period it includes all the information about the request as a part of the URL. POST sends information in visibly, which is to say as a part of the request header and not part of the URL so you cannot type a post request into your browser’s locations bar. How do you know when to use each? The best way to think of this is to consider GET high as read method. It should never do anything destructive, such as modifying a database record. POST, on the other hand, can be thought of as a writer method. When you need to create data, use POST. PATCH is used when you need to update a record partially, for instance, only changing your e-mail address. PUT is used to update a record completely. Most of the time, our controllers handle interactions with a collection of things, so we reflected by using a plural name. Comments are interesting because they are a little different from our other models so far. Comments depend on a particular article; They never exist on their own because they are conceptually meaningless if they are not tight to an article. Remember that you always have the article_id in your parameters because it is always included in your nested name routes. Also notice how you find they assign comment you do so using @article. comments. HTTP is a stateless so how can the application remember you are logged in if HTTP is a stateless? The answer is that you fake state with session object. Example: session[:account_id] = @account. id. Notice that you define session as a resource and not resources, because you never deal a set of sessions at once. The rule of thumb is that whenever you have data that are provided by the user, you cannot trust them blindly . You need to escape it. This includes model attributes as well ask parameters. Fortunately, railes escapes all rendered as strings for you. html_safe method skips the HTML escaping process. simple_fromat method Convert text to HTML using simple formatting rules. The chapters of Active Storage, how to implement Ajax (was implemented for creating and deleting comments, interacted with the DOM with a . js file where all the code for doing this was placed) and sending and receiving email (Action Mailer and Action Mailbox) is difficult to describe but overall those chapters are pretty neat, I’d say more than https://guides. rubyonrails. org/. Active Job chapter covers the configuration, the creation, the exception handling, retry, discard and finally it has a benchmark exercise where the perform_later method on the mail delivery improved significantly the app performance. This is the first time I faced Active Model, before this one I didn’t know it existed, the book take that module to build an EmailAFriend without the need to create the whole model as Article for example and with all the benefits a model implies, Active Record, callbacks, validations, attributes and so on. The Action Cable chapter is short, explains how HTTP is the normal way the web works, then how web sockets were introduced as a bidirectional server communication and after that it just lays out the four main concepts as connections, channels, streams, broadcasting, subscription and so on, it configures it and apply the broadcast to Article so every time one article is published it will appear at the top without refreshing and start the cycle from the beginning. The last 3 chapters covers testing, internationalization and the upload to Heroku, the first on them emphasize the importance of always test after each small change, and why the didn’t apply test to follow along, they bring up the technical debt, refactoring. what tools are outside to automate the testing like Unit::Test, fixtures, validations and lastly the 4 types of tests, for models, for controllers, mailers and system, it doesn’t go deep into the weeds, it only explain what they are. "
    }, {
    "id": 92,
    "url": "http://localhost:4000/2021/02/21/ruby_way.html",
    "title": "The Ruby Way",
    "body": "2021/02/21 - The book is on its third edition, it has had plenty of space as the must-read for every Ruby programmer, many great personalities in the software development community have commented, praised, written about this book (including Yukihiro “Matz” Matsumoto, the creator of Ruby) because a few years after Ruby was conceived the first edition was published, and as everything evolved, the book has done as well. This time the background of the beginning of this language is presented, how Matz thought in terms of design and usage for building this language, it went from the approach machine-centered paradigm to a human-centered one. Ruby strives to be friendly to the programmer, and with that in mind, we can rely on a completely new style of software development, more strategically then tactic, easier to read, needlessly to add comments. This piece has 22 chapters, and more than 700 pages; it covers the conception of the language, introduction to object orientation, basic syntax and semantics, working with strings, symbols, ranges, numbers, times and dates and of course our arrays, hashes and other Enumerables, also, goes over more advanced data structures like trees, graphs, sets, stacks and queues. It brings the difference between static and dynamic languages, testing, how to handle different data formats, how is related Ruby and web applications, and more stuff that you can leverage in order to cement draw Ruby fundamentals. To me it was the longest book I’d ever had in my hands, quite hard to start to be honest but as soon as you pass the first pages you get caught, it refreshed me a ton of built in methods for the most important data structures, and when I say a ton, it’s about 80% of all what you need (very comfy way to read these methods on the book, and with the method description more friendlier) , so very well thought from the author perspective, not hard theory to digest, only practical examples and a few debates between 2 different points of view but nothing abstract. I think is a good start for people who want to harden their programming skills because it covers many topics of software development, it doesn’t matter what language you come from, it works for processing text files, web development, graphical interfaces, some algorithms to get familiarized with. Notes. ✍🏻 An object is an entity that serves as a container for data and also controls access to the data. Associated with the object is a set of attributes, which are essentially no more than variables belonging to the object. Also associated with an object is a set of functions that provide an interface to the functionality of the object, called methods. It is a essential that any OOP language to provide encapsulation. The class may be thought of as the blueprint or pattern; The object itself is the thing created from that blueprint or pattern. A class is often thought of as an abstract type, a more complex type than, for example, an integer or character string. Inheritance is a mechanism that allows us to extend previously existing entity by adding features to create a new entity. In short, inheritance is a way of reusing code. Easy effective code reuse has long been the Holy Grail of computer science, resulting in the invention decades ago of parameterized subroutines and code libraries. Multiple inheritance he’s probably the most controversial area in OOP; one camp will point out the potential for ambiguity that must be resolved. It is conceivable that a new class could inherit from more than one class. Diamond inheritance problem, so-called because of the shape of its inheritance diagram, with both super classes inheriting from a single common superclass. The literal meaning of polymorphism is the ability to take on multiple forms or shapes. In its broadest sense, this refers to the ability to different objects to respond in different ways to the same message (or method invocation). The first, inheritance polymorphism, is what most programmers are referring to when they talk about polymorphism. When a class inherits from its superclass we know that any method present in the superclass is also present in the subclass. The second kind of polymorphism Conway identifies is interface polymorphism. This does not require any inheritance relationship between classes; It only requires that the interface of the object have met thoughts of a certain name. A module consists of methods or constants that may be used as though they were actually part of the class or object; When a module is mixed in via the include statement this is considered to be a restrictive form of multiple inheritance. By rivals are used to hold reference to objects. A module is a collection of methods and constants that is external to the Ruby program. The private level means that the method is accessible only within the class or its subclass. Ruby is a dynamic language in the sense that objects and classes may be altered at runtime. Will be has the capability to construct and evaluate pieces of gold in the course of executing the existing statically coded program. This is perhaps the most difficult area a programmer will encounter in learning Ruby. Everything is intuitive once you understand it. Everything is true except false and nil. many languages have some kind of for loop, as does Ruby. The question sooner or later arises as to whether the index variable can be modified. Any object can be in principle converted to some kind of string representation; That is why nearly every quarter class has a to_s method. A symbol is like a string in that it corresponds to a sequence of chapters. It is unlikely string in that each symbol has only one instance (just as a fixed number works). Therefore there is a memory or performance issue to be aware of. The &amp; notation allows us to pass a proc instead of an explicit attached block if we want. Because we use the &amp; on an object that is not a problem interpreter tries to call to_call on that object. It will call it repeatedly, once for each element in the right. The collect method (part of innumerable) is a useful tool that proves to be a time and labor saver in many circumstances. If you want to delete all instances of a certain piece of data, delete would do the job. The compact method (or it’s in place version compact!) removes nil values from an array, leaving the rest untouched. The delete_if passes every element into the supply block and delete the elements for which the block evaluates to true. It behaves similarly to reject!, except that the latter can return when the array remains unchanged. They reject method takes a block and produces a new array without the elements for which the block returns true. Bear in mind that +, concat, and even +=always create a new array object. Also bear in mind that while « adds to the existing array, it happens a new array element (which may itself be an array). What makes a collection enumerable ? Largely it is just the fact of being a collection. The module enumerable has the requirements that the default iterate each should be defined. Sequence as such is not an issue because even on unordered collection can have any generator. And enumerator is basically an object that can be used for external or internal iteration. In internal iteration, we simply iterate over each item in the collection and execute the block for each item in the sequence; External iteration means that the code can grab the next item in the sequence “on demand”. There are many other methods on Enumerable, and I cover most of them here. For convenience, I have divided them a little arbitrarily in four areas: searching and selecting, counting and comparing, iterating, and finally extracting and converting . The purpose of inheritance, of course, is to add or enhance functionality. It’s not always necessary to use super in such a way, but it is often convenient. Every attribute and method of the point is reflected in the child. The child can have additional attributes and methods, as you have already seen. The child can override or redefine any of the attributes and methods of the parents. If we invoke a method on a subclass, the method for that class will be called if it exists. If it does not the method in the superclass will be called, and so on. When we create a new structure template by calling Struct . New we may pass a string with the class name as the first argument. If we do come a new class is created where in class Struct itself, with the name passed in as the first parameter and the attributes given as the rest of the parameters. Every time you invoke a method, you are sending a message to an object. "
    }, {
    "id": 93,
    "url": "http://localhost:4000/2021/01/22/agile.html",
    "title": "Agile web Development with Rails 6 🛤",
    "body": "2021/01/22 - This was the first Rails book I read and caught me with the real example it takes you through, you’ll be building an online shop and the author goes from installing Rails, ruby and other libraries to finally code some automations and uploading to Heroku, you can either follow the book or at the beginning of each chapter you can download the final version of the app so that you will never lose track of what is being presented, also, brings a summary after lesson and has a playtime section where you can push yourself to do a bit more of the exercises. In addition something I find very interesting in the book is that the foreword and some sections in each chapter DHH had the opportunity to share either his experience or advice regarding the current topic and he, being the creator of this framework and having built a company on top of it (Basecamp and Hey), I consider it as a nugget of information. Lastly, this is the book that has the best explanation about how Action Pack, Action Controller, Action View, Action Dispatch work together; it dedicates 1 chapter to just explain how routes get match to the controller and their actions and how are they converted into views. Very immaculate. Let’s begin with chapter 2 (1st is about installing all the stuff) The first example is to show the reader how to use the rails command, in this case the author creates a demo app with two views and one controller, after that it creates a couple of links in order to show how works, nothing fancy so far. Next chapter goes over the MVC architecture, the model is responsible for maintaining the state of the application. Is more than data; It enforces all the business rules that apply to the that data. For example, if a discount should not be applied to orders of less than $20, the model enforces the constraint. The model acts as both a gatekeeper and a data stored. That view is responsible for generating a user interface, normally based on data in the model. For example, an online store has a list of products to be displayed on a catalog screen. The list is accessible via the model, but it is a view that formats the list for the end user. Debut itself never handles incoming data. Controllers on the other side, orchestrate the application. They receive events from the outside world (normally, user input), interact with the model, and display an appropriate view to the user. The MVC architecture was originally intended for conventional GUI applications, where developers found that the separation of concerns led to far less coupling which in turn made the code easier to write and maintain. Each concept or action was expressed in a single, well known place. In a Rails application, an incoming request is first sent to a router, which works out where in the application the request should be sent and how the request should be parsed. Ultimately, these face identifies a particular method (called an action in rails parlance) somewhere in the controller code. The action might look at data in the request it might interact with the model, and it might cause other actions to be invoked. Eventually the action prepares information for the view, renders something to the user. The routing component receives the incoming request and immediately picks it apart. The request contains a path (/line_items?product_id=2) and a method (this button does a POST operation; Other commands methods are GET, PUT, PATCH and DELETE). In this case, Rails takes the first part of the path line_items as the name of the controller and the product_id as the id of the product . By convention, POST methods are associated with create actions. They create method handles user requests. In this case, it finds the current user shopping cart when parentheses which is an object managed by the model). It also asks the model to find the information for product 2. It then tells the shopping cart to add the product to itself. Object relational mapping (ORM) libraries map database tables to classes. If a database has a table called orders, our program will have a class name Order. Rows in this table correspond to objects of the class - a particular order is represented as an object of the Order class. Within that object, attributes are used to get and set the individual columns . Our order object has methods to get and set the amount, sales tax, and so on. So, and ORM layer maps tables to classes, rows to objects, and columns to attributes of those objects. Class methods are used to perform table level operations, and instance method perform operations on individual rows. Active record is the ORM layer supplied with rails. It closely follows the standard model: tables map 2 classes, roast two objects, and columns to object attributes. Action pack: the view and controller When you think about it, and controller parts of the MVC are pretty intimate. The controller supplies their data to the view and the controller receives events from the pages generated by the abuse. Because of these interactions, support for views and controllers in rails is bundled into a single component, Action pack. The view is responsible for creating all or part of the response to the displayed in a browser, to be processed by an application, or to be sent as an e-mail. At its simplest , is a chunk of HTML code that displays some fixed text. More typically, you will want to include dynamic content created by the action method in the controller. The controller in rails is the logical center of your applications. It coordinates the interaction among the user, the abuse, and the model . however, rails handles most of this interaction behind the scenes; The code you write concentrates on application level functionality . This makes rails controller code remarkably easy to develop and maintain. The controller is also home to a number of important ancillary services: • It is responsible for routing external requests to internal actions. It handles people friendly you are extremely well. • It manages catching, which can give application orders of magnitude performance boosts. • It manages helper modules, which extend the capabilities of the view templates without walking up their code. • It manages sessions, giving the users the impression of ongoing traction with our applications. Chapter 4 goes on to what is an object oriented language, will we names for local variables, methods parameters, and methods names, it provides the general rules of syntax, the kind of data types you will find in groovy like strings, array, hashes. The core of the Ruby language, which is blocks and iterators, control structures with the if statements, while loops, unless, until. Chapter 5: incremental development, use cases, page flow, data and priorities are covered. The first sketch of the shopping cart is shown, the user stories are broken down for instance: the buyer uses the web app to browse products we have to sell , select some of to purchase, and supply the information needed to create an order. On the other side the seller journey is as well described and something important is how the data is it going to be handled, how many controllers are we planning to code, the schemas are presented as well and finally the author emphasizes that all of these planning will become outdated because we must get customer feedback and most of these will change. The book pushes you to develop the web app in incremental changes called iterations. Chapter 6, it starts with the application “rails new depot” and creating the first model in this case the product , it shows you how to migrate, the addition of CSS for the forms, it explains the HTTP verbs and this is the first commit to GitHub. Next chapter added some model validations in order to ensure the user input, also, introduced the first unit test examples and explain how they work; the importance of naming self-explanatory variables, tests. Chapter 8, builds the 2nd controller in this case is a Store and it added some CSS to the index view, also, went over the layout, using partials files in order to create the navbar, and continued with the testing now including the front end (what should the &lt;H2&gt; tag title contain or how many items &lt;li&gt; should have). The following chapter creates the Cart model, line_item, by a scaffolding them, and connect the line_item model to product and to cart, becoming a joint table; another feature added here is the introduction to sessions , it explains how they work, how much they can carry on and what are they useful. Chapter 10 covers how to deploy a new migration because in the first one, something was forgotten and leveraging how you can juggle with migrations there are four decided to add a new one instead of creating everything from scratch. Some flash notice modifications took place, and a strong parameter adjustment as well, finally the CSS was at refined to the new changes. The next chapter introduced they AJAX and it explains it very well, the book contains why Ajax exist how can I change the flow of the views, then Ajax feature it’s just highlighting some data without refreshing the whole page and finally action cable is presented with the core concepts. Within the next iteration the add_order_to_line_item model is created, a new form for capturing the lines items for the order as well and linking Line items 2 one order, after each addition a test is deployed and passed. In order to make more dynamic our rails app we need to add React which is a JavaScript view library designed to quickly create dynamic user interfaces. We will use it to create a dynamic payment method details form coma and Webpacker will ensure that the configuration and set-up for all these is as simple as possible. That said, there is a bit of setup we need to do. Web Packer essentially is the decisions made by the rail steam and bundled up into a gem. React dynamically renders HTML. Unlike ERB, react does this in the browser, and it is optimized to do it fast. React re render each field of the form instead of having this server re render the entire thing. the core concept in react is components. A component is a view, backed by some sort of state. When the state changes, the rear Enders. The view can behave differently depending on the current state inside the component. Chapter 14 goes on the e-mail module of Rails and explain why sending e-mail normally is slow, why would you choose Action Mailer and then you put on top of it Active Job to offload the work. In a Rails app, when a bit of logic becomes more complex than a line or two of code, you want to move that out of the controller and put it into a model. The chapter 15, 16, 17, are about logging in, internationalization, and responding emails with rich text this is almost as straight out as you may find it in the rails guide so I won’t go deeper due to is configuration, set-up and little adjustments. The last part of the book (III) contains 6 chapters and they are under a title called “Rails in depth” I consider this very helpful if you want to go deep into the weeds and explore how is rails composed? why does rails app contain many default files? What are they for? When is correct to use a helper from there app file or from the model? Where does rail put the logs? Naming conventions? Where do you configure the environments? And many interesting methods that I didn’t know. Active record he’s also touched in this chapter and with more detail the CRUD actions are explained, also, using like classes, order, limit, using the word keyword, joins coma scopes, writing your own SQL, What are the 16 call backs Rails includes. Action Pack lies at the heart of rails applications. It consists of three Ruby modules: action dispatch, action controller and action view. Action dispatch routes request to controllers. Action controller converts requests into responses. Action view is used by action controller to format those responses. Components such as action controller, action view, and active record handled the processing of request, and the rails environments needs them together into a coherent and easy to use whole. At its most basic, a web application accepts an incoming request from my browser, process it, and sends a response. The first question that springs to mind is, how does the application know what to do with the incoming request? A shopping cart application will receive requests to display a catalog, add items to a part, create an order, and so on. How does it route these requests to the appropriate code?it turns out that Rails provides two ways to define how to route a request: a comprehensive way that you will use when you need to and a convenient way that you will generally use whenever you can. The comprehensive way lets you define a direct mapping of URLs to actions based on pattern matching, requirements and conditions. The convenient way lets you define routes based on resources, such as the models that you define. And because the convenient weight is built on the comprehensive way, you can freely mix and match the two approaches. A controller always responds to they use exactly one time per request. This means you should have just one call to a render(), redirect_to() or send() method in the processing of any request. Because the controller must respond exactly once, it checks to see whether a response has been generated just before it finishes handling a request. If not, the controller looks for a template named after the controller and action and automatically renders it. This is the most common way that rendering takes place. You may have noticed that in most of the actions north shopping cart tutorial we never explicitly rendered anything. Instead, or action methods set-up the context for the view and return. The controller notices that no rendering has taken place and automatically invokes the appropriate template. A real session is a hash-like structure that persists across request. Unlike raw cookies, sessions can hold any objects as long as those objects can be marshaled, which makes them ideal for holding state information in web applications. Rails encourages and agile, iterative style of development. We don’t expect to get everything right the first time period instead, we write tests and interact with our customer to refine our understanding as we go. For that to work, we need any supporting set of practices. We write tests to help us design our interfaces and to act as a safety net when we change things, and we use a version control to store our application source files, allowing us to undo mistakes and to monitor what changes day today. The database schema in a rails application constantly evolves as we progress through the development column we add a table here, rename a column there, and so on the database changes in step with the applications code. With rails, each of those steps is made possible through the use of migration. A migration is simply a Ruby source file in your applications and You can modify column types, renaming columns, changing columns, defining indices, renaming tables, the usage of primary keys, and even using native SQL and always you can rollback their migrations when they go bad. "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,120)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}
</script>

<style>
    .lunrsearchresult .title {color: #0f4fd9;}
    .lunrsearchresult .url {color: rgb(149, 165, 169);}
    .lunrsearchresult a {display: block; color: #4f4d4d; text-decoration: none;}
    .lunrsearchresult a:hover, .lunrsearchresult a:focus {text-decoration: none;}
    .lunrsearchresult a:hover .title {text-decoration: underline dotted;}
</style>

<form onSubmit="return lunr_search(document.getElementById('lunrsearch').value);">
  <div class="search-input-container">
    <input
      type="text"
      class="search-input"
      id="lunrsearch"
      name="q"
      maxlength="120"
      placeholder="Search"
    />
  </div>
</form>

<div class="limiter">
  <div id="lunrsearchresults">
    <ul></ul>
  </div>
</div>
  </div>
  <div class='' style='position:relative'>
    
    <div class='only-print'>
      <h2>dom lizarraga</h2>
      <div style='margin-top:0;'>dominiclizarraga@hotmail.com</div>
    </div>
    <nav class='header-wrap'>
      <div class='header nu limiter no-print'>
        <h1 style='line-height:1.6;font-size:1rem;margin:0 0 0.25em 0;'>dom lizarraga</h1>
        <ul style='list-style:none;padding:0;margin:0;'>
          <li style='margin:0.5rem 0;'><a href='/'>Notes</a>⇠</li>
          <li style='margin:0.5rem 0;'><a href='/reading/'>Reading</a></li>
          <li style='margin:0.5rem 0;'><a href='/projects/'>Projects</a></li>
          <li style='margin:0.5rem 0;'><a href='/computer-science/'>Computer <br>Science</a></li>
          <li style='margin:0.5rem 0;'><a href='/pood/'>Object-Oriented <br>Design</a></li>          <li style='margin:0.5rem 0;'><a href='/confs/'>Confs</a></li>
          <li style='margin:0.5rem 0;'><a href='/about/'>About</a></li>
        </ul>
      </div>
    </nav>
    <div class='limiter content '>
      <div class='writing nu'>

  <div><a title='#37' href='/2025/08/04/double-testing-mental-model.html'>Mental model for writing double tests</a></div>
  <time>2025-08-04</time>

  <div><a title='#36' href='/2025/06/28/good-enough-testing.html'>Good enough testing workshop | notes</a></div>
  <time>2025-06-28</time>

  <div><a title='#35' href='/2025/01/31/rails-code-guide-through.html'>Rails code guide through with Kasper Timm Hansen | notes</a></div>
  <time>2025-01-31</time>

  <div><a title='#34' href='/2024/12/15/uml-inventor.html'>UML inventor interview (Grady Booch) | notes</a></div>
  <time>2024-12-15</time>

  <div><a title='#33' href='/2024/10/12/intercom-off-script.html'>Intercom Off Script series | notes</a></div>
  <time>2024-10-12</time>

  <div><a title='#32' href='/2024/03/12/stimulus-controller-life-cycle.html'>Stimulus controller - life cycle</a></div>
  <time>2024-03-12</time>

  <div><a title='#31' href='/2024/02/17/refactoring-and-testing.html'>Refactoring and testing a long method in Ruby on Rails</a></div>
  <time>2024-02-17</time>

  <div><a title='#30' href='/2024/02/14/difference-between-buttonto-linkto-formwith.html'>What's the difference behing button_to link_to form_with</a></div>
  <time>2024-02-14</time>

  <div><a title='#29' href='/2024/02/07/follow-as-polymorphic.html'>Follow as Polymorphic</a></div>
  <time>2024-02-07</time>

  <div><a title='#28' href='/2024/01/28/beginner-guide-docker.html'>Beginner guide to Docker 🐳</a></div>
  <time>2024-01-28</time>

  <div><a title='#27' href='/2024/01/26/action-policy-cache.html'>Action policy gem + Cache</a></div>
  <time>2024-01-26</time>

  <div><a title='#26' href='/2024/01/22/when-you-see-the-count.html'>When you see the `.count` in a Rails view 👀</a></div>
  <time>2024-01-22</time>

  <div><a title='#25' href='/2024/01/18/the-where-clause.html'>Avoiding N+1 Queries 🚓</a></div>
  <time>2024-01-18</time>

  <div><a title='#24' href='/2024/01/16/cache-and-redis.html'>Key concepts for Redis and cache 💽</a></div>
  <time>2024-01-16</time>

  <div><a title='#23' href='/2024/01/14/what-is-cache.html'>What is cache? 💵 💰</a></div>
  <time>2024-01-14</time>

  <div><a title='#22' href='/2023/12/17/kasper-product-focused-ruby.html'>Product Focused Ruby - Kasper Timm Hansen.</a></div>
  <time>2023-12-17</time>

  <div><a title='#21' href='/2023/12/14/how-to-explore-a-new-codebase.html'>How to quickly deep dive into a new code base.</a></div>
  <time>2023-12-14</time>

  <div><a title='#20' href='/2023/12/12/always-have-a-question-in-mind.html'>Always have a question to solve in mind.</a></div>
  <time>2023-12-12</time>

  <div><a title='#19' href='/2023/12/06/n-+-1-queries.html'>N + 1 queries and how to fix them.</a></div>
  <time>2023-12-06</time>

  <div><a title='#18' href='/2023/12/01/debugging-libraries.html'>Debugging libraries for Ruby and Rails</a></div>
  <time>2023-12-01</time>

  <div><a title='#17' href='/2023/11/21/hotwire-codex.html'>The Rails and Hotwire Codex 🌀</a></div>
  <time>2023-11-21</time>

  <div><a title='#16' href='/2023/11/08/shape-up.html'>Shape up 🎢</a></div>
  <time>2023-11-08</time>

  <div><a title='#15' href='/2023/11/07/decompose-for-method-call.html'>Decompose for method calls</a></div>
  <time>2023-11-07</time>

  <div><a title='#14' href='/2023/11/02/positional-vs-keyword-params.html'>Positional vs Keyword arguments</a></div>
  <time>2023-11-02</time>

  <div><a title='#13' href='/2023/10/26/lastest-tips-and-tricks.html'>Latest tips & tricks | Ruby & Rails</a></div>
  <time>2023-10-26</time>

  <div><a title='#12' href='/2023/10/09/financial-wisdom-over-forks.html'>Financial Wisdom Over Forks.</a></div>
  <time>2023-10-09</time>

  <div><a title='#11' href='/2023/09/30/how-to-crack-you-next-code-challenges.html'>How to crack your next code challenge 🧮</a></div>
  <time>2023-09-30</time>

  <div><a title='#10' href='/2023/09/10/search-bar-rails.html'>Search bar in Rails 🔍</a></div>
  <time>2023-09-10</time>

  <div><a title='#9' href='/2023/08/20/chartkick-gem.html'>Chartkick gem vs chart.js</a></div>
  <time>2023-08-20</time>

  <div><a title='#8' href='/2023/08/01/llm-langchain-rb.html'>LLM Langchain.rb 🦜 | Andrei Bondarev</a></div>
  <time>2023-08-01</time>

  <div><a title='#7' href='/2023/07/24/NYU-startup-summer.html'>NYU Startup Summer program</a></div>
  <time>2023-07-24</time>

  <div><a title='#6' href='/2023/06/14/how_i_learned_rspec.html'>How I learned rpsec</a></div>
  <time>2023-06-14</time>

  <div><a title='#5' href='/2022/03/26/practicing_rails.html'>Practicing Rails | Justin Weiss</a></div>
  <time>2022-03-26</time>

  <div><a title='#4' href='/2022/03/04/testing_waterloo.html'>Rails Testing | University of Waterloo</a></div>
  <time>2022-03-04</time>

  <div><a title='#3' href='/2022/02/14/test_jason_swett.html'>The Beginner’s Guide to Rails Testing Jason Swett</a></div>
  <time>2022-02-14</time>

  <div><a title='#2' href='/2022/02/05/the_man_in_the_arena.html'>The man in the arena</a></div>
  <time>2022-02-05</time>

  <div><a title='#1' href='/2021/12/24/how_to_set_right_obj.html'>How to set the right objectives</a></div>
  <time>2021-12-24</time>

</div>

    </div>
  </div>
</body>
</html>
