<!doctype html>
<html lang=en>
<head>
  <meta charset=utf-8>
  <meta name=author content='dom lizarraga' />
  <meta name='theme-color' content='#fff' />
  <meta name='twitter:title' content="Computer Science Notes" />
  <meta name=description content="Your collection of Computer Science Notes" />
  <meta name='twitter:description' content="Your collection of Computer Science Notes" />
  <meta name='og:description' content="Your collection of Computer Science Notes" />
  
  <meta name=viewport content='width=device-width,minimum-scale=1'>
  <meta property='og:site_name' content="dominiclizarraga.github.io"/>
  <meta property='og:email' content="dominiclizarraga@hotmail.com"/>
  <meta property='og:type' content=blog />
  <meta property='twitter:account_id' content=domlizarraga_ />
  
  
  <script type='application/ld+json'>{"@context": "http://schema.org","@type": "CreativeWork","author": "dom lizarraga"}</script>
  
    <link rel=alternate type='application/rss+xml' title="dominiclizarraga.github.io" href="http://localhost:4000/rss.xml" />
    <link rel=alternate type='application/atom+xml' title="dominiclizarraga.github.io" href="http://localhost:4000/atom.xml" />
  
  <link rel=icon type=image/x-icon href=/css/favicon.png />
  <style>:root {
  --mono-font: San Francisco Mono, Monaco, "Consolas", "Lucida Console",
    "DejaVu Sans Mono", "Bitstream Vera Sans Mono", monospace;
  --sans-font: -apple-system, BlinkMacSystemFont, "avenir next", avenir,
    helvetica, "helvetica neue", ubuntu, roboto, noto, "segoe ui", arial,
    sans-serif;
}

.star {
  width: 13px;
  height: 12px;
  display: inline-block;
  background: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTMiIGhlaWdodD0iMTIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTYuMzA5IDkuMjJMMi40MDkgMTJsMS40NC00LjU2N0wwIDQuNTgzbDQuNzg4LS4wNDJMNi4zMDggMCA3LjgzIDQuNTRsNC43ODkuMDQ0LTMuODUgMi44NDlMMTAuMjA5IDEyeiIgZmlsbC1ydWxlPSJldmVub2RkIi8+PC9zdmc+");
}

body {
  color: #111;
  margin: 0px auto;
  -webkit-font-smoothing: antialiased;
  text-rendering: optimizeLegibility;
  line-height: 1.6;
  font-size: 1rem;
  font-family: var(--sans-font);
  background-color: #f8f5d5;
}

/* Print tweaks ------------------------------------------------------------- */
.only-print {
  display: none;
}

.notitle .body p:first-child {
  margin-top: 0.25rem;
}

.body img {
  width: 100%;
  max-width: 640px;
}

/* Element styles ----------------------------------------------------------- */
sup,
sub {
  vertical-align: baseline;
  position: relative;
  top: -0.4em;
}

sub {
  top: 0.4em;
}

a {
  color: #000;
  text-decoration-skip-ink: auto;
  text-decoration: underline;
}

a:visited {
  color: #333;
}

ol,
ul {
  margin: 1rem 0;
}

ul ul {
  margin: 0;
}

ol li ul {
  margin: 5px 10px;
}

iframe {
  border: 0;
}

small,
.small {
  font-size: 14px;
}

br {
  line-height: 1em;
}

h1 a {
  color: #111;
}

em {
  font-style: italic;
}

h1 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 32px;
  letter-spacing: 0.004em;
}

h2 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 1.5rem;
  letter-spacing: 0.009em;
}

h3 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 1.25rem;
  letter-spacing: 0.009em;
}

h4 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 1rem;
}

h5 {
  margin-bottom: 0.5rem;
  line-height: 1.25;
  font-weight: 600;
  font-size: 0.875rem;
}

p {
  margin: 1rem 0;
}

blockquote {
  font-size: 16px;
  line-height: 25px;
}

td {
  vertical-align: top;
}

hr {
  background: #000;
  height: 1px;
  border: 0;
}

summary {
  cursor: pointer;
}

.body table {
  border-collapse: collapse;
  border-spacing: 0;
  width: 100%;
}

.body th {
  text-align: left;
}

.body td,
.body th {
  padding: 0.5rem;
}

.body td {
  border: 1px solid #cfcfcf;
}

.limiter {
  max-width: 640px;
  padding-left: 20px;
  padding-right: 20px;
  margin-left: auto;
  margin-right: auto;
}

/* Padding --------------------------------------- */
.pad2y {
  padding-top: 20px;
  padding-bottom: 20px;
}

span.image-credit {
  float: right;
  margin: 0 0 10px 10px;
  font-size: 12px;
}

span.image-credit:before {
  content: "‚Üë";
  margin-right: 5px;
}

figcaption {
  font-size: 11px;
  text-align: center;
  font-size: 0.8rem;
  margin-top: -1.2rem;
}

div.post blockquote p {
  margin: 0;
}

/** Writing ----------------------------------------------------------------- */
.writing,
.books {
  display: grid;
  grid-column-gap: 5px;
  grid-row-gap: 5px;
}

.writing {
  grid-template-columns: 1fr min-content;
}

.books {
  grid-template-columns: 1fr 0.75fr min-content 70px;
}

.writing a,
.books a {
  font-weight: 500;
  letter-spacing: -0.015em;
}

.writing > div,
.books > div {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.writing time,
.books time {
  padding-right: 0.25em;
  color: #333;
  font-variant-numeric: tabular-nums;
  letter-spacing: -0.012em;
  white-space: pre;
}

.project-box {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-gap: 30px;
}

.project-box a.project {
  text-decoration: none;
  color: #666;
}
.project-box a.project:hover {
  color: #000;
}
.project-box a.project img {
  display: block;
  margin-bottom: 10px;
  border-radius: 0.375rem;
  height: 160px;
  object-fit: cover;
}

/** Responsive -------------------------------------------------------------- */

/* Screen width:  0px -------- 480px -------- 640px -------- 1024px -------- ‚àû */
/* max-width: 480px:  |‚Üê‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï| */
/* max-width: 640px:  |‚Üê‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï| */
/* min-width: 640px:                    |‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Üí| */
/* max-width: 1024px: |‚Üê‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï‚Äï| */

@media screen and (max-width: 480px) {
  .project-box {
    grid-template-columns: repeat(1, 1fr);
  }
}

@media screen and (max-width: 640px) {
  .limiter {
    width: auto;
  }
  .project-box {
    grid-template-columns: repeat(2, 1fr);
  }
  .writing,
  .books {
    grid-template-columns: 1fr;
    grid-row-gap: 0px;
  }

  .writing div,
  .books div {
    white-space: normal;
  }

  .writing time,
  .books div:nth-child(4n) {
    padding-bottom: 20px;
  }
}

@media screen and (min-width: 640px) {
  .nu a {
    text-decoration: none;
  }

  .nu a:hover {
    text-decoration: underline;
  }
}

@media screen and (max-width: 1024px) {
  .header-wrap {
    border-bottom: 1px solid #000;
    padding-bottom: 10px;
  }

  .sigil {
    display: none;
  }
  /* this css if for containing search result in mobile */
  #lunrsearchresults {
    width: 350px !important;
    overflow-x: hidden;
  }

  .about-image{
    margin-top: 5px;
  }

  .project-box {
    margin-top: 5px;
    margin-bottom: 20px;
  }
}

@media screen and (min-width: 1025px) {
  .header {
    position: absolute;
    /* top: 40px; */
    right: 50%;
    margin-right: 340px !important;
    letter-spacing: -0.009em;
  }
  .content h1:first-child {
    margin-top: 0;
  }
}

@media print {
  .no-print {
    display: none;
  }
  .only-print {
    display: block;
  }
  body {
    margin: 0;
  }
  .limiter {
    max-width: 100% !important;
    margin: 0 !important;
    padding: 0 !important;
  }
}

/** Code highlighting ------------------------------------------------------- */
p code,
pre code,
li code,
g.highlight,
.code {
  font-family: var(--mono-font);
}

p code {
  font-size: 90%;
}

pre code {
  font-size: 0.8rem;
  line-height: 1.5;
}

.highlight,
blockquote {
  overflow-x: auto;
  padding: 10px 20px;
  margin: 0;
  background: #fff;
  border-radius: 10px;
}

blockquote {
  font-style: italic;
}

blockquote p:first-child {
  margin-top: 0;
}

blockquote p:last-child {
  margin-bottom: 0;
}

/* pygments theme. does not support generics. .highlight class omitted */
.highlight {
  margin: 10px 0;
}

.highlight .hll {
  background-color: #ffffcc;
}

.c, /* Comment */
.cm, /* Comment.Multiline */
.cp, /* Comment.Preproc */
.cs, /* Comment.Special */
.c1 {
  color: #999988;
} /* Comment.Single */

.o, /* Operator */
.ow, /* Operator.Word */
.ge {
  color: #000000;
} /* Generic.Emph */

.kc, /* Keyword.Constant */
.kd, /* Keyword.Declaration */
.kn, /* Keyword.Namespace */
.kp, /* Keyword.Pseudo */
.kr, /* Keyword.Reserved */
.kt {
  color: #445588;
} /* Keyword.Type */

.err {
  color: #a61717;
} /* Error */

.m {
  color: #007f7f;
} /* Literal.Number */
.s {
  color: #d01040;
} /* Literal.String */

.na, /* Name.Attribute */
.nb, /* Name.Builtin */
.nc, /* Name.Class */
.no, /* Name.Constant */
.nd, /* Name.Decorator */
.ni, /* Name.Entity */
.ne, /* Name.Exception */
.nf, /* Name.Function */
.nn, /* Name.Namespace */
.nt, /* Name.Tag */
.nl {
  color: #990000;
} /* Name.Label */

.k, /* Keyword */
.nv {
  color: #008080;
} /* Name.Variable */

.mf, /* Literal.Number.Float */
.mh, /* Literal.Number.Hex */
.mi, /* Literal.Number.Integer */
.mo {
  color: #009999;
} /* Literal.Number.Oct */

.sb, /* Literal.String.Backtick */
.sc, /* Literal.String.Char */
.sd, /* Literal.String.Doc */
.s2, /* Literal.String.Double */
.se, /* Literal.String.Escape */
.sh, /* Literal.String.Heredoc */
.s1, /* Literal.String.Single */
.si, /* Literal.String.Interpol */
.ss, /* Literal.String.Symbol */
.bp, /* Name.Builtin.Pseudo */
.sx {
  color: #d01040;
} /* Literal.String.Other */

.sr, /* Literal.String.Regex */
.vc, /* Name.Variable.Class */
.vg, /* Name.Variable.Global */
.vi, /* Name.Variable.Instance */
.il {
  color: #009999;
} /* Literal.Number.Integer.Long */

/** Code for buy me a coffe mobile version ------------------------------------------------------- */

.mobile-only-button {
  margin-top: 30px;
  display: none;
}

@media screen and (max-width: 480px) {
  .mobile-only-button {
    display: flex;
    justify-content: center;
    align-items: center;
    margin-bottom: 50px;
  }
  
  /* Style for the generated iframe */
  .mobile-only-button iframe {
    margin: 0 auto;
  }
}

/** Code for styling reading time ------------------------------------------------------- */

.reading-time {
  color: #475569;
  text-align: right;
  font-style: italic;
}

/** Code for footer + RSS svg ------------------------------------------------------- */

.personal-elements-container, a[rel="nofollow"], .rss-text {
  color:rgb(71, 95, 105);
  font-style: italic;
  display: flex;
  /* align-items: center; */
  flex-direction: column;
  gap: 10px;
}

.rss-link {
  display: flex;
  align-items: flex-end;
}

/** Code for search bar ------------------------------------------------------- */

.search-bar-desktop {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
}

.search-input-container {
  max-width: 600px;
  margin-top: 10px;
  margin-right: 40px;
}

.search-input {
  border: 1px solid rgb(133, 134, 133);
  padding: 0.75rem;
  background-color: #ffffff;
  width: 100%;
  border-radius: 0.375rem;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
  transition: border-color 0.2s, box-shadow 0.2s;
  height: 10px;
  margin-left: 10px;
  font-size: 0.875rem;
}

.search-input:focus {
  border-color: #3b82f6;
  outline: none;
  box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
}

/** Code for search bar RESULTS ------------------------------------------------------- */

#lunrsearchresults {
  padding-top: 0.2rem;
  width: 100%;
}

.limiter > #lunrsearchresults {
  margin-top: 1rem;
  margin-left: -20px !important;
}

.limiter #lunrsearchresults ul {
  padding-left: 0;
  list-style: none;
}

.lunrsearchresult {
  /* padding-bottom: 1rem; */
  margin-bottom: 1rem;
}

.lunrsearchresult a:hover .title {
  text-underline-offset: 3px;
}

strong {
  margin-bottom:1rem;
  display:block;
}</style>
  <title>Computer Science Notes - dominiclizarraga.github.io</title>
  
  <link rel="canonical" href="http://localhost:4000/computer_science/">
  <script data-name="BMC-Widget" data-cfasync="false" src="https://cdnjs.buymeacoffee.com/1.0.0/widget.prod.min.js" data-id="domlizarrraga" data-description="Support me on Buy me a coffee!" data-message="" data-color="#5F7FFF" data-position="Right" data-x_margin="18" data-y_margin="18"></script>
</head>
<body>
  <div class="limiter search-bar-desktop">
    <script src="/js/lunr.js"></script>

<script>

var documents = [{
    "id": 0,
    "url": "http://localhost:4000/computer_science/beyond/2025-05-02-beyond-programming",
    "title": "This is a test for beyond programming",
    "body": "BEYOND "
    }, {
    "id": 1,
    "url": "http://localhost:4000/404",
    "title": "",
    "body": "404!"
    }, {
    "id": 2,
    "url": "http://localhost:4000/about/index.html",
    "title": "About",
    "body": "üëã Hey there! I‚Äôm Dominic a software developer proficient in Ruby on Rails, Hotwire (including Turbo + Stimulus), JS, APIs, Minitest, Capybara, Postgres, HTML, CSS(bootstrap) &amp; Tailwind. üöÄ I‚Äôm currently looking for my next adventure, my last job was with Oblsk where we worked on some amazing projects like PLT4M where I solved user stories from developing new features, creating models, involving ORM queries Sequel, testing with Mini &amp; Capy &amp; CSS responsiveness. üèÉ Then we moved to work on H4H a non-profit org that needed a solution for its marketing team so they can create content easily, here we implemented Strapi API as a headless CMS and Tailwind design (fully-responsive). ü•ä I‚Äôm currently working on a Ruby for good project called CASA where I help them to solve stakeholders tickets, I‚Äôve been doing this as a way of giving back to the community and keep learning since this project uses Rspec, bootstrap, JavaScript and bits of jQuery ‚ú®. I consider myself as very resilient and resourceful also I have learnt how to manage my emotional state and communicate efficiently and on time. üîë Here you may find my resume, LinkedIn, GitHub or if you want to drop me a line :) Tech stack  Ruby on Rails - Hotwire (Turbo &amp; Stimulus) Tailwind / Bootstrap Minitest &amp; Rspec - Capybara API‚Äôs - Agile methodologies SQL &amp; PostgreSQL AWS S3 - JavaScript HTML, CSS - GitHub - HerokuLanguages üá∫üá∏ English - Professional üá≤üáΩ Spanish - Native üá©üá™ German - Basic "
    }, {
    "id": 3,
    "url": "http://localhost:4000/confs/index.html",
    "title": "Conferences",
    "body": " Here you‚Äôll find the confs that I have attended or will be attending in the future.  Rails Saas | Oct 2022. Description pending.  Rails Conf | Apr 2023. Description pending.  Blue Ridge Ruby | Jun 2023. Description pending.  Ruby For Good | Jul 2023. Description pending.  Rails Camp | Sep 2023. Description pending.  Rails world | Oct 2023. Description pending.  Ruby Conf | Nov 2023. Description pending.  Sin City Ruby | Mar 2024. Coming soon ü§ó Rails conf | May 2024. Coming soon ü§ó Blue Ridge Ruby | May 2024. Coming soon ü§ó"
    }, {
    "id": 4,
    "url": "http://localhost:4000/",
    "title": "",
    "body": " Good enough testing workshop | notes 2025-06-28 Rails code guide through with Kasper Timm Hansen | notes 2025-01-31 UML inventor interview (Grady Booch) | notes 2024-12-15 Intercom Off Script series | notes 2024-10-12 Stimulus controller - life cycle 2024-03-12 Refactoring and testing a long method in Ruby on Rails 2024-02-17 What's the difference behing button_to link_to form_with 2024-02-14 Follow as Polymorphic 2024-02-07 Beginner guide to Docker üê≥ 2024-01-28 Action policy gem + Cache 2024-01-26 When you see the `. count` in a Rails view üëÄ 2024-01-22 Avoiding N+1 Queries üöì 2024-01-18 Key concepts for Redis and cache üíΩ 2024-01-16 What is cache? üíµ üí∞ 2024-01-14 Product Focused Ruby - Kasper Timm Hansen.  2023-12-17 How to quickly deep dive into a new code base.  2023-12-14 Always have a question to solve in mind.  2023-12-12 N + 1 queries and how to fix them.  2023-12-06 Debugging libraries for Ruby and Rails 2023-12-01 The Rails and Hotwire Codex üåÄ 2023-11-21 Shape up üé¢ 2023-11-08 Decompose for method calls 2023-11-07 Positional vs Keyword arguments 2023-11-02 Latest tips &amp; tricks | Ruby &amp; Rails 2023-10-26 Financial Wisdom Over Forks.  2023-10-09 How to crack your next code challenge üßÆ 2023-09-30 Search bar in Rails üîç 2023-09-10 Chartkick gem vs chart. js 2023-08-20 LLM Langchain. rb ü¶ú | Andrei Bondarev 2023-08-01 NYU Startup Summer program 2023-07-24 How I learned rpsec 2023-06-14 Practicing Rails | Justin Weiss 2022-03-26 Rails Testing | University of Waterloo 2022-03-04 The Beginner‚Äôs Guide to Rails Testing Jason Swett 2022-02-14 The man in the arena 2022-02-05 How to set the right objectives 2021-12-24"
    }, {
    "id": 5,
    "url": "http://localhost:4000/computer_science/",
    "title": "Computer Science Notes",
    "body": " I‚Äôve committed to gaining depth in computer science, and here are the notes I‚Äôm taking along with the lessons on csprimer. com. Categories:  Programming: Beyond the basics Computer Systems Networking Databases   Systems Test Post  2025-03-09   Networking Test Post  2025-03-08   This is a test for db  2024-05-06   UTF-8, bits, bytes and binary numbers!  2024-05-05 "
    }, {
    "id": 6,
    "url": "http://localhost:4000/computer_science/database/",
    "title": "Computer Systems Notes",
    "body": " Notes on Databases  {% for post in site. categories. database %}  {{ post. title }}  {{ post. date | date:  %Y-%m-%d  }} {% endfor %}"
    }, {
    "id": 7,
    "url": "http://localhost:4000/computer_science/beyond/",
    "title": "Computer Systems Notes",
    "body": " Notes on Beyond Programming  {% for post in site. categories. beyond %}  {{ post. title }}  {{ post. date | date:  %Y-%m-%d  }} {% endfor %}"
    }, {
    "id": 8,
    "url": "http://localhost:4000/computer_science/networking/",
    "title": "Networking Notes",
    "body": " Notes on Networking  {% for post in site. categories. networking %}  {{ post. title }}  {{ post. date | date:  %Y-%m-%d  }} {% endfor %}"
    }, {
    "id": 9,
    "url": "http://localhost:4000/computer_science/systems/",
    "title": "Computer Systems Notes",
    "body": " Notes on Computer Systems  {% for post in site. categories. systems %}  {{ post. title }}  {{ post. date | date:  %Y-%m-%d  }} {% endfor %}"
    }, {
    "id": 10,
    "url": "http://localhost:4000/projects/index.html",
    "title": "Projects",
    "body": " {% for project in page. projects %}        {{ project. name }}   {{ project. description }}   {% endfor %} "
    }, {
    "id": 11,
    "url": "http://localhost:4000/reading/index.html",
    "title": "Reading",
    "body": "{% for book in site. categories. book %}   {{ book. title }}  {{ book. author }} {{ book. date | date:  %Y-%m-%d  }}    {% endfor %}"
    }, {
    "id": 12,
    "url": "http://localhost:4000/2025/06/28/good-enough-testing.html",
    "title": "Good enough testing workshop | notes",
    "body": "2025/06/28 - Recently, I attended a workshop by Lucian Ghinda called Good Enough Testing. The workshop was a great experience, and I learned a lot about testing in Ruby on Rails. Here are my notes from the workshop:  How do you know how many tests are enough? How do you know if your tests are covering enough business logic? When do you stop testing based on risk and time? What kind of bugs are you trying to catch? what does mean to test a feature?We tend to write test on habit or gut feeling. This can be systematic. Taking into consideration the context, we choose coverage criteria (what we pay attention to), and this will drive the test design and test cases we write so we can cover what‚Äôs important with minimum effort. In other words: considering the level of risk, we define test coverage that will drive the test design so that we can achieve 100% coverage with the minimum number of test cases. Objectives of workshop:  Model the universe of all possible test cases.  Define the test coverage that is the most important in the context Identify the minimum number of test cases to achieve 100% of coverage. Do this in a systematic way. 4 test design techniques. Equivalence partitioningBounday value analysisDecision tableState transition "
    }, {
    "id": 13,
    "url": "http://localhost:4000/2025/04/11/effective-testing-with-rspec.html",
    "title": "Effective testing with RSpec",
    "body": "2025/04/11 - Recently, I participated in a very competitive interview. When I submitted the code challenge, I felt my weakest area was the testing suite. Even though feedback was not available, being honest with myself and seeing some posts from the reviewers, I decided to dive deeper into testing. I picked up books like Professional Rails Testing by Jason Swett, Hands-On Test Driven Development by Greg Donald, Effective Testing with RSpec by Myron Marston and Ian Dees and even attended a testing workshop by Lucian Ghinda. I had practiced testing before, but I felt it was time to level up and get it closer to the same standard as the rest of my code. Here are the notes, examples, and quotes that stood out to me while reading.  Installing RSpec.  From writing specs to running them.  The RSpec way.  pending.  pending. Part I ‚Äî Chapter 1. Getting Started. : Picture of the book! The forward is written by Tom Stewart author of Understanding Computation And he expresses something that picked my curiosity:  After all, the big challenge of test-driven development is not knowing how to write tests, but knowing how to listen to them. For your tests to be worth the bites they are written in, they must be able to speak to you about how well the underlying program is designed and implemented and, crucially, you must be able to hear them. The words and ideas baked into RSpec are carefully chosen to heighten your sensitivity to this kind of feedback. As you play with its expressive little pieces you will develop a test for what a good test looks like, and the occasional stumble over a test that now seems harder or uglier or way more annoying than necessary will start you on a journey of discovery that leads to a better design for that part of your code base. ‚Äù In the introduction we see different quotes like our tests are broken again! Why does the suite take so long to run? What value are we getting from this test anyway?No matter whether you are new to automated tests or helping using them for years, this book will help you write more effective tests. by effective, we mean tests that give you more value than the time spent writing them. This book you will learn RSpec in three phases: Part I: Introductory exercises to get you acquainted with respectPart II: A work example spanning several chapters, so that you can see RSpecin action on a meaningful sized projectPart III-V: A series of deep dives into specific aspects of RSpec, which will have you get the most out of RSpec RSpec and behavior driven development: RSpec bills itself as a Behavior Driven Development (BDD) test framework. I would like to take a moment to talk about our use of that term, along with the related term, Test Driven Development (TDD). With TDD, you write each test case just before implementing the next bit of behavior. When you have a well written test, you wind up with more maintainable code. you can make changes with the confidence that your test suite will let you know if you have broken something. It is about the way they enable fearless improvements to your design. BDD brings the emphasis to where it is supposed to be: your code‚Äôs behavior.  RSpec is a productive Ruby test framework. we say productive because everything about it, its style, api, libraries, and settings are designed to support you as you write great software. We have a specific definition of effective here, does this test pay for the cost of writing and running it? A good test will provide at least one of these benefits:    design guidance: helping you distill all those fantastic ideas in your head into running, maintainable code     safety net: finding errors in your code before your customers do     documentation:capturing the behavior of a working system to help it‚Äôs maintainers  As you follow along through the examples in this book, you will practice several habits that will help you test effectively: When you describe precisely what you want your program to do, you avoid being too strict ( and failing when an irrelevant detail changes) or too lax (and getting false Confidence from incomplete tests). By writing your specs to report failure at the right level of detail, you give just enough information to find the cause of the problem, without drawing in excessive output. By clearly separating essential test code from noisy setup code, you communicate what‚Äôs exactly expected of the application, and you avoid repeating unnecessary detail. When you reorder, profile, and filter your specs, you unearth order dependencies, slow tests and incomplete work. Installing RSpec. It is made of three independent ruby gems: rspec-core: is the overall test harness that runs your specs. rspec-expectations: provides a readable, powerful Syntax for checking properties of your code. rspec-mocks: makes it easy to isolate the code you are testing from the rest of the system. ‚ûú rspec-book rbenv local 3. 4. 2‚ûú rspec-book rbenv rehash‚ûú rspec-book ruby -vruby 3. 4. 2 (2025-02-15 revision d2930f8e7a) +PRISM [arm64-darwin24]‚ûú rspec-book bundle initWriting new Gemfile to /Users/dominiclizarraga/code/dominiclizarraga/rspec-book/Gemfile‚ûú rspec-book bundle add rspecFetching gem metadata from https://rubygems. org/. . . Resolving dependencies. . . Fetching gem metadata from https://rubygems. org/. Fetching diff-lcs 1. 6. 2Fetching rspec-support 3. 13. 4Installing rspec-support 3. 13. 4Installing diff-lcs 1. 6. 2Fetching rspec-core 3. 13. 4Fetching rspec-expectations 3. 13. 5Fetching rspec-mocks 3. 13. 5Installing rspec-core 3. 13. 4Installing rspec-expectations 3. 13. 5Installing rspec-mocks 3. 13. 5Fetching rspec 3. 13. 1Installing rspec 3. 13. 1Note: The book suggests to use gem install rspec however I think it‚Äôs important to remember that, that command will install the library globally to that Ruby version so if you want to avoid that and narrow the impact that this installation may have, I suggest to create its own directory and use bundle init which will create a Gemfile and then you can add rspec gem to the Gemfile or use bundle add rspec. This will set this rspec version only to this project. Let‚Äôs write our first spec üòÅ The book starts with the very simple example of building a sandwich. What‚Äôs the most important property of a sandwich? the bread? the condiments? No, the most important thing about a sandwich is that it should taste good. RSpec uses the words describe a it to express concepts in a conversational format:  ‚ÄúDescribe an ideal sandwich‚Äù ‚ÄúFirst, it is delicious‚Äù01-getting-started/01/spec/sandwich_spec. rbRSpec. describe ‚ÄúAn ideal sandwich‚Äù do it ‚Äúis delicious‚Äù do  # developers work this way with RSpec all the time; they start with an outline and fill it in as they go.  endendThen let‚Äôs add the classes and methods 01-getting-started/01/spec/sandwich_spec. rbRSpec. describe ‚ÄúAn ideal sandwich‚Äù do it ‚Äúis delicious‚Äù do  sandwich = sandwich. new(‚Äúit‚Äôs delicious‚Äù, [])  taste = sandwich. taste  expect(sandwich). to eq(‚Äúit‚Äôs delicious‚Äù) endendThis file defines your test, known in RSpec as your specs, short for a specification (because they specify the desired behavior of your code). The outer describe block creates an example group ‚Äì an example group defines what you are testing, in this case, a sandwich, and keeps related specs together. The nested block, the one beginning with it, is an example of the sandwich‚Äôs use. As you write specs, you will tend to keep each example focused on one particular size of behavior you are testing.  This first paragraphs reminds me of Jason Swett‚Äôs book on how many times he stresses to the readers that tests are a specifications not validations! I was able to count at least 8 times that he mentions that for example:A specification is a statement of how some aspect of a software product should behave. Remember that testing is about a specification, not verification.  A test suite is a structured collection of behavior specifications. Differences between tests, specs and examples: ‚Ä¢ A test validates that a bit of code is working properly. ‚Ä¢ A spec describes the desired behavior of a bit of code. ‚Ä¢ An example shows how a particular API is intended to be used. In the bits of code that we wrote we can clearly see the pattern arrange/act/assert. The last line with the expect keyword is the assertion in other test frameworks. Let‚Äôs look at the RSpec methods we‚Äôve used: ‚Ä¢ RSpec. describe creates an example group (set of related tests). ‚Ä¢ it creates an example (individual test). ‚Ä¢ expect verifies an expected outcome (assertion). Up to this point this spec serves two purposes: documenting what your sandwich should do and checking that the sandwich does what it is supposed to. (Lovely, isn‚Äôt it? ü§å) Let‚Äôs run the test and see what happens. (We‚Äôll start reading common error tests) $ ‚ûú rspec-book git:(master) ‚úó bundle exec rspec 01-getting-started/01/spec/sandwich_spec. rbFFailures: 1) An ideal sandwich is delicious   Failure/Error: sandwich = Sandwich. new( delicious , [])     NameError:    uninitialized constant Sandwich   # . /01-getting-started/01/spec/sandwich_spec. rb:8:in 'block (2 levels) in &lt;top (required)&gt;'Finished in 0. 00539 seconds (files took 0. 09368 seconds to load)1 example, 1 failureFailed examples:rspec . /01-getting-started/01/spec/sandwich_spec. rb:6 # An ideal sandwich is deliciousHere we can see that RSpec gives us a detailed report showing us the line of code where the error occurred, and the description of the problem, in this case sandwich has not been initialized. With this we are following Red/Green/Refactor development practice essential to TDD and BDD. With this workflow, you‚Äôll make sure each example catches failing or missing code before you implement the behavior you‚Äôre testing. The next step after writing a failing spec is to make it pass. # add to the top of the file `Sandwich = Struct. new(:taste, :toppings)` # more about [Structs official docs](https://rubyapi. org/3. 4/o/struct) and [Stackoverflow](https://stackoverflow. com/questions/25873672/ruby-class-vs-struct)# re-run the testsYou should see now a green dot ‚Äú. ‚Äù and 0 failures ‚ûú rspec-book git:(master) ‚úó bundle exec rspec 01-getting-started/01/spec/sandwich_spec. rb. Finished in 0. 00578 seconds (files took 0. 07271 seconds to load)1 example, 0 failuresLet‚Äôs add a second spec! Sandwich = Struct. new(:taste, :toppings)RSpec. describe  An ideal sandwich  do it  is delicious  do  # Developers work this way with RSpec all the time; they start with an outline and fill it in as they go  sandwich = Sandwich. new( delicious , [])  taste = sandwich. taste  expect(taste). to eq( delicious ) end it  lets me add toppings  do  # Developers work this way with RSpec all the time; they start with an outline and fill it in as they go  sandwich = Sandwich. new( delicious , [])  sandwich. toppings &lt;&lt;  cheese   toppings = sandwich. toppings  expect(toppings). not_to be_empty endendThis example shows 2 new features, check for falsehood (using . not_to instead of . to) and check for data structure attributes But also they are repetitive, let‚Äôs introduce 3 new RSpec features: ‚Ä¢ RSpec hooks run automatically at specific times during testing. ‚Ä¢ Helper methods are regular Ruby methods; you control when these run. ‚Ä¢ RSpec‚Äôs let construct initializes data on demand. To avoid the repetitiveness that the prior code shows, let‚Äôs start using what we described previously hooks, helper methods, let. Hooks The first thing that we will try in our test Suite is a before hook, which will run automatically before each example. (it reminds me to ActiveRecord callbacks) RSpec. describe  An ideal sandwich  do before { @sandwich = Sandwich. new( delicious , []) }  it  is delicious  do  taste = @sandwich. taste  expect(taste). to eq( delicious ) end it  lets me add toppings  do  @sandwich. toppings &lt;&lt;  cheese   toppings = @sandwich. toppings  expect(toppings). not_to be_empty endendThe setup code is shared across specs, but the individual Sandwich instance is not. Every example gets its own sandwich. That means that you can add toppings as you do in the second spec, with the confidence that the changes won‚Äôt affect other examples. RSpec keeps track of all the hooks you have registered. Each time RSpec is about to start running one of your examples, it will run any `before` hooks that apply.  `hooks` are great for running, setup code that has real-world side effects. If you need to clear out a test database before each example, a hook is a great place to do so. Here are some drawbacks from `hooks`: First, If you misspelled `@sandwich`, Ruby will silently return `nil` instead of aborting with a failure right away. The result is typically a confusing error message. Second, to refactor your specs to use instance variables, you have had to go through the entire file and replace `sandwich` with `@sandwich`. Finally, when you initialize an instance variable maybe `before hook`, you pay the cost of that setup time for all the examples in the group even if some of them never use the instance variable. That is inefficient and can be quite noticeable. Let‚Äôs try a different approach. (a more traditional Ruby approach) RSpec does a lot for us; it is easy to forget that it is just playing Ruby underneath. Each example group is a ruby class, which means that we can define methods on it. RSpec. describe  An ideal sandwich  do def sandwich  @sandwich ||= Sandwich. new( delicious , []) end it  is delicious  do  taste = sandwich. taste  expect(taste). to eq( delicious ) end it  lets me add toppings  do  sandwich. toppings &lt;&lt;  cheese   toppings = sandwich. toppings  expect(toppings). not_to be_empty endendA typical Ruby implementation might look something like the one we just wrote which uses memoization. This pattern is pretty easy to find in Ruby but it is not without its pitfalls. the ||= operator works by seeing if @sandwich is falsey, that is, false or nil, before creating a new @sandwich. That means that it won‚Äôt work if we are actually trying to store something falsey. Sharing objects with let RSpec gives us an alternative construct, let. Which handles the edge case that we previously discussed with memoization. You can think of let as assigning a name ‚Äî in this case, :sandwich ‚Äî to the result of a block. This block is lazily evaluated, meaning RSpec will only run it the first time :sandwich is accessed within an example. The result is then memoized (cached) for the remainder of that example. Our recommendation is to use these code-sharing techniques where they improve maintainability, lesson noise, and increase clarity. RSpec. describe  An ideal sandwich  do let (:sandwich) { Sandwich. new( delicious , []) } # [let official docs](https://rspec. info/features/3-13/rspec-core/helper-methods/let/) it  is delicious  do  taste = sandwich. taste  expect(taste). to eq( delicious ) end it  lets me add toppings  do  sandwich. toppings &lt;&lt;  cheese   toppings = sandwich. toppings  expect(toppings). not_to be_empty endendClaude convo about let At the end of the chapter there is a ‚ÄúYour turn‚Äù section where the author encouraged you to respond a couple of questions and for the first chapter they asked the following: Which of the three ways to reduce duplication that we have shown to you do you like the best for this example? Why? Can you think of situations where the others might be a better option? As all good engineering questions it depends as we have seen the first one which was the before hook, it is very clean, it reads good however we saw that it has some drawbacks, like it would return nil if the instance variable is misspelled and all the refactor gymnastics that it implies for refactoring just one file even when the instance variable is not used in a group example. Then the helper method has the memoization problem and finally they let alternative covers those issues. Some extra coding for solidifying let knowledge: RSpec. describe  An ideal sandwich  do let(:sandwich) { Sandwich. new( delicious , []) }  it  is delicious  do  puts  Example 1 - Sandwich object_id: #{sandwich. object_id}   # Example 1 - Sandwich object_id: 1232  taste = sandwich. taste  expect(taste). to eq( delicious ) end it  lets me add toppings  do  puts  Example 2 - Sandwich object_id: #{sandwich. object_id}   # Example 2 - Sandwich object_id: 1240  sandwich. toppings &lt;&lt;  cheese   toppings = sandwich. toppings  expect(toppings). not_to be_empty endend# within same group exampleit  uses the same object within one example  do puts  First call: #{sandwich. object_id}  # First call: 1248 sandwich. toppings &lt;&lt;  cheese   puts  Second call: #{sandwich. object_id}  # Same object! # Second call: 1248 expect(sandwich. toppings). to include( cheese ) # Cheese is still thereendA recap of Chapter 1: We explored the describe block, which is called a group of examples, and the it block, which is called an example (or a test case in some other testing frameworks). We covered the expect keyword. We also looked at the Arrange-Act-Assert pattern. We thoroughly read through test failures and what they mean. We understood that testing serves two purposes: documenting what the code should do, and checking that the code does what it‚Äôs supposed to do. We explored how to negate an expectation, and how to test collections such as arrays and hashes. Finally, we saw three different ways of reducing code in tests: hooks, Ruby helper methods, and the let construct. Part I ‚Äî Chapter 2. From writing specs to running them. : # Add the next file 01-getting-started/01/spec/coffee_spec. rbclass Coffee def ingridients  @ingridients ||= [] end def add(ingridient)  ingridients &lt;&lt; ingridient end def price  1. 00 endendRSpec. describe  A cup of coffee  do let(:coffee) { Coffee. new } it  costs $1  do  expect(coffee. price). to eq(1) end context  with milk  do  before { coffee. add :milk }  it  costs $1. 25  do   expect(coffee. price). to eq(1. 25)  end endendAnd in this chapter we explore the --format documentation ‚ûú rspec-book git:(master) bundle exec rspec 01-getting-started/01 --format documentationA cup of coffee costs $1 with milk  costs $1. 25 (FAILED - 1)An ideal sandwich is delicious lets me add toppingsFailures: 1) A cup of coffee with milk costs $1. 25   Failure/Error: expect(coffee. price). to eq(1. 25)      expected: 1. 25      got: 1. 0      (compared using ==)   # . /01-getting-started/01/spec/coffee_spec. rb:25:in 'block (3 levels) in &lt;top (required)&gt;'Finished in 0. 01762 seconds (files took 0. 08827 seconds to load)4 examples, 1 failureFailed examples:rspec . /01-getting-started/01/spec/coffee_spec. rb:24 # A cup of coffee with milk costs $1. 25Another suggestion from the book is adding the gem coderay which highlights with different colors the line that is failing. This is particularly useful when dealing with complex tests suites. bundle exec rspec 01-getting-started/01 -fd (see the expect and 1. 25) Another tool that is shown in this chapter is how to identify a slow test by adding --profile n (n is the number of offenders we‚Äôd like to see) # 01-getting-started/01/spec/slow_spec. rbRSpec. describe  The sleep() method  do it( can sleep for 0. 1 seconds ) { sleep 0. 1 } it( can sleep for 0. 2 seconds ) { sleep 0. 2 } it( can sleep for 0. 3 seconds ) { sleep 0. 3 } it( can sleep for 0. 4 seconds ) { sleep 0. 4 } it( can sleep for 0. 5 seconds ) { sleep 0. 5 }end# $ bundle exec rspec 01-getting-started/01 -fd --profile 2The sleep() method can sleep for 0. 1 seconds can sleep for 0. 2 seconds can sleep for 0. 3 seconds can sleep for 0. 4 seconds can sleep for 0. 5 secondsTop 2 slowest examples (0. 90852 seconds, 58. 8% of total time): The sleep() method can sleep for 0. 5 seconds  0. 50321 seconds . /01-getting-started/01/spec/slow_spec. rb:6 The sleep() method can sleep for 0. 4 seconds  0. 40531 seconds . /01-getting-started/01/spec/slow_spec. rb:5Finished in 1. 54 seconds (files took 0. 0894 seconds to load)5 examples, 0 failuresAlso this chapter covers how to run specific tests when you don‚Äôt need to run the whole test suite (from directories, to files to even just examples). $ rspec spec/unit/specific_spec. rb # Load just one spec file$ rspec spec/unit spec/foo_spec. rb # Or mix and match files and directoriesExample for running examples that contains word ‚Äúmilk‚Äù (searches arecase-sensitive) $ bundle exec rspec 01-getting-started/01 -e milk -fd Run options: include {full_description: /milk/}A cup of coffee with milk  costs $1. 25 (FAILED - 1)Failures: 1) A cup of coffee with milk costs $1. 25   Failure/Error: expect(coffee. price). to eq(1. 25)      expected: 1. 25      got: 1. 0      (compared using ==)   # . /01-getting-started/01/spec/coffee_spec. rb:25:in 'block (3 levels) in &lt;top (required)&gt;'Finished in 0. 0128 seconds (files took 0. 06799 seconds to load)1 example, 1 failureAnd if you need to run only one example or test case, you can pass rspec 01-getting-started/01/spec/coffee_spec. rb:25 and RSpec will run the example that starts on that line. Rerunning Everything That Failed There is one RSpec command that allows you to run just exactly the failing specs, this is pretty useful as the last command because you avoid running the whole test suite and you can fix one spec, rerun it, fix the next one and so on let‚Äôs dive in # here we can see that same error is being brought up, example: `with milk costs $1. 25`‚ûú rspec-book git:(master) ‚úó bundle exec rspec 01-getting-started/01/. F. . . . . . . Failures: 1) A cup of coffee with milk costs $1. 25   Failure/Error: expect(coffee. price). to eq(1. 25)      expected: 1. 25      got: 1. 0      (compared using ==)   # . /01-getting-started/01/spec/coffee_spec. rb:29:in 'block (3 levels) in &lt;top (required)&gt;'Finished in 1. 55 seconds (files took 0. 08332 seconds to load)9 examples, 1 failureFailed examples:rspec . /01-getting-started/01/spec/coffee_spec. rb:28 # A cup of coffee with milk costs $1. 25Then we add the command --only-failures at the end and this will ask us for a path to write the last run diagnosis, in this case we added: ‚ûú rspec-book git:(master) ‚úó bundle exec rspec 01-getting-started/01/ --only-failuresTo use `--only-failures`, you must first set `config. example_status_persistence_file_path`. # add this config lineRSpec. configure do |config| config. example_status_persistence_file_path = 'spec/examples. txt'endWhich will add a spec/examples. txt file with details as the following:       example_id   status   run_time         . /01-getting-started/01/spec/coffee_spec. rb[1:1]   passed   0. 00064 seconds       . /01-getting-started/01/spec/coffee_spec. rb[1:2:1]   failed   0. 01486 seconds       . /01-getting-started/01/spec/sandwich_spec. rb[1:1]   passed   0. 00007 seconds       . /01-getting-started/01/spec/sandwich_spec. rb[1:2]   passed   0. 00163 seconds       . /01-getting-started/01/spec/slow_spec. rb[1:1]   passed   0. 10517 seconds       . /01-getting-started/01/spec/slow_spec. rb[1:2]   passed   0. 20549 seconds       . /01-getting-started/01/spec/slow_spec. rb[1:3]   passed   0. 30431 seconds       . /01-getting-started/01/spec/slow_spec. rb[1:4]   passed   0. 40278 seconds       . /01-getting-started/01/spec/slow_spec. rb[1:5]   passed   0. 50561 seconds   Finally, when we re-run the --only-failures it will search for that ‚Äúfailed status‚Äù and run only that one! You can see it below: ‚ûú rspec-book git:(master) ‚úó bundle exec rspec 01-getting-started/01/ --only-failuresRun options: include {last_run_status:  failed } üëàFFailures: 1) A cup of coffee with milk costs $1. 25   Failure/Error: expect(coffee. price). to eq(1. 25)      expected: 1. 25      got: 1. 0      (compared using ==)   # . /01-getting-started/01/spec/coffee_spec. rb:29:in 'block (3 levels) in &lt;top (required)&gt;'Finished in 0. 01276 seconds (files took 0. 08701 seconds to load)1 example, 1 failureFailed examples:rspec . /01-getting-started/01/spec/coffee_spec. rb:28 # A cup of coffee with milk costs $1. 25The usage of command rspec ‚Äìnext-failure rspec-book git:(master) ‚úó bundle exec rspec 02-running-specs# above command created spec/tea_examples. txtexample_id             | status | run_time    |----------------------------------- | ------ | --------------- |. /02-running-specs/tea_spec. rb[1:1] | failed | 0. 0001 seconds |. /02-running-specs/tea_spec. rb[1:2] | failed | 0. 00005 seconds |02-running-specs/tea_spec. rbclass TeaendRSpec. configure do |config| config. example_status_persistence_file_path = 'spec/tea_examples. txt'endRSpec. describe  Tea  do let(:tea) { Tea. new } it  tastes like Earl Grey  do  expect(tea. flavor). to be :earl_grey end it  is hot  do  expect(tea. temperature). to be &gt; 200. 0 endend‚ûú rspec-book git:(master) ‚úó bundle exec rspec 02-running-specs      FFFailures: 1) Tea tastes like Earl Grey   Failure/Error: expect(tea. flavor). to be :earl_grey     NoMethodError:    undefined method 'flavor' for an instance of Tea   # . /02-running-specs/tea_spec. rb:11:in 'block (2 levels) in &lt;top (required)&gt;' 2) Tea is hot   Failure/Error: expect(tea. temperature). to be &gt; 200. 0     NoMethodError:    undefined method 'temperature' for an instance of Tea   # . /02-running-specs/tea_spec. rb:15:in 'block (2 levels) in &lt;top (required)&gt;'Finished in 0. 00362 seconds (files took 0. 08398 seconds to load)2 examples, 2 failuresFailed examples:rspec . /02-running-specs/tea_spec. rb:10 # Tea tastes like Earl Greyrspec . /02-running-specs/tea_spec. rb:14 # Tea is hotThen we add the option ‚Äìnext-failure and it will only run the very next failure, not the whole test suite. $ bundle exec rspec 02-running-specs --next-failureRun options: include {last_run_status:  failed }FFailures: 1) Tea tastes like Earl Grey   Failure/Error: expect(tea. flavor). to be :earl_grey     NoMethodError:    undefined method 'flavor' for an instance of Tea   # . /02-running-specs/tea_spec. rb:11:in 'block (2 levels) in &lt;top (required)&gt;'Finished in 0. 00049 seconds (files took 0. 08649 seconds to load)1 example, 1 failureFailed examples:rspec . /02-running-specs/tea_spec. rb:10 # Tea tastes like Earl GreyThis chapter focused on how specs should look and how they can be run. It began with the introduction of the context block, which is an alias for describe. However, it has a more specific and useful purpose: it‚Äôs often used for phrases that describe a particular state or condition of the object being tested. We learned about the command rspec --format documentation or --f d, which separates group examples from individual examples and adds indentation to visually show nesting‚Äîsuch as one or two levels deep. We also explored the gem called coderay, which adds color to test output, making it easier to scan for failures. Additionally, we covered the command rspec --profile 2, which helps identify the slowest-running tests. Next, we learned about the rspec --example word command, which allows us to run only the group examples or examples that match the given word. Then, we explored how to run a specific test by including the line number in the command, like so:rspec . /spec/coffee_spec. rb:25. We also discovered a very useful command: rspec --only-failures. This runs only the tests that failed in the previous run by using a file that stores the status of each example. We then looked into running tests in focused mode‚Äîallowing us to run only specific context, it, or describe blocks by tagging them. We can assign custom tags and then pass those tags when running rspec to filter the examples accordingly. Another feature we explored was how to sketch out the test suite when you have more ideas in mind than time to implement them. You can use an it block with just a description (without a body), which RSpec treats as pending. You can also mark tests as incomplete using pending, skip, or xit. Finally, we covered the --next-failure command, which runs only the next failing test from the previous run.       Command   Description         rspec ‚Äìformat documentation   Displays test output with indentation to show nesting of examples.        rspec ‚Äìprofile 2   Shows the 2 slowest-running tests to help identify performance bottlenecks.        rspec ‚Äìexample word   Runs only the examples that match the given word.        rspec . /spec/filename_spec. rb:25   Runs only the test located on line 25 of the specified file.        rspec ‚Äìonly-failures   Runs only the tests that failed in the previous run.        rspec ‚Äìnext-failure   Runs the next failing test from the last run.    Part I ‚Äî Chapter 3. The RSpec Way. : Part II ‚Äî Building an App With RSpec. : Part III ‚Äî RSpec Core. : Part IV ‚Äî RSpec Expectations. : Part V ‚Äî RSpec Mocks. : "
    }, {
    "id": 14,
    "url": "http://localhost:4000/2025/03/16/hands-on-tdd-rails.html",
    "title": "Hands-on TDD: Using Ruby, Rails, and RSpec",
    "body": "2025/03/16 - The book has a very practical approach (living up to its title ‚Äúhands-on‚Äù) where the author explains what you‚Äôre going to build, which tools and why those tools. It‚Äôs meant for beginner-intermediate developers. The content follows a linear structure which means you should read chapters from the beginning to the end, in a straightforward manner, you‚Äôll follow him along as he codes the web app as you see the red-green-refactor cycle. The outcome will be getting a better grasp of the benefits of applying Test-Driven Development (TDD), how to adopt this new mindset.  Introduction.  What is TDD?.  Getting started with Ruby. Introduction. : It was not so long ago that we did not even write tests for our software. at some points, some very smart people realize that writing tests for our software was actually a good idea. our tests will provide us with confidence that our software worked as expected and even more importantly keep us from getting phone calls in the middle of the night to fix things that would break in production. not long after we started writing tests, some other very smart people realize that writing our test first would give us an opportunity to think about what we were going to ride before we would write it. it will give us a Target to aim at, in effect. this was the birth of test driven development tdd is a style of software development where we write our test first, see that they are failing as expected, and only then do we pursue writing the code to make those tests passed. this is the central idea of my book. we will think about what we want to do, then we will capture that idea with a properly failing test. we will then write the code to make the test pass. we will then we Factor our code to make it better, or prettier, or less repetitive. we will use test driven development style of software design and engineering, which means we will write failing test first and only then write our implementation code to get our failing test passing. we will use our spec testing framework to write our test. our spec describes itself as a tool for performing behavioral driven development and as in fact the best tool available for testing will be code. The main goal of this book is to provide a practical common Hands-On introduction to test driven style of software design and engineering. many books on the topic of test driven development have been written before this one. most other books are written in a small problem sort of writing style. they cover single topics, one of the time, barely more than a reference guy. they do not cover the entire process of building software application from start to finish, using tdd. as a result, they are, in my opinion, let‚Äôs practical and much less useful for actually learning practical tdd. The author Estates the following colon I have never seen software written using tdd that was not better than software written without tdd What is Test Driven Development?: Getting started with Ruby. : "
    }, {
    "id": 15,
    "url": "http://localhost:4000/2025/03/09/systems_test_post.html",
    "title": "Systems Test Post",
    "body": "2025/03/09 - Test for systems``` "
    }, {
    "id": 16,
    "url": "http://localhost:4000/2025/03/08/networking_test_post.html",
    "title": "Networking Test Post",
    "body": "2025/03/08 - Test for networking``` "
    }, {
    "id": 17,
    "url": "http://localhost:4000/2025/02/05/professional-rails-testing.html",
    "title": "Professional Rails Testing",
    "body": "2025/02/05 - This book has two parts, the first one goes over principles of testing, the second is about the tools you can use to test your code base.  Chapter 1. Introduction.  Chapter 2. Tests as specifications.  Chapter 3. Test driven development.  Chapter 4. Writing meaningful tests.  Chapter 5. Writing understandable tests.  Chapter 6. Duplication in test code.  Chapter 7. Mocks and stubs.  Chapter 8. Flaky tests.  Chapter 9. Testing sins and crimes.  Chapter 10. Ruby DSL.  Chapter 11. Factory bot.  Chapter 12. RSpec syntax.  Chapter 13. Capybara‚Äôs DSL. Chapter 1. Introduction. : The first chapter is about what you can expect from the book, why the author chose Rspec over Minitest and the ways you can reach out to Jason Swett. Chapter 2. Tests as specifications. : The 2nd chapter aims to lay out what a test is, in this case the author rejects the idea that tests are verifications, rather they are specifications and with this definition the objective of testing goes from ‚Äúmake sure the code worked‚Äù to ‚Äúenforce the code behave as specified‚Äù. He also provides an example of a manufacturing site where all of its finished products behave the same way because they meet their design specifications due to its production system therefore it produces that same throughput always. He also shares that the main challenge is to switch developer‚Äôs mindset from verification to a specification, this will entail moving from ‚Äúcapabilities‚Äù to ‚Äúscenarios‚Äù. the next examples are going to be capabilities: the user can update their email address the user can sign in the user can reset their password on the other hand we have scenarios, for instance: when the user signs in with a valid credentials, the dashboard page will show up when the user attempts to sign in with invalid credentials and error message is shown A specification is a statement of how some aspect of a software product should behave. Again departing from the scenario point of view and we can break it down to the following: Scenario: when a user enters a valid email and password combination into the email and password fields, then clicks ‚Äòsign in‚Äô Expectation: the user dashboards page is shown. This is a style that the author has conceived and he denotes that it makes sense to him but it is not a golden rule, in other words ‚Äúunder such-and-such a scenario, we expect such-and-such behavior‚Äù The author describes with an example of a parser program the same pattern of a scenario and expectation and it goes step by step from creating the file, adding some boilerplate, starting with some comments in order to remove the writer‚Äôs block and finally he quotes the ‚Äòarrange act and assert‚Äô phases. Small recap:Scenario (what to test, we can remember this with words like ‚Äúwhen‚Äù or ‚Äúgiven‚Äù)Expectation (We can remember with the keyword ‚Äúthen‚Äù)Setup, exercise and assertion ( arrange act and assert)     Source: Medium  Chapter 3. Test driven development. : Chapter 3 is about TTD (test driven development) he briefly describes what it is, pointing out why it is often called the ‚Äòred, green, refactor loop‚Äô, what do those colors mean? and finally the importance of refactoring the code you wrote. Red: Firstly we start with deciding ‚Äúwhat to do‚Äù and then ‚Äúdoing it‚Äù (this reduces cognitive load) keeping in mind that a test is an executable and ‚Äúspecification‚Äù. We first write the test so we set out the ‚Äòspecification‚Äô and then we write the code to fulfill given a specification. Something important here is to run the test so we can clear out any false positives on the code, by running it and getting the red color we make sure that it is failing. Importance of the green color and as the author quotes ‚ÄòKent Beck‚Äô you can make any ‚Äòsins code‚Äô in order to make the code pass, this means to write crappy code but make sure that you pass from red color to green color. Also the author describes that if the whole system is covered by testing, we can refactor the system code as much as we want without too much fear that refactoring will introduce regressions. It is not an absolute warranty but it provides high degree of well justified confidence. The author also said that he focuses on writing just enough code to make the current failure message go away, maybe not passing the whole test but just a small bit of it. And finally ‚Äòrefactor‚Äô this is where all the mess is cleaned up, duplication is removed maybe some optimization is added and here the author again shares one of his personal exercises that once he have passed the testing he hold off and give himself sometime to forget about the problem because it is very embedded in his brain and the refactor is not going to be very effective, instead he takes some time and then comes back and address the exact pain Here is one statement about TDD that I liked ‚Äú the main reason for practicing TDD is to go faster and be more productive in simpler terms you want to decrease the radio of effort invested to Value produced‚Äù TTD also encourages modular, loosely coupled design, less mental effort, more enjoyable workflow, fewer bugs, documentation, feedback loops (most important I personally think!) Here is the feedback loop that TDD can create: specify an objective devise a test that can be performed to see if #1 is done perform the test device in step 2 do some work toward the objective ( wright a line of code) repeat steps three and four until the test passes repeat from step one with a new objective Some notes from the author that I think are worth is when you write a line of code it is going to help us the message failure to go away so we can avoid coding speculatively and this will help us lower the mental burden in each step of this feedback loop, Lastly the author closes this chapter by comparing the ‚Äòmanual testing‚Äò versus the TDD that as much as you practice it, you‚Äôll get more fluent and it will become a great time saver Chapter 4. Writing meaningful tests. : The author states that having tests is better than not having tests but not always writing tests are equally good tests are more valuable when they are meaningful. A test is Meaningful if it tests not just means to ends but ends themselves. When we are testing something we can focus either on means or ends, for example if we test a staple by just examining if it has all the right parts and just trying to staple 3 sheets of paper.  By making sure that it has all the right parts it doesn‚Äôt mean we are testing the ends. On the contrary, if we staple 3, then 12, 20 and we can affirm that we can continually do this activity, that‚Äôs when we test the ends. When it comes to testing model associations it would be more meaningful to make assertions on the behaviors that these associations enable. Another great example is that airplanes engines can be tested even without attaching the engines to an airplane. How to decide what kind of test drive, here we only have cost and benefits, we want to achieve satisfactory test coverage while incurring the smallest cost possible. System tests are the only type of test that proves that all the parts of your system are successfully working together without system tests. We could theoretically have a web application with a fully passing suite of unit tests even if the application is unable to successfully serve a single request. Something that I have seen has always been trivial is % of test coverage and the author suggests the following:  What if we use a minimum number of system tests, perhaps one for the happy path and one or two more for the failure cases and then use fast unit tests for all the edge cases? This way we will get a reasonable level of confidence that our system works as a whole. Then we have: how to test models (POROs), requests, background jobs, mailer specs, helper specs, view specs and view components. Also we have a very important question ‚Äúwhen to write a test and went to not‚Äù, remember that testing is not about right or wrong but about cost and benefits here are five questions:  Is the behavior likely to ever break? If the behavior were to fail, would it fail silently? if the behavior were to fail, would it fail frequently? if the behavior were to fail, would the consequence be severe? Is the test easy to write?If any of the answers to these questions is a yes, I write the test. If and only if all of the answers are negative I do skip the test. The aggregate benefit of tests. It is common to want to get some sort of 80/20 benefit by only covering the most important 20% of the codebase tests.  I think this way of thinking focuses on the benefit of individual tests while missing the aggregate benefit of tests. Remember cost and benefits of testing can be refactoring with no fear, gaining speed for development without even thinking Dusty‚Äôs part of the code base is tested well enough? In a model do we need to test every method, again remember that we covered every Behavior not every method. Chapter 5. Writing understandable tests. : I think this is the longest chapter but is the one that has more meat because it touches topics as code quality in tests, in this case ‚Äúabstraction‚Äù, (we always hear about quality code of the app itself but not in tests), it revisits the what the ‚Äòwhen‚Äô, the ‚Äògiven‚Äô, ‚Äòthen‚Äô as a structure for the test. Also how to accommodate the different files you need in the rails app, when to use helper when those are helpful, what about concerns, when is a good practice to create a model without inheriting from ActiveRecord, how to preserve ‚Äòcohesion‚Äô, also Rspec feature which is ‚Äòshared examples‚Äô, what may cause obfuscation in the tests, whether you use ‚Äòsubject‚Äô or ‚Äòlet‚Äô in our specs, plus the author gives a very useful opinion about code duplication (he shares that duplication is okay when it comes to testing). Something that I truly liked is when the author brings up that a codebase is like a story book so each file has to be seen as a chapter, where you see essential points and it remains on those essentials topics and also incidental/distracting things that may go on the footnote or appendix. Tests are more than just a safety net to catch regressions. A test suite can serve as a guidebook to a system, showing what the system‚Äôs parts are, how the parts relate to each other, which ideas are more and less important, and of course, how are the parts of the system are supposed to behave A test suite is a structured collection of behavior specifications, and can also serve as the backbone for a systems design. It is common to think of a system‚Äôs code as its essence and the tests as something secondary.  I invite you to think of it the other way around. A system‚Äôs code shows what the system does, but the system‚Äôs application code does not have the last word.  Because an application tests are specifications, whatever the test specifies is, by definition, correct. So far we have mostly focused on writing new tests and writing them. but in a production application, in addition to being written and run, tests often need to be understood and modified. Abstraction is the art of hiding distracting details and emphasizing essential information. Test code is responsible for jobs that vary widely in the relevance to the high level meaning of the test. 1 test data has to be created. 2 dependencies have to be initialized. 3 code has to be finagled into the right state. 4 assertions have to be made, etc. Here is a testing code example: Before: RSpec. describe  Creating Comment , type: :feature, js: true do let(:user) { create(:user) } let(:raw_comment) { Faker::Lorem. paragraph }let(:article) do create(:article, user_id: user. id, show_comments: true)end  before { sign_in user }  it  User replies to a comment  do  create(:comment, commentable_id: article. id, user_id: user. id)    visit article. path. to_s    find( . toggle-reply-form ). click  find(   :xpath,     ‚Äú//div[@class=‚Äôactions‚Äô]/form[@class=‚Äônew_comment‚Äô]/textarea‚Äù). set(raw_comment)  find(   :xpath,     ‚Äú//div[contains(@class, ‚Äôreply-actions‚Äô)]/input[@name=‚Äôcommit‚Äô]). click  expect(page). to have_text(raw_comment) endendThe ‚Äúit‚Äù block should describe how it (the system) should behave. To me the way this test description is written is a sign that this test is not the result of a clearly thought out specification The next step is to think about the one or the given, in this case when user submits a reply to a comment or not article ( a scenario) the body of the reply shows up on the article‚Äôs page ( expectation) After (with better description): RSpec. describe ‚ÄúCreating Comment‚Äù, type: :feature, js: true do  context  user submits a reply to a comment on an article‚Äù do  it ‚Äúshows the reply on the article‚Äôs page‚Äù do  end endendIf an abstraction does not give you the slightest clue of what it is doing without looking at its content, Then it is a pretty poor abstraction. When a test is full of distracting details, simply moving the details behind methods is not necessarily an improvement; careful thought must be given to what abstractions the methods represent and why they are helpful. RSpec. describe  Creating Comment , type: :feature, js: true do before { sign_in user } it  User replies to a comment  do  create_setup_data  submit_comment  expect_correct_comment end def create_setup_data  let(:user) { create(:user) }  let(:raw_comment) { Faker::Lorem. paragraph }  let(:article) do   create(:article, user_id: user. id, show_comments: true)  end end def submit_comment  create(:comment, commentable_id: article. id, user_id: user. id)  visit article_path. to_s  find( . toggle-reply-form ). click    find(   :xpath,    //div[@class='actions']/form[@class='new_comment']/textarea   ). set(raw_comment)    find(   :xpath,    //div[contains(@class, 'reply-actions')]/input[@name='commit']   ). click end def expect_correct_comment  expect(page). to have_text(raw_comment) endendThe author also speaks about scoping (arranging app‚Äôs files) and gives a relevant example of an appointment model ls -1 spec/modelsappointment_spec. rbinvoice_spec. rbpatient_spec. rbuser_spec. rbls -1 app/modelsappointment. rbinvoice. rbpatient. rbuser. rbThe rails g scaffold appointment command gave the developers to containers to put stuff in, one called app/models/appointment. rband another called spec/models/appointment. rb. Slowly over time, each of these containers group, a few lines of code at a time, into a monster. How do we fix this? by slicing up the model code into a smaller, more cohesive pieces for instance: The recurrence logic moved into an object called RecurrenceRule which lives in app/models/recurrence_rule. rb or even better with namespace Schedule::RecurrenceRule and lives at app/models/schedule/recurrence_rule. rb Cohesion If a code base is like a story, a file in a code base is perhaps like a chapter in a book. A well-written chapter will clearly let the reader know what the most important points are and will feature those important points most prominently. A chapter is most understandable when it principally sticks to just one topic. If a detail would pose too much of a distraction or an interruption, it gets moved to a footnote or appendix or parenthetical clause. A piece of code is cohesive if a) everything in it shares one single idea and b) it doesn‚Äôt mix into incidental details with essential points. How cohesion gets lost  Fresh new projects are usually pretty easy to work with because when you don‚Äôt have very much code, it is easier to keep your code organized and when the total amount of code is small, things have to be pretty disorganized in order for it to hurt. Things get tougher as the project grows. Entropy is the tendency for all things to decline to disorder unavoidably sets in. A common manifestation of entropy is when I developer is tasked with adding a new behavior. he or she goes looking for the object that seems like the most fitting home for that new behavior. he or she adds the new behavior, which does not perfectly fit the object where it was placed, but the code only makes the object say 5% less cohesive, the result of all these changes in aggregate is a surprisingly bad mass. How cohesion can be preserved?  The first key to maintaining cohesion in any particular piece of code is to make a clear distinction between what‚Äôs essential and what‚Äôs incidental. Let‚Äôs say that I have for example a class called Appointment. The concerns of Appointment include among other things, start time, a client and some matters related to caching. I would say that the start time and client are essential concerns of an appointment and that the caching is probably incidental. Now where to put these newly sprouted files. The rationale here is that cashing logic will only ever be relevant to a scheduling whereas an appointment might be viewed in multiple contexts, for example sometimes scheduling and sometimes billing. app/models/appointment. rbapp/models/scheduling/appointment_caching. rbHere is another example of a Customer object with certain method including one called balance.  Over time the balance calculation becomes increasingly complicated to the point that it causes Customer to lose cohesion. I can just move the guts of the balance method into a new object (a PORO) called CustomerBalance and delegate all the gory details of balance calculation to that object. Now the Customer object once again focuses on the essential points and forget about the incidental details. app/models/customer. rbapp/models/billing/customer_balance. rbIn the case that we cannot extract the incidental details of an object we can use a ‚Äòmixin‚Äô instead. I view ‚Äòmixin‚Äô as a good way to hold a bit of code which has cohesion with itself but which does not quite qualify as an abstraction and so does not make sense as an object. For me, ‚Äòmixins‚Äô usually don‚Äôt have a standalone value, and they are usually only ever ‚Äúmixed in‚Äù to one object as supposed to be reusable.  I could have said ‚Äòconcern‚Äô instead of ‚Äòmixin‚Äô, but to me it is a distinction without a meaningful difference, and concerns come along with some conceptual baggage that I don‚Äôt want to bring into the picture here. Jason believes in organizing files by meaning rather than type. Shared examples from our spec is something that at first glance seems to be a good idea however it provides obfuscation because it is difficult for the programmer to know where the values and variables come from https://rspec. info/features/3-13/rspec-core/example-groups/shared-examples/ Duplication code only for testing. Duplication is mainly bad when it passes a risk of two or more pieces of behavior getting out of sync due to a mistake, leaving one copy of the behavior correct and the other one incorrect. Since tests are not behavior, they are not always susceptible to the same kinds of duplication mistakes as application code. Test helpers on DRY That DRY principle does not apply to test code in the same way that it applies to application code, since application code is behavior whereas the test code is a specification. Helpers are not tested and they do not contain specifications. They simply help with gruntwork. online test code a helper does benefit from being DRY just like application code does. Managing setup data Most tests require some setup data, the more setup data there is, the harder it is to keep the test code understandable. It‚Äôs important for tests to be deterministic, meaning that they behave the same way every time. if a test is not deterministic, it may pass sometimes and fail sometimes, giving false negatives and causing numbness to legitimate failures. A key ingredient in making a test stick is to start with the same state every time. If a test is allowed to pollute its environment by changing for example environmental variables, configuration settings or database data, then the test that runs after it will run in a fould environment instead of a clean slate. For this reason, Rails by default runs every test inside of the database transaction, before the test finishes, the transaction gets aborted so that any data created inside the test never gets committed to the database. Every piece of data that‚Äôs in the database when test starts, we will call this data ‚Äúbackground data‚Äù, has the potential to influence how the test behaves. the less background data there is, the fewer headaches it can cause. Naming. The author lays out a test that has three values: ‚Äòuser‚Äô, ‚Äòtoken‚Äô, ‚Äòmismatch_token‚Äô.  He states that the last one is pretty clear, however after reading the whole test he suggested changing from ‚Äòtoken‚Äô to ‚Äòvalid_token‚Äô in order to make it clearer. A good rule of thumb for naming is to call things what they are.  This rule may sound obvious, but how many times have you encountered a variable method, class or database table that‚Äôs named according to something other than what it actually is? Because code is read many more times than it is written, the cost of a poor name is often many times more than the cost saved by skipping the effort of giving it a clear name. One topic per test. Some testers believe that each test should have just one assertion, others believe that this rule is hogwash, and that a test should have as many assertions as it needs. The significant thing about the test is not how many assertions it contains but rather how many topics it contains. A test with just one topic ‚Äì a test that‚Äôs only about one thing‚Äì it‚Äôs going to be easier to understand than a test that conflates multiple topics. It is common for developers to stuff several assertions into one test out of a desire for performance efficiency, especially in system specs, which are expensive to run. That I think this is usually a false economy. Yes, a performance benefit is cheap but at expense of understandably but the savings in CPU time is paid for by engineer time and we of course know which of the two is more expensive. The phases of a test Every test has four phases: set up, exercise, assertions and tear down. in Rails the tear down usually happens automatically, so we only need to think about the ‚Äòsetup‚Äô, ‚Äòexercise‚Äô and ‚Äòassertion‚Äô steps done. They are also known as a range, act, assert. Organizing your test Suite. As we saw at the beginning of this chapter, a test suite, when thought of as a structure set of behavior specifications, can serve as the backbone of a systems design. The files and folders in a test suit should be laid out in an orderly and logically fashion so that when one needs to find something, it can be found easily. Instead of organizing tests by test type, which in a sense is an incidental detail, I find it more logical to organize my test by domain concept. Each folder in a test suite can be thought of as having two dimensions: to what domain concept it belongs and to what type of test it pertains. Traditional Rspec way to order files:      | billing     | schedule    | clinical    ----------|----------------|----------------|----------------models  | models/billing | models/schedule | models/clinicalrequests | requests/billing | requests/schedule | requests/clinicalsystem  | system/billing | system/schedule | system/clinicalJason suggests the following by meaning (domain-specific) and then type:      | models     | requests    | system    ----------|---------------|----------------|---------------billing  | billing/models | billing/requests | billing/systemschedule | schedule/models | schedule/requests | schedule/systemclinical | clinical/models | clinical/requests | clinical/systemLastly, something helpful that this new approach helps is to catch regressions, when tests are organized by the main concept, the search for regressions can be conducted much more logically and efficiently. Once you get for instance spec/schedule/appointments/system/cancel _appointment. rb passing, you can then locally run all the tests in that parent folder spec/schedule/appointment. Chapter 6. Duplication in test code. : It is commonly believed that duplication is code that appears in two or more places. But this is actually mistaken. Duplication is when there is a single behavior that‚Äôs specified into or more places. Just because two identical pieces of code are present does not necessarily mean duplication exists. And just because there are no two identical pieces of code present doesn‚Äôt mean here is no duplication. Two pieces of code could happen to be identical, but if they actually serve different purposes and lead separate lives, then they do not represent the same behavior, and they do not constitute duplication. The way to tell if two pieces of code are duplicative is not to see if their code matches. The question that determines application is; ‚Äúif I changed one piece of code in order to meet any requirement, would it be logically necessary to update the other piece of code the same way?‚Äù The main reason for duplication is that it leaves a problem susceptible to developing logical inconsistencies. If a behavior is expressed in two different places in a program, and one of them accidentally does not match the other, then the deviating behavior is necessarily wrong. Another reason duplication can be bad is because it can cost an extra maintenance burden. What determines how risky duplication is 1) one how easily noticeable the duplication is2) how much extra maintenance overhead the presence of the duplication incurs,3) how much traffic that area receives( how frequently that area of code needs to be changed or understood) Noticeability If someone updates one of the code of the behavior to meet any requirement they are very likely to miss updating the other one. We might call this the proximity factor. If two pieces of duplicated behavior appear in different files in different areas of the application, then a mess is much likely to occur, and therefore the application processes a larger risk. Another quality that makes the noise ability of the application issued is similarity. If two pieces of code look very similar than the duplicity is more likely to be noticed than if the two pieces of code do not look the same (similarity factor) Maintenance overhead If a piece of duplication exists as a part of the database schema, that‚Äôs a much higher maintenance cost than a small duplication in code. Instances of duplication there are large and are not represented by identical code can also be costly to maintain because, in those cases, you cannot just type the same thing twice, you have to perform a potentially expensive translation step in your head. Traffic levelThe more frequently the code is changed, the more of a toll it is going to incur, and so the bigger problem it is. Another tollway is when a piece of code needs to be understood as a priority to understanding a different piece of code. How to decide whether to DRY up a piece of code. There are two simple options, although it is not always easy. Severity. If a piece of duplication is severe for example it has low noticeability, it posses high maintenance overhead, and has a high traffic level, then those all add weight to the argument that the duplication should be cleaned up. The quality of alternatives just because a piece of duplication costs something does not automatically mean that the duplicated version costs less. It doesn‚Äôt happen very often but sometimes ad duplication unavoidably results in code that‚Äôs so generalized that it is virtually impossible to understand. Rule of three, write everything twice. When I‚Äôm deciding whether to dry up a duplication, I asked myself: how severe is this instance of duplication? Are we able to come up with a fix that‚Äôs better than the duplicated version and not worse? Example, imagine a piece of duplication in the form of three very simple and nearly identical lines, group together in a single file, the file is a unimportant one which only gets touch a couple of times a year, and no one needs to understand that piece of code as a prerequisite to understanding anything else. Now imagine another piece of duplication. The duplication appears in only two places but the places are distant from each other and therefore the application is hard to notice. The two places where the duplicated behavior appears are expressed differently enough that the code would elude detection by a quality tool or a manual human search. The behavior is vitality central and important one and the two places the behavior appears are virtually painful to keep in sync. Duplication is cheaper than the wrong abstraction The real difference between duplication and test code and application code. Duplication, again, is when a one behavior is expressed into or more places. The difference between the test code and application code is that test code does not contain behavior. all the behaviors are in the application code. the purpose of the test code is to specify the behaviors of the application code. What is the codebase that determines whether the application code is correct? the test. If a piece of behavior is duplicated in two places in the application code and one piece of behavior gets changed, it does always logically follow that the other piece of behavior needs to get updated to match. (otherwise they will not be the instance of a duplication. ) Chapter 7. Mocks and stubs. : What is a stub? In a football scrimmage, the team doesn‚Äôt play against a real opponent because:  It‚Äôs expensive (travel, logistics, etc. ).  It could have unwanted side effects (injuries, revealing strategies, etc. ).  Instead, they simulate the opponent using their own players to control the scenario. Similarly, in testing: A stub replaces an actual method with a controlled response. It prevents expensive operations like:  Database queries.  External API calls.  Complex calculations.  It ensures the test has more controllable responses. Example: class PaymentGateway def charge(amount)  # Imagine this calls an external API (expensive!)   Charged #{amount}  endendRSpec. describe PaymentGateway do it  stubs the charge method  do  gateway = PaymentGateway. new  allow(gateway). to receive(:charge). with(100). and_return( Stubbed charge )  expect(gateway. charge(100)). to eq( Stubbed charge ) # Controlled response endendWhat is a mock? Imagine Mr. Boss pretends to be a regular customer (mock objects pretend to be real objects)He orders specific items like a hamburger, fries, and a coke (sets expected method calls). Afterward, he ‚Äúinterrogates‚Äù the experience - ‚ÄúDid you receive the hamburger you ordered?‚Äù (verifies that expected interactions occurred) If any verification fails, the test fails A mock is a fake object (like the undercover boss is a fake customer)It has predetermined responses class Waiter def take_order(order)  # Imagine this method interacts with a real kitchen system   Order placed: #{order}  endendRSpec. describe Waiter do it  verifies that the order was placed  do  waiter = Waiter. new  expect(waiter). to receive(:take_order). with( hamburger )  waiter. take_order( hamburger ) # If this isn't called, the test fails endendSummary    A stub is like using a fake team in a football scrimmage‚Äîit avoids unnecessary costs.     A mock is like an undercover boss‚Äîit checks if expected interactions happen.  ‚ÄúDo I just need to fake a response?‚Äù ‚Üí Use a stub. ‚ÄúDo I need to verify that something was called?‚Äù ‚Üí Use a mock.       Feature   Stub   Mock         Purpose   Controls return values   Verifies method calls       Tracks calls?   No   Yes       Fails test if method is not called?   No   Yes   Testing third party interactions using stubs In principle we could test third party interactions by actually hitting live services. the upside to this approach is that it provides a very realistic environment, however the downsides are: Loss of determinism, this means that our tests will potentially be non-deterministic. Determinism is the property of always behaving the same way given the same starting conditions. Tests that involve third-party services may behave one way on some runs and another way on other runs even though they‚Äôre starting conditions were the same. Limited ability to control test scenarios, when writing tests that involved third-party services, it is desirable to cover certain scenarios such as when the server returns a value response, when the service return a graceful error response, or a 500 error so creating this scenario is impossible. Side effects, using live services can also cause rate limiting, causing the test to eventually flake once requests start failing due to rate limits, and also preventing real production requests. Stubbing services. Stubbing third party services avoids the problems that come with using live services. When services are stubbed our test can be deterministic, we can control our test scenarios and we don‚Äôt have to worry about introducing side effects. What exactly is stubbing? is a practice of replacing one piece of behavior with another. Coming up with good tests A common mistake is to write tests that ‚Äúmake sure the API gets called‚Äù and to ‚Äúmake sure the right results get returned‚Äù.  Remember that testing is about a specification, not verification. The test is not to ‚Äúmake sure the code worked‚Äù but rather to specify how the code should work. Remember that the behavior we are interested in is what happens after the API (stripe, paypal) response is received. Example of code before ‚Äústubbing‚Äù require  rails_helper include APIAuthenticationHelperRSpec. describe  GitHub tokens , type: :request do Describe ‚ÄúPOST /api/v1/github_tokens‚Äù do  it  returns a token  do   post(       api_v1_github_tokens_path,        headers: api_authorization_headers   )  expect(response. body). to be( ABC123 ) endendAfter stubbing: require  rails_helper include APIAuthenticationHelperRSpec. describe  POST /api/v1/github_tokens , type: :request do it  returns a token  do  allow(GitHubToken). to receive(:generate). and_return( ABC123 ) üëà  post(   api_v1_github_tokens_path,   headers: api_authorization_headers  )  expect(response. body). to eq( ABC123 ) endendThe behavior we are mainly interested in is not how the token gets generated but in how the GitHub tokens API endpoint response to a request for a token. The line ‚Äúallow(GitHubToken)‚Äù Does not actually call the method, but instead return the hard coded value ‚ÄúABC123‚Äù. Code example for mocking class TaskProcessor def self. process  puts  Processing task. . .   endendclass BackgroundJob def perform  TaskProcessor. process endenddef start_background_job(job = BackgroundJob. new) job. performendclass MockedJob def initialize  @performed = false end def perform  TaskProcessor. process  @performed = true end def performed?  @performed endendRSpec. describe  Starting the background job with RSpec mock  do it  calls . perform on the mock job  do  job = MockedJob. new üëà  expect(job). to receive(:perform) üëà  start_background_job(job) endendChapter 8. Flaky tests. : When a boat leaks, the crew has not one problem but two. One problem is the water that‚Äôs in the boat, causing it to lose buoyancy. This problem can be mitigated by bailing out water, but it won‚Äôt solve the other problem, which is that there are holes in the boat allowing more water to leak in.       Layer   Symptom   Root cause         Secondary   Water in the boat   Holes in the boat.        Primary   Holes in the boat   Poor design? Aging?   The holes in the boat are the symptom of the primary problem. The two layers of the flaky test problem       Layer   Symptom   Root cause         Secondary   Individual flaky tests   Instances of non-determinism (race conditions, environment corruption, randomness, external dependencies in tests, fragile time dependencies)       Primary   Instances of non-determinism (race conditions, environment corruption, randomness, external dependencies in tests, fragile time dependencies)   Application complexity, poor test design.    What is a flaky test? A flaky test is a test that passes sometimes and fails sometimes even when no code has changed. Flaky test cost test runs to fail illegitimately, causing annoyance, wasted time and a numbness to legitimate failures. All flaky tests are caused by some form of non-determinism. Code that‚Äôs deterministic is code that always gives the same output for a given input. Flaky tests are caused by some form of non-determinism. Race conditions Race conditions are most likely to arise when the buffer is small. Imagine, a guy arrives at the train station with only a 1-minute buffer. If a ticket machine is slow or a gate malfunctions, he misses the train. Similarly, in software, race conditions occur when timing issues cause unpredictable failures. This gets fixed by adding an expect(page). to have_content command immediately after the command that submits in this case the form. Unlike the indifferent click_on command expect_page. to have_content will wait a bit before it gives up and allows the test Runner to continue. click_on ‚Äúsubmit‚Äùexpect(page). to have_content(‚ÄúThanks‚Äù) # to prevent race conditionsclick_on ‚ÄúHome‚ÄùYou can modify the default wait time docs Capybara. default_max_wait_time = 10 And also per-test basis Capybara. using_wait_time(10) do expec(page). to have_content(‚ÄúSuccess‚Äù)endEnvironment state corruption Imagine two tests, each of which creates a user with email_address: test@example. com the first test will pass and, if there is a unique constraint on user. email, the second test will raise an error due to unique constraint validation. Sometimes the first test will fail and sometimes the second test will fail depending on the order in which order you run them. Another way to spoil the environment is to change a configuration setting. Let‚Äôs say you have a test environment with a background job configured not to run for most tests because most background jobs are irrelevant to what‚Äôs being tested and would just slow things down. But then let‚Äôs imagine that you have one test that you do want background jobs to run, and so at the beginning of the test you set background job setting from the don‚Äôt run to run. if you don‚Äôt remember to change the setting back to don‚Äôt run at the end all background jobs will run for all later tests and potentially cause problematic behavior. External dependencies in tests. The way to prevent flaky test caused by network dependencies is to stub services rather than hitting live services Randomness By definition common non-deterministic. If you have for example a test that generates a random integer between one and two and then asserts that the number is one that is going to fail about half the time period. Fragile time dependencies in test The way around this problem is to always use absolute times in tests instead of relative ones. For instance ‚Äú2025-03-10 08:00:00‚Äù Instead of ‚Äútomorrow 12:00 p. m. ‚Äù       Problem   Prerequisite         Race conditions   Concurrency       Environment state corruption   Mutable environment state       Randomness   Randomness       External dependencies   External dependencies       Fragile time dependencies   Features that involve time   To summarize all this in a few words, complicated applications tend to have more flaky tests than simple ones. How to fix flaky tests Flaky tests are hard to fix largely because they are hard to reproduce. If a flaky test cannot be consistently reproduced then it is very hard to hypothesize about the conditions to make it fail. It is also hard to hypothesize about the case of a flaky chest if we don‚Äôt have enough background knowledge to guide our hypothesis. If we are familiar with the conditions that can lead to flaky tests, then we can come up with much more intelligent guesses than if we are clueless about how flaky tests arise. The fact that flaky tests are hard to reproduce also means that our fixed attempts are hard to validate or invalidate. Adopt an effective bug fix methodology. I find it helpful to split the bug fix process into three distinct stages:  reproduction, diagnosis and fix. When fixing a bug it is very easy to let your head get filled with a jumble of thoughts and lose track of what you‚Äôre doing. Dividing the processing to steps helps us stay focused on one activity at the time. Arm yourself with background knowledge. All about diagnosis start as guesses to get more efficient in diagnosing flaky tests, commit to five causes of flaky tests to memory. Before reproducing: determine whether it is really a flaky test. Not everything that appears to be a flaky test is actually a flaky test. Sometimes a test that appears to be flaky is just a healthy test that‚Äôs legitimately failing. Reproducing a flaky test.  My go-to method for reproducing a flaky chest is simply to re-run the test suite multiple times on my CI service until I see the flaky test fail. I like to run the test so it‚Äôs a large number of times to not only reproduce the failure but also to get a feel for how frequently the flaky test fails. Diagnosing flaky tests.  Remember that if you preferably understood all the code and tests, you would also understand the cause of the flaky test that you are trying to diagnose. All that lies between you and a diagnosis is certain amount of understanding. Applying the fix for a flaky test. Sometimes the only way to see if a flaky test is fixed with our attempt is to wait. Do not delete a test without a good reason. Remember that the important thing is not the cost benefit ratio of an individual flaky test fixed, but the cost benefit ratio of all the flaky test fixes on average. This means that fixing flaky tests creates a positive feedback loop. Chapter 9. Testing sins and crimes. : Chapter 10. Ruby DSL. : Chapter 11. Factory bot. : Chapter 12. RSpec syntax. : Chapter 13. Capybara‚Äôs DSL. : "
    }, {
    "id": 18,
    "url": "http://localhost:4000/2025/01/31/rails-code-guide-through.html",
    "title": "Rails code guide through with Kasper Timm Hansen | notes",
    "body": "2025/01/31 - Next session with Kasper (luma link) Last Friday I attended a session with Kasper where he shared with us how he usually explores Rails codebase, he‚Äôs got a lot of experience doing this therefore I applied what I learned here. I‚Äôve always been curious how callbacks and model validations work in Rails, so I decided to explore this topic.  Setting up the app Possible error with bundle First exploration with ActiveRecord lib super keyword for . valid? super keyword for . save Ruby call stack Recap with flow chart Shortcut for Ruby method lookupAlways have a question in mind that you want to answer otherwise it may be pretty easy to get lost. üí° Setting up the app: # create a new rails apprails new callbacks &amp;&amp; cd callbacks# create a new modelrails g model Post titlerails db:migrate# add the following code to the modelclass Post &lt; ApplicationRecord validates :title, presence: true, allow_nil: false before_validation :titleize_title after_create :print_out_title private  def titleize_title   return unless title. present?   self. title = title. downcase. titleize   puts  before_validation- Title changed to #{title}   end  def print_out_title   puts  after_create- Title was saved as: #{title}   endendAfter setting up a very basic app with 2 callbacks, and one validation, we can see that both callbacks are running corrrectly. ‚ûú callbacks git:(main) ‚úó rcLoading development environment (Rails 8. 0. 1)callbacks(dev)&gt; p = Post. new=&gt; #&lt;Post:0x00000001205322c8 id: nil, title: nil, created_at: nil, updated_at: nil&gt;callbacks(dev)&gt; p. valid?=&gt; falsecallbacks(dev)&gt; p. errors. full_messages=&gt; [ Title can't be blank ]callbacks(dev)&gt; p. title =  HOLA =&gt;  HOLA callbacks(dev)&gt; p. savebefore_validation- Title changed to Hola üëà TRANSACTION (0. 1ms) BEGIN immediate TRANSACTION /*application='Callbacks'*/ Post Create (10. 0ms) INSERT INTO  posts  ( title ,  created_at ,  updated_at ) VALUES ('Hola', '2025-02-03 01:09:45. 881379', '2025-02-03 01:09:45. 881379') RETURNING  id  /*application='Callbacks'*/after_create- Title was saved as: Hola üëà TRANSACTION (0. 3ms) COMMIT TRANSACTION /*application='Callbacks'*/=&gt; truePretty standard, now what does trigger ‚Äòactive_record_callbacks‚Äô? Was it after calling ‚Äú. valid?‚Äù or ‚Äú. save‚Äù? Possible error with bundle: Let‚Äôs go and open active_record library with ‚Äòbundle open activerecord‚Äô, it might throw you an error, I fixed it by typing: # in your console, it will work for one sessionEDITOR=code bundle open activerecord# or permanently set it in your . zshrc fileexport BUNDLER_EDITOR=code# close the . zshrc filesource ~/. zshrcDocs for ‚Äòbundle open‚Äô and setting your editor for opening gems ü™Ñ First exploration with ActiveRecord lib: Within lib/active_record/validations. rb:69 and after reading a bit we can see the following chain of method calls: save ‚Üí perform_validations ‚Üí valid?. Let‚Äôs add a puts statement and test it out. def valid?(context = nil) puts  you are calling 'valid?' :)  # added for testing üëà context ||= default_validation_context output = super(context) # &lt;--- calls ActiveModel::Validations#valid? (parent method) errors. empty? &amp;&amp; outputendClose the editor and ‚Äòreload!‚Äô rails console ‚ûú callbacks git:(main) reload!Loading development environment (Rails 8. 0. 1)callbacks(dev)&gt; p = Post. new=&gt; #&lt;Post:0x0000000120b394c8 id: nil, title: nil, created_at: nil, updated_at: nil&gt;callbacks(dev)&gt; p. valid?you are calling 'valid?' :) üëà=&gt; falsecallbacks(dev)&gt; p. title =  HOLA! =&gt;  HOLA! callbacks(dev)&gt; p. saveyou are calling 'valid?' :) üëàbefore_validation- Title changed to Hola! TRANSACTION (0. 1ms) BEGIN immediate TRANSACTION /*application='Callbacks'*/ Post Create (3. 0ms) INSERT INTO  posts  ( title ,  created_at ,  updated_at ) VALUES ('Hola!', '2025-02-03 01:32:16. 234929', '2025-02-03 01:32:16. 234929') RETURNING  id  /*application='Callbacks'*/after_create- Title was saved as: Hola! TRANSACTION (0. 5ms) COMMIT TRANSACTION /*application='Callbacks'*/=&gt; trueWe can conclude with this inspection that each time we call ‚Äú. save‚Äù or ‚Äúsave!‚Äù we call in the end ‚Äú. valid?‚Äù. Now, let‚Äôs explore the 2 ‚Äòsuper‚Äô keywords following the chain of methods up to its ancestor. ‚Äòsuper‚Äô keyword for . valid?: Let‚Äôs open the gem with ‚Äòbundle open activemodel‚Äô. ‚Äò. valid?‚Äô will invoke ActiveModel::Validations#valid? lib/active_model/validations. rb:361 this method will call ‚Äòrun_validations!‚Äô which is defined in lib/active_model/validations. rb:459 def valid?(context = nil) current_context = validation_context context_for_validation. context = context errors. clear run_validations! # &lt;--- calls all validation callbacks (returns true if the record is valid, false otherwise)ensure context_for_validation. context = current_contextendrun_validations! ‚Üí _run_validate_callbacks The latter comes from ActiveSupport::Callbacks, it is dynamically generated via ‚Äòdefine_callbacks‚Äô, inside of this ActiveSupport module you‚Äôll find very interesting classes as Before, After, Around, CallbackSequence, CallbackChain (where the callbacks are stored in a []) ‚Äòsuper‚Äô keyword for . save: The second ‚Äòsuper‚Äô keyword is in ‚Äò. save‚Äô and goes up to ActiveRecord::Persistence module. Just for making this more practical I have added a puts statement to lib/active_record/persistence. rb:390 def save(**options, &amp;block) create_or_update(**options, &amp;block) puts  you saved it :)  # added for testing üëàrescue ActiveRecord::RecordInvalid falseendrails console üéÆ callbacks(dev)&gt; p = Post. new=&gt; #&lt;Post:0x000000011d5b92a8 id: nil, title: nil, created_at: nil, updated_at: nil&gt;callbacks(dev)&gt; p. title =  HOLA? =&gt;  HOLA? callbacks(dev)&gt; p. valid?you are calling 'valid?' :)before_validation- Title changed to Hola?=&gt; truecallbacks(dev)&gt; p. saveyou are calling 'valid?' :)before_validation- Title changed to Hola? TRANSACTION (0. 1ms) BEGIN immediate TRANSACTION /*application='Callbacks'*/ Post Create (8. 7ms) INSERT INTO  posts  ( title ,  created_at ,  updated_at ) VALUES ('Hola?', '2025-02-03 23:16:20. 758330', '2025-02-03 23:16:20. 758330') RETURNING  id  /*application='Callbacks'*/after_create- Title was saved as: Hola?you saved it :) üëà TRANSACTION (0. 0ms) ROLLBACK TRANSACTION /*application='Callbacks'*/=&gt; nil‚Äò. save‚Äô will call ‚Äòcreate_or_update‚Äô and then depending on whether the object is new or not, it can be about an ‚Äòinsert‚Äô or ‚Äòupdate‚Äô operation. How ruby call up its ancestor objects: Something that was difficult to wrap my head around was why ‚Äòvalid?‚Äô and ‚Äòsave‚Äô point to different modules and how they get overridden? After some lookups I figured that this is because in ‚Äòlib/active_record/base. rb‚Äô we have the following: Module ActiveRecord class Base  include Persistence  include Validations  include Callbacks  . . . endendSince Validations is included after Persistence, it overrides ‚Äòsave‚Äô, adding validation checks before calling ‚Äòsuper‚Äô to go back to ‚ÄòPersistence#save‚Äô. Recap with visual aid: When we call ‚Äò. save‚Äô, Ruby follows this lookup order: First, it checks the model‚Äôs own class (Post in this case). The Post model does not define ‚Äòsave‚Äô, so Ruby looks in the included modules. If not found, it looks in Callbacks, which does not define ‚Äòsave‚Äô either. Third, it checks ‚ÄòActiveRecord::Validations#save‚Äô. Since this method exists, it runs, calling ‚Äòperform_validations‚Äô. If validation passes, it calls ‚Äòsuper‚Äô, which means ‚Äúfind the next save method in the lookup chain. ‚Äù Finally, super calls ‚ÄòActiveRecord::Persistence#save‚Äô. This method handles inserting/updating the record.    Persistence   ‚Üë   Validations   ‚Üë   Callbacks   ‚Üë   Transactions   ‚Üë   First, Ruby looks in the Post class itself Here a flow chart as recap of what we explored: Shorcut - Ruby method lookup: I got some feeback from Kasper and he suggested the following commands as alternatives, they seem to be more efficient than looking up the code in the gem. The code will tell you where the method is defined, and you can keep chaining . super_method to go up the inheritance chain. ‚ûú callbacks git:(main) rcLoading development environment (Rails 8. 0. 1)callbacks(dev)&gt; Post. instance_method(:save). super_method=&gt; #&lt;UnboundMethod: ActiveRecord::Transactions#save(**) /Users/dominiclizarraga/. rbenv/versions/3. 4. 1/lib/ruby/gems/3. 4. 0/gems/activerecord-8. 0. 1/lib/active_record/transactions. rb:361&gt;# 2 times '. super_method'callbacks(dev)&gt; Post. instance_method(:save). super_method. super_method=&gt; #&lt;UnboundMethod: ActiveRecord::Validations#save(**options) /Users/dominiclizarraga/. rbenv/versions/3. 4. 1/lib/ruby/gems/3. 4. 0/gems/activerecord-8. 0. 1/lib/active_record/validations. rb:47&gt;# 3 times '. super_method'callbacks(dev)&gt; Post. instance_method(:save). super_method. super_method. super_method=&gt; #&lt;UnboundMethod: ActiveRecord::Persistence#save(**options, &amp;block) /Users/dominiclizarraga/. rbenv/versions/3. 4. 1/lib/ruby/gems/3. 4. 0/gems/activerecord-8. 0. 1/lib/active_record/persistence. rb:390&gt;And also for seeing the module hierarchy and suplerclasses you can use the following command: Post. ancestors=&gt; [Post (call 'Post. load_schema' to load schema informations), Post::GeneratedAssociationMethods, Post::GeneratedAttributeMethods, ApplicationRecord(abstract), ApplicationRecord::GeneratedAssociationMethods, ApplicationRecord::GeneratedAttributeMethods, ActionText::Encryption, ActiveRecord::Base, Turbo::Broadcastable, ü§Ø ActionText::Attribute, ActiveStorage::Reflection::ActiveRecordExtensions, ActiveStorage::Attached::Model, GlobalID::Identification, ActiveRecord::Marshalling::Methods, . . . . . . . . . ActiveRecord::ReadonlyAttributes, ActiveRecord::Persistence, üëà ActiveSupport::Callbacks, üëà ActiveModel::Validations, üëà ActiveSupport::Dependencies::RequireDependency, Object, PP::ObjectMixin, ActiveSupport::ToJsonWithActiveSupportEncoder, ActiveSupport::Tryable, JSON::Ext::Generator::GeneratorMethods::Object, Kernel, BasicObject]"
    }, {
    "id": 19,
    "url": "http://localhost:4000/2024/12/15/uml-inventor.html",
    "title": "UML inventor interview (Grady Booch) | notes",
    "body": "2024/12/15 - Full interview UML creator defines UML as reason tool, not coding! Also invented object oriented analysis and design. IBM fellow is a distinguished role where he seeks to do improvements for the next 5-10 years, as Alan Kay said: The best way to predict the future is to invent it. He was after automating discovery patterns in legacy code way before LLM‚Äôs (didn‚Äôt continue the project). The moment you write a code it becomes ‚Äúlegacy‚Äù until you throw it away, even when it‚Äôs very small, it has a cost, has to be maintainable, tech debt, etc. ~60s IRS population increased and paperwork was too much that was not able to be done by hand so a new process of automation with Fortran came (they used to close earlier in order to reconcile accounts) that code is still running, mostly business rules plus the government still issuing more rules YOY. Complex systems started with the defense department (SAGE 50s-80s) before satellites and radars, around this time NATO was created and they aimed to fix this problem. (Golden age of software) The premise back in the day was to build monolith systems that were sustainable over time with algorithmic languages (Cobol, Fortran). The transition from monoliths to distributed systems initially with DARPA was funded by the government and having an email was pretty difficult only a thousand people had. The issue started to be more noticeable when they wanted to scale the system with algorithmic decomposition, they needed software that work in a variety of computers, multi-lingual, distributed and real time. Late 70s Smalltalk arose and the government had an issue that all their systems were using different languages so they wanted to unify them to only one, which was Ada. Ada was far ahead of its time, it used the ideas of abstract data types, which was extremely new back in the day. This new Ada wave brought the Booch method (1979) this is the 2nd golden era of software where they dealt with system distributed problems not only algorithms. Grady came up with the Booch method by reading many sources but one that caught his attention was Plato and his quote ‚Äúhow one should best see the world? As processes or as atoms‚Äù the latter was more inclined to OOP (classes and objects, behavior). (among other philosophical sources) ~1950 subroutines were considered a bad practice/controversial because doing a function call added 2 or 3 more instructions, now is seen normal, this was before the Booch method and thinking in classes and objects, now we take that for granted! The goal of UML was to look at the software from multiple points of view. Before data orientation, people who write COBOL used to print every day a document called ‚Äúcommon data‚Äù as a matter of practice not due to language so that the whole team had the abstractions on a daily basis. Grady and his partners after spending some years in defense they moved to commercial space and built ROSE which helped the teams to write UML diagrams easily, only as a design tool. The market then asked ‚Äúnow we have an arpanet and these personal computers, how do we keep building software?‚Äù and that was the time that the concept of ‚Äúuse-cases‚Äù was conceived, it was very strange to look through it back in the day. UML helped people along Microsoft VScode to drive more complex software because now they have these two that most people can use and write code depicting entities relationships responsibilities and that increase the complexity on the systems (maybe LLM will enable us to develop more complex software?) After the. com hype people realized that the companies or products that were developed we‚Äôre not economically sustainable (maybe all the microapps we currently have?) Why u m l is not longer used in modern software? Grady‚Äôs outlooks  Big companies have exposed their apis therefore there is no much architectural thinking and company keeps building on top of it Startups for instance they just built with others people money and if it fails it doesn‚Äôt matter so I don‚Äôt have formality I just want to build something Another example if I build an airplane software I want more discipline and I want more ceremony so uml is going to be part of Also if I‚Äôm building a defense software and someone may die i want formality Also if I‚Äôm going to build something that people have built in the past again and again I don‚Äôt need uml for instance the users profiles or liking a post I just prompted the LLM On the other hand if I‚Äôm going to build something that I have never seen before something really complex that‚Äôs the sweet spot for UML James Webb space telescope uses UML. Economicals on software has changed, back in the day a computer was more expensive than a human so you have to spend more time thinking about the algorithm before trying it out now that has changed and you take that for granted but the competitional resources were very scarce Regarding the role of software architect: ‚ÄúAll architecture is designed but to all design is architecture‚Äù It represents significant design decisions that shape the form and shape of the system where significant is measured by cost of change. The above paragraph reminded me of: ‚ÄúSuccessful (working) but undesigned applications carry the seeds of their own destruction; they are easy to write, but gradually become impossible to change. ‚Äù‚Äï Sandi Metz The entire history of software engineering is rising levels of abstraction, and that‚Äôs what we are currently seeing at very high level of abstraction that does not require any more the system decision which back in the day was bread and butter Now the decisions that have to be made are what cloud service I use? What message system do I use or what platform? Which are economic decisions, should I use AWS for this? A very interesting comment from Grady was that if you are a startup you‚Äôre going to hire someone who has done this before because they know the caveats of these new ‚Äúarchitectural decision‚Äù in this case let‚Äôs say AWS because this guy has work on it before and he already knows it‚Äôs limitations and how far it can go, the costs and so forth therefore they can accelerate your development because they have more expertise on this and now these are ‚Äúsystemic decisions‚Äù because they have economic impact (even on the long term) Another bite from Grady Regarding why migrations are very hard to carry out is that you aim to build economically feasible software but technology is changing out of you so you that makes you think that you need to change either a new framework or where is the background jobs for the calculations being done either on the server or the mobile for instance ‚ÄúThe code is is the truth but the code is not the whole truth‚Äù this quote again is for design decisions and sits around that you cannot just focus on what‚Äôs the best approach to this problem where is the most optimized solution for this because it involves hardware and even society, even culture. A comparable change in history like that recent AI has brought can be when software went from being developed just to one monolith across different computers like a distributed systems systems, that forced us to rethink how we design systems because now you are able to have it either on your mobile or your PC (lates 70s) By this time many changes came for instance time-sharing, whirlwind computers then mini computers (digital) with help of semiconductors. The rise of distributed systems can be like new LLMS. The perfect storm for AI was having Andrew NG discovering that the matrix multiplication that the NVIDIA GPU us were doing for more realistic game development was the ones that they need for deep learning Grady‚Äôs take on LLM: based on his vast experience on AI and now that he has 6 years researching the brain and its parts, he concludes that LLMs are unreliable narrators based on their architecture, they allow us to build scale bullshit generators, like stochastic parrots. The result is coherent though. We are not going to hit AGI by scaling. For new folks joining the market: -You will always need people to make informed decisions, tools change, it‚Äôs another level of abstraction. Find a place yourself where no one else is there and make your name there. There are plenty of spaces in the computer field, lastly have fun! Books recommendations "
    }, {
    "id": 20,
    "url": "http://localhost:4000/2024/10/12/intercom-off-script.html",
    "title": "Intercom Off Script series | notes",
    "body": "2024/10/12 - Here I wrote down some notes after watcihng the Intercom Off-script series about how they are facing the AI age and how the see it Youtube playlist Video #1  technology comes and goes,you gotta fall in love with the problem think of the core problem of your business, not the tech stack or framework work is always the same, if you want to send something you used to send it on a horse, now you use ups or fedex, want to entertain people? first it was newspaper now it‚Äôs smartphones.  the quickest to adapt, not the strongest does AI would change something in my process?It will blow up the total address of all Market because it will and I will customers or users who know what they want to do however they don‚Äôt know how to do it for instance in Excel or monday. com, salesforce who are great product very robust products but not so many people know how to use them, AI will enable them to use them at its maximum We need to rebuild our products our societies around this new technology and it is day one Video #2 Being disturbing pollution change and reshape our society because before that everything was made by hand and after that breakthrough moment we were able to have houses cars clothing Also technology is like a one-way street that once you go and cross that door you never look back before for instance once we had the iPhone in our hands we did not think about the traditional phone call or mail post What matters the most is that customers and businesses get greater experiences, it boils down to it Video #3 Attention algorithm and then wrap up with a Transformer machine learning technique Then the Transformer was trained with the huge amount of data that never before And finally it seems like it is understanding and it is capable to do some summarizing words follow some instructions An example of what AI needs was when governments increase their budget in order to roll out new highways because they saw that as much highways and streets interconnected you have the more trade Commerce and tourist activity you will get in this case AI needs more compute infrastructure and so on (Things happen fast when the value is there and apparently AI is delivering some value) Apparently it is learning because it is paying attention to the important things It‚Äôs got some limitations but you can‚Äôt work around those limitations People say that it is just a talking prediction like predicting the next word on the sentence RAG Is given the llm more context in order to make it understand the current situation therefore it will provide a more accurate answer Take a small series of tasks That you can really over-delivery on, not too broad. We have used openAI models as building blocks, Maybe five or 10 different prompts Underneath the hood, Each of them doing a specific task like search for this customer in the db, then get their last order, then disambiguate this question From an engineering perspective take five things your product should do and isolate them And get AI to do that task separately Video #4 Mother sauce and software in general seems to be very complicated and clunky because they serve a broad amount of users, It‚Äôs like cities in general they are designed for a general audience not for cyclist or pet owners or car drivers Now with AI you can have UI design that is generated on the Fly based on the user request instead of having a form where users submits email phone number number order it will go and retrieve those data from the database and make up a new form just to confirm that the information is correct and it will be completely Custom Tailor to each requested and even to each user It raises the floor for the designers, the human touch becomes more valued If you wear a drummer in the 80s and you see that a rhythm controller has come out you would thought that you are cooked but it happened all the opposite more drummers came to play their songs (democratizacion of music) So you don‚Äôt need to become a master at your craft in order to make music however there still need of people who are a master at the craft even when AI provides shortcuts Embrace the squiggle (process of designing something, converge, diverge ideas, discussions, etc) Video #5 Better, faster cheaper on online business Customer service in businesses prior the war was more personal they made individual transactions, and then as the business expanded they needed to hire more customer service in order to make it more Global more professional and then after that the 01800 phone lines came up and that was the time that the call centers started then with computers and internet the email and then the CRM too, chatbots, etc, also how customers leave feedback from the service they got and that was a time where you needed a quality customer service. Easiest decision is to cut people in order to make profit‚Ä¶So in order to increase the quality of your customer service at the internet scale is very difficult Video #6 Big boys and small are no longer selling software seats to humans, but software doing the work. We don‚Äôt pay for CS, we pay what‚Äôs in the receipt, and CS is all around. Having a internet business bring the benefits of scales which is selling around the clock, around the globe Heretofore (before now, new word) Agents gen1 (conversation, text boxes) and gen 2 (more familiar, proactive and take action) Cannibalize themselves if they want to survive and Netflix did with their shipping DVD business before streaming. "
    }, {
    "id": 21,
    "url": "http://localhost:4000/2024/05/06/this-is-a-test-2.html",
    "title": "This is a test for db",
    "body": "2024/05/06 - Test 2 "
    }, {
    "id": 22,
    "url": "http://localhost:4000/2024/05/05/utf-8-bits-bytes-binary.html",
    "title": "UTF-8, bits, bytes and binary numbers!",
    "body": "2024/05/05 - Test 1 "
    }, {
    "id": 23,
    "url": "http://localhost:4000/2024/03/12/stimulus-controller-life-cycle.html",
    "title": "Stimulus controller - life cycle",
    "body": "2024/03/12 - "
    }, {
    "id": 24,
    "url": "http://localhost:4000/2024/02/17/refactoring-and-testing.html",
    "title": "Refactoring and testing a long method in Ruby on Rails",
    "body": "2024/02/17 - Recently, we had the opportunity to refactor a lengthy method in a Ruby on Rails project. The method had multiple conditional statements (around 6) that checked various aspects of a project, such as whether it was discarded, on time, accepting entries, and more. Refactoring this method required careful planning and testing to ensure that the functionality remained intact while improving the code‚Äôs maintainability and readability. Before diving into the refactoring process, we first focused on writing tests that covered all the edge and corner cases. To do this, we wrote tests that checked the opposite of what the method was currently doing. For each conditional statement, we created a test that verified the expected behavior when the condition was met and when it was not. Here‚Äôs an example of how we tested a condition that checked if a project was able to receive entries using FactoryBot: # In the test filedescribe 'Project entries' do it 'should not accept entries when the project is not set to receive entries' do  project = FactoryBot. create(:project, receive_entries: false)  # Assert that the project does not accept entries  expect(project. accept_entries?). to be_falsey end it 'should accept entries when the project is set to receive entries' do  project = FactoryBot. create(:project, receive_entries: true)  # Assert that the project accepts entries  expect(project. accept_entries?). to be_truthy endendBy writing tests for both scenarios (project accepting entries and not accepting entries), we ensured that the refactored method would handle these cases correctly. Once we had a comprehensive test suite in place and all the tests were passing, we started the refactoring process. It‚Äôs important to remember that refactoring aims to modify the internal structure of the code without changing its external behavior. The goal is to improve performance, maintainability, and readability while adhering to the DRY (Don‚Äôt Repeat Yourself) principle. During the refactoring, we focused on breaking down the long method into smaller, more manageable chunks. we extracted common functionality into separate methods and aimed to reduce the complexity of the conditional statements. Here‚Äôs a simplified example of how the refactored method might look: def process_project(project) return if project. discarded? return unless project. on_time? return unless project. accept_entries? # Process the project # . . . endBy separating the conditions into individual guard clauses, the method becomes more readable and easier to understand. Throughout the refactoring process, we continuously ran the tests to ensure that the functionality remained intact and that we didn‚Äôt introduce any unintended changes. Refactoring a long method can be a challenging task, especially for beginners. However, by following a systematic approach of writing comprehensive tests, breaking down the method into smaller parts, and focusing on improving maintainability and readability, you can successfully refactor your code and make it more manageable for future changes. Remember üéóÔ∏è, refactoring is an iterative process, and it‚Äôs okay to take small steps and gradually improve your code over time. By consistently applying good coding practices and seeking feedback from more experienced developers, you can continuously enhance your refactoring skills and write cleaner, more maintainable code.  Breaking down the method into smaller, more manageable pieces.  Applying the DRY (Don‚Äôt Repeat Yourself) principle to eliminate redundancy.  Enhancing performance and maintainability to ensure the code could be easily modified in the future. "
    }, {
    "id": 25,
    "url": "http://localhost:4000/2024/02/14/difference-between-buttonto-linkto-formwith.html",
    "title": "What's the difference behing button_to link_to form_with",
    "body": "2024/02/14 - In this blog post I‚Äôll share my findings when developing a Like model and how I got to find these differences very particular. remote: true "
    }, {
    "id": 26,
    "url": "http://localhost:4000/2024/02/07/follow-as-polymorphic.html",
    "title": "Follow as Polymorphic",
    "body": "2024/02/07 - In this blog post I‚Äôll share my findings when developing a Follow model (User can follow another User, Post, Comapny) with a polymorphic property. With the next models you can create a ‚ÄòFollowing‚Äô feature that can be applied to almost any model you want, just add one line of code. class User &lt; ApplicationRecord # Users that follow this user 'Followers' has_many :followers, class_name: 'Follow', as: :followable # Entities this user follows 'Following' has_many :following, class_name: 'Follow', foreign_key: 'user_id'endclass Follow &lt; ApplicationRecord belongs_to :user # who is making/pushing the button  Follow  (doing the following) belongs_to :followable, polymorphic: true # This validation doesn't allow that user_1 follow user_2 twice validates :user_id, uniqueness: { scope: [:followable_type, :followable_id] }endLet‚Äôs try out the code in rails console rails consoleu1 = User. firstu2 = User. lastfollow = u1. following. create(followable: u2)Follow Create (3. 8ms) INSERT INTO  follows  ( user_id ,  followable_type ,  followable_id ,  created_at ,  updated_at ) VALUES ($1, $2, $3, $4, $5) RETURNING  id  [[ user_id , 1], [ followable_type ,  User ], [ followable_id , 18], [ created_at ,  2024-02-29 05:25:28. 228037 ], [ updated_at ,  2024-02-29 05:25:28. 228037 ]] TRANSACTION (0. 6ms) COMMIT=&gt; #&lt;Follow:0x0000000102d226e0 id: 6, user_id: 1, followable_type:  User , followable_id: 18, created_at: Thu, 29 Feb 2024 05:25:28. 228037000 UTC +00:00, updated_at: Thu, 29 Feb 2024 05:25:28. 228037000 UTC +00:00&gt;Follow. count=&gt; 1u1. following. create(followable: u2)=&gt; TRANSACTION (0. 8ms) ROLLBACK (due to model validation)# class User# def follows?(user)#  following. exists?(followable: user)# endu1. follows? u2=&gt; trueu2. followers=&gt; [#&lt;Follow:0x000000012eb126d0 id: 6, user_id: 1, followable_type:  User , followable_id: 18, created_at: Thu, 29 Feb 2024 05:12:17. 215129000 UTC +00:00, updated_at: Thu, 29 Feb 2024 05:12:17. 215129000 UTC +00:00&gt;]u1. following[#&lt;Follow:0x0000000102b63fc0 id: 6, user_id: 1, followable_type:  User , followable_id: 18, created_at: Thu, 29 Feb 2024 05:12:17. 215129000 UTC +00:00, updated_at: Thu, 29 Feb 2024 05:12:17. 215129000 UTC +00:00&gt;, #&lt;Follow:0x0000000102d226e0 . . . ]And it worked for other models like (Post, Company, etc) class Post &lt; ApplicationRecord has_many :followers, class_name: 'Follow', as: :followableenduser = User. find(user_id)post = Post. find(post_id)user. following. create(followable: post) TRANSACTION (0. 6ms) COMMIT=&gt; #&lt;Follow:0x0000000150038080 id: 8, user_id: 1, followable_type:  Post , followable_id: 92, created_at: Thu, 29 Feb 2024 05:56:29. 921783000 UTC +00:00, updated_at: Thu, 29 Feb 2024 05:56:29. 921783000 UTC +00:00&gt;We‚Äôve explored creating a follower system in Rails, showcasing the flexibility of polymorphic associations and the importance of validations. This guide provides a solid foundation for adding social functionalities to your Rails applications, ensuring a robust and scalable feature set. "
    }, {
    "id": 27,
    "url": "http://localhost:4000/2024/01/28/beginner-guide-docker.html",
    "title": "Beginner guide to Docker üê≥",
    "body": "2024/01/28 - This is a guide to explore what is Docker and also when it‚Äôs useful. "
    }, {
    "id": 28,
    "url": "http://localhost:4000/2024/01/26/action-policy-cache.html",
    "title": "Action policy gem + Cache",
    "body": "2024/01/26 - Recently I worked with an app that was using Action Policy, I noticed that those policies were being called almost everywhere! So I started a small research and found that there was a section for cache authorizations. Let‚Äôs dive in with Redis and how policies are saved in memory. Here are the official (docs)[https://actionpolicy. evilmartians. io/#/caching] for combinig action policy + cache. "
    }, {
    "id": 29,
    "url": "http://localhost:4000/2024/01/22/when-you-see-the-count.html",
    "title": "When you see the `.count` in a Rails view üëÄ",
    "body": "2024/01/22 - I‚Äôve been working on improving the app performance and have learnt about how. count works and how it can slow down the app. As a solution we have counter_cacheprovided by default by rails and also something more advance like counter_culturegem! Let‚Äôs see how it can improve you app as well! "
    }, {
    "id": 30,
    "url": "http://localhost:4000/2024/01/18/the-where-clause.html",
    "title": "Avoiding N+1 Queries üöì",
    "body": "2024/01/18 - When optimizing an app, I recently learned to pay attention to the . where or . find methods inside . each loops because they can be potential candidates for association preloading. The reason is that for each element we iterate over, another operation will be executed, in this case . where or . find, which can lead to an N+1 query problem. Let‚Äôs see how it works. # Controller actiondef index @posts = Post. allend# View template&lt;% @posts. each do |post| %&gt; &lt;h2&gt;&lt;%= post. title %&gt;&lt;/h2&gt; # This will trigger separate query for each post to fetch the author &lt;p&gt;Author: &lt;%= post. author. name %&gt;&lt;/p&gt; # This will trigger separate query for each post to fetch the comments &lt;p&gt;Comments: &lt;%= post. comments. count %&gt;&lt;/p&gt;&lt;% end %&gt;SQL produced: -- 1 for Post. allSELECT  posts . * FROM  posts -- 2 for each post's author and comments count, this can get really worseSELECT  authors . * FROM  authors  WHERE  authors .  id  = ? LIMIT 1 [[ id , 1]]SELECT COUNT(*) FROM  comments  WHERE  comments .  post_id  = ? [[ post_id , 1]]To avoid this we can use . includes # Controller actiondef index # we eagerly load the author and comments for all the posts in a single query @posts = Post. includes(:author, :comments). allend# View template&lt;% @posts. each do |post| %&gt; &lt;h2&gt;&lt;%= post. title %&gt;&lt;/h2&gt; &lt;p&gt;Author: &lt;%= post. author. name %&gt;&lt;/p&gt; &lt;p&gt;Comments: &lt;%= post. comments. count %&gt;&lt;/p&gt;&lt;% end %&gt;SQL produced: -- 1 for Post. includes(:author, :comments), which eagerly loads the associated author and comments-- The number of queries is reduced to 3 (1 for posts, 1 for authors, 1 for comments), regardless of the number of posts. SELECT  posts . * FROM  posts SELECT  authors . * FROM  authors  WHERE  authors .  id  IN (1, 2, 3)SELECT  comments . * FROM  comments  WHERE  comments .  post_id  IN (1, 2, 3)Another alternative is to use . eager_load instead of . includes. The difference is that . includes uses separate queries to load the associations, while . eager_load uses a single query with a LEFT_OUTER_JOIN. Here I have a deeper blog about it! Just wanted to highlight that you must be careful of those where, find and find_by inside of loops! "
    }, {
    "id": 31,
    "url": "http://localhost:4000/2024/01/16/cache-and-redis.html",
    "title": "Key concepts for Redis and cache üíΩ",
    "body": "2024/01/16 - Expire Bust Cache hit Cache miss user. touch Setting up redis in production since developers want a slower app in development rails dev:cache type of redies: volatile (cache data that can be retrieve at some point again) or non-volatile (sidekiq because it cannot be recreated since we loose the jobs that are queued) "
    }, {
    "id": 32,
    "url": "http://localhost:4000/2024/01/14/what-is-cache.html",
    "title": "What is cache? üíµ üí∞",
    "body": "2024/01/14 - Currently, I‚Äôm focusing on enhancing the performance of an application, and one of the key areas I‚Äôve explored in-depth is caching. Although I was aware of caching before, I didn‚Äôt fully grasp its concept or have the opportunity to apply it, so I never felt compelled to delve into it. If you find yourself in a similar position, here are some initial steps to build a strong understanding of caching :) What is cache? The term ‚Äòcache‚Äô is an English word meaning a secure place where items are stored and hidden. Now this concept will make more sense in computing. Cache is a method of storing frequently accessed data in fast memory to keep it closer to the user. This fast memory can be found either on hard drives, processors (like CPUs and GPUs) or web browser, web server, databases, client-side, CDNs and it goes from KBs to MBs and in different layers (L1, L2, etc). In browser for example, the first time you visit a web site it will download the HTML, CSS and images then computer will save a copy of those files. The next time you visit that page, it will retrieve a local copy instead of requesting a web server, which speeds up the process. Think of a coffee shop where the barista keeps commonly used items like milk and sugar at hand, rather than going to the storage room for each order. This is like 'caching', where frequently used data is kept readily accessible. ‚òïÔ∏è Fun fact: The concept of caching was originally proposed in 1965 by Maurice Wilkes. Paper When is it useful? There are 2 main ways so far to implement with Ruby on Rails app.    HTTP Caching - Web browser can cache HTTP responses to enable faster retrieval data. It improves response time and reduce load on back-end. By storing copies of frequently accessed data, caching reduces the need for repeated requests to the server, thereby enhancing overall performance and user experience. (Mostly for Static assets and JSON APIs and AJAX endpoints. )     This involves caching within the application itself and can be tailored to the specific needs of your Rails application. Rails provides several caching techniques like page caching, action caching, and fragment caching.  How to use it in rails? Rails has 3 ways of caching data: page, action and fragment. Each of them has different purposes.    Page caching stores the entire HTML response, serving it directly from the web server without hitting the Rails stack.     Action caching caches the output of controller actions.     Fragment caching is more granular and caches smaller pieces of a view.  Also there are different techniques as well like Russian Doll Caching, Shared partial caching, Low-Level Caching and Key-based cache expiration. Extra tools you need. üõ†Ô∏è Rails caching is designed to be backend agnostic. This means you can implement custom caching solutions or adapters for other storage mechanisms. Redis: Advanced in-memory data store, supports complex structures, ensures data persistence, replication, and integrity. Memcached: Efficient, simple key-value store, ideal for caching static data, quick setup. Memory Store: Caches data in the Rails server‚Äôs memory. This is a good option for single-server setups and development environments. File Store: Caches data as files on the disk. This can be useful in environments where memory is limited. Is it truly beneficial for your App? Currently in the implementation phase, the improvements are evident on the pages where it has been applied. It is advisable to compare response times before and after implementing these changes. If feasible, establish a Maximum Average Response Time (MART) as a benchmark. More when we complete this process! "
    }, {
    "id": 33,
    "url": "http://localhost:4000/2023/12/17/kasper-product-focused-ruby.html",
    "title": "Product Focused Ruby - Kasper Timm Hansen.",
    "body": "2023/12/17 - Sketching and mental model of programming. I recently attended a live session with Kasper Timm Hansen, he unfolded his approach to product-focused development, blending technical prowess with real-world problem solving. 1st session notes: How to start sketching out a new feature development. 1. - Have a problem definition. 2. - In a rails context, start with a controller and start figuring out how to pass stuff to the view (it will give you a lot of constraints already). 3. - Then sketch stuff out like write methods that reflect ‚Äúcomplete‚Äù and ‚Äúuncomplete‚Äù (for a Todo app and task feature), don‚Äôt focus on assigning instance variables, inheritance of the controller (you save this for later). 4. - At this point we have how routes are going to be. What are going to be the ‚Äúresources‚Äù are they going to be nested? We have figured out the organizational stuff around things. So now we know how to put into business logic and complete it. 5. - Take a break from it like an outside view of like, okay, can I name this differently because. So far, it's just more meant to have a direct communication with what I intend to code and my own mental model rather than the code that I'm ending up generating. If the problem definition has a known unknown that would be one thing to start tackling, or it can help reveal unknown unknowns. And and then figure out, if it's something involved with like TCP connections, and we haven't worked with those before. Use method you know how they work to keep sketching things out (inheritance from ApplicationController or RESTful methods). 6. - Delineate between what‚Äôs the feature, and what‚Äôs the architecture? User model would be architecture and User and its Invite (User::Invite) would be the feature. This prorcess should be really flexible, really fluid, like having a conversation and not to be attached to the code you've written. Also play around with `irb`, read the Ruby docs and seek. Making abstractions by finding concepts through ‚Äònaming‚Äô. 1. - Now that you have a sense of the concept and know how things fit together. 2. - You can build solid blocks of knowledge that you can later use. In example, how a AssociationObject works and you find more similar cases in the rest of the app. 2nd session notes (more hands-on): 1. - At the very start of the feature cycle, what you essentially do is a deep dive. You try to keep going for about half an hour, maybe an hour and you‚Äôre just trying to fire off ideas. 2. - Try to take full advantage of the fact that Ruby reads somewhat like pseudocode. It‚Äôs a case of ‚Äòfirst thought, best thought‚Äô, allowing for a more rapid-fire approach. 3. - What you actually want is to quickly formulate a hypothesis. Figure out how to disprove or prove it, at least, and then keep making rapid changes. "
    }, {
    "id": 34,
    "url": "http://localhost:4000/2023/12/14/how-to-explore-a-new-codebase.html",
    "title": "How to quickly deep dive into a new code base.",
    "body": "2023/12/14 -    Utilize the user interface (UI) to create domain model objects (Posts, Books, Reservations, etc), followed by monitoring the server-side Rails logs.     Examine the generated SQL and then directly access the database using either psql or the rails dbconsole.     Read the Models file (book. rb), search for associations, callbacks, scopes.     Lastly look up the most recent record that has been saved or added to the database rails c and play with it.  "
    }, {
    "id": 35,
    "url": "http://localhost:4000/2023/12/12/always-have-a-question-in-mind.html",
    "title": "Always have a question to solve in mind.",
    "body": "2023/12/12 - I recently explored a new code base, which was challenging, but focusing on a specific question helped me to direct my research more effectively‚Ä¶. . "
    }, {
    "id": 36,
    "url": "http://localhost:4000/2023/12/06/n-+-1-queries.html",
    "title": "N + 1 queries and how to fix them.",
    "body": "2023/12/06 - I recently had to deal with a n + 1 query‚Ä¶. Firstly let‚Äôs understand why does this happen? The N+1 query problem is like inviting friends to a party and then calling each one separately to ask if they‚Äôre coming. If you have 10 friends, you make 1 call to decide to invite them and then 10 more calls to each friend. So, for 10 friends, you make 11 calls in total. In databases, this is like fetching a list of items (like blog posts), and then for each item, making another query to fetch related data (like comments on each post). If you have 10 posts and you fetch comments for each one by one, you end up making 1 query to get all posts plus 10 more queries for comments, leading to 11 queries. But why in db happens this?? The First Query (N): When you ask for the list of posts, the ORM makes one query to fetch all posts. This is your ‚ÄúN‚Äù part of the problem, where ‚ÄúN‚Äù is the number of posts. The Plus One (+1) Part: For each post, when you try to access its comments, the ORM realizes it hasn‚Äôt fetched those yet. So, it makes a new query for each post to fetch its comments. If you have 10 posts, this approach results in 10 additional queries - one for each post to get its comments. The ORM‚Äôs default behavior is to load data on demand (lazy loading). It avoids fetching related data until you explicitly access it, which can be efficient in scenarios where the related data is not needed. However, when you do need related data for each item in a list, it leads to multiple queries, creating the N+1 problem. Example: # rails console@events = Event. all Event Load (0. 5ms) SELECT  events . *  FROM  events  /* loading for pp */ LIMIT ? [[ LIMIT , 11]]# Each call to `event. attendees` for an `event` triggers a separate query to fetch the `attendees` for just that `event`. @events. each do |event| puts  Event: #{event. name}  üëâevent. attendees. each do |attendee|  puts   Attendee: #{attendee. name}  endend# Logs:üëâEvent Load (0. 2ms) SELECT  events . * FROM  events  Event: Tech Conference üëâAttendee Load (0. 1ms) SELECT  attendees . * FROM  attendees  INNER JOIN  registrations  ON  attendees .  id  =  registrations .  attendee_id  WHERE  registrations .  event_id  = ? [[ event_id , 1]]  Attendee: Alice  Attendee: Bob  Attendee: Charlie Event: Music Festival üëâAttendee Load (0. 0ms) SELECT  attendees . * FROM  attendees  INNER JOIN  registrations  ON  attendees .  id  =  registrations .  attendee_id  WHERE  registrations .  event_id  = ? [[ event_id , 2]]  Attendee: Bob  Attendee: DanaData to recreate a small excercise: Let‚Äôs create a small app so we can see in detail what is being produced by each active record method. # Create app with name `preload_demo_app`rails new preload_demo_app# Go to `preload_demo_app` dircd preload_demo_appThen let‚Äôs create models and add the associations we need needed. # Create `Event` modelrails generate model Event name:string location:string start_time:datetime# Create `Attendee` modelrails generate model Attendee name:string# Create `Registration` modelrails generate model Registration event:references attendee:referencesActive Record Associations üëá # app/models/event. rbclass Event &lt; ApplicationRecord has_many :registrations has_many :attendees, through: :registrationsend# app/models/attendee. rbclass Attendee &lt; ApplicationRecord has_many :registrations has_many :events, through: :registrationsend# app/models/registration. rbclass Registration &lt; ApplicationRecord belongs_to :event belongs_to :attendeeendOne last step, we need some data to play with: # eventsevent1 = Event. create(name:  Tech Conference , location:  Conference Center , start_time: DateTime. new(2024, 5, 20, 10, 0, 0))event2 = Event. create(name:  Music Festival , location:  Outdoor Park , start_time: DateTime. new(2024, 6, 15, 12, 0, 0))# attendeesattendee1 = Attendee. create(name:  Alice )attendee2 = Attendee. create(name:  Bob )attendee3 = Attendee. create(name:  Charlie )attendee4 = Attendee. create(name:  Dana )# registrations Registration. create(event: event1, attendee: attendee1)Registration. create(event: event1, attendee: attendee2)Registration. create(event: event1, attendee: attendee3)Registration. create(event: event2, attendee: attendee2)Registration. create(event: event2, attendee: attendee4)With this in place we can start playing with the model by opening ‚Äòrails c‚Äô üî∫ Let‚Äôs see includes behavior: # `. includes` is designed to minimize the number of queries and the overall load on the database by preloading associated dataEvent. includes(:attendees) # See the `IN` SQL keyword in the query for both `registrations` and `attendees` # A single SQL query that retrieves both in a single database roundtrip.  Event Load (0. 3ms) SELECT  events . * FROM  events  /* loading for pp */ LIMIT ? [[ LIMIT , 11]]  Registration Load (0. 4ms) SELECT  registrations . * FROM  registrations     WHERE  registrations .  event_id  IN (?, ?) [[ event_id , 1], [ event_id , 2]]  Attendee Load (0. 1ms) SELECT  attendees . * FROM  attendees     WHERE  attendees .  id  IN (?, ?, ?, ?) [[ id , 1], [ id , 2], [ id , 3], [ id , 4]]üî∫ Now preload: Event. preload(:attendees) # See the `IN` SQL keyword as well, here the key difference is how you apply the `. where` Event Load (0. 1ms) SELECT  events . * FROM  events  /* loading for pp */ LIMIT ? [[ LIMIT , 11]] Registration Load (0. 3ms) SELECT  registrations . * FROM  registrations   WHERE  registrations .  event_id  IN (?, ?) [[ event_id , 1], [ event_id , 2]] Attendee Load (0. 1ms) SELECT  attendees . * FROM  attendees   WHERE  attendees .  id  IN (?, ?, ?, ?) [[ id , 1], [ id , 2], [ id , 3], [ id , 4]]üî∫ eager_load: Event. eager_load(:attendees) # See the LEFT OUTER JOIN, it ensures that even `events` without any attendees are included in the result SQL (0. 1ms) SELECT DISTINCT  events .  id  FROM  events   LEFT OUTER JOIN  registrations  ON  registrations .  event_id  =  events .  id   LEFT OUTER JOIN  attendees  ON  attendees .  id  =  registrations .  attendee_id  /* loading for pp */ LIMIT ? [[ LIMIT , 11]] SQL (0. 1ms) SELECT  events .  id  AS t0_r0,  events .  name  AS t0_r1,  events .  location  AS t0_r2,   events .  start_time  AS t0_r3,  events .  created_at  AS t0_r4,  events .  updated_at  AS t0_r5,   attendees .  id  AS t1_r0,  attendees .  name  AS t1_r1,  attendees .  created_at  AS t1_r2,    attendees .  updated_at  AS t1_r3 FROM  events  LEFT OUTER JOIN  registrations    ON  registrations .  event_id  =  events .  id  LEFT OUTER JOIN  attendees    ON  attendees .  id  =  registrations .  attendee_id  WHERE  events .  id    IN (?, ?) /* loading for pp */ [[ id , 1], [ id , 2]]üî∫ What happens with . joins: event = Event. find_by(name:  Tech Conference )Event Load (0. 1ms) SELECT  events . * FROM  events  WHERE  events .  name  = ? LIMIT ? [[ name ,  Tech Conference ], [ LIMIT , 1]]# Usage of `. joins`Attendee. joins(:registrations). where(registrations: {event_id: event. id}) # an `INNER JOIN` is performed between `attendees` and `registrations`.  # It uses the association named `registrations` defined in the `Attendee` model.  Attendee Load (0. 2ms) SELECT  attendees . * FROM  attendees   INNER JOIN  registrations  ON  registrations .  attendee_id  =  attendees .  id   WHERE  registrations .  event_id  = ? /* loading for pp */ LIMIT ? [[ event_id , 1], [ LIMIT , 11]]Event. joins(:registrations). distinct # See the `DISTINCT` in the `SELECT` statement (ensures that events are listed uniquely).  SELECT DISTINCT  events . * FROM  events   INNER JOIN  registrations  ON  registrations .  event_id  =  events .  id  Summary: Hope you get more understanding on this topic! More blog posts here: üëá Bhumi‚Äôs N + 1 blog postarunyadav N + 1Benito Serna N + 1 ebookSo you need a sort at database level or just with ruby is enough? "
    }, {
    "id": 37,
    "url": "http://localhost:4000/2023/12/01/debugging-libraries.html",
    "title": "Debugging libraries for Ruby and Rails",
    "body": "2023/12/01 - Exploring Ruby Debugging Tools Section 1: Pry Pry GitHub Section 2: Pry-Rails Pry-Rails GitHub Difference between ‚Äúpry‚Äù and ‚Äúpry-rails‚Äù Stackoverflow response Section 3: Debug Debug GitHub Section 4: Byebug Byebug GitHub "
    }, {
    "id": 38,
    "url": "http://localhost:4000/2023/11/21/hotwire-codex.html",
    "title": "The Rails and Hotwire Codex üåÄ",
    "body": "2023/11/21 - Notes: Turbo Native is the core of Hotwire‚Äôs native extensions. It orchestrates a native web view through multiple screens within native navigation. This way the app has a native feel, despite all the content being rendered using the same HTML views as the web app. Native navigation: Navigation in a Turbo Native app is completely native. When the user taps a link, a native method is called to handle the visit proposal. If a fully native screen is preferred for a given URL, this method is where that choice can be made. More commonly, we‚Äôll want to visit the destination URL. 1) When a link is tapped, 2) Turbo Native creates a new screen, 3) injects the web view into it, 4) drives the web view to the new location using Turbo, and 5) displays the screen to the user. Authentication: Turbo Native apps use cookie based authentication for requests originating in a web view. If you have purely native screens and need to make HTTP requests from native code, you‚Äôll need to implement a form of token based authentication on the server. Session: A session co-ordinates a single native web view. It‚Äôs responsible for triggering URL visits using Turbo, and for inserting the web view into new screens when displayed to the user, we‚Äôll use a different session for each tab so the navigation in each tab is totally independent. Path Configuration: The path configuration is a JSON file stored in the app bundle. This file specifies a set of rules that match URLs, using regex patterns, to a set of properties. These properties define how a URL should be displayed in the app. If a particular URL has a fully native screen, this is where we tell Turbo Native about that. Feature flags and other settings can also be defined making it simple to turn features on and off remotely. All of this content was taken from book below, they‚Äôre personal notes. I encourage you buy it. Book link is here. "
    }, {
    "id": 39,
    "url": "http://localhost:4000/2023/11/13/conf-7.html",
    "title": "Ruby conf @ San Diego, CA.",
    "body": "2023/11/13 - Blog about this conf is pending. "
    }, {
    "id": 40,
    "url": "http://localhost:4000/2023/11/08/shape-up.html",
    "title": "Shape up üé¢",
    "body": "2023/11/08 - Shaping Up Methodology Notes: These are some insights I‚Äôve gathered from the ‚ÄúShaping Up‚Äù methodology, which is neither Scrum nor dependent on Kanban boards. The Challenge of Building Software: In the realm of software development, there‚Äôs a substantial element of the unknown, given that what we‚Äôre building hasn‚Äôt existed before. Waiting six months to realize we‚Äôre on the wrong path is excessively long, while a two-week span is typically too brief to produce anything substantial. The Solution: Defining Scope and Time: The solution lies in defining smaller projects that are actionable and testable. A period of six weeks is sufficient to both complete and deliver a project and short enough to allow for directional changes should they be necessary. Key Idea #1: Estimate vs. Appetite: Instead of attaching a time estimate to a technical task, we should ask ourselves how much time we actually want to spend on this project. Consider the analogy of setting a budget before choosing a restaurant for dinner; it‚Äôs a strategic approach that takes into account the value, urgency, and business context. We should strive for an agreement between product teams and technical staff to ensure the time is fixed and the scope is adaptable. Key Idea #2: Shaping: ‚ÄúShaping‚Äù considers two major questions about scope: ‚ÄúWhat is included?‚Äù and ‚ÄúWhat is excluded?‚Äù It also addresses the detail required upfront versus what can be delegated to the team to resolve later. ‚ÄúLatitude‚Äù refers to the level of freedom or specificity given to the team. A key part of shaping is the willingness to abandon features that are either technically impractical or not critical to the user interface. Key Idea #3: Autonomy: Teams, consisting of two to three members, collaborate within a six-week cycle to deliver the complete project, not merely pieces of it. These teams maintain their focus without being burdened by unrelated tasks and are self-managed, operating at their own pace. Work is distinguished as either planned (strategic) or unplanned (reactive). Further Learning:  Shaping in a Nutshell Applying Shape Up in the Real World - Rails World 2023"
    }, {
    "id": 41,
    "url": "http://localhost:4000/2023/11/07/decompose-for-method-call.html",
    "title": "Decompose for method calls",
    "body": "2023/11/07 - In Ruby, it is possible to decompose the elements of arrays/hashes into distinct variables. Since values appear within arrays in a index order, they are unpacked into variables in the same order. # Decompose of an array&gt;&gt; fruits = [ apple ,  banana ,  cherry ]&gt;&gt; x, y, z = fruits&gt;&gt; x=&gt;  apple In this case we are going to use decompose for a method call, (with arrays only one splat needed *). def send_welcome_email(name, email, signup_date) puts  Sending welcome email to: #{name}  puts  Email: #{email}  puts  Signed up on: #{signup_date} end# Array of user informationuser_data = ['Jane Doe', 'jane. doe@example. com', '2023-04-01']# Using splat to pass an array of elementssend_welcome_email(*user_data) üëà# This code will output:Sending welcome email to: Jane DoeEmail: jane. doe@example. comSigned up on: 2023-04-01Now we are going to decompose for a hash, (two splats needed **). def configure_user(profile:, preferences:, settings:) puts  Configuring user profile:  puts  Profile: #{profile}  puts  Preferences: #{preferences}  puts  Settings: #{settings} end# Hash of user configurationuser_configuration = { profile: { username: 'johndoe', language: 'EN' }, preferences: { theme: 'dark', notifications: true }, settings: { privacy: 'high', location: 'off' }}# Using 2 splats to pass a hashconfigure_user(**user_configuration) üëà# This code will output:Configuring user profile:Profile: {:username=&gt; johndoe , :language=&gt; EN }Preferences: {:theme=&gt; dark , :notifications=&gt;true}Settings: {:privacy=&gt; high , :location=&gt; off }"
    }, {
    "id": 42,
    "url": "http://localhost:4000/2023/11/02/positional-vs-keyword-params.html",
    "title": "Positional vs Keyword arguments",
    "body": "2023/11/02 - When I began programming, I was puzzled by why some parameters were named and others not. Seeing *argument_name or **argument_name threw me for a loop. üò≥ Here you‚Äôll find the definitive guide to understand both! Positional arguments: # This method takes any number of user names as positional arguments. üôãüôã‚Äç‚ôÄÔ∏èdef greet_users(*users) users. each { |user| puts  Hello, #{user}!  }end# Passing individual user names to the method, which are packed into an array. greet_users( Alice ,  Bob ,  Carlos )# Outputs:# Hello, Alice!# Hello, Bob!# Hello, Carlos!# This method can take a variable number of fruit names. üçéüçådef list_fruits(*fruits) fruits. join(', ')end# Passing a list of fruits to the method. puts list_fruits( Apple ,  Banana ,  Cherry )# Outputs: Apple, Banana, CherryKeyword arguments: # Usage of ** for keyword arguments: üôãüôã‚Äç‚ôÄÔ∏èdef greet_users(**users) users. each do |identifier, user_info|  puts  Hello, #{user_info[:name]}!  endend# Passing user details as keyword arguments. # The keys `:user1`, `:user2`, and `:user3` are identifiers for each user's hash. greet_users( user1: { name:  Alice , age: 30 }, user2: { name:  Bob , age: 22 }, user3: { name:  Carlos , age: 25 })# Outputs:# Hello, Alice!# Hello, Bob!# Hello, Carlos!# This method takes a variable number of fruit names with details. üçéüçådef list_fruits(**fruits_with_details) fruits_with_details. map { |fruit, color|  #{fruit}: #{color}  }. join(', ')end# Passing a hash of fruits with details to the method. puts list_fruits(Apple:  Green , Banana:  Yellow , Cherry:  Red )# Outputs: Apple: Green, Banana: Yellow, Cherry: Red# More real example of user attributes as keyword arguments. üôãüôã‚Äç‚ôÄÔ∏èdef create_user_profile(**attributes) puts  Creating a profile for: #{attributes[:name]}  puts  Email: #{attributes[:email]}  if attributes[:email] puts  Signup Date: #{attributes[:signup_date]}  if attributes[:signup_date]end# Passing attributes as a hash, packed with a double splat. create_user_profile(name:  Jane Doe , email:  jane. doe@example. com , signup_date:  2023-04-01 )# Outputs:# Creating a profile for: Jane Doe# Email: jane. doe@example. com# Signup Date: 2023-04-01Passing objects üôãüôã‚Äç‚ôÄÔ∏è: class User attr_reader :name def initialize(name)  @name = name endend# Create an array of User instancesusers = [ User. new( Alice ), User. new( Bob ), User. new( Carlos )]# Define the greet_users method to accept multiple user objectsdef greet_users(*users) users. each { |user| puts  Hello, #{user. name}!  }end# Call greet_users with the array of User instancesgreet_users(*users)# Outputs:# Hello, Alice!# Hello, Bob!# Hello, CarlosIf you already have a hash with the appropriate keys, you can pass it to the method using the double splat operator **, which will convert the hash into keyword arguments. Docs for reference: *positional_argument **keyword_argument "
    }, {
    "id": 43,
    "url": "http://localhost:4000/2023/10/26/lastest-tips-and-tricks.html",
    "title": "Latest tips & tricks | Ruby & Rails",
    "body": "2023/10/26 - First filter then map: When you first filter a collection, you‚Äôre reducing its size by selecting only the elements that meet a certain condition. This step inherently decreases the number of items that will subsequently be processed by the map operation. Imagine you have an array of user records, and you‚Äôre only interested in processing active users with an age above 18, where the processing involves a complex calculation. users = User. allactive_adult_users = users. filter { |user| user. active? &amp;&amp; user. age &gt; 18 }processed_users = active_adult_users. map { |user| complex_calculation(user) }In this case, filtering out inactive users or those under 18 before applying the complex calculation minimizes the number of calculations, thus improving the performance. If you were to map first and then filter, every element in the collection, this means potentially performing a lot of unnecessary work. Remember: . select, . filter and find_all are Enumerable methods that do the same thing! Similar methods are . collect and . map! filter_map vs filter + map: The filter_map method iterates over an enumerable, applying a block to each element. This approach eliminates the need to iterate over a collection twice (once for filtering and once for mapping). Performance Benefits filter_map is more efficient than using filter and map separately because:  It reduces the number of iterations over the collection to just one.  It avoids creating an intermediate array that would result from the first operation (filter or map) before passing it to the second operation. fruits = ['apple', 'pear', 'banana', 'cherry', nil, 'fig', 'grape']uppercase_fruits = fruits. filter_map { |fruit| fruit. upcase if fruit&amp;. length &gt; 4 }puts uppercase_fruits # Output: [ APPLE ,  BANANA ,  CHERRY ,  GRAPE ]With both methods separate filter + map fruits = ['apple', 'pear', 'banana', 'cherry', nil, 'fig', 'grape']# First, filter out the fruits with more than 4 letters, excluding nil valuesfiltered_fruits = fruits. filter { |fruit| fruit&amp;. length &gt; 4 }# Then, map the filtered fruits to uppercaseuppercase_fruits = filtered_fruits. map(&amp;:upcase)puts uppercase_fruits # Output: [ APPLE ,  BANANA ,  CHERRY ,  GRAPE ]find_each vs all + each: When dealing with ActiveRecord objects, understanding the difference between find_each and using all followed by each is crucial for optimizing database interactions and memory usage. Using all followed by each is a straightforward way to iterate over a collection of records from the database. all retrieves all the records and loads them into memory, and each then iterates over these records one by one. Student. all. each do |student| puts student. nameendThings to consider:  Memory Usage: If the students table contains a large number of records, loading all of them with all can consume a significant amount of memory,find_each find_each is specifically designed to manage memory consumption and efficiency when processing large numbers of records. Instead of loading all records into memory at once, find_each retrieves and loads records in batches, processing each batch before moving on to the next. By default, the batch size is 1000 records, but you can specify a different batch size if needed. # Students records are proccesed in batches of 100, significantly reducing memory usage. Student. find_each(batch_size: 100) do |student| puts student. name endfind_each has different options to apply more details. Student. find_each(batch_size: 200, start: 1000, finish: 5000, order: :desc, error_on_ignore: true) do |student| # Your processing logic hereend. count vs . length vs . size: count directly translates to a SELECT COUNT(*) SQL query against the database. It asks the database to count the number of entries that match the query and does not load the objects into memory. This makes it very efficient for large datasets. Every time you call count, it performs a database query, which could be a downside if called repeatedly without a need for real-time accuracy. It will make an SQL COUNT regardless of the state of the collection in memory. (See this article to know how to tackle count efficiently) book = Book. first# Book Load . . . book. comments. load# Comment Load (0. 3ms) SELECT  comments . * FROM  comments  WHERE  comments .  book_id  = $1 [[ book_id , 1]]book. comments. count# Comment Count (0. 5ms) SELECT COUNT(*) FROM  comments  WHERE  comments .  book_id  = $1 [[ book_id , 1]]length loads the entire collection of objects into memory and then counts the number of elements. This can be memory-intensive for large datasets because it initializes all the objects. It does not trigger an extra database query if the collection is already loaded. ActiveRecord loads the comments from the database (if they haven‚Äôt been loaded already) to count them. The count is done by Ruby in memory after loading the records. blogpost = BlogPost. first# BlogPost Load . . . blogpost. comments. to_a # Comment Load (0. 2ms) SELECT  comments . * FROM  comments  WHERE  comments .  blog_post_id  = $1 [[ blog_post_id , 1]] [[ blog_post_id , 1]]blogpost. comments. length# (no additional database query is executed, comments are already loaded into memory. )size combines the behaviors of both count and length. If the collection has already been loaded, size will calculate the number of elements in-memory, avoiding a database query. If the collection has not been loaded, it will perform a SELECT COUNT(*) query, similar to count. When a counter cache is implemented, . size uses the cached value for the count, eliminating the need for database queries to count the records. With data loaded: # `size` if loaded, calculates the length with Rubyblogpost = BlogPost. first# BlogPost Load . . . blogpost. comments. load# Comment Load (0. 5ms) SELECT  comments . * FROM  comments  WHERE  comments .  blog_post_id  = $1 [[ blog_post_id , 1]]puts blogpost. comments. size# (no db hit) - Uses Ruby to calculate the size from the loaded collectionWithout data loaded: # `size` if not loaded, performs an SQL COUNT queryblogpost = BlogPost. first# BlogPost Load . . . puts blogpost. comments. size# Comment Count (0. 4ms) SELECT COUNT(*) FROM  comments  WHERE  comments .  blog_post_id  = $1 [[ blog_post_id , 1]]With counter cache: # Scenario 6: `size` if there is a counter cache, uses the cached countblogpost = BlogPost. first# BlogPost Load . . . puts blogpost. likes. size# (no db hit) - Uses counter cacheputs blogpost. likes. size# (no db hit) - Uses counter cache again without additional queriesorder vs sort_by: order method is used with ActiveRecord relations to specify the order of records returned by a query. It translates directly into an SQL ORDER BY clause, meaning the sorting is done by the database before the records are returned to your Rails application. Since order operates at the database level, it is generally more efficient for large datasets. Databases are optimized for sorting operations, especially when working with indexes. Book. order(publication_year: :desc)When you use sort_by (Ruby Enumerable), the entire collection needs to be loaded into memory first. Only then does sort_by reorder the collection based on the specified attributes or criteria. Use sort_by for smaller datasets or when you need to sort based on computed values. Here, the trick is to work on a ActiveRecord relation otherwhise Rails loads the entire collection into memory. This is because . sort_by is an Enumerable method that operates on arrays, not on database queries. So, the first step is converting the ActiveRecord relation into an array of model instances and after loading, . sort_by then iterates over the in-memory array: posts = Post. where(published: true)# This line implicitly loads all published posts into memory and then sorts them by titlesorted_posts = posts. sort_by(&amp;:title)This is just an advice I got and wanted to keep it here.  Try to make the calculations and queries even if they become big in controllers or models and in view just sort them in memory.  Better to ship the wrong thing today than the right thing in 2 weeks! Because then you can get feedback and learn 14 things in 2 weeks instead of 1 thing. And you are as useful as the code you ship. So try to ship every day, multiple times if possible :smile: @books. shuffle (in-memory): The . shuffle method is a Ruby Array method that randomly reorders the elements of the array. It operates in memory, meaning the entire array needs to be loaded. Ideal for situations where you have a relatively small dataset already loaded. Ruby API. @books. order(‚Äòrandom()‚Äô) (in db): random() operation is performed by the database engine, which means it does not require loading all the data into your application‚Äôs memory to shuffle it. More details. any? =&gt; exist? vs present? =&gt; in memory: "
    }, {
    "id": 44,
    "url": "http://localhost:4000/2023/10/09/financial-wisdom-over-forks.html",
    "title": "Financial Wisdom Over Forks.",
    "body": "2023/10/09 - A Dinner Chat with 2 experienced developers. Recently, I had the opportunity to have dinner and engage in conversation with Chris O. and Harry L. at Rails World. Eager to delve into the nitty-gritty of consulting, I was particularly interested in uncovering the secrets of how to increase chances of success in this field. Among the insights shared by DHH was ‚ÄúThe One-Person Framework‚Äù which enables one to achieve remarkable productivity with Rails. This framework allows for a comprehensive understanding of everything from backend to frontend to deployment, all while Rails navigates through the complexities aiming for simplicity. Inspired by DHH‚Äôs insights, I‚Äôm keen on taking advantage of ‚ÄúThe One-Person Framework‚Äù to enhance my consulting practice. The discussion unfolded as follows: Accounting:    Always set aside 30% of each income you receive from consulting to cushion yourself when it‚Äôs time to pay taxes. 30 is a good figure; it‚Äôs enough.     Hire an accountant; don‚Äôt do it yourself, as it can become difficult.  Accounts:    The money that a business generates is one thing, and it must be in an exclusive account. Separate it from everything else (LLC or whatever structure).     Create a personal account for personal expenses, and avoid mixing expenses. It might seem easy initially, but it can become difficult to handle.  Sales:    Get with your referals, friends, uncles, cousins, people you were in school with and offer your services, it‚Äôd more easy if they own a company or have a decision makier position.     When it comes to consulting, once you finish a project and haven‚Äôt worked on securing another project, it‚Äôs very likely that you‚Äôll end up doing nothing.     Therefore, in the hypothetical case that you finish ‚ÄúProject A‚Äù in December, dedicate 80% of your time to the project to get it done, and 20% on sales activities (attending meetups, calls, creating content, follow-ups).     Then, as you get closer to finishing the project, switch to spending 80% of your time on selling and 20% on the project so that when you finish ‚ÄúProject A‚Äù in December, you have ‚ÄúProject B‚Äù waiting in January.  Always Work with Contracts:  Include a clause specifying that if the client tells you not to finish, he has to pay you at the point or progress where you leave the projectWork on Building Trust with Clients:    When you develop for a customer, aim to either cut their costs or increase their revenue/productivity or help them have more control over their business therefore you‚Äôll gain their trust.      Cut their costs: ‚ÄúOptimize processes to save your customer money. ‚Äù   Increase their revenue or productivity: ‚ÄúEnhance features to boost customer revenue and efficiency. ‚Äù   Help them have more control: ‚ÄúEmpower customers with tools for informed business decisions. ‚Äù      Earned trust will increase eventually like compound interest over the years, as they will share with others how you helped them and how efficient you are.  Where to Find Potential Customers:    One approach is to get in touch with local marketing agencies and offer to outsource their work to you, whether it‚Äôs web apps or web pages. This is beneficial as it‚Äôs easier to secure payments from organizations than individuals, and it also enhances your portfolio and reputation.     For the point above üëÜ, show up! Don‚Äôt just email them; meet them in person, attend meetups, even those not related to tech.     Another approach is to reconnect with previous customers and inquire if there‚Äôs another department you can assist; this should happen naturally if you‚Äôve had a good working relationship.  Don‚Äôt Convince Customers to Have a Rails App When They Don‚Äôt Really Need It (Avoid This üö´):    One individual secured a contract where the customer apparently needed a WordPress management system, but he kept pushing for a Rails application.     Somehow, the customer paid him in advance, and after a few months, rejected the project and asked for a refund. By then, he had already spent the money without setting aside funds for taxes, and found himself having to answer to both the customer and the tax authorities.  "
    }, {
    "id": 45,
    "url": "http://localhost:4000/2023/10/05/conf-6.html",
    "title": "Rails World @ Amsterdam, NL.",
    "body": "2023/10/05 - Blog about this conf is pending. "
    }, {
    "id": 46,
    "url": "http://localhost:4000/2023/09/30/how-to-crack-you-next-code-challenges.html",
    "title": "How to crack your next code challenge üßÆ",
    "body": "2023/09/30 - Notes that will help you understand and then solve a code challenge interview. "
    }, {
    "id": 47,
    "url": "http://localhost:4000/2023/09/22/apprenticeship-patterns.html",
    "title": "Apprenticeship Patterns üåå",
    "body": "2023/09/22 - "
    }, {
    "id": 48,
    "url": "http://localhost:4000/2023/09/15/conf-5.html",
    "title": "Rails Camp @ Honolulu, HI.",
    "body": "2023/09/15 - Blog about this conf is pending. "
    }, {
    "id": 49,
    "url": "http://localhost:4000/2023/09/10/search-bar-rails.html",
    "title": "Search bar in Rails üîç",
    "body": "2023/09/10 - Notes from building a Search bar. Justin Weiss search bar using scopes. Search bar using turbo frames. Search bar Test double. "
    }, {
    "id": 50,
    "url": "http://localhost:4000/2023/08/20/chartkick-gem.html",
    "title": "Chartkick gem vs chart.js",
    "body": "2023/08/20 - Notes from chartkick gem implementation "
    }, {
    "id": 51,
    "url": "http://localhost:4000/2023/08/01/llm-langchain-rb.html",
    "title": "LLM Langchain.rb ü¶ú | Andrei Bondarev",
    "body": "2023/08/01 - While I was in New York I had the opportunity to attend a nyc. rb webinar where the main subject to discuss was going to be LLMs and what is the Ruby community doing about, Andrei Bondarev was the speaker. I know it was a webinar you can attend it wherever you are! However I found it because I was looking for a monthly meeting in NY, also I found that NYC on rails is about to start, so folks from NY please support Avi in this journey üôè. Tweet where Avi anounces that he is going to take up rails monthly meeting (they were held off since 2016). OK moving on from ads, here I‚Äôll share with you the resources that I have gone over the last week so I got my feet wet with this new topic called LLMs (Large Language Models). What is LLMs? It‚Äôs a subset of Deep Learning as well as Generative AI, both belong to AI. Google video that explains it very neat What is langchain then? ü¶ú How LLMs work? Why are they useful? Use cases? Andrei NYC. rb slides Main Langchain ruby repo Chatbot Proof of Concept: Multi-Agent Chatbot developed by Flexport member (Ben Zhang) Courses: LangChain for LLM Application Development from Deep Learning AI "
    }, {
    "id": 52,
    "url": "http://localhost:4000/2023/07/27/conf-4.html",
    "title": "Ruby For Good @ Washington, DC.",
    "body": "2023/07/27 - Blog about this conf is pending. "
    }, {
    "id": 53,
    "url": "http://localhost:4000/2023/07/24/NYU-startup-summer.html",
    "title": "NYU Startup Summer program",
    "body": "2023/07/24 - Notes from NYU clases "
    }, {
    "id": 54,
    "url": "http://localhost:4000/2023/06/14/how_i_learned_rspec.html",
    "title": "How I learned rpsec",
    "body": "2023/06/14 - Rspec learning resources I believe that the best way to get a grasp of testing in general and rspec is to start from scratch a project and start writing down each test, that way you‚Äôll be able to see what happens if you forget to close either a context block or an it block or even more intricate subjects like what‚Äôs the difference between describe and context. While developing a freelance project I wanted to add testing as a way to push myself to learn more about testing and also give rspec a try and by doing it I learned how to use gems like: faker, shoulda-matchers, factory_bot and finally rspec. üé≤ You‚Äôll additionally acquire: ‚Äì how to read the output of the test suite in the console. ‚Äì difference between create and build more details. ; # build doesn't persist user = build(:user, name:  John )expect(user. name). to eq( John )# create does persist user = create(:user, name:  Jane )expect(user. persisted?). to be true‚Äì How to include Devise‚Äôs test helpers class PostsControllerTest &lt; ActionController::TestCase config. include Devise::Test::ControllerHelpers, type: :requestsendblog; ‚Äì difference between fixtures and factories; ‚Äì and finally learn how to integrate FactoryBot with RSpec link. class Test::Unit::TestCase include FactoryBot::Syntax::MethodsendHere are also another resources that I followed in order to cement more my knowledge.    2 hours long video from Type Fast a Youtube channel that makes rails tutorials. The video is very thorough. Covers model, requests, background job testing and system tests. Fairly comprehensive starter guide to RSpec     1 hour long rspec tutorial from Type Fast was well (it‚Äôs more on the setup for an app) testing setup with rspec     How to test models CJ Avila     How to use factory_bot Deanin, short tutorial     Full marathon of rspec tutorial (reading not video) from syntax, how to test a model and installing rspec Remi rspec tutorials     The Complete Guide to Rails Testing by Jason Swett link  Learn by doing is the best way to learn rspec DSL, development stack, learn what to test and why it‚Äôs important to test and avoid technical debt. So give it a try, it wont be difficult after all. Lately, I have completed a few books on testing, inclding Professional Rails Testing by Jason Swett, Hands-On Test Driven Development by Greg Donald, Effective Testing with RSpec by Myron Marston and Ian Dees and even attended a testing workshop by Lucian Ghinda. "
    }, {
    "id": 55,
    "url": "http://localhost:4000/2023/06/05/conf-3.html",
    "title": "Blue Ridge Ruby @ Asheville, NC.",
    "body": "2023/06/05 - Blog about this conf is pending. "
    }, {
    "id": 56,
    "url": "http://localhost:4000/2023/04/24/conf-2.html",
    "title": "Rails Conf @ Atlanta, GA.",
    "body": "2023/04/24 - Blog about this conf is pending. "
    }, {
    "id": 57,
    "url": "http://localhost:4000/2022/10/04/conf-1.html",
    "title": "Rails Saas @ Los Angeles, CA.",
    "body": "2022/10/04 - Blog about this conf is pending. "
    }, {
    "id": 58,
    "url": "http://localhost:4000/2022/03/26/practicing_rails.html",
    "title": "Practicing Rails | Justin Weiss",
    "body": "2022/03/26 - Introduction It is possible to learn Rails without having the things you learn abandon you as soon as you try to grab ahold of them. That‚Äôs what this book is about. It‚Äôs a second book of Rails. A companion. It‚Äôll show you how to learn the most in the least amount of time, using the resources and knowledge you already have. And in the process, I‚Äôll guide you through some of the toughest lessons I‚Äôve learned during my programming and Rails career. Embrace struggle, failure, and reward. Learning to become a great Rails developer is hard work. And, being hard work, the only way to learn is to struggle. I‚Äôve heard programming described as ‚ÄúRunning into a brick wall, constantly. ‚Äù So don‚Äôt worry if you feel that way ‚Äì we all do. Learning isn‚Äôt just about reading. It‚Äôs also about action. And that is why you can‚Äôt learn Rails without practicing Rails. Chapter 1 Tiny Apps: The best way to study new Rails ideas The best way to learn new Rails ideas and techniques is to use them. Right away. Practice them, internalize them, and make those techniques yours. When you‚Äôre working with such small apps, you focus on the single thing you want to learn. That way, you don‚Äôt have to worry about learning that new idea inside your existing, more complicated apps. For example, if you‚Äôre trying to learn ActiveModel::Serializers, and your controller isn‚Äôt serializing the model correctly, you can never be sure if the problem‚Äôs a gap in your knowledge, a problem with Rails, or a problem with your app. If you tried this out in a tiny test app, you could be pretty sure the problem was just a simple mistake or a misunderstanding. You can catch these mistakes on a small scale before you fight the bugs that appear when you use them into a larger app. I care about getting the most knowledge in the least amount of time, and scaffolds and other Rails code generators are a great way to do just that. Using the console and Tests for learning. The console is great for messing with objects, but getting those objects set up can be hard. Tests are great for getting objects set up, but hard for messing with them. Most Rails books and videos are good at showing you what‚Äôs possible. But they can‚Äôt explain everything. Those gaps will raise questions, and you‚Äôll naturally want to have those questions answered. ‚ÄúWhy does it work that way?‚Äù ‚ÄúHow could this possibly work?‚Äù ‚ÄúWhat if I tried using it with this other idea I just learned about?‚Äù So, when I say ‚Äúplay with and modify the things you learn‚Äù, I mean ‚ÄúAnswer the questions you have about the things you learn, using code. ‚Äù Chapter 2 How to build your own Rails app This feeling is totally normal. Whenever I‚Äôm about to start a new Rails app, I still feel like I want to give up computers forever and run into the woods or something. But I have a process to share with you that will help you get past this, so you can turn your ideas into real, working apps. When you face a large, fuzzy, overwhelming task like this, the answer is always the same: Break it apart! Break your big idea into small tasks that lead you to where you want to be. You‚Äôll have a path you can take that, no matter what, will get you closer to finishing your app. How do you choose the first thing to work on? When you start a new project, try this short process to help decide which thing to work on first: Take a few minutes and think what you‚Äôre trying to build. Write down every feature that comes to mind. Think of the different paths a user could take through your application, the different things they could do. Describe each one in a single sentence. Then, focus on just the paths where, if you didn‚Äôt have them, your app couldn‚Äôt exist. Core paths. Core paths are the things you‚Äôd talk about if someone asked you to describe your app in 30 seconds. Which part of the feature should you start with? Once you‚Äôre ready to build your first core path, you might feel like writing models for all the objects you have in mind. Maybe you want to create migrations, add attributes, and connect everything together. But soon, you‚Äôll have a ton of pieces that may not all fit. It‚Äôll take a long time before you can actually use your app. And if you didn‚Äôt design your models well, you‚Äôll just have to do that work over again when you build your UI and actually start playing with your app. So, start with UI, and infer your data model from what you see in the UI. When you begin work on a single, small feature, start with the UI:    Take the small feature, or core path, from earlier.     Think of one simple thing someone could do with that feature.     Draw just enough screens for that user to be able to do that thing.     Describe the path through that action, as if you were telling someone what you were going to do.     As you describe that path, write out the objects, properties of those objects, and other actions you think you need to develop that path.  "
    }, {
    "id": 59,
    "url": "http://localhost:4000/2022/03/04/testing_waterloo.html",
    "title": "Rails Testing | University of Waterloo",
    "body": "2022/03/04 - This is a series of lectures about rails testing -Databases &amp; Software Engineering course. How to test? Mike Cohn in his book Succeeding with agile. You should spend most of your time in Unit. End to end is manual and it means a person goes through all the user flow to reach a user acceptance criteria, click buttons, links, add stuff to the shopping cart, make a payment. This can be Manual test, actually using the interface, this is what the customer will see/use. Template:Given: that I‚Äôm a logged in user in ‚Äúhome page‚ÄùWhen: when I click on ‚Äúlog out‚ÄùThen: I‚Äôm logged out Only the basics here, for example: I can create an account but don‚Äôt extensively, send an email, one happy path and one sad path. In Rails End to end tests are called system tests Integration, tests multiple components but exclude user interface. In Rails it tests the controller. what does it respond? what does it send? POST to this path with this params (we can see if a form is going to the right path) Unit, it isolates one single object or method from the rest of the system and test it by itself. This help us see where the problem is. Models, and classes we create, First I need to make sure my individual pieces work, then i put them together and see if that larger system works and eventually we‚Äôre going to check out and test the whole entire system. Testing Pyramid and Rails Video Lecture MSCI 245 : Testing Is my app free of bugs?Does the program work as specified? Write a specification or a test that specifies expected behavior. Test case: average_rating Arrange - what is the input?Act - run the programAssert - check the output against the expected output Then we need 2 cases:  For a Book with 1 or more rating, it should return the average of that book‚Äôs ratings     known gotchas: integers vs float division, off by one (when you skip 1st element of the loop).     For a Book with 0 rating, it should return nilThis is the arrangeBob rated 5Sue rated -2Ali rated 4total 7 Run the program total 7 / 3 = 2. 333 Asserttotal vs expected_value https://www. youtube. com/watch?v=2yYSR6ftxUo Testing fundamentals - equivalence classes You cannot test all inputs. You need to carefully pick inputs to find your mistakes. ‚Äú‚Ä¶ testing can be used very effectively to show the presence of bugs, but never to show their absence‚Äù E. W. Dijkstra if 2 inputs produce the same output, they are said to be member of the same equivalence class. if the net method is tested correctly, the behavior of the method should be the same, there are only 2 inputs that we must use: [1, 2, 3] and [0, -12] def absolute_value(x)	if x &lt;= 0		return -1 * x	else		return x	endendInterior &amp; boundary values. Values that sit on either side of a division between equivalence classes are boundary valuer -&gt; where bugs hide. Other values are the interior values. [minimum. . . -1]|[0 . . . maximum] the boundary is between -1 and 0Test cases: (try to put all below in just one test) Equivalence test case min(a, b) Test:  a == b a &lt; b a &gt; bhttps://www. youtube. com/watch?v=-1kCdERz1sMBase, Edge, and Corner Cases; Happy and Sad Paths Base case - normal expected inputsEdge case - inputs approach limits or outside limitsCorner case - crazy values, should never see in real world Example: user interface - e commerce - shopping cart Base -&gt; user adds a few itemsEdge -&gt; user surprises us with a large order 100-1000 thingsCorner -&gt; whole store in cart (we don‚Äôt want the whole site to fail, we should put a limit) We can think of a form for creating a user name, nick names, emails, domains, capitalization Success &amp; failure (code should handle both) Test both good input (success). Test bad inputs (failure) to test proper error handling. Black box, you test the software and don‚Äôt get a look at the code, you cannot call the code White box, you test the software and get a look at the code to see what is happening https://www. youtube. com/watch?v=NoP3am8ipYw Hunting for bugs Logic errors  boundaries common inputs to test     some minimum   zero   one                         empty - zero       length       list       empty                     negative numbers   first/last element of an array   Most common working with arrays or any sort of list:  skip first/last element don‚Äôt process last elementNumerical erros  accidental truncation of floating point to integer divide by zero (think of a way how a user can input a 0 as denominator and catch the error) bad floating behavior (try to add a lot of small numbers to a larger numbers) assume the sum of the computer is correct sqrt(2) != ‚àö2Integrating boundaries  one system talking to another misunderstandings about proper inputs/outputsOther  null values -nil handling of exceptions loss of networks/disk/power?https://www. youtube. com/watch?v=crFl2K1bOhI MSCI 245 : A quick intro to Minitest and automated testing  testing framework enabled by default in Rails automated testing at 3 levels     Unit (individual methods or objects, this part works correctly)   Controller (integration) (we reproduce a browser with http verbs POST, GET)   System - end to end (E2E) user interface (manual, buttons)   To do unit testing we make a class that inherits from ActiveSupport::TestCase. We make one test case for every class we want to unit test. test/models/book_test. rbArrangeActAssertrequire 'test_helper' # brings test/test_helper. rbclass BookTest &lt; ActiveSupport::TestCase	# (always start with  test_ )	# The DB within test is empty	def test_average_rating_multiple_ratings		# you have to build up the case in the database		card = Author. create!(name:  Orson Scott Card ) arrange		ender_game = Book. create!(title:  Ender's Game , year:  1985 , author: card arrange		. . . 		. . . add ratings/ users				assert_in_delta(2. 333, ender_game. average_rating, 0. 001,  should return 2. 333 for Ender's Game )	end	def test_average_rating_no_ratings		christie = Author. create!(name:  Agatha Christie )		fire_pigs = Book. create!(title:  Fire Pigs , year:  1942 , author: christie)				# first the expected, then the actual		assert_nil(fire_pigs. average_nil,  this should be nil )	endThings to note:  File that start with ‚Äútest_‚Äù are run with ‚Äúrails test‚Äù You can create other methods You have access to all Rails You can use debugger Each test should be independent of other tests You can define a setup method in the beginning and call it before every method, (to create data)https://www. youtube. com/watch?v=JYbHurKGzM0 Testing - Test Cases - Minitest - Capybara Arrange - setup the input codeAct - execute the code w/ inputAssert - check the result against our expected output Example: we are testing addition, the input is 1 and 2, the expected result is 3. E2E or systems tests: Arrange  - sometimes could be add items to DBAct - visit the home page, click a link to create accountAssert - did i end up in the home page? seeds. rb is not for tests, is for using the app, like: admin. FIRST properties of good tests Fast - run fastI - independent | isolated, a test should not depend on another test that has run before it; what went wrong and where (try one idea per test)R - repeatable, every time you run a test it behaves the sameS - self validating, tests reports pass or fail by automatic T - timely | thorough, write the test when your write the code; coverage Test Frameworks - Minitest (will help us write FIRST tests)  resetting the Rails app and DB after each test (repeatable, independent) run tests in randomly order (independent) provide assert statements &amp; reports of pass and fail (self validating)Fast is mainly a property of this type of test, low overhead (faster than Rspec)Timely &amp; Through this is about developer behavior and skills Basics of Minitest  You write classes that inherit from Minitest.  Each method of the class that star with ‚Äútest_‚Äù is run as independent test .  You can write a ‚Äúsetup‚Äù method, it will run before every test within that class (for creating user for instance).  Rails and Minitest restore state after each test, includes the DB.  Everything in Minitest in plain Ruby (only new methods like assert) (not like Rspec or cucumber).  Your class can have non-test methods.  You have access to all Rails, models methods and so on.  Separate test DB to avoid contamination.  There are a lots of ways to assert. assert(test = must be a boolean, message to display) - &gt; assert(expected == results) assert_equal(expected, actual) assert_nil(nil) flunk (msg) make the test fail in purpose skip (msg)       Capybara   url = root_pathvisit url ‚Äî‚Äîassert_current_path url‚Äî‚Äìclick_link(‚Äòid-of-link‚Äô) # id‚Äôs from HTMLclick_link(‚ÄòBooks‚Äô)click_button(‚ÄòSubmit‚Äô) # it‚Äôs better to click on idfill_in(‚ÄòName‚Äô, with: ‚ÄòBob‚Äô)‚Äî‚Äî-assert page. has_content?(‚ÄòSorry Invalid. ‚Äô) You can search element on the page and interact with them or inspect thempage. find(:css, ‚Äòa[href=‚Äôsign_up_path‚Äô]‚Äô). click assert_text (‚ÄòCreate an account. ‚Äô) =&gt; all about UI. If you wont access session &amp; other ‚Äúlower stuff‚Äù then write an integration. Example: class LinkTest &lt; ApplicationSystemTestCase	def test_nav_root_to_create_account		visit root_path		click_link('Create Account')		assert_current_path sign_up_path	endendhttps://www. youtube. com/watch?v=DxIoWJKYxIg&amp;t=1278s Demo of TDD ArrangeActAssertclass StatFunction	def self. median(values)		if values. nil? || values. length == 0 			raise ArgumentError( it needs at least one element )		end				if values. length == 1			return values[0]		end				values = values. sort		if values. length. even?			left_of_mid = (values. length / 2) - 1			result = ( values[left_of_mid] + values[left_of_mid] + 1 ) / 2. 0			return result		else			mid = (values. length / 2 )			return values[mid]		end	endendTest def test_median_one_element	# arrange	elements = [1]	# act	result = TestingExample::StatFunction. median( elements)	# assert	assert_equal( 1, result)enddef test_median_two_elements	elements = [1, 2]	result = TestingExample::StatFunction. median( elements)	assert_in_delta( 1. 5, result)enddef test_median_three_elements	elements = [1, 2, 3]	result = TestingExample::StatFunction. median( elements)	assert_equal(2enddef test_median_zero_elements	elements = []	assert_raises(ArgumentError) do		result = TestingExample::StatFunction. median( elements)	endenddef test_median_zero_elements	elements = []	assert_raises(ArgumentError) do		result = TestingExample::StatFunction. median( elements)	endenddef test_median_nil	elements = nil	assert_raises(ArgumentError) do		result = TestingExample::StatFunction. median( elements)	endendhttps://www. youtube. com/watch?v=sOT2FgD22VI What is Minitest? https://semaphoreci. com/community/tutorials/getting-started-with-minitest How to Test Rails Models with Minitest https://semaphoreci. com/community/tutorials/how-to-test-rails-models-with-minitest Getting Started With Testing In Rails (Using Minitest and RSpec) https://medium. com/@ethanryan/getting-started-with-testing-in-rails-using-minitest-and-rspec-113fe1f866a Getting Started With System Tests in Rails With Minitest In Rails jargon, system testing refers to ‚Äútesting an application as a whole system‚Äù. That is done by using a browser in the tests. Instead of testing separate parts, with system tests, we can test a whole ‚Äòworkflow‚Äô, just like what a user goes through while interacting with our app, including the JavaScript parts. In practice, it means that we don‚Äôt want a system test to check if a record is created in the database when a user clicks a button; we just test if that new record appears on their screen. These kinds of user interaction tests are also called feature tests or acceptance tests. They are different from integration tests: integration tests are for testing the behavior, especially of all the parts of the app together, but not via the user interface. https://blog. appsignal. com/2020/02/12/getting-started-with-system-tests-in-ruby-with-minitest. html Official Docs https://guides. rubyonrails. org/testing. html#rails-meets-minitest Minitest vs. RSpec in Rails https://www. honeybadger. io/blog/minitest-rspec-rails/ "
    }, {
    "id": 60,
    "url": "http://localhost:4000/2022/02/14/test_jason_swett.html",
    "title": "The Beginner‚Äôs Guide to Rails Testing Jason Swett",
    "body": "2022/02/14 - The eight types of RSpec specs ‚Ä¢ Model specs‚Ä¢ System specs‚Ä¢ Request specs‚Ä¢ Helper specs‚Ä¢ View specs‚Ä¢ Routing specs‚Ä¢ Mailer specs‚Ä¢ Job specs Jason usage: ‚Ä¢ Model specs always‚Ä¢ System specs always‚Ä¢ Request specs rarely‚Ä¢ Helper specs rarely‚Ä¢ View specs never‚Ä¢ Routing specs never‚Ä¢ Mailer specs never‚Ä¢ Job specs never Model spec I use model specs to test my models‚Äô methods. When I do so, I tend to use a test-first approach and write a failing test before I add a new line of code so that I‚Äôm sure every bit of code in my model is covered by a test. System spec System specs are the only type of test that give me confidence my whole application really works. Even though system specs are indispensable, they‚Äôre not without drawbacks. System specs are somewhat ‚Äúheavy‚Äù Request specI tend not to use request specs much because in most cases they would be redundant to my system specs. If I have system specs covering all my features, then of course a broken controller would fail one or more of my tests, making tests specifically for my controllers unnecessary. I also try to keep my controllers sufficiently simple as to not call for tests of their own. There are just three scenarios in which I do use request specs. First: If I‚Äôm working on a legacy project with fat controllers, sometimes I‚Äôll use request specs to help me harness and refactor all that controller code. Second: If I‚Äôm working on an API-only Rails app, then system specs are physically impossible and I drop down to request specs instead. Lastly, if it‚Äôs just too awkward or expensive to use a system spec in a certain case then I‚Äôll use a request spec instead. View and routing spec I find view specs and routing specs to be redundant to system specs. If something is wrong with one of my views or routes, it‚Äôs highly likely that one of my system specs will catch the problem. What are all the Rails testing tools and how do I use them? RSpec is a test framework. A test framework is what gives us a structure for writing our tests as well as the ability to run our tests. One of the challenges of Rails testing is generating test data. There are two common ways of generating test data in Rails tests: fixtures and factories. Fixtures typically take the form of one or more YAML files with some hardcoded data. The data is translated into database records one time, before any of the tests are run, and then deleted afterward. (This happens in a separate test database instance of course. ) With factories, database data is generated specifically for each test. Instead of loading all the data once at the beginning and deleting it at the end, data is inserted before each test case and then deleted before the next test case starts. One principle of testing is that tests should be deterministic, meaning they run the same way every time no matter what. Capybara: Some Rails tests only exercise Ruby code. Other tests actually open up a browser and simulate user clicks and keystrokes. VCR and WebMock: One principle of testing is that tests should be deterministic, meaning they run the same way every time no matter what. When an application‚Äôs behavior depends on external services (e. g. a thirdparty API like Stripe) it makes it harder to have deterministic tests. The tests can be made to fail by an internet connection failure or a temporary outage of the external service. VCR can let us run our tests against the real external service, but capture all the service‚Äôs responses in local files so that subsequent test runs don‚Äôt talk to the external service but rather just go off of the saved responses. That way, even if the internet connection fails or the service goes down, the tests still work. What keeps them (Rails devs) in the habit of writing tests consistently? Laziness, fear, and pride. Mental energy. If I write a feature without using tests, I‚Äôm often juggling the ‚Äúdeciding what to do‚Äù work and the ‚Äúactually doing it‚Äù work at the same time, which has a cognitive cost more than twice as much as performing those two jobs separately in serial. When I build a feature with the aid of tests, the tests allow me to separate the ‚Äúdeciding what to do‚Äù work from the ‚Äúactually doing it‚Äù work. it‚Äôs not possible to have clean, understandable code without having automated tests. Pains that tell you your test coverage might be insufficient? Too many bugs. Inability to refactor or make big changes When a change has a large footprint, like a Rails version upgrade or a broad refactoring, it‚Äôs basically impossible to gain sufficient confidence of the safety of the change without having a solid automated test suite. So on codebases without good test coverage, these types of improvements tend not to happen. How do I set up a new Rails project for testing? Start rails with template: https://guides. rubyonrails. org/rails_application_templates. html rails new my_project -T -d postgresql \ -m https://raw. githubusercontent. com/jasonswett/testing_application_template/master/applicatiOnceHow do I add tests to an existing Rails project? If you have little testing experience, I would suggest getting some practice on a fresh Rails app before trying to introduce testing to the existing Rails project you want to add tests to. Adding tests to an existing project is a distinct skill from writing tests for new projects "
    }, {
    "id": 61,
    "url": "http://localhost:4000/2022/02/05/the_man_in_the_arena.html",
    "title": "The man in the arena",
    "body": "2022/02/05 - The GOAT üêê  Chastising the Spanish artist for painting unrepresentative cubistic abstractions, a layman withdrew a photograph of his wife from his pocket and held it up to Picasso with the admonition, ‚ÄúWhy can‚Äôt you paint realistically, like that?‚Äù ‚ÄúIs that what your wife really looks like?‚Äù Picasso asked. ‚ÄúYes,‚Äù replied the man. ‚ÄúWell, she‚Äôs very small, and quite flat. ‚Äù First of all i need to be clear that I‚Äôm neither a football follower nor fanatic but somehow TB (Tom Brady) caught me up with his ‚Äúunderdog/rejection‚Äù story. Chapter 1 On naming the series. The meaning behind the title of this series is because that quote was on the weight room at Michigan University and TB saw it for almost 5 years (it was coined by Theodore Roosevelt) and for him was that eventually you become that man where all eyes are on you and only you know what is all about. All began in 1993-1996 when Patriots were playing good football however they were not winning, they lost 1 super bowl, new coach; then Mr. Brady appeared in 1999 with a very solid foundation from Michigan state, - ‚Äúthe team, the team is first‚Äù was the guideline he was trained. He defines it as a combination of talent, what you can add on a daily/weekly basis; at this time he didn‚Äôt know what were his strengths, everynight he looked up what phase was the draft on in order to know his position. Something worth mentioning is that 5 rounds passed and no one chose him, his attributes were not even close to what a pro football team expects, finally he was picked at #199 (only 200 are allowed). Main QB (quarterback, D. Bledsoe) at that time describe him as ‚Äúinquisitive‚Äù, asking about everything, everyone thought that he‚Äôd be just a backup, was not perceived as a threat; on the other side TB defined himself either ‚Äújust being naive‚Äù or ‚Äútoo much confidence‚Äù but he was determined to play pro üèà.  ‚ÄúWorking hard is a very sustainable trait. Part of your character. If you don‚Äôt have that, at some point the talent does wear off, you‚Äôre drafted based on both therefore you must work hard . ‚Äù Tom Brady. Second season with Brady on board started, Bledsoe signed the highest contract ever for the next 10 years, TB was on the bench until Bledsoe was hit, time to take the grid. Despite of the very low expectation people had on him, he felt ready to do the job. TB continued playing good waiting Bledsoe to get back of his injury however Bill Belichick (coach) made the decision of giving that role to TB, seeking the best for the team. At the AFC finale (one game before Super Bowl) TB had an ankle injury, Bledsoe took his role back, made a couple of touchdowns and won the game, this only remarks how mentally strong was TB since the beginning, everything came down to Bledsoe would be the starting QB, coach thought different, Tom will play the SB. As always all odds against Patriots, however the Pats won being the most underdogs üèÜ.  You gotta be ready when your opportunity presents itself. I don‚Äôt think I was physically prepared. Was I mentally and emotionally ready? Absolutely. It‚Äôs like anything. Its progress and its evolution. It‚Äôs a series of small steps that seem so insignificant. ‚Äù Tom Brady. Chapter 2 On team culture. TB describes how people, teammates, competitors have been such impactful in his life, on and off the field, those people must help you create the best version of you, if not you gotta move on. After winning the SB they lost the next season, it was time to regroup the team, they had to have more consistency; following season Belichick cut the defense leader (L. Malloy, best friend of TB) no one understood that decision which gave room to the media to start creating news about the feelings within the team, thing that TB refused with the next phrase ‚Äúignore the noise, focus on tactics‚Äù. ‚ÄúPatriots is not collecting talent, is building a team‚Äù B. Belichick. With that being said, TB worked his way to carefully listen to every advice from his coach that gave him structure and confidence, it enabled him to execute selfishness, caring about all his teammates, no one care about who takes the credit.  ‚ÄúWinning is probably the outcome but the process of winning was what the culture was all about. What are you willing to commit to be your the very best?‚Äù Tom Brady. TB learned to study every top player, take the good stuff, fine tune it and put it on practice. He used the next metaphor: ‚ÄúBe the best husband you could be, the best father, the best in your job, because you cannot control everything. If you have perspective in the end nothing bad really happens because out of the bad comes the really good things. ‚Äù  Mental toughness is how you deal with adversity. What‚Äôs the attitude of your heart? Embrace challenge? Failure?‚Äù Rodney Harrison. Chapter 3 The edge. This episode was on motivational style, TB put a statement about how their mentality was - one game at the time, this was tough to put into practice due to they had more than 20 wins in a row. The main responsibility of any leader is to know how to motivate each member of his team, some of them like hard coaching others need just a push and in this sports the QB is the chief; this time Belichick worked to create a competitive environment where all the players wanted to give more, here are some phrases he shares:    It was not the more you can do it. It was who could do the most.     You came 6:30 am? I‚Äôve already got a half hour on you.     I‚Äôm getting the edge on you.     This is what I did. What‚Äôd you do?  -Are you leaving already? -Still not doing the extra, huh? I‚Äôm getting the edge on you today I think is worth pointing out the good outcome that Belichick achieved by building this environment, it‚Äôs only as good as the ability of the players to receive it. The team at that time had a high level cohesiveness and the feedback, communication was on point to keep the culture up.  ‚ÄúYou don‚Äôt know what kind of culture you have until things aren‚Äôt going well. ‚Äù When you have failure, when you don‚Äôt do what you were supposed to do, you‚Äôll define how your culture looks like. ‚Äù Mike Vrabel. TB also mentioned how people think there are going to be more opportunities and that is a mistake because it lowers the bar and keeps you away from doing your best effort, you may miss a chance and will disappoint you next time, it will create fear, you‚Äôll want a lower level to play in order to avoid frustration. Chapter 4 The goliaths. In this episode you‚Äôll find how the Patriots reached its highest level and passed from being the underdogs to the goliaths. Many new team members Randy Moss, Wes Welker amongst others; they knew they were the team to defeat which I think played against them this time. Pats had a first time ever record with 16 wins and 0 loses, no team had accomplished this before, they made football look easy, then the ‚Äúspygate‚Äù got and again TB spoke up with his phrase ‚Äúignore the noise‚Äù. ‚ÄúSo much of the success in the life is about that journey and it‚Äôs not about whether you win or lose always. It‚Äôs about how hard you try and what you put into it, thr relationships, the learnings you develop. ‚Äù Tom Brady. In the end Pats lost the Super Bowl against New York Giants, this time Giants were the weaker. Chapter 5 No guarantees. This episode covers 4 seasons and Tom describes how are the relationships he was able to develop throughout these years, friendships, the born of his 2 kids, how supportive and stabilizer was Gisselle for him and how you must overcome failure, learn from it and move on. Some highlights of this episode are the union of NFL players took place for the first time, they couldn‚Äôt attend training however TB convoked to train in one college field without coaches with gave the team an advantage over the others, ultimately the got the conditions they were after. And finally Patriots faced Giants in the finale and they lost, after a series of inconvenient events, Eli Manning won the SB.  ‚ÄúChallenges are opportunities in disguise‚Äù. Gisele B√ºndchen. Chapter 6 Stop the bleeding. Things were not clear for this season, the media started pressing on TB retirement, a new draft for his position had been picked. Pats did a comeback throuthroug the season to reach the SB with a record of 12 - 4 gaining confidence game after game, ignoring the noise and building momentum, they did their job and stop the bleeding; suddenly another scandal arose the ‚Äúdeflategate‚Äù just a few days before the SB, they faced the best defense at that time Seattle Seahawks with Richard Sherman. Notwithstanding the dire comments about them, the conquered their 4th Super Bowl üèÜ  ‚ÄúGreatness come with taking chances‚Äù. Vince Wilfork. Chapter 7 Surrender. For this chapter Tom invited his 3 sisters in order to lay out how his childhood was, they were a typical California family, attending all 49‚Äôs games, Tom Brady being the youngest felt always protected by his 3 sisters and his parents, they did a pretty well job, until he left to attend Michigan University. The season covered here was on year 2017 when Tom had to defend himself against the ‚Äúdeflategate‚Äù, he was penalized, suspended and the worst; his mom was detected with cancer, the quimio and radiation started so his mind was cut on two sides. Tom depicts this Super Bowl as the greatest game ever played (I didn‚Äôt know why until I watched how it unfold); this finale had the biggest difference in points ever, 28 to be precise despite that, Pats did comeback and scored as many touchdowns as needed to defeat Atlanta Falcons (play after play). ‚ÄúI think he lives his life to really be the best at something. He is a hundred, a thousand % committed to being the better than he was a day before. ‚Äù Tom Brady sister. ‚ÄãChapter 8 No body‚Äôs business. Tom introduced his rehab clinic and method along his coach body Alex Guerrero; it seems to be his secret weapon after finishing each game as well as every recovery. From my perspective Alex is an alternative physician who uses natural healing and different methods to prepare the muscles, also he goes over emotional and mental subjects trying to get up to an integral readiness. After years working on theses methods and proving they really work, Tom convinced Rob Gronkowski to get to Alex and try out his alternatives methods, thing that Belichick didn‚Äôt agree with and sent Tom and the trainer to remain outside each meeting and game. These supplemental activities seemed to gained relevance when Tom suffered a dire injury in his thumb days before the AFC final, he needed punctures and the recovery appeared to be beyond Sunday however after several treatments he was able to flex and use his hand for Sunday and passed to the SB LII. The super Bowl was fought by the two teams but Pats couldn‚Äôt beat the Philadelphia Eagles, another lose for Tom Brady üëé. Chapter 9 Maybe. Last episode of this series goes over the season 2018 and 2019 where Pats had to face Kansas City and Patrick Mahomes, I think they highlight this game because KC started to show how good they were and the pro football they play, also because some key teammates were out so regular season was not great. The Super bowl was against Los Angeles Rams which was meant to be a tough game, very physical, low opportunities, in the end Tom was bearing in mind that it was going to be his last season playing with New England because he didn‚Äôt get a new contract.  ‚ÄúAll comes down to the people and relationship what I value the most. Tom Brady. Conclusion. It definitely is a combination of different factors that take you to succeed or to the place you want to be, those factors may be hard work, readiness, persistence and of course luck or how tom said a few times ‚Äúsituacional football‚Äù which is when something completely out of your control plays in favor of you, kicker missed the goal, the receiver couldn‚Äôt catch the pass, you name them and here is the part of commitment you need to place in every activity, relationship you want to develop because if everything derails and nothing comes to the place you planned was the best; you must be satisfied that you gave everything you could in order to accomplish but luck this time was not on your side. Having lost so many SB‚Äôs being the most prestigious sports in America has to be tough as well, it‚Äôs said very easy, -he won 7 Super Bowls. But how manys he lost?! It‚Äôs tough to miss a flight, to be rejected by the company you would have loved to work for, imagine how hard is to lose the most important event in the year, after having practiced and played 9 months in a row without being with your family. Tom developed a resilient mentality which was key for his journey, to keep his feet on earth and to overcome those setbacks, never look back and learn the most from them. "
    }, {
    "id": 62,
    "url": "http://localhost:4000/2022/01/05/minitest_cookbook.html",
    "title": "The Minitest Cookbook",
    "body": "2022/01/05 - Today though, the separation between development and testing has largely disappeared - at least in the universe that most Ruby and Rails programmers occupy. In many if not most cases now, the one writing the code is also responsible for producing automated tests that cover the workdone. And while you‚Äôre probably sick of hearing it, this is a good thing for all kinds of reasons. Why? ‚Ä¢ Tests demonstrate that your code actually works. ‚Ä¢ The pattern of thinking needed to write tests for code is very close tothat needed to design it. ‚Ä¢ Testing and developing in parallel tends to surface more bugs early in the development process when fixing them is cheap and easy. ‚Ä¢ Well-tested code tends to be better designed with reduced coupling and greater cohesion. ‚Ä¢ A good test suite acts as a detailed specification. ‚Ä¢ Writing tests during development increases programmer engagement and efficiency. ‚Ä¢ A test suite with good coverage aids in maintenance, refactoring, and upgrades with reduced risk of breakage and regression. ‚Ä¢ It‚Äôs faster to write code with tests than without. ‚Ä¢ Having automated tests reduces or removes the need for manual testing Best tests will have a few important characteristics in common:‚Ä¢ Clarity: The name of each test suggests what it‚Äôs about at a glance. ‚Ä¢ Purpose: The intent and meaning of the test is obvious and unambiguous from the testing logic. ‚Ä¢ Eloquence: The test logic is expressed through fluent use of the language and the testing framework. ‚Ä¢ Readability: Tests are written and formatted in a way that promotes rapid discovery and comprehension. ‚Ä¢ Efficiency: All other things being equal, automated tests should use the minimum possible system resources Unlike a lot of books on testing, this one won‚Äôt dwell on the mechanics of test-driven development. TDD has become so prevalent and popular among the Ruby and Rails development community that you‚Äôd be hard pressed to find a book on testing or development that doesn‚Äôt take it as a starting point for everything taught. But TDD is primarily about development and only incidentally about testing, and it often treats the tests that fall out of it as a by-product rather than as first-class citizens of your project. That tends to result in test suites that are neglected after they‚Äôve served the purpose of driving out features. ‚Ä¢ Fact: The entire framework weighs in at less than 1600 lines of code. RSpec is almost 8 times as large. With a code base that size, the source practically becomes its own documentation. ‚Ä¢ Fact: Minitest has been singled out as a very readable project because it‚Äôs written in plain Ruby that developers of all experiencelevels can dig into and understand. ‚Ä¢ Fact: The project has remained small and simple because of conscious decisions to keep it that way in spite of frequent requestsfor expanded features. ‚Ä¢ Fact: The source code showcases Ruby‚Äôs power and elegance with great uses of closures, metaprogramming, concurrent programming, and others. ‚Ä¢ Fact: Since the Minitest framework also happens to be tested with Minitest, it includes some exceptional practical examples illustrating good testing technique To really get comfortable with Minitest‚Äôs internals, there are four basic abstractions that you‚Äôll need to understand: plugins, reporters, runnables and the Minitest runner. Plugins In Minitest, plugins are modules that extend or modify the behavior of Minitest. They can be used to add new features, customize the test runner, or modify the output of test results. Examples of plugins in Minitest include pride (a colorful test runner), parallel (for parallel test execution), and focus (to run specific tests or test suites). Minitest plugins are usually packaged as RubyGems which implement a simple framework-defined contract that allows them to be loaded an initialized by the framework. Specifically speaking, every plugin includes a loader file that follows a standard naming convention - ex: minitest/ foo_plugin. rb where foo is the name of the plugin. minitest-rails is a plugin for Minitest that adds some additional features for working with Ruby on Rails applications. It provides some additional test generators that can create test files for your Rails application‚Äôs models, controllers, views, and helpers. It also includes support for testing Rails-specific features like routes and controllers. In addition to the generators, minitest-rails also provides a Rails-specific test runner that sets up the Rails environment before running the tests. This can be helpful if your tests need to access Rails configuration or other Rails-specific features. Overall, minitest-rails is a helpful plugin for anyone working with Ruby on Rails applications and using Minitest as their testing framework. Another example: the minitest/pride plugin adds colorful output to your test results in the terminal. Reporters A test suite is a map for directing development effort to the parts of your project that need it. From this perspective, the results reported by your test suite act as its user interface and indicate the state of your code base. Each test Minitest runs passes a result to a Reporter object which is responsible for acting on it. Depending on the Reporter, it might:‚Ä¢ Display information to the console. ‚Ä¢ Store the result for later processing. ‚Ä¢ Increment counters or compile statistics. ‚Ä¢ Send the result to another system - ex: a CI, a database, etc. As an abstraction, a Reporter is just an object that implements four methods that allow it to accept and operate on test results:‚Ä¢ #start - called before the first test is run‚Ä¢ #record - accept and process a single test result‚Ä¢ #report - deliver a detailed report after the test run‚Ä¢ #passed? - indicate passed/failed/errored/skipped tests In Minitest, reporters are used to generate output of the test results. They provide various types of outputs such as progress bar, detailed documentation, and colorized output. Runnables In Minitest, runners are classes that run a set of tests. Assert-style tests and Spec-style tests are two different styles of writing tests in Minitest. Assert-style tests are based on assertions that verify the expected result of a test. They are usually written using methods such as assert, assert_equal, assert_match, etc. The focus is on verifying specific outcomes and behavior of the code being tested. Spec-style tests are based on specifying the expected behavior of a system or component. They are usually written using describe and it blocks that describe the behavior of the code being tested. The focus is on describing the behavior and intent of the code, rather than just verifying specific outcomes. Assert-style tests are based on the idea of making assertions about the state of the system under test. These tests usually follow the ‚ÄúArrange-Act-Assert‚Äù pattern, where the test sets up the system‚Äôs initial state, performs some action, and then makes one or more assertions about the system‚Äôs final state. (This uses instance methods starting with the string ‚Äútest_‚Äù). Spec-style tests, on the other hand, are based on the idea of describing the behavior of the system under test using a domain-specific language (DSL). In these tests, the focus is on describing what the system should do rather than how it should do it. Spec-style tests often use ‚Äúdescribe‚Äù and ‚Äúit‚Äù blocks to structure the test code. Both styles of testing have their pros and cons, and the choice of which one to use often comes down to personal preference and the requirements of the project. Some developers prefer the clarity and simplicity of Assert-style tests, while others find the expressiveness and readability of Spec-style tests to be more appealing. Ultimately, the most important thing is to choose a style that works for you and your team and allows you to write effective, maintainable tests. The Minitest Runner The Minitest Runner is the component responsible for running Minitest test suites. It loads the test files, executes the tests, and reports the results. By default, Minitest uses the Minitest::Runnable and Minitest::Test classes to define and run tests, respectively. However, the runner can be customized to use other classes or to change the way the tests are run. The runner is a key part of Minitest‚Äôs flexibility and extensibility. The runner and Runnables fit together like the layers of an onion where each layer represents a Ruby block or method. The inner layers represent the Runnables where the tests are actually executed, and the outer layers represent the runner - the code that gives the onion its shape. Minitest. runNext, Minitest sets up the environment for the test run along with all the necessary supporting objects. All the framework‚Äôs major responsibilities are handled right here as it:‚Ä¢ Parses the command line arguments. ‚Ä¢ Loads and initializes all detected Minitest plugins. ‚Ä¢ Instantiates and runs the reporters. ‚Ä¢ Runs tests by passing control on to the next layer. ‚Ä¢ Ensures that parallel worker threads are shut down gracefully. Basic Recipes Problem:class FizzBuzz	def convert(number)		if number % 15 == 0			 FizzBuzz 		elsif number % 5 == 0			 Buzz 		elsif number % 3 == 0			 Fizz 		else		number. to_s		end	endendTakeawaysYou need four things to develop a Ruby project with Minitest:‚Ä¢ Install Minitest as a project dependency with Bundler. ‚Ä¢ Create a test directory at test/ . ‚Ä¢ Create a test helper to include all global configuration and customization at test/test_helper. rb . ‚Ä¢ Create a new Rakefile or update the existing one with a Rake::TestTask configured to suit your needs (by convention to run tests you use the command rake) Writing Tests All the tests that we write follow the same basic four-phase structure. 	1. Setup the inputs and data objects prior to running the test. 	2. Exercise the logic under test. 	3. Verify that the tested code produces the expected results. 	4. Teardown or reset application state before running the next test. require 'test_helper'require 'fizz_buzz'class FizzBuzzTest &lt; Minitest::Test	def setup 		@fb = FizzBuzz. new	end	def test_converts_multiples_of_fifteen_to_fizzbuzz		# fb = FizzBuzz. new		assert_equal 'FizzBuzz', @fb. convert(15)		assert_equal 'FizzBuzz', @fb. convert(45)		assert_equal 'FizzBuzz', @fb. convert(90)		[15, 45, 90]. each do |i|			assert_equal 'FizzBuzz', @fb. convert(i)		end	end	def test_converts_multiples_of_five_to_buzz		# fb = FizzBuzz. new		assert_equal 'Buzz', @fb. convert(5)		assert_equal 'Buzz', @fb. convert(10)		assert_equal 'Buzz', 2fb. convert(20)	end	def test_converts_multiples_of_three_to_fizz		# fb = FizzBuzz. new		assert_equal 'Fizz', @fb. convert(3)		assert_equal 'Fizz', @fb. convert(12)		assert_equal 'Fizz', @fb. convert(48)		# another example could have been assert 'Fizz' == fb. convert(3)	end	def test_returns_same_number_for_other_numbers		assert_equal '1', @fb. convert(1)		assert_equal '101', @fb. convert(101)		assert_equal '2014', @fb. convert(2014)	endendAnother example of syntaxis: class ArticleTest &lt; ActiveSupport::TestCase	test  should not save article without title  do		article = Article. new		assert_not article. save	endendThat‚Äôs why many developers follow a strict one assertion per test policy - so that each assertion has exactly one chance to succeed or fail. It‚Äôs true that your tests will be better and more maintainable when each test verifies a single behavior of the system, but writing a single test for each of the assertions above seems like overkill to me since they‚Äôre all testing the same general behavior. setup runs before each test. teardown runs after each test. It‚Äôs better to favor readability over DRY-ness when writing tests. Usage of skip Skip can be useful in situations where you want to write a test that specs out some future work that you‚Äôre notquite ready to code just yet. For example, FizzBuzzTest doesn‚Äôt currently check to see what happens when we pass it an unexpected input. def test_raises_argument_error_for_bad_argument	skip 'not yet implemented'	assert_raises(ArgumentError) { @fb. convert(-1) }	assert_raises(ArgumentError) { @fb. convert(0) }	assert_raises(ArgumentError) { @fb. convert(1. 0) }	assert_raises(ArgumentError) { @fb. convert('foo') }	assert_raises(ArgumentError) { @fb. convert(nil) }endTakeaways	‚Ä¢ Assert-style test cases are classes that inherit from Minitest::Test. 	‚Ä¢ Public instance methods of those classes whose names begin with test_ are treated as tests by the runner. 	‚Ä¢ Minitest provides a small set of assertions out of the box, and of those, about half are used frequently. 	‚Ä¢ Override the setup and teardown methods to include code that should be executed before or, respectively, after each test is	executed. 	‚Ä¢ If you have to choose between readability and DRY-ness in your tests, you should almost always choose readability. Writing Specs class FizzBuzzIterator	def initialize(start = 1)		@counter = start		@fb = FizzBuzz. new	end	def next		input = @counter		@counter += 1		@fb. convert(input)	endendrequire 'test_helper'require 'fizz_buzz_iterator'describe FizzBuzzIterator do	it 'outputs sequential FizzBuzz values starting from 1 when initialized without a starting value' do		iterator = FizzBuzzIterator. new				expect(iterator. next). must_equal '1'		expect(iterator. next). must_equal '2'		expect(iterator. next). must_equal 'Fizz'		expect(iterator. next). must_equal '4'		expect(iterator. next). must_equal 'Buzz'		expect(iterator. next). must_equal 'Fizz'	end	it 'outputs sequential FizzBuzz values starting from the starting value when initialized with a starting value' do		iterator = FizzBuzzIterator. new(10)				expect(iterator. next). must_equal 'Buzz'		expect(iterator. next). must_equal '11'		expect(iterator. next). must_equal 'Fizz'		expect(iterator. next). must_equal '13'		expect(iterator. next). must_equal '14'		expect(iterator. next). must_equal 'FizzBuzz'	endend# Other alternativesexpect(iterator. next). must_equal 'Fizz'value(iteratory. next). must_equal '11'_(iterator. next). must_equal 'Buzz'Assertion vs Expectation Like most powerful tools, this one can be abused. As a general rule, try to limit describe block nesting to at most two or three layers deep. More than that and the specs hard to follow and less readable for future developers (including future you). Before and After for Spec-Style before blocks for all enclosing scopes will be called before the test logic in order from outermost to innermost. after blocks for all enclosing scopes will be called after the test logic in order from innermost to outermost. In practical terms, this lets us define blocks with increasingly specific setup and teardown logic that cascade or override previous operations require 'test_helper'require 'fizz_buzz_iterator'describe FizzBuzzIterator do	before do		@iterator = FizzBuzzIterator. new	end		it 'outputs sequential FizzBuzz values starting from 1' do		expect(@iterator. next). must_equal '1'		expect(@iterator. next). must_equal '2'		expect(@iterator. next). must_equal 'Fizz'		expect(@iterator. next). must_equal '4'		expect(@iterator. next). must_equal 'Buzz'		expect(@iterator. next). must_equal 'Fizz'	end		describe 'when initialized with a starting value' do		before do			@iterator = FizzBuzzIterator. new(10)		end		it 'outputs sequential FizzBuzz values starting from the starting value' do			expect(@iterator. next). must_equal 'Buzz'			expect(@iterator. next). must_equal '11'			expect(@iterator. next). must_equal 'Fizz'			expect(@iterator. next). must_equal '13'			expect(@iterator. next). must_equal '14'			expect(@iterator. next). must_equal 'FizzBuzz'		end	endendThe let function provides an alternate and some would say more elegant way of setting up testing state with a more declarative syntax. describe FizzBuzzIterator do	let(:iterator) { FizzBuzzIterator. new }	# . . . enddescribe FizzBuzzIterator do	let(:iterator) { FizzBuzzIterator. new(10) }	# . . . endEach call to let dynamically defines a new method with the specified name that executes the block argument upon the first invocation and caches the result for later access - in other words, a lazy initializer. Takeaways ‚Ä¢ Create a new test case in Minitest::Spec using a top-level describe block with a String or Class argument. ‚Ä¢ Define a test using an it block with a descriptive String passed as a parameter. ‚Ä¢ Make assertions on the values of expressions by wrapping them in a Minitest::Expectation object using expect or one of its aliases. ‚Ä¢ Use nested describe blocks to define scopes within a test case as a way of grouping related tests. ‚Ä¢ Implement before and after blocks for shared setup and teardown logic specific to a block context. ‚Ä¢ Create named lazy initializers using let blocks. : Configure Pre-Test State As explained back in Writing Tests, each test run under Minitest follows a common progression of steps: Setup, Exercise, Verify, and Teardown. Of these, Setup usually accounts for more lines of code and can be the toughest for new developers to understand. There are several options for setting the state, and knowing which one is the best fit requires familiarity with all of them. Method 1: Set up the same state before each test. Method 2: Configure different state before each test. Method 3: Using a memoized helper method. Method 4: Create data objects within the test. Collections Enumerable types where order doesn‚Äôt matter like Hash and Set count two instances as being equal if they contain the same elements regardless of the order in which the elements were added or passed during initialization. Relations (active record) Just as with Arrays though, order matters, so you‚Äôll need to ensure that both the actual and the expected values are sorted the same way when performing comparisons. ActiveRecord::Relation objects compare mostly like Arrays except when compared with others of the same type, and then according to the SQL representation. Dates and Times Intermediate Recipes Mocks: mocks test the behavior of an object toward the objects to which it sends messages. Use mocks sparingly and only after careful consideration. The more collaborators you mock, the greater your risk of false positives. ‚Ä¢ Only mock what you own. If you don‚Äôt own it, the API could change, and you‚Äôd never detect it in your tests. ‚Ä¢ Only mock immediate collaborators and avoid deep mocking (mocks returning mocks returning mocks). ‚Ä¢ Ideally, only use mocks to solve specific difficult problems like:‚ó¶ Connecting to unreliable or uncontrollable external resources‚ó¶ Real object performance is prohibitively slow‚ó¶ Expensive setup and/or configuration‚ó¶ Avoiding other undesirable side effects StubsStubs provide the context needed to fully exercise an object through a given test scenario ‚Ä¢ Use stubs wherever and whenever they‚Äôre needed, but recognize that needing too many is probably a code smell. ‚Ä¢ Don‚Äôt use stubs where they‚Äôre not needed, and apply them as narrowly as possible where you do use them. (See Mocha‚Äôs stub_everything and any_instance. stub as prime examples of mocking framework features promoting bad coding practices. )‚Ä¢ Never ever, ever stub the object under test. More often than not, you‚Äôll end up testing the stub and not the object itself. Fake Objects A fake is an alternate version of a given class intended for testing only. It exposes an interface resembling that of the real thing it replaces but with an implementation that‚Äôs either simplified or hollowed out which allowsthem to:‚Ä¢ Capture and verify interactions between the object under test and the fake object (like a mock). ‚Ä¢ Maintain consistent interactions between the object under test and the fake object (like a stub). ‚Ä¢ Avoid resource-intensive or otherwise undesirable processing (like both mocks and stubs). We could have gotten the same result using mocking or stubbing, but it might have taken many more lines of setup code. A fake can be a great fit when dealing with complex APIs since it comes ready-made and pre-programmed with the behavior we want and need for running our tests. Testing Mixin Behavior Testing something that can‚Äôt be instantiated on its own confuses many developers. two types of mixins: Those that are coupled with the classes that include them, and those that aren‚Äôt (non-coupled modules) Takeaways ‚Ä¢ Use Object#extend to patch a mixin‚Äôs method into a simple Object for easy testing. ‚Ä¢ Try mixing into a Ruby Struct in cases where you need the including class to have some specific attributes or behavior of its own. Sharing Code Between Tests One point that should be clear to you by now is this: a self-contained test is a readable test. Minitest provides a nice, narrow vocabulary for writing tests, and when we stick to that vocabulary, life becomes better for the developers that follow. When it comes to organizing tests:‚Ä¢ Extracting code into a new helper methods‚Ä¢ Extracting helper methods into a new module‚Ä¢ Extracting tests into a new module Extracting helper methods by:‚Ä¢ Using descriptive names for helper methods and variable arguments‚Ä¢ Updating the extracted code to ensure that it‚Äôs still comprehensible, even outside the previous context Takeaways ‚Ä¢ Code shared within a single test case can be extracted to a private helper method in the same class. ‚Ä¢ Code shared across multiple test cases can be extracted to a module that may be included in all. 	‚ó¶ Sharing tests between test cases is a special case of this Managing Test Data ‚Ä¢ Whenever persistence isn‚Äôt important to your test, use Object. new to create a new instance. ‚Ä¢ Rails fixtures have a lot going for them including great performance and a reliable set of known models for your tests. ‚Ä¢ Use both functional and memorable names for your fixtures. ‚Ä¢ Configure your fixtures carefully, and try to cover at least:‚ó¶ One minimal valid configuration‚ó¶ One or two realistic models‚ó¶ Other well-defined object states‚Ä¢ Use advanced ERB and YAML features to define fixtures dynamically. Testing Active Record Models Active Record maps the application database to Ruby objects that manage attributes, relationships, queries, and lifecycle methods among other things. ‚Ä¢ Test public methods, not private ones. ‚Ä¢ Test interfaces, not implementations. ‚Ä¢ Don‚Äôt test Active Record (or the rest of Rails, for that matter). ‚Ä¢ You need to test some of the typical aspects of Active Record models:	‚ó¶ Complex validations	‚ó¶ Scopes	‚ó¶ Callback targets and hooks‚Ä¢ Make assertions about the results and side effects of public instance methods. ‚Ä¢ Make (selective) assertions an object‚Äôs behavior toward collaborators. Testing Controllers There‚Äôs been a faction of the Rails community that has become vocal about skipping controller testing completely. They usually argue that simulating more realistic user interactions eliminates the need for more focused controller tests which tend to be very repetitive and dull to write anyway. Even the core team has started a gradual move away from controller testing. ‚ó¶ Controller tests should include assertions for the visible side effects that controller actions produce including:	‚ó¶ HTTP response code	‚ó¶ Redirect location	‚ó¶ System state changes (models created, updated, or destroyed)	‚ó¶ Flash variables, session variables, and cookies set or changed‚Ä¢ You should write tests for complex or generated routes. ‚Ä¢ Controllers should specifically not make assertions about any of the following:	‚ó¶ Rendered templates	‚ó¶ Instance variables passed to the view "
    }, {
    "id": 63,
    "url": "http://localhost:4000/2021/12/24/how_to_set_right_obj.html",
    "title": "How to set the right objectives",
    "body": "2021/12/24 - Why Greatness Cannot Be Planned: The Myth of the Objective. Kenneth Stanley Knowledge Project Podcast AI Researcher Reveals How to Set the Right Objectives Objectives are good when they are modest, but things get complicated when they are more ambitious. We as society believe that setting objectives and pursuing them it‚Äôs going to help us make new discoveries comma new accomplishments, achievements. Some great ideas were never an objective until they were discovered. (Rock and roll, penicillin) Serendipity are discoveries that you were not planning to make it. The core problem with ambitious objectives is that many cases trying harder won‚Äôt help you achieve the outcome you‚Äôre seeking. You can‚Äôt be so tied to your vision of accomplishment that you‚Äôre not open to the unexpected or unplanned. You can block your own ability to reach an objective by setting it. Assessment feels like we‚Äôre moving towards our objective; the problem is that even if the metric shows that you‚Äôre moving up in the short run it doesn‚Äôt mean it will lead to the point all the way down. Example: increasing the tests scores in the US schools. (Universal global achievement. Incredible complex) The metric is the assessment and year over year can be going up but it doesn‚Äôt solve the fundamental problem. It needs accountability and assessment with a different approach (an approach that recognizes how you actually make innovative progress in a extreme complex problem) If stepping stones are counter-intuitive (they are not what you would expect) then the metrics are useless because they (metrics) won‚Äôt detect those stepping stones If stepping stones are not counter-intuitive then it‚Äôs not a hard problem, we would have solved already; that‚Äôs what makes the problem hard to solve that you don‚Äôt know the steps. So we need to proliferate stepping stones. It‚Äôs like investing portfolio, they are just ideas, you don‚Äôt know what is going to pay off but you do need that portfolio and make that kind of prediction; some of them will not work out and we need to tolerate. Traditional metrics don‚Äôt allow stepping stones that won‚Äôt lead to the objective. Accountability must thrive interesting steppingstone, even when they won‚Äôt go up. What is not a stepping stone is having everyone getting better than prior year. A solution for the education problem is dissemination of the network teachers, see what on teacher did and work and build from that; it may lead to an end road buy we can‚Äôt find out if not try. We need to find interesting things that are not objectively detectable through the usual assessment. Peer review allows to see from the global optic to the individual. (Academic publishing is an example)Innovations happen through individual connections. With ambitious goals they are far off in the future and we don‚Äôt know what the next stepping stone is so it‚Äôs better to almost take like an evolutionary approach where we are creating these mutations or copying errors or trying all these little experiments and then we see which of those experiments leads to some interesting insights or conclusions and then the idea being, we take those conclusions and then we propagate it to and we propagate it to all other nodes almost like nature sort of rewarding. Subjective judgments are interesting because objective judgments are easy. One example is when we got through this pandemic we should have chosen the best 5th grade teachers (State level or city) and gave them the opportunity to teach all 5th grade students because they were the best, and have best practices however this implies two things: subjection (this is teacher than these others) and failure (which we as a humankind are afraid of). Security blanket is provided by assessments, it makes sure nothing really bad happen. Reality is inconvenient, scary, and difficult. A visionary is someone who in contrast who has recognized when the stepping stones actually have stepped into place now that‚Äôs a person you should follow and that‚Äôs a very interesting and kind of person. Within the corp-life one of the best ways to innovate is to pursue your dream, quit your job and start a start-up this is because the whole society is trapped in this ‚Äúset goals minded‚Äù instead of capturing and developing the idea, they just let it go. "
    }, {
    "id": 64,
    "url": "http://localhost:4000/2021/09/25/refactoring.html",
    "title": "Refactoring",
    "body": "2021/09/25 - This book will take you from beginner to advanced in terms of refactoring. It‚Äôs recommended to have prior knowledge of either one Object Oriented language or Ruby however the Ruby language is very idiomatic so you don‚Äôt need to have a deep understanding of it in order to identify what is the author trying to teach. Firstly let‚Äôs bring up what ‚ÄúRefactoring‚Äù means: Verb: To restructure software by applying a series of refactorings without changing its observable behavior. Noun: A change made to the internal structure of software to make it easier to understand and cheaper to modify without changing its observable behavior. The book has around 70 examples of how you can clean your code up and some others well known ‚Äúgood practices‚Äù. What are the main benefits of doing it and also it considers its downsides so that you can see the whole picture, bearing in mind that the code you write today must be easy to understand and even change tomorrow. The first chapter begins with a good example of a Movie theater system, on the left side you may find some spaghetti code and on the right the code after applying some refactoring twists. Also, he brings some step by step methodology which consists in small changes, test, another small change, test in order to make sure nothing has been broken. He gives you a brief example and then provides a small image, the motivation, the mechanics and the example. For visual learners, the book has plenty of diagrams, before the Refactoring and after so you can see how a requests is sent from the user/browser and pass through different methods and by doing that you may see how an object is modified and what methods intervene and also how clean is the new diagram. There is a section called ‚ÄúTip‚Äù where the author gives you some advices in order to perform better; this is the first: When you find you have to add a feature to a program, and the programs code is not structured in a convenient way to add the feature, first refactor the program to make it easy to add the feature, then add the feature. He goes over about the ROI (return of investment), the technical debt, how to manage it in the case we have tight deadlines and how much we should invest in order to write good code in the first attempts. Notes. Instance methods should not be too long nor does too much. Even if it works, it‚Äôs until we want to change the system when we notice there‚Äôs a bad smell. Code is written by humans and humans need to understand it also care about it. A poorly design system is hard to change. If it‚Äôs hard to figure out what to change is very likely that programmer will make a mistake and introduce bugs. The only guarantee you‚Äôre going to have is that they will change it again within six months. The first to refactor is always the same. I need to build a solid set of tests for that section of code. Decomposing and Refactoring the Statement Method I am looking to decompose the method into smaller pieces. Smaller pieces of code tend to make things more manageable. They are easier to work and to move around. My first step is to find a logical clump of code and use Extract Method. When I extract, I need to know what could go wrong. If I take a larger piece, I can introduce a bug into the program. So before doing it try to figure out how to do it safely. Any non modified variable can be passed as parameter. Modified variables need more care. Never be afraid to change names of things to improve clarity. Good programmers write code that humans can understand. In most cases a method should be on the object whose data it uses. While Refactoring you should focus on clarity, and then later focus on performance as a separate activity. Replacing the Conditional Logic with Polymorphism. If you must use a case statement should be your own data, not on someone else‚Äôs. Using subclasses, we can get rid of the case statement using Polymorphism. Example: Movie (as main class) then subclasses: RegularMovie, Children‚ÄôsMovie and NewMovie. An object cannot change its class during its lifetime. All these lead to better-distributed responsibilities and code that is easier to maintain. The purpose of refactoring is to make software easier to understand and modify. You can make many changes in software that make little or no change in the observable behavior. It only alters the internal structure. Any user, whether an end user or another programmer, cannot tell that things have changed. The two hats by Kent Beck. When you add a function, you should not modify existing code, you‚Äôre just adding new features (hat #1), on the other hand when you are refactoring, you should not add code, just restructure the code (hat #2). Refactoring is not the silver bullet for all software development issues. Loss of the structure of code has a cumulative effect. The harder it‚Äôs to see the design in the code, the harder it‚Äôs to preserve it. Refactoring helps you spot bugs. When I‚Äôm studying code, I find Refactoring leads me to higher levels of understanding that otherwise I would miss. You don‚Äôt decide to refactor, you refactor because you want to do something else, and refactoring helps you do that other thing. I ask myself if I can refactor the code to make that understanding more immediately apparent. Then I refactor it. The other driver of Refactoring is a design that does not help me add a feature easily Developers often to both things, to remove existing pain points and experiment with new solutions. When developers have a deeper understanding of the code base they can ne more effective at adding to it and suggesting how to improve it. Refactoring tends to break big objects and big methods into several smaller ones. When shouldn‚Äôt you refactor? A compromise route is to refactor a large piece of software into components with strong encapsulation. Then you can make a refactor-versus-rebuild decision for one component at a time. Another time you should avoid refactoring is when you are close to a deadline. At that point the productivity gain from refactoring would appear after the deadline and thus be too late. With refactoring the emphasis changes. You still do up-front design, but now you don‚Äôt try to find the perfect solution. You may find that the solution is different from the one you previously came up. Always look for flexible solutions. Refactoring can lead to simpler designs without sacrificing flexibility. The secret to fast software is to write tunable software first and then to tune it for sufficient speed. Since the early days of programming people have realized that the longer a procedure is, the more difficult it is to understand. If you have a good name for a method, you should not look at the body. Ninety-nine percent of the time, all you have to do to shorten a method is Extract method. Find the parts of the method that seem to go nicely together and make a new method. A block of code with a comment that tells you what it is doing can be replaced by a method whose name is based on the comment. When a class is trying to do too much, it often shows up as too many instance variables. When a class has too many instances variables, duplicated code cannot be far behind. As with a class with a huge wad of variables, the usual solution for a class with too much code is either to Extract class, Extract module or extract subclass. A Useful trick is to determine how clients use the class and to use the Extract module for each of these uses. That may give you ideas of how you can break up the class. A class smell is a method that seems more interested in a class other than the one it actually is in. You can shrink a lot of parameter lists and simplify method calling. Bunches of data that hang around together really ought to be made into their own object. Most times when you see a case statement it may be replaced by Polymorphism. Each class you create costs money to maintain and to understand. A class that isn‚Äôt doing enough to pay for itself should be eliminated. Inheritance often leads to over-intimacy. One of the prime features of Objects is encapsulation ‚Äì hiding internal details form the rest of the world. Comments are used as deodorant to somehow mask the bad smell. If you want to refactor, the essential precondition is having solid tests. If you don‚Äôt write self-testing code, you‚Äôll end up spending most time debugging. When you get a bug report, start by writing a unit test that exposes the bug. Write isolated tests that do not depend on each other. You should concentrate on where the risk is. Look at the code and see where it becomes more complex. I emphasize the safe way of doing the refactoring, which is to take small steps and test after every one. A large part of refactoring is composing methods to package code properly. Almost all the time the problems come from methods that are too long. Long methods are troublesome because they often contain a lot of information which gets buried by the complex logic that usually gets dragged in. The key refactoring is Extract method, which takes a clump of code and turns it into its own method. Inline method which does the opposite. I prefer short, well-named methods. It increases the chances that other methods can use a method and also allows you to read from a higher level as a series of comments. Comments often identify pieces of a method that can be extracted. In such situation temporary variables can be helpful to break down the expression into something more manageable. The difficulty in decomposing a method lies in local variables. Refactoring can break down something complex into simpler pieces, but sometimes you just reach the point at which you have to remove the whole algorithm and replace it with something simpler. Moving methods is the bread and butter of refactoring. I move methods when classes have too much behavior or when classes are collaborating too much and are highly coupled. I consider moving a field if I see more methods on another class using the information in the field than the class itself. You‚Äôve Probably heard that a class should be a crisp abstraction, handle a few clear responsibilities, or some similar guideline. You need to consider where it can be split, and you split it. A good sign that a subset of the data and a subset of the methods seem to go together. Other good signs are subsets of data that usually change together or are particularly dependent on each other. One of the keys, if not the key; to objects is encapsulation. Encapsulation means that object need to know less about other parts of the system. A class is doing too much, remove the middleman with method delegation. Each object stands for one object in the real world. Having many two-way links also makes it easy for mistakes to lead to zombies: objects that should be dead but still hang around because of a reference that was not cleared. Replacing case-like or conditional statements with Polymorphism involves blowing away the original class and replacing it with a new class for each type code. If the original class has a large chunk of code that doesn‚Äôt use the type code, I choose either Replace Type code with Module Extension or Replace Type code with State/Strategy. Replace Type code with Module Extension aims to remove conditional logic. Both the original class and the module that is being extended can access the same instance variables. Modules cannot be unmixed easily. When the code is changed at the runtime and the type changes are complex enough that I cant get away with Module Extension I use State/Strategy. I often find conditionals expressions come in two forms. The first form is a check where either course is part of the normal behavior. The second is a form situation in which one answer from the conditional indicates normal behavior and the other indicates an unusual condition. You have a conditional that chooses different behavior depending on the type of an object. One of the grandest sounding words in object jargon is polymorphism. The essence of polymorphism is that it allows you to avoid writing an explicit conditional when you have objects whose behavior varies depending on their types. You can achieve polymorphism in two ways in Ruby, one by implementing the same method signature on multiples objects and call these methods polymorphically and the second by introducing inheritance hierarchy and have the method that is to be called polymorphically on the subclasses. The essence of polymorphism is that instead of asking an object what type it is and the invoking some behavior based on the answer you just invoke the behavior. An assertion technique is a conditional statement that is assumed to be always true. Goal of interface is to show only what they have to and no more. Remember your code is for a human first and a computer second. Methods should be named in a way that communicates their intention. A good way to do this is to think about the comment you would use to describe the method and turn that comment into the name of the method. A good rule to follow is to say that any method that returns a value should not have observable side effects. If you come across a method that returns a value that is used by the caller and also has side effects, you should try to separate the query from the modifier. There are two motivations here for using Replace Constructor with Factory Method. The first comes about if we need to perform this construction login in more than one place. And the second motivation is encapsulation. Exceptions are better because they clearly separate normal processing form error processing. A module should have one single responsibility, just like a class. A module that is difficult to name with the words ‚Äúhelper‚Äù or ‚Äúassistant‚Äù is probably doing too much. The main trigger for use of Extract Subclass is the realization that a class has behavior used for some instances of the class and not for others. A Ruby Class can only inherit from one superclass directly. If you want the class to vary in several different ways, you have to use delegation or module extension for all but one of them. Notice that the implementation using extension of modules is similar to the inheritance example. So why use extend instead of inheritance? The answer is that you would use extend if the modules you were creating could be used to extend various classes. By using delegation instead, you make it clear that you are making only partial use of the delegated class. Book examples: https://github. com/DominicLizarraga/refactoring_ruby_edition "
    }, {
    "id": 65,
    "url": "http://localhost:4000/2021/06/15/well_grounded_rubyist.html",
    "title": "The Well-Grounded Rubyist",
    "body": "2021/06/15 - The book is on its 3rd edition and it‚Äôs comprised of 3 parts and 16 chapters:  Ruby foundations: (chapters 1-6)The syntax is introduced, key concepts and semantics that Ruby uses, also the construction of objects, classes, modules and identifiers, code conventions, also, how to execute files from the console, how to use Gem files and finally using the Ruby interpreter (irb).  Built-in Classes and methods: (chapters 7-12)The most used built-in classes, including: String, Array, Hash, Numeric, Range, Date, Time and Regular Expressions are presented with many examples, what should you expect out of it? How to use it? How the Boolean logic works. The book has a very digested way of reading how the code is flowing, it has a numerical series where you can read from 1 to 12, step by step, line by line so that you can see how the program reads variables, re-assign them and lastly how the output reached that level, instead of jumping from one line to another.  Ruby dynamics (chapters 12-16)Here you will find the metaprogramming basics, as well as handlers for non-existing methods, how to catch up those exceptions, callbacks, hook messages and finally a functional programming example. Notes. false and cause I conditional expression to evaluate as false; all other objects including true, of course, but also including 0 an ‚Äúempty strings‚Äù caused it to evaluate to true . Variables types: locals, instance, class, global. Every object is capable of understanding a certain set of messages. Each message that an object understands corresponds directly to a- method, a name, executable routine whose execution the object has the ability to trigger. A class defines an object functionality, and every object is an instance of exactly one class period every time you create a string object, you have created an instance of the class string. Although every object is an instance of a class, the concept of class is less important than the concept of object. That‚Äôs because objects can change acquiring methods and behaviors that were not defined in their class period the class is responsible for launching object into existence, a process known as instantiation, but they‚Äôre after the object has a life of its own. The ability of objects to adopt behaviors that their class did not give them is one of the most central defining principles of design of Ruby as a language. Rather than asking in the abstract weather a = b, you ask whether it considers itself equal to B. If you want to know whether a given student is taking a class from a given teacher, you ask the student, are you student of this teacher ? There is room for debate as to whether this or that programming language, or even these or that kind of programming language, corresponds more closely than others to shape of the real world. A lot depends on how you perceive the world. Do you perceive it as people with things, each of which has task to do and waits for someone to request the task? If so, you may conclude that object oriented languages model the world best. Do you see life as a series of to-do items on a checklist, to be gone through in order? If so, you may see a strictly procedural programming language as having closer ties to the characteristics of the real world. In short there is no answer to the question of what the real world is. Designing object oriented software is largely a matter of figuring out what you want your objects to be: what they should do, how they will interact with each other, how many of each there should be . For example, many students, one register. And other such questions. To get an object to talk, you have to ask it to talk. But before you ask it to talk, you have to teach it how to talk. It‚Äôs all about asking objects to do things and tell you things. respond_to? is an example of introspection or reflection. Keywords are special reserved words that you cannot use as variable names. For example def is a keyword ; The only thing you can use it for is to start a method definition. Defining a class lets you group behaviors (methods) into convenient bundles, so that you can quickly create many objects that behave essentially the same way . You can also add methods to individual objects, if that‚Äôs appropriate for what you are trying to do in your program. But you don‚Äôt have to do that with every object if you model your domain into classes. A typical class consists of a collection of methods definition. Classes usually exist for the purpose of being instantiated that is, of having objects created instances of that class periodMovies about objects, and objects are instances of classes. The instance variable enables individual objects to remember state. Instance variables work much like other variables: you assign values to them, and you read those values back; You can add them together, print them out, and so on pivot but instance variables have a few differences: ‚Ä¢ Always start with a single @ ‚Ä¢ Are only visible to the object to which they belong ‚Ä¢ Instance variable initialized in one method inside a class can be used by any instance method defined within that class. An attribute is a property of an object whose value can be read and or written through the object. Every Ruby class can have only one superclass, in keeping with the principle of single inheritance. Ruby provides modules, which art bundles of programming functionality similar to classes (except that they don‚Äôt have instances), that you can easily graft onto your class family tree to provide as many methods for your objects as you need. Your line the idea of a class method is that you send a message to the object that‚Äôs the class rather than the one of the class instances. Like classes, modules are bundles of methods and constants. Unlike classes, models don‚Äôt have instances; Instead, you specify that you want to add the functionality of a particular module to that of a class or a specific object. No class can inherit from more than one class. In cases where you want numerous extra behaviors for a class instances and you don‚Äôt want to stash them all in the class superclass and its ancestral classes, you can use modules to organize your code in a more granular weight. When you are designing a program and you identify a behavior or set of behaviors that may be exhibited by more than one kind of entity or object, you have found a good candidate for a module. The practice of arranging objects that talk to one another in a complete program is called object-oriented design. You learn in chapter 3 that you define a method twice inside the same class, the second definition takes precedence over the first. If the object‚Äôs method lookup path includes two or more same name methods, the first one encounter is the winner and is executed. Include will make a module‚Äôs methods available as instance method. extend on the other hand, will make a modules method available as class methods. The kernel module provides an instance method called _missing. This method is executed whenever an object receives a method that it does not know how to respond to that is, a message that does not match a method anywhere in the object‚Äôs method look-up path. ‚Ä¢ Modules don‚Äôt have instances. It follows that entities or things are generally best modeled in classes, while characteristics, shared behaviors, and properties of entities or things are best encapsulated in modules. ‚Ä¢ A class can have only one superclass, but it means in as many modules as it wants. If you are using inheritance, give priority to create a sensible superclass/subclass relationship. To know which object itself, you need to know what context you are in. In practice, there are not many contexts to worry about. There is the top level ( before you have entered or after you have left any other context, such as a class definition). There are class definition blocks, model definition blocks, and method definition blocks. It‚Äôs all about self switching from one object to another, which it does when you enter a class or module definition, an instance method definition, or a Singleton method (including class method) definition. As soon as you cross a class or module keyword boundary , the class or module whose definition block you‚Äôve entered ‚Äì the Class or Module object becomes self. A simple rule governs instance variables and their resolution: every instance variable you will ever see in a Ruby program belongs to whatever object is the current object (self) at that point in the program. Using global variables tends to end up being a substitute for solid, flexible program design , rather than contributing to it. One of the main points of object oriented programming is that data and actions are encapsulated in objects. You are supposed to have to query objects for information and to request that they perform actions. And objects are supposed to have a certain privacy. When you ask an object to do something, you are not supposed to care what the object does internally to get the job done. Even if you yourself wrote the code for the objects method, when you send the object a message, you treat the object as a black box that works behind the scenes and provides a response. Global variables these sort the landscape by providing a layer information shared by every object in every context. Globally scoped data is fundamentally in conflict with the object oriented philosophy of endowing objects with abilities and then getting things done by sending request to those objects. Every definition block whether for a class, a model, a method, starts a new local scope, a new local variable, scratch pad, and get its own variable. At its simplest, idea behind a class variable is that it provides a storage mechanism that‚Äôs shared between a class and instance of that class, and that‚Äôs not visible to any other objects. No other entity can fill this role. Local variables don‚Äôt survive the scope change between class definition and their inner method definition. Globals do but they are also visible and mutual everywhere else in the program someone not just in one class. So class variables have a niche to feel: visibility to a class and its instances, and to no one else. The main business of Ruby program is to send messages to objects. And the main business of an object is to respond to messages. Sometimes, and object wants to be able to send itself messages that it does not want anyone else to be able to send it. For this scenario, Ruby provides the ability to make a method private. If you don‚Äôt use an explicit receiver for a method call, Ruby assumes that you want to send the message to the current object , self. Ruby control flow techniques include the following: Conditional execution. Execution depends on the truth of an expression. Looping. A single segment of code is executed repeatedly Iteration. a call to a method is supplemented with a segment of code that the method can call one or more times during its own execution. Exceptions. Error conditions are handled by special control for rules. After all, when you call a method on an object, control is passed to the body of the method ( 8 different scope); And when the method has finished executing, control returns to the point right after the point where the method call took place. The difference between a method call with a block and a method call without a block comes down to whether or not the method can deal. If there is a block, then it can; If not it cannot, because there is nothing to deal to. An Exception is a special kind of object, an instance of the class exception or a descendant of that class period raising an exception means stopping normal execution of the program and either dealing with the problem that‚Äôs being encountered or existing the program completely. It‚Äôs generally considered good practice to catch a specific exceptions rather than simply using rescue to catch all exceptions. ensure clause is executed whether an exception is raised or not. In short it is packed to begin/end structure of which it is a part, and its execution is unconditional. The fact that you can define an even redefine elements like the + -, and square brackets means that Ruby has a great deal of flexibility. But there are limits of what you can redefining will be. You can‚Äôt where they find any of the literal object constructors: {} it‚Äôs always a hash literal (or a code block, if it appears in that context), ‚Äú‚Äù we‚Äôll always delimit a string, and so forth. One consideration, weighing in on the side of modifying objects instead of creating new ones, is efficiency, creating new objects is expensive in terms of memory and processing. All that matters is what the object can do, what methods it can execute. Nil does exist. Single values, such as integer and strings, as opposed to collection or container objects that hold multiple values are considered as a scalar. Symbols aren‚Äôt unique. Whenever you see xyz, you are seeing a representation of the same object. Again, symbols are more like integers than strings in this respect. When you see the notation ‚Äúxyz‚Äù in two places, you are looking at representations of two different string objects; The literal string constructor ‚Äú‚Äù creates a new string. But :xyz is always the same Symbol object, just as 100 is always the same object. Symbols are immutable. There is no such thing as appending characters to a symbol; Once the symbol exists, that‚Äôs it. You will never see :abc ¬´¬†:d or anything of that kind. Symbols have a number of users, but most appearance fall into one of two categories, method arguments and hash keys. Well we can process symbol faster. Whereas the strings have a malleability that‚Äôs a good fit for their presentation of arbitrary values. Strings being mutual, symbols not. Symbols share with integers not only immutability and uniqueness but also immediacy: a variable to which a symbol is bound provides the actual symbol value, not a reference tweet. Any class that aspires to be innumerable must have an each method whose job is to yield items to a supply code block , one at a time periodNumerators are closely related to eaters, but they are not the same thing period and iterate are is a method that yields one or more values to a code block. And enumerator is an object, not a method, therefore maintain state. An Enumerator can add innumerably to objects that don‚Äôt have it. It‚Äôs a matter of wiring: if you hook up and enumerators each method to any iterate are, then you can use the numerator to perform innumerable operations on the object that owns the iterator, whether that object considers itself innumerable or not. Here is the source code https://github. com/jleo3/twgr "
    }, {
    "id": 66,
    "url": "http://localhost:4000/2021/05/30/practical_oriented.html",
    "title": "Practical Object-Oriented Design (POODR)",
    "body": "2021/05/30 - This book is the second edition that Sandi Metz publishes and it‚Äôs even considered as a must-read by the RoR community, give it a shot you won‚Äôt regret at all no matter what language you‚Äôre coming from. The introduction gives you why we want to work at a place where we feel as if we had some real impact, without being painful and why not make it funny as well, also explores the idea of increasing the productivity and reducing costs associated with poor design software. It goes over some agile methodology; it brings up the ‚ÄúAgile Manifesto‚Äù and explores its points of intersection between project management and software development. The core example of the book is a Bicycle store and it starts with the most simple but thorough class and it gradually increases its complexity always by giving you the reason why would you for instance need to add spare parts method to the main class or create a new one from scratch, what are the benefits and downsides? Is the customer really requesting this? What if we go beyond the scope of the app and make it flexible since the beginning? And finally, you end up with a Bicycle store and an app to book trips. üö≤ üèî It offers many examples of all the good practices or rules you may find below and gives you the before and after of each scenario, and you can find the most important examples in my repository. https://github. com/DominicLizarraga/refactoring_ruby_edition Chapter 1. ‚ÄúObject-Oriented Design‚Äù Encourages you to shift your thinking from a world of collection of predefined procedures to modeling the world as a series of messages that pass between objects. It depicts that statement with an example of a woman waking up at the same hour, preparing her coffee and suddenly steps on the cat, causing a reaction that was not on the normal routine. üêà It also elaborates on the idea that the only sure thing that will happen is that your app will need some changes, it‚Äôs impossible to never change. It includes some customer perspective and how the client doesn‚Äôt not even know what they want so you must be ready for progressive modifications. ‚ÄúYou must combine an overall understanding of your application‚Äôs requirements with knowledge of the costs and benefits of design alternatives and then devise an arrangement of code that is cost effective in the present and will continue to be so I the future. ‚Äù ‚ÄúThe purpose of design is to allow you to design later, and its primary goal is to reduce the cost of change. ‚Äù The chapter 2. ‚ÄúDesigning Classes with a single responsibility‚Äù The foundation of an object-oriented system is the message, but the most visible organizational structure is the class. Your goal is to model your application, using classes, such that it does what it is supposed to do right now and is also easy to change later. Creating an easy-to-change application, however, is a different matter. Your application needs to work right now just once; it must be easy to change forever. The problem is not one of technical knowledge but of organization; you know how to write the code but not where to put it. When it says easy to change it means the following: ‚Ä¢ changes have no unexpected side effects, ‚Ä¢ small changes in requirements require correspondingly small changes in code, ‚Ä¢ existing code is easy to reuse, and ‚Ä¢ the easiest way to make a change is to add code that in itself is easy to change. A class should do the smallest possible useful thing; that is, it should have a single responsibility. Chapter 3. ‚ÄúManaging Dependencies‚Äù Because well-designed objects have a single responsibility, their very nature requires that they collaborate to accomplish complex tasks. This collaboration is powerful and perilous. To collaborate, an object must know something know about others. Knowing creates a dependency. Ig not managed carefully; these dependencies will strangle your application. Your design challenge is to manage dependencies so that each class has the fewest possible; a class should know just enough to do its job and not one thing more. To some degree of dependency between these two classes is inevitable; after all, they must collaborate. When two (or more) objects are so tightly coupled that they behave as a unit, it‚Äôs impossible to reuse just one. Every dependency is like a little dot of glue that causes your class to stick to the things it touches. A few dots are necessary. If prevented from achieving perfection, your goals should switch to improving the overall situation by leaving the code better than you found it. If you get this right, your application will be pleasant to work on and easy to maintain. If you get it wrong, the dependencies will gradually take over and the application will become harder to change. Depend on things that change less often than you do. Injecting dependencies creates loosely coupled objects that can be reused in novel ways. Isolating dependencies allows objects to quickly adapt to unexpected changes. The key to managing dependencies is to control their direction. Chapter 4. ‚ÄúCreating Flexible Interfaces‚Äù It‚Äôs easy to think about object-oriented applications as being the sum of their classes, they are so very visible; and they spin around responsibilities and dependencies. There is design detail that must be captured at that level, but an object-oriented application is more than just classes. It is made up of classes but defined by messages. Classes control what‚Äôs in your source code repository; messages reflect the living, animated application. Design therefore, must be concerned with the messages that pass between objects. It deals not only with what objects know (their responsibilities) but also with how they talk to one another. The conversation between objects takes place using their interfaces; this chapter explores creating flexible interfaces that allow applications to grow and to change. Imagine two running applications. Each consists of objects and the messages that pass between them. In the first application, the messages have no apparent pattern. Every object may send any message to any other object. If the message left visible trails, there trails would eventually draw a woven mat, with each object connected to every other. In the second application, the messages have a clearly defined pattern. Here the object communicates in specific and well-defined ways. If these messages left a trail, the trails would accumulate to create a set of islands with occasional bridges between them. The second application is composed of a pluggable, component-like objects. Each reveals as little about itself, and knows as little about others, as possible. The design goal, as always, is to retain maximum future flexibility while writing only enough code to meet today‚Äôs requirements. Drawing this sequence diagram exposes the message passing between the objects. The best possible situation is for an object to be completely independent of its context. An object that could collaborate with others without knowing who they are or what they do could be reused in novel and unanticipated ways. Your goal is to write code that works today, that can easily be reused, and that can be adapted for unexpected use in the future. Object-oriented applications are defined by the messages that pass between objects. This message passing takes place along ‚Äúpublic‚Äù interfaces; well-defined public interfaces consists of stable method that expose the responsibilities of their underlying classes and provide maximal benefit at minimal cost. Chapter 5. ‚ÄúReducing Costs with Duck Typing‚Äù The purpose of object-oriented design is to reduce the cost of change. Duck typed objects are chameleons that are defined more by their behavior than by their class. Avoid getting sidetracked by your knowledge of what each argument class already does; think instead about what the object needs. Concrete code is easy to understand but costly to extend. Abstract code may initially seem more obscure, but once understood is far easier to change. Recognizing hidden ducks. Case statements that switch on class Uses of method: kind_of? and is_a? responds_to? Polymorphism in OOP refers to the ability of many different objects to respond to the same message. Duck typing reveals virtual underlying abstractions that might otherwise be invisible. Depending on these abstractions reduces risks and increases flexibility, making your application cheaper to maintain and easier to change. Chapter 6. ‚ÄúAcquiring Behavior through Inheritance‚Äù This chapters offers a detailed example of how to write code that properly uses inheritance. The idea of inheritance may seem complicated, but as with all complexity, there‚Äôs a simplifying abstraction. Inheritance is, at its core, a mechanism for automatic message delegation, if and object cannot respond to a received message, it delegates that message to another. A superclass can have many subclasses, but each subclass is permitted have one superclass. Creating hierarchy has costs; the best way to minimize these costs is to maximize your chance of getting the abstraction right before allowing subclasses to depend on it. The best way to create an abstract superclass Is by pushing code up from concrete subclasses. Chapter 7. ‚Äúsharing Role Behavior with Modules‚Äù To reap benefits from using inheritance you must understand not only how to write inheritable code but also when it makes sense to do so. Use of inheritance is always optional; every problem that it solves can be solved another way. Because no design technique is free, creating the most cost-effective application requires making informed tradeoffs between the relative costs and likely benefits alternatives. When formerly unrelated objects begin to play a common role, they enter into a relationship with the objects for whom they play the role. Many object-oriented languages provide a way to define a named group of methods that are independent of class and can be mixed in to any object. In ruby these mix-ins are called modules. When objects that play a common role need to share behavior, they do so via a Ruby module. When a class includes a module, the methods in that module get put into the same look path as methods acquired via inheritance. Chapter 8. ‚ÄúCombining Objects with Composition‚Äù Composition is the act of combining distinct parts into a complex whole such that the whole becomes more than the sum of its parts. Music for example, is composed. You can create software this same way, by using object-oriented composition to combine simple, independent objects into larger, more complex wholes. A bicycle has parts. Bicycle is the containing object, the parts are contained within a bicycle. The Bicycle class is responsible for responding to the spares message. This spares message should return a list of spare parts. The more parts an object has, the more likely it is that it should be modeled with composition. Composition, classical inheritance and behavior sharing via modules are competing techniques for arranging code. Each has different costs and benefits; these differences predispose them to be better at solving slightly different problems. Chapter 9. ‚ÄúDesigning Cost-Effective Tests‚Äù Without tests, these applications can be neither understood nor safely changed. They add value without increasing costs. These are notes I took from the book, nothing is mine. "
    }, {
    "id": 67,
    "url": "http://localhost:4000/2021/05/29/example.html",
    "title": "Example",
    "body": "2021/05/29 - Test photo! "
    }, {
    "id": 68,
    "url": "http://localhost:4000/2021/05/23/eloquent-ruby.html",
    "title": "Eloquent Ruby",
    "body": "2021/05/23 - This is book is not for learning the very basics of Ruby, it‚Äôs more for people who have played with the language, the console and maybe built simple web app, I say this because it assumes you know what is an array, how you can manipulate or work with it therefore the book only shows shortcuts for instance methods on arrays, the correct usage of bang (!). I contains 3 sections after each chapter, staying out of trouble, in the wild and to wrap up, which has the most important takeaway after the lesson, i. e. ‚ÄúChoose the right control structure‚Äù, a real example from a codebase and finally a summary of what it went over. The book navigates each lesson through a kind of library system where a Document is created with its author, it plays with the first name and last name of the author, then it adds it to an array, then to a hash in order to have it more well organized. It will refresh you some basics methods like inject, map, sort, reverse, push, pop, delete, shift with the bang and without it always keeping in mind that Ruby is an idiomatic language. The book dedicates one chapter to learn how to work and mutilate this String class which is something Ruby is pretty smart and after that String brush up it goes to the Regular Expression, It shows you only the basics of how to validate an e-mail, address how to format a date, and it helps you find it easy to use instead of the intimidating appearance it seems to be. It has a deep chapter on the usage of symbols, it shows you the difference between a symbol and just string, it brings the symbol characteristics, it‚Äôs immutability, its better performance and it‚Äôs memory space utilization. The core of Ruby on Rails, everything is an object, shows you the keywords, how to treat the self, some instance methods in order to know what class is the object you are evaluating, it also presents why treating everything as an object is a good way because it provides consistency to your application, the difference between public, private, protected methods. how to require external libraries like date for instance and it closes remembering us that virtually everything in Ruby is an object, and virtually all of those objects inherit the basic set of methods from the Object class. Engineering is all about tradeoffs. just about every engineering decision involves getting something, but at a price, and there is a price to be paid for dynamic typing. In the chapter 8 lays out the difference between dynamic and static programming languages and encourages you to write tests which is the best way 2 make sure your code works as it should, do you need to test it early, you need to test it often, and you certainly need to test it whenever you change it. The tests framework used on this book are Unit::Test and RSpec it shows you how to start those tests and make them work with their document class. The author Hardly stresses how important is to write test in order to know how your code is working there is no shortcut, there is no easy way it would save you tons of hours if you do it often. The part II of the books goes over the back bone of the language, in this case Classes, Modules and Blocks. Despite shelves full of books on software architecture, and UML diagrams to fill an Art Museum and design meeting that seem to last longer than the pyramids, building software mostly comes down to writing one method after another, methods that stick to doing one thing and doing it well. Composing methods for humans, this technique advocates dividing your class up into methods that have three characteristics. first, each message should do a single thing , focus on solving a single aspect of the problem. by concentrating on one thing, your methods are not only easier to write, they are also easier to understand. second, each method needs to operate at a single conceptual level: Simply put, don‚Äôt mix high level logic with the nitty-gritty details. a method that implements their business logic around say, currency conversions, should not suddenly veer off into the details of how the various accounts are sorted in the database. Finally, each method needs to have a name that reflects its purpose. nothing new here, we have all heard endless lectures about picking good method names. the time to listen to all of them haranguing is when you are creating lots of little methods that you are trying to put together into a functional whole. Why is building small, well named methods that do one thing such a good idea? it‚Äôs not about writing better code for the computer, because the computer does not care. you can code the same algorithm in a handful of large methods or in a myriad of little message and , as long as you‚Äôve gotten the details right, the computer will give you exactly the same answer. the reason you should lean towards smaller methods is that all those compact, easy-to-comprehend methods will help you get the details right. Short, easily comprehending methods also have some secondary advantages as well. take the old bit of coding advice that every message should have exactly one way out, so that all of the logic converges at the bottom for a single return. the key to preventing your compose methods from turning on you is to remember that every method should have two things going for it. First, it should be short. and second, it should be coherent. In plain English, your method should be compact, but it should also do something. Unfortunately, since short is so much easier to remember than coherent, programmers will sometimes go too far in breaking up their methods. There is also a chapter that teaches you how to modify normal operators (&lt;, &gt;, +, -, =, %, *) and change their behavior totally, it demonstrates the ups and downs of defining your own operators, and what are they consequences for others users if they don‚Äôt know what outcome will they get. Chapter 12 and 13 explore the idea behind equality classes, how you can leverage the custom operator by giving them another behavior, how equal? is different from ==, or even ===; all of them have different meaning and the author breaks them all down, next it touches the Singleton and class methods what are their uses, when should you use them, how are they built and again they differences. The usage of Class instance variables, instance variables and modules, what are the benefits , the caveats, what happen if a name collision takes place, what can they hold, what are the risks of over using a module and one of the keys of programming which is naming these instances, those classes, these modules. How to include that module into a Class, how to extend the usage of that module, and also how is the look-up procedure when you call a method (Inheritance tree). An easy rule of thumb for naming modules is that if you find yourself creating a lot of names that all start with the same word, perhaps ‚ÄòTonsOTonerPrintQueue‚Äô and ‚ÄòTonsOTonerPrintAdministration‚Äô, then you just may need a ‚ÄòTonsOToner‚Äô module. The book also covers iterators with 3 chapters, they‚Äôre different ways of calling, the usage of yield (Execute around), the naming convention, how to enable a class to use more than 40 methods coming from the enumerable module, the usage of rescue, begin, raise; Come on errors when using execute around which can be for instance forget about exceptions; because execute around is all about warranties. The whole idea of execute around is that the color is warranty that this will happen before the code fires and that will happen after. The technique ‚Äúexecute later ‚Äú is when you add a parameter prefix with an ampersand, some practical examples of lambdas and procs as well and lastly it touches some of the metaprogramming topics to modify subclasses, to use the method_missing method In order to rescue one execution and provide an exception. Updating existing classes, fixing broken classes, what is the monkey patching? Dealing with DSL and XML, what are the Gems package, how to consume them, nuts and bolts of gems, where are they located and also how to build a gem publish them and make it public. "
    }, {
    "id": 69,
    "url": "http://localhost:4000/2021/04/01/beginning.html",
    "title": "Beginning Rails 6 üöá",
    "body": "2021/04/01 - This book takes you from the straightforward ‚Äúrails new blog ‚Äìd=postgrsql‚Äù to adding active jobs and sending automated emails; it goes step by step so that you can see gradually the app development, it has more than 500 pages with 18 chapters; it touches the very basics of Ruby in the 4th just in case the reader has no experience with this language however Rails is very intuitive and easy to follow along. As you may read the main web app that is built along with this book is a blog where an user can sign-in/ log-in with email and password, can post with ‚ÄúRich Text‚Äù (attach images, modify font, color, size), can edit its own posts, can comment on other‚Äôs posts and finally can delete only posts that user has created. Articles are the epicenter of the application. It uses the most common Gems in order to get the app up and running, it helps you add the gem to translate the app into different languages (Spanish, Portuguese, etc. ), it helps you enable the active storage gem which is used like a cloud storage (comes by default with Rails), explains you the differences between CSS and SCSS, also how to connect JavaScript, what is it for?, action text, Ajax, Action Cable and finally it uploads the app to Heroku (Cloud platform to host your app) in order to grant access anyone in the world. It was also the first book I‚Äôve read that contains the whole Action Pack broken down, routes, controllers, views, which means Action Controller, Action View and Action Dispatch respectively in addition the whole request cycle, who are the actors, what is DNS for? And lands all of this with a CD player in a car example, pretty clear for me. Notes. ‚úçüèª A framework is a collection of libraries and tools intended to facilitate development. Design with productivity in mind a good framework provides a basic but complete infrastructure on top of which to build an application. Why choose Rails? üõ§ It provides a powerful database abstraction layer called active records, which works with all popular data based systems. It chips with a sensible set of defaults and provides a well-proven, multi-layer system for organizing programs files and concerns. Its goal as a framework is to solve 80% of the problems that occur in web development, assuming that the remaining 20% are problems that are unique to the applications domain; you get to focus on just 20% which is what really matters. With rails, you can respond to the needs of customers quickly and easily, and rails works well during collaborative development. It has the famous convention over configuration, ‚Äúdon‚Äôt repeat yourself‚Äù (DRY), the concepts of rapid prototyping and that ‚Äúyou ain‚Äôt gonna need it‚Äù (YAGNI) Philosophy, closing the gap between customer and programmer. Programming is all about making decisions. If you were to write a system from scratch, without the aid of rails, you would have to make a lot of decisions: how to organize your files, what naming conventions to adopt, and how to handle databases access are only a few. Rails lets you start right away by encompassing a set of intelligent decisions about how you program should work and alleviating theamount of low-level decisions making you need to do up front. As a result, you can focus on the problems direct trying to solve and get the job done more quickly. Although you can manipulate most things in the Rails setup and environment, the more you accept the defaults, the faster you can develop applications and predict how they will work. If you put your files in the right place and name them according to the right conventions, things just work. If you are willing to agree to the defaults, you‚Äôre generally have less code to write. The more duplication exists in a system, the more room box has to hide. Ruby is known for making certain programmatic constructs look more natural by way of what‚Äôs called syntactic sugar. Rails has popularized the term synthetic vinegar coma is the exact opposite of syntactic sugar: awkward programmatic constructs are discouraged by making their syntax look sour. Rails employs a time honored and well-established architectural pattern that advocates dividing application logic and labor into three distinct categories: the model, view, and controller. In the MVC pattern, the model represents the data, the view represents the user interface, and the controller directs all the action. The real power lies in the combination of the MVC layers. Using the pain of maintenance considerably while increasing the level of ability among components. Models. in rails, the model layer represents the database. For example, a model called User convention, would map to a table called users. All the rules for data access, associations, validation, calculations and routines that should be executed before and after save, update or destroy operation and nearly encapsulated in get model. Controllers. It is the controller‚Äôs job to fill with requests coma like processing server variables and formatting data, asking the model for information, and sending information back to the model to be saved in the database. It sets up variables to be used in the view, and then proceeds to render or redirect to another action after processing is complete. Controllers typically manage a single area of an application. For example, in a recipe application, you probably have a controller just for managing recipes. Inside the recipes controller, you can define what are called actions. Actions describe what a controller can do. If you want to be able to create, read coma update and delete recipes, you create appropriately named actions in the recipe‚Äôs controller. When a request comes into a controller, it uses a URL parameter to identify the action to execute; And when it is done, it‚Äôs sensory response to the browser. Their response is what you look at next. Views. The view layer in the MVC forms the visible part of the application. In rails, views are the templates that (most of the time) contain HTML markup to be rendered in a browser. It‚Äôs important to note that views are meant to be free of all but the simplest programming logic. Any direct interaction with the model layer it should be delegated to the controller layer, to keep the view clean and decouple from the applications business logic. active_record: a library that handles database abstraction and interaction. Action view: a templating system that generates the HTML documents the visitor gets back as a result of a request to a rails application. Action controller: a library for manipulating both application flow and the data coming from the database on its way to being displayed in a view. New lane these libraries can be used independently of rails one of another. Together, they form the rails MVC development stack. Rails is modular. One of the greatest features of rails is that it was built with modularity in mind from the ground up. Although many developers appreciate the fact that they get a full stack, you may have your own preferences in libraries. In the real world, specifications above as we learn how real users interact with our web applications. Chapter 3, goes to explain how is the rails architecture distributed, what are the files inside of each folder, how to start writing our first migration, execute it, how to add validations to the model, add more fields to the model, and also, how to rollback a migration in case you make a mistake or you did not add something important, it is always reversible. Chapter 4, explains why Ruby is dynamic, how you can use the IRB prompt, what are the Ruby data types such as string, numbers, symbols, arrays and hashes. what are variables, what are they for, and they need do not specify a data type for the variable or the find it in your code before you use it. What are the best practices for naming variables, in this case long and descriptive. Blocks and iterators, comments, control structures, methods. And finally, a brief introduction to object-oriented programming, objects and classes. A key feature of active record which maps table to classes, table rows to object, and table columns to object attributes. This practice is commonly known as object relational mapping (ORM). rails db:system:change -Which makes it easy to switch databases. Active Record provides the link between these classes and your tables, allowing you to work with what look like regular objects, which, in turn, can be persisted to the database. This frees you from having to write low level SQL to talk to the database. Object oriented programming is all about objects. You create a class that encapsulates all the logic required to create an object, along with its properties and attributes, and use the class to produce new objects, each of which is in unique instance, distinct from other objects of the same class. That means sound a little abstract (and with good reason abstraction, after all, is the name of the game) but if it helps you can think of a class as being an object factory. Classes are used to create objects, and objects have attributes. Every object has a unique set of attributes different from other objects of the same class. A return of nil always represents nothing. The new constructor creates a new object, but it is your responsibility to save it. If you forget to save the object, it will never be written to the database. To summarize, when you want to create a new object and save it manually, use the new constructor; When you want to create and save in one operation, use create. update_attributes is an instance variable if you want to update attributes in just one operation. The following call works for deleting or what‚Äôs inside the array Article. delete([1, 2, 3]) The primary way in which you enhance models is by adding methods to them. This is referred to as adding domain logic. With active record, all the logic for a particular table is contained in one place that model. This is why the model is set to encapsulate all the domain logic. This logic includes access rules, validations, relationships, and well, just about anything else you feel like adding. user. build_profile(attributes={}) Returns a new profile object that has been instantiated with attributes and linked to user through a foreign key but has not yet been saved. user. create_profile(attributes={}) Returns a new profile object that has been instantiated with attributes and linked to user through a foreign key that has already been saved. Their rule of thumb is that belongs_to declaration always go in the class with the foreign key rails db:setup Command recreates the database and adds the seat data as you may expect. Whenever you want to add a validation error to the list of errors, you just type errors. add(column_name, error_message). Action Controller. Orchestrate your applications flow. Every time a user requests a page, submits a form, or clicks a link, that request is handled in one way or another by a controller. A typical controller is most often a collection of actions that relates to a specific area of concern. For example, consider the blog application you have been building in the previous chapters. The controller that manages articles has the class name articles controller and has action methods for listing, creating, updating, reading, and deleting articles. The controller looks for a view whose name matches they requested name action. Action View. this library is another important part of action pack. Given that controllers are responsible for handling the request and issuing a response, views are responsible for rendering the output of a response in a way a browser or any other user agent can understand. The primary mechanism by which they do is through shared variables. All instance variables that you may see in a view comes from the controller; look at the view is not handling any logic to fetch the list of these articles. Action Pack. routing salt this problem by decoupling the URL from the underlying program implementation. Request cycle Then type request to response process is called the action pack request cycle. They request cycle consists of the following steps:Rails receives a request from the outside world (usually a browser). routing picks apart the request to determine the controller and action to invoke. A new controller object is instantiated, and an action method is called. The controller interacts with the model (usually performing a CRUD operation in a database with an Active Record model, but not necessarily). A response is sent back to the browser, in the form of either a render or a red direct. HTTP verbs The HTTP protocol defines several request methods, the most popular of which art GET and POST. Both our method for requesting a webpage; The differences in how the request is sent. GET is the simpler of the two period it includes all the information about the request as a part of the URL. POST sends information in visibly, which is to say as a part of the request header and not part of the URL so you cannot type a post request into your browser‚Äôs locations bar. How do you know when to use each? The best way to think of this is to consider GET high as read method. It should never do anything destructive, such as modifying a database record. POST, on the other hand, can be thought of as a writer method. When you need to create data, use POST. PATCH is used when you need to update a record partially, for instance, only changing your e-mail address. PUT is used to update a record completely. Most of the time, our controllers handle interactions with a collection of things, so we reflected by using a plural name. Comments are interesting because they are a little different from our other models so far. Comments depend on a particular article; They never exist on their own because they are conceptually meaningless if they are not tight to an article. Remember that you always have the article_id in your parameters because it is always included in your nested name routes. Also notice how you find they assign comment you do so using @article. comments. HTTP is a stateless so how can the application remember you are logged in if HTTP is a stateless? The answer is that you fake state with session object. Example: session[:account_id] = @account. id. Notice that you define session as a resource and not resources, because you never deal a set of sessions at once. The rule of thumb is that whenever you have data that are provided by the user, you cannot trust them blindly . You need to escape it. This includes model attributes as well ask parameters. Fortunately, railes escapes all rendered as strings for you. html_safe method skips the HTML escaping process. simple_fromat method Convert text to HTML using simple formatting rules. The chapters of Active Storage, how to implement Ajax (was implemented for creating and deleting comments, interacted with the DOM with a . js file where all the code for doing this was placed) and sending and receiving email (Action Mailer and Action Mailbox) is difficult to describe but overall those chapters are pretty neat, I‚Äôd say more than https://guides. rubyonrails. org/. Active Job chapter covers the configuration, the creation, the exception handling, retry, discard and finally it has a benchmark exercise where the perform_later method on the mail delivery improved significantly the app performance. This is the first time I faced Active Model, before this one I didn‚Äôt know it existed, the book take that module to build an EmailAFriend without the need to create the whole model as Article for example and with all the benefits a model implies, Active Record, callbacks, validations, attributes and so on. The Action Cable chapter is short, explains how HTTP is the normal way the web works, then how web sockets were introduced as a bidirectional server communication and after that it just lays out the four main concepts as connections, channels, streams, broadcasting, subscription and so on, it configures it and apply the broadcast to Article so every time one article is published it will appear at the top without refreshing and start the cycle from the beginning. The last 3 chapters covers testing, internationalization and the upload to Heroku, the first on them emphasize the importance of always test after each small change, and why the didn‚Äôt apply test to follow along, they bring up the technical debt, refactoring. what tools are outside to automate the testing like Unit::Test, fixtures, validations and lastly the 4 types of tests, for models, for controllers, mailers and system, it doesn‚Äôt go deep into the weeds, it only explain what they are. "
    }, {
    "id": 70,
    "url": "http://localhost:4000/2021/02/21/ruby_way.html",
    "title": "The Ruby Way",
    "body": "2021/02/21 - The book is on its third edition, it has had plenty of space as the must-read for every Ruby programmer, many great personalities in the software development community have commented, praised, written about this book (including Yukihiro ‚ÄúMatz‚Äù Matsumoto, the creator of Ruby) because a few years after Ruby was conceived the first edition was published, and as everything evolved, the book has done as well. This time the background of the beginning of this language is presented, how Matz thought in terms of design and usage for building this language, it went from the approach machine-centered paradigm to a human-centered one. Ruby strives to be friendly to the programmer, and with that in mind, we can rely on a completely new style of software development, more strategically then tactic, easier to read, needlessly to add comments. This piece has 22 chapters, and more than 700 pages; it covers the conception of the language, introduction to object orientation, basic syntax and semantics, working with strings, symbols, ranges, numbers, times and dates and of course our arrays, hashes and other Enumerables, also, goes over more advanced data structures like trees, graphs, sets, stacks and queues. It brings the difference between static and dynamic languages, testing, how to handle different data formats, how is related Ruby and web applications, and more stuff that you can leverage in order to cement draw Ruby fundamentals. To me it was the longest book I‚Äôd ever had in my hands, quite hard to start to be honest but as soon as you pass the first pages you get caught, it refreshed me a ton of built in methods for the most important data structures, and when I say a ton, it‚Äôs about 80% of all what you need (very comfy way to read these methods on the book, and with the method description more friendlier) , so very well thought from the author perspective, not hard theory to digest, only practical examples and a few debates between 2 different points of view but nothing abstract. I think is a good start for people who want to harden their programming skills because it covers many topics of software development, it doesn‚Äôt matter what language you come from, it works for processing text files, web development, graphical interfaces, some algorithms to get familiarized with. Notes. ‚úçüèª An object is an entity that serves as a container for data and also controls access to the data. Associated with the object is a set of attributes, which are essentially no more than variables belonging to the object. Also associated with an object is a set of functions that provide an interface to the functionality of the object, called methods. It is a essential that any OOP language to provide encapsulation. The class may be thought of as the blueprint or pattern; The object itself is the thing created from that blueprint or pattern. A class is often thought of as an abstract type, a more complex type than, for example, an integer or character string. Inheritance is a mechanism that allows us to extend previously existing entity by adding features to create a new entity. In short, inheritance is a way of reusing code. Easy effective code reuse has long been the Holy Grail of computer science, resulting in the invention decades ago of parameterized subroutines and code libraries. Multiple inheritance he‚Äôs probably the most controversial area in OOP; one camp will point out the potential for ambiguity that must be resolved. It is conceivable that a new class could inherit from more than one class. Diamond inheritance problem, so-called because of the shape of its inheritance diagram, with both super classes inheriting from a single common superclass. The literal meaning of polymorphism is the ability to take on multiple forms or shapes. In its broadest sense, this refers to the ability to different objects to respond in different ways to the same message (or method invocation). The first, inheritance polymorphism, is what most programmers are referring to when they talk about polymorphism. When a class inherits from its superclass we know that any method present in the superclass is also present in the subclass. The second kind of polymorphism Conway identifies is interface polymorphism. This does not require any inheritance relationship between classes; It only requires that the interface of the object have met thoughts of a certain name. A module consists of methods or constants that may be used as though they were actually part of the class or object; When a module is mixed in via the include statement this is considered to be a restrictive form of multiple inheritance. By rivals are used to hold reference to objects. A module is a collection of methods and constants that is external to the Ruby program. The private level means that the method is accessible only within the class or its subclass. Ruby is a dynamic language in the sense that objects and classes may be altered at runtime. Will be has the capability to construct and evaluate pieces of gold in the course of executing the existing statically coded program. This is perhaps the most difficult area a programmer will encounter in learning Ruby. Everything is intuitive once you understand it. Everything is true except false and nil. many languages have some kind of for loop, as does Ruby. The question sooner or later arises as to whether the index variable can be modified. Any object can be in principle converted to some kind of string representation; That is why nearly every quarter class has a to_s method. A symbol is like a string in that it corresponds to a sequence of chapters. It is unlikely string in that each symbol has only one instance (just as a fixed number works). Therefore there is a memory or performance issue to be aware of. The &amp; notation allows us to pass a proc instead of an explicit attached block if we want. Because we use the &amp; on an object that is not a problem interpreter tries to call to_call on that object. It will call it repeatedly, once for each element in the right. The collect method (part of innumerable) is a useful tool that proves to be a time and labor saver in many circumstances. If you want to delete all instances of a certain piece of data, delete would do the job. The compact method (or it‚Äôs in place version compact!) removes nil values from an array, leaving the rest untouched. The delete_if passes every element into the supply block and delete the elements for which the block evaluates to true. It behaves similarly to reject!, except that the latter can return when the array remains unchanged. They reject method takes a block and produces a new array without the elements for which the block returns true. Bear in mind that +, concat, and even +=always create a new array object. Also bear in mind that while ¬´¬†adds to the existing array, it happens a new array element (which may itself be an array). What makes a collection enumerable ? Largely it is just the fact of being a collection. The module enumerable has the requirements that the default iterate each should be defined. Sequence as such is not an issue because even on unordered collection can have any generator. And enumerator is basically an object that can be used for external or internal iteration. In internal iteration, we simply iterate over each item in the collection and execute the block for each item in the sequence; External iteration means that the code can grab the next item in the sequence ‚Äúon demand‚Äù. There are many other methods on Enumerable, and I cover most of them here. For convenience, I have divided them a little arbitrarily in four areas: searching and selecting, counting and comparing, iterating, and finally extracting and converting . The purpose of inheritance, of course, is to add or enhance functionality. It‚Äôs not always necessary to use super in such a way, but it is often convenient. Every attribute and method of the point is reflected in the child. The child can have additional attributes and methods, as you have already seen. The child can override or redefine any of the attributes and methods of the parents. If we invoke a method on a subclass, the method for that class will be called if it exists. If it does not the method in the superclass will be called, and so on. When we create a new structure template by calling Struct . New we may pass a string with the class name as the first argument. If we do come a new class is created where in class Struct itself, with the name passed in as the first parameter and the attributes given as the rest of the parameters. Every time you invoke a method, you are sending a message to an object. "
    }, {
    "id": 71,
    "url": "http://localhost:4000/2021/01/22/agile.html",
    "title": "Agile web Development with Rails 6 üõ§",
    "body": "2021/01/22 - This was the first Rails book I read and caught me with the real example it takes you through, you‚Äôll be building an online shop and the author goes from installing Rails, ruby and other libraries to finally code some automations and uploading to Heroku, you can either follow the book or at the beginning of each chapter you can download the final version of the app so that you will never lose track of what is being presented, also, brings a summary after lesson and has a playtime section where you can push yourself to do a bit more of the exercises. In addition something I find very interesting in the book is that the foreword and some sections in each chapter DHH had the opportunity to share either his experience or advice regarding the current topic and he, being the creator of this framework and having built a company on top of it (Basecamp and Hey), I consider it as a nugget of information. Lastly, this is the book that has the best explanation about how Action Pack, Action Controller, Action View, Action Dispatch work together; it dedicates 1 chapter to just explain how routes get match to the controller and their actions and how are they converted into views. Very immaculate. Let‚Äôs begin with chapter 2 (1st is about installing all the stuff) The first example is to show the reader how to use the rails command, in this case the author creates a demo app with two views and one controller, after that it creates a couple of links in order to show how works, nothing fancy so far. Next chapter goes over the MVC architecture, the model is responsible for maintaining the state of the application. Is more than data; It enforces all the business rules that apply to the that data. For example, if a discount should not be applied to orders of less than $20, the model enforces the constraint. The model acts as both a gatekeeper and a data stored. That view is responsible for generating a user interface, normally based on data in the model. For example, an online store has a list of products to be displayed on a catalog screen. The list is accessible via the model, but it is a view that formats the list for the end user. Debut itself never handles incoming data. Controllers on the other side, orchestrate the application. They receive events from the outside world (normally, user input), interact with the model, and display an appropriate view to the user. The MVC architecture was originally intended for conventional GUI applications, where developers found that the separation of concerns led to far less coupling which in turn made the code easier to write and maintain. Each concept or action was expressed in a single, well known place. In a Rails application, an incoming request is first sent to a router, which works out where in the application the request should be sent and how the request should be parsed. Ultimately, these face identifies a particular method (called an action in rails parlance) somewhere in the controller code. The action might look at data in the request it might interact with the model, and it might cause other actions to be invoked. Eventually the action prepares information for the view, renders something to the user. The routing component receives the incoming request and immediately picks it apart. The request contains a path (/line_items?product_id=2) and a method (this button does a POST operation; Other commands methods are GET, PUT, PATCH and DELETE). In this case, Rails takes the first part of the path line_items as the name of the controller and the product_id as the id of the product . By convention, POST methods are associated with create actions. They create method handles user requests. In this case, it finds the current user shopping cart when parentheses which is an object managed by the model). It also asks the model to find the information for product 2. It then tells the shopping cart to add the product to itself. Object relational mapping (ORM) libraries map database tables to classes. If a database has a table called orders, our program will have a class name Order. Rows in this table correspond to objects of the class - a particular order is represented as an object of the Order class. Within that object, attributes are used to get and set the individual columns . Our order object has methods to get and set the amount, sales tax, and so on. So, and ORM layer maps tables to classes, rows to objects, and columns to attributes of those objects. Class methods are used to perform table level operations, and instance method perform operations on individual rows. Active record is the ORM layer supplied with rails. It closely follows the standard model: tables map 2 classes, roast two objects, and columns to object attributes. Action pack: the view and controller When you think about it, and controller parts of the MVC are pretty intimate. The controller supplies their data to the view and the controller receives events from the pages generated by the abuse. Because of these interactions, support for views and controllers in rails is bundled into a single component, Action pack. The view is responsible for creating all or part of the response to the displayed in a browser, to be processed by an application, or to be sent as an e-mail. At its simplest , is a chunk of HTML code that displays some fixed text. More typically, you will want to include dynamic content created by the action method in the controller. The controller in rails is the logical center of your applications. It coordinates the interaction among the user, the abuse, and the model . however, rails handles most of this interaction behind the scenes; The code you write concentrates on application level functionality . This makes rails controller code remarkably easy to develop and maintain. The controller is also home to a number of important ancillary services: ‚Ä¢ It is responsible for routing external requests to internal actions. It handles people friendly you are extremely well. ‚Ä¢ It manages catching, which can give application orders of magnitude performance boosts. ‚Ä¢ It manages helper modules, which extend the capabilities of the view templates without walking up their code. ‚Ä¢ It manages sessions, giving the users the impression of ongoing traction with our applications. Chapter 4 goes on to what is an object oriented language, will we names for local variables, methods parameters, and methods names, it provides the general rules of syntax, the kind of data types you will find in groovy like strings, array, hashes. The core of the Ruby language, which is blocks and iterators, control structures with the if statements, while loops, unless, until. Chapter 5: incremental development, use cases, page flow, data and priorities are covered. The first sketch of the shopping cart is shown, the user stories are broken down for instance: the buyer uses the web app to browse products we have to sell , select some of to purchase, and supply the information needed to create an order. On the other side the seller journey is as well described and something important is how the data is it going to be handled, how many controllers are we planning to code, the schemas are presented as well and finally the author emphasizes that all of these planning will become outdated because we must get customer feedback and most of these will change. The book pushes you to develop the web app in incremental changes called iterations. Chapter 6, it starts with the application ‚Äúrails new depot‚Äù and creating the first model in this case the product , it shows you how to migrate, the addition of CSS for the forms, it explains the HTTP verbs and this is the first commit to GitHub. Next chapter added some model validations in order to ensure the user input, also, introduced the first unit test examples and explain how they work; the importance of naming self-explanatory variables, tests. Chapter 8, builds the 2nd controller in this case is a Store and it added some CSS to the index view, also, went over the layout, using partials files in order to create the navbar, and continued with the testing now including the front end (what should the &lt;H2&gt; tag title contain or how many items &lt;li&gt; should have). The following chapter creates the Cart model, line_item, by a scaffolding them, and connect the line_item model to product and to cart, becoming a joint table; another feature added here is the introduction to sessions , it explains how they work, how much they can carry on and what are they useful. Chapter 10 covers how to deploy a new migration because in the first one, something was forgotten and leveraging how you can juggle with migrations there are four decided to add a new one instead of creating everything from scratch. Some flash notice modifications took place, and a strong parameter adjustment as well, finally the CSS was at refined to the new changes. The next chapter introduced they AJAX and it explains it very well, the book contains why Ajax exist how can I change the flow of the views, then Ajax feature it‚Äôs just highlighting some data without refreshing the whole page and finally action cable is presented with the core concepts. Within the next iteration the add_order_to_line_item model is created, a new form for capturing the lines items for the order as well and linking Line items 2 one order, after each addition a test is deployed and passed. In order to make more dynamic our rails app we need to add React which is a JavaScript view library designed to quickly create dynamic user interfaces. We will use it to create a dynamic payment method details form coma and Webpacker will ensure that the configuration and set-up for all these is as simple as possible. That said, there is a bit of setup we need to do. Web Packer essentially is the decisions made by the rail steam and bundled up into a gem. React dynamically renders HTML. Unlike ERB, react does this in the browser, and it is optimized to do it fast. React re render each field of the form instead of having this server re render the entire thing. the core concept in react is components. A component is a view, backed by some sort of state. When the state changes, the rear Enders. The view can behave differently depending on the current state inside the component. Chapter 14 goes on the e-mail module of Rails and explain why sending e-mail normally is slow, why would you choose Action Mailer and then you put on top of it Active Job to offload the work. In a Rails app, when a bit of logic becomes more complex than a line or two of code, you want to move that out of the controller and put it into a model. The chapter 15, 16, 17, are about logging in, internationalization, and responding emails with rich text this is almost as straight out as you may find it in the rails guide so I won‚Äôt go deeper due to is configuration, set-up and little adjustments. The last part of the book (III) contains 6 chapters and they are under a title called ‚ÄúRails in depth‚Äù I consider this very helpful if you want to go deep into the weeds and explore how is rails composed? why does rails app contain many default files? What are they for? When is correct to use a helper from there app file or from the model? Where does rail put the logs? Naming conventions? Where do you configure the environments? And many interesting methods that I didn‚Äôt know. Active record he‚Äôs also touched in this chapter and with more detail the CRUD actions are explained, also, using like classes, order, limit, using the word keyword, joins coma scopes, writing your own SQL, What are the 16 call backs Rails includes. Action Pack lies at the heart of rails applications. It consists of three Ruby modules: action dispatch, action controller and action view. Action dispatch routes request to controllers. Action controller converts requests into responses. Action view is used by action controller to format those responses. Components such as action controller, action view, and active record handled the processing of request, and the rails environments needs them together into a coherent and easy to use whole. At its most basic, a web application accepts an incoming request from my browser, process it, and sends a response. The first question that springs to mind is, how does the application know what to do with the incoming request? A shopping cart application will receive requests to display a catalog, add items to a part, create an order, and so on. How does it route these requests to the appropriate code?it turns out that Rails provides two ways to define how to route a request: a comprehensive way that you will use when you need to and a convenient way that you will generally use whenever you can. The comprehensive way lets you define a direct mapping of URLs to actions based on pattern matching, requirements and conditions. The convenient way lets you define routes based on resources, such as the models that you define. And because the convenient weight is built on the comprehensive way, you can freely mix and match the two approaches. A controller always responds to they use exactly one time per request. This means you should have just one call to a render(), redirect_to() or send() method in the processing of any request. Because the controller must respond exactly once, it checks to see whether a response has been generated just before it finishes handling a request. If not, the controller looks for a template named after the controller and action and automatically renders it. This is the most common way that rendering takes place. You may have noticed that in most of the actions north shopping cart tutorial we never explicitly rendered anything. Instead, or action methods set-up the context for the view and return. The controller notices that no rendering has taken place and automatically invokes the appropriate template. A real session is a hash-like structure that persists across request. Unlike raw cookies, sessions can hold any objects as long as those objects can be marshaled, which makes them ideal for holding state information in web applications. Rails encourages and agile, iterative style of development. We don‚Äôt expect to get everything right the first time period instead, we write tests and interact with our customer to refine our understanding as we go. For that to work, we need any supporting set of practices. We write tests to help us design our interfaces and to act as a safety net when we change things, and we use a version control to store our application source files, allowing us to undo mistakes and to monitor what changes day today. The database schema in a rails application constantly evolves as we progress through the development column we add a table here, rename a column there, and so on the database changes in step with the applications code. With rails, each of those steps is made possible through the use of migration. A migration is simply a Ruby source file in your applications and You can modify column types, renaming columns, changing columns, defining indices, renaming tables, the usage of primary keys, and even using native SQL and always you can rollback their migrations when they go bad. "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,120)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}
</script>

<style>
    .lunrsearchresult .title {color: #0f4fd9;}
    .lunrsearchresult .url {color: rgb(149, 165, 169);}
    .lunrsearchresult a {display: block; color: #4f4d4d; text-decoration: none;}
    .lunrsearchresult a:hover, .lunrsearchresult a:focus {text-decoration: none;}
    .lunrsearchresult a:hover .title {text-decoration: underline dotted;}
</style>

<form onSubmit="return lunr_search(document.getElementById('lunrsearch').value);">
  <div class="search-input-container">
    <input
      type="text"
      class="search-input"
      id="lunrsearch"
      name="q"
      maxlength="120"
      placeholder="Search"
    />
  </div>
</form>

<div class="limiter">
  <div id="lunrsearchresults">
    <ul></ul>
  </div>
</div>
  </div>
  <div class='' style='position:relative'>
    
    <div class='only-print'>
      <h2>dom lizarraga</h2>
      <div style='margin-top:0;'>dominiclizarraga@hotmail.com</div>
    </div>
    <nav class='header-wrap'>
      <div class='header nu limiter no-print'>
        <h1 style='line-height:1.6;font-size:1rem;margin:0 0 0.25em 0;'>dom lizarraga</h1>
        <ul style='list-style:none;padding:0;margin:0;'>
          <li style='margin:0.5rem 0;'><a href='/'>Notes</a></li>
          <li style='margin:0.5rem 0;'><a href='/reading/'>Reading</a></li>
          <li style='margin:0.5rem 0;'><a href='/projects/'>Projects</a></li>
          <li style='margin:0.5rem 0;'><a href='/computer_science/'>Computer <br>Science</a>‚á†</li>
          <li style='margin:0.5rem 0;'><a href='/confs/'>Confs</a></li>
          <li style='margin:0.5rem 0;'><a href='/about/'>About</a></li>
        </ul>
      </div>
    </nav>
    <div class='limiter content '>
      <p><strong style="margin-top:-1rem;">
  I‚Äôve committed to gaining depth in computer science, and here are the notes I‚Äôm taking along with the lessons on csprimer.com.
</strong></p>

<h2 id="categories">Categories</h2>

<ul>
  <li><a href="/computer_science/beyond/">Programming: Beyond the basics</a></li>
  <li><a href="/computer_science/systems/">Computer Systems</a></li>
  <li><a href="/computer_science/networking/">Networking</a></li>
  <li><a href="/computer_science/database/">Databases</a></li>
</ul>

<hr />

<div class="writing nu">
  
    <div><a title="#4" href="/2025/03/09/systems_test_post.html">Systems Test Post</a></div>
    <time>2025-03-09</time>
  
    <div><a title="#3" href="/2025/03/08/networking_test_post.html">Networking Test Post</a></div>
    <time>2025-03-08</time>
  
    <div><a title="#2" href="/2024/05/06/this-is-a-test-2.html">This is a test for db</a></div>
    <time>2024-05-06</time>
  
    <div><a title="#1" href="/2024/05/05/utf-8-bits-bytes-binary.html">UTF-8, bits, bytes and binary numbers!</a></div>
    <time>2024-05-05</time>
  
</div>

    </div>
  </div>
</body>
</html>
